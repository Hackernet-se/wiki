<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>HackerNet</sitename>
    <dbname>wiki</dbname>
    <base>https://wiki.hackernet.se/w/Main_Page</base>
    <generator>MediaWiki 1.33.4</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">HackerNet</namespace>
      <namespace key="5" case="first-letter">HackerNet talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Ansible</title>
    <ns>0</ns>
    <id>70</id>
    <revision>
      <id>3123</id>
      <parentid>2987</parentid>
      <timestamp>2021-05-08T21:38:55Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Templates */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4397">Ansible är ett automatiseringsverktyg som hjälper till att managera din miljö. Ansible ansluter till flera hostar samtidigt och kör små program som heter "moduler" i den ordning som har specificerats i "playbooks".

“I wanted a tool that I could not use for 6 months, come back later, and still remember how it worked.” - Michael DeHaan, creator.

Är det rätt verktyg för dig? http://www.infoworld.com/article/2609482/data-center/data-center-review-puppet-vs-chef-vs-ansible-vs-salt.html

==Installation==
Till skillnad mot t.ex. puppet finns det inga agenter/klienter utan man installerar endast på en maskin, dvs standalone.
 #Ubuntu 
 sudo apt-get install software-properties-common
 sudo apt-add-repository ppa:ansible/ansible
 sudo apt-get update &amp;&amp; sudo apt-get -y install ansible
 
 #CentOS/Fedora
 sudo yum install ansible
 
 #Alternativt
 sudo pip install ansible

==Grunder==
Efter installation är det dags att sätta ihop sin inventory-fil. Där listar och grupperar man alla hostar som man ska jobba med, se nästa stycke. Förslagsvis använder man inte IP-adresser utan namn i DNS/hosts-fil för att hitta rätt. Det behöver också fixas SSH-nycklar på alla hostar så att ansible kan autentisera sig på hostarna utan lösenord. Se [[Jumpgate]] för hur man genererar nycklar och skickar ut. Har man olika användarnamn på maskinerna man ska in på kan man specificera det i sin inventory-fil men för att hålla den så ren som möjligt kan det också göras i ~/.ssh/config, se [[Jumpgate]].

==Konfiguration==
I ditt inventory läggs alla maskiner till och finns default i: /etc/ansible/hosts
 #[all] gäller alla
 cacti
 ns02
 beeswarm:2222
 
 [dbservers]
 dbsrv1
 dbsrv2
 
 [webservers]
 websrv1
 websrv2

==Moduler==
http://docs.ansible.com/modules_by_category.html

 ansible -m [modulnamn] all
 ansible -m shell -a 'free -m' host1:host3
Testa så att det funkar. Ping-modulen loggar in på maskinerna och kör ping 127.0.0.1, output blir success eller fail.
 ansible all -m ping
Default används SSH-nyckel för autentisering, för pw-fråga istället lägg till: -k

==Playbooks==
En playbook är en uppsättning instruktioner skrivna i yaml. Yaml är lättläst för oss människor. 
 ansible-playbook -i inventory_file dinplaybook.yml
Exempel på playbook:
&lt;syntaxhighlight lang="yaml"&gt;
---
- hosts: all
  sudo: true
  tasks:
  - name: install apache2
    apt: 
      pkg: apache 
      state: present 
      update_cache: true
  - name: start service
    service: 
      name: apache2 
      state: started
&lt;/syntaxhighlight&gt;

Om man har angett hosts i playbooken behövs de inte anges när man kör kommandot. Annars kan man specificera enskilda hosts.
 ansible-playbook -l host5 apache.yml
Kolla vilka hostar som eventuellt skulle beröras
 ansible-playbook playbook.yml --list-hosts
Sudo
 ansible-playbook apache.yml -K  #--ask-sudo-pass

===Ladda upp filer===
Man kan ladda upp lokala filer i tasken.
    - name: Upload default index.html for host
      copy: src=localfiles/index.html dest=/var/www/html/ mode=0644

===Ladda ner filer===
    - name: Download file from website
      get_url: url=http://hackernet.se/file.htm dest=/var/www/html/index.html

===Roller===
Med roller kan man kalla på variabler, tasks och handlers som är fördefinierade. Det kräver att man har en filstruktur för det.
 mkdir -p /etc/ansible/roles/

===YAML===
Yaml använder mellanslag som delimiter, använd ej tab.&lt;br/&gt;
&lt;syntaxhighlight lang="yaml"&gt;
---
- hosts: [target hosts]
  remote_user: [yourname]
  tasks:
    - [task 1]
    - [task 2]
&lt;/syntaxhighlight&gt;

'''handlers:'''&lt;br/&gt;
Handler är samma sak som task fast körs bara om de blivit kallade på av en notify. Notify läggs i en task.
&lt;syntaxhighlight lang="yaml"&gt;
tasks:
  - [task 1]
    notify:
      - restart apache

handlers:
  - name: restart apache
    service: name=apache state=restarted
&lt;/syntaxhighlight&gt;

'''vars_prompt'''&lt;br/&gt;
&lt;syntaxhighlight lang="yaml"&gt;
vars_prompt:

- name: "Password"
  prompt: "Enter password"
  private: yes

...
  password: "{{Password}}"
...
&lt;/syntaxhighlight&gt;

===Templates===
Bygg och testa jinja-templates: https://ansible.sivel.net/test/

==Vault==
Med vault kan man skydda sina lösenord och nycklar med assymetrisk AES-kryptering.
 ansible-vault create vault.yml
 ansible-vault edit vault.yml
 ansible-playbook vault.yml --ask-vault-pass

[[Category:Guider]]</text>
      <sha1>0e5seuvf98q9vvd450qry41d9lzn2xd</sha1>
    </revision>
  </page>
  <page>
    <title>Apache</title>
    <ns>0</ns>
    <id>42</id>
    <revision>
      <id>1791</id>
      <parentid>1652</parentid>
      <timestamp>2016-05-21T16:46:53Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3453">Apache är en av världens mest använda webbservrar. Och hostar idag ca 35-40% av alla hemsidor i världen. Apache är en väldigt enkel webbserver att konfigurera och har även flera användbara tillägg.

==Installation==
 sudo apt-get install apache2

=== Apache kommandon ===
&lt;code&gt;a2ensite&lt;/code&gt;  För att aktivera en sida. Tillgängliga sidor finns i mappen &lt;code&gt;/etc/apache2/sites-available&lt;/code&gt;

&lt;code&gt;a2dissite&lt;/code&gt; För att inaktivera av en sida. Aktiverade sidor finns i mappen &lt;code&gt;/etc/apache2/sites-enabled&lt;/code&gt; 

&lt;code&gt;a2dismod&lt;/code&gt; För att stänga av ett tillägg. Aktiverade tillägg finns i mappen &lt;code&gt;/etc/apache2/mods-enabled&lt;/code&gt;

&lt;code&gt;a2enmod&lt;/code&gt; För att aktivera ett tillägg. Tillgängliga tillägg finns i mappen &lt;code&gt;/etc/apache2/mods-available&lt;/code&gt;

== Konfiguration ==
vHosts är bra att använda om man bara har en IP utåt och vill dela port 80/443 med flera hemsidor men ha olika domännamn. För att få virtualhost att fungera så räcker det att man lägger till denna raden i apache configen.
 ServerName hackernet.se

Kopiera default filen under sites-available.
 cp /etc/apache2/sites-available/default /etc/apache2/sites-available/hackernet
Öppna den nya filen och lägg till raden precis under &lt;code&gt;ServerAdmin&lt;/code&gt; och över &lt;code&gt;DocumentRoot&lt;/code&gt;

Ändra även &lt;code&gt;DocumentRoot&lt;/code&gt; och &lt;code&gt;Directory&lt;/code&gt; ifall du vill att en annan hemsida ska visas istället för orginal.

Aktivera sedan sidan med 
 a2ensite hackernet

=== Apachectl ===
Kolla grundläggande konfiguration:
 apachectl -S

Kör ett configtest:
 apachectl -t

== Permissions ==
Följande är en bra grund för filrättigheter.
 chown root:www-data /var/www/html -R
 chmod g+s /var/www/html
 chmod o-wrx /var/www/html -R
www-data, apache2′s user, har nu grupp-ägarskapet för default web root och alla filer däri. g+s säger åt filsystemet att alla nya filer som skapas får samma grupp-ägarskap.

==Log files==
 tail -f /var/log/apache2/access.log

==SSL==
Enable module
 sudo a2enmod ssl &amp;&amp; sudo a2enmod headers &amp;&amp; sudo service apache2 restart

'''Certifikat''' &lt;br/&gt;
Fixa ett certifikat, antingen från en CA (t.ex. [[Let%27s_Encrypt|Let's Encrypt]]) eller [[Digitala_Certifikat#Self-signed|self-signed]].

Konfiguration med säkerhet i fokus. 
 https://cipherli.st/

Aktivera vHost
 sudo a2ensite hackernet &amp;&amp; sudo service apache2 restart

== Dölj Version ==
Skriv följande i &lt;code&gt;Apache.conf/httpd.conf&lt;/code&gt;
 ServerTokens ProductOnly
 ServerSignature Off

==ApacheBench==
Benchmarking tool
 ''sudo apt-get install apache2-utils''
 ab -n 500 -c 100 http://example.com/

==Known errors==
===[warn] _default_ VirtualHost overlap on port 443, the first has precedence===

Kan man få när man försöker skapa flera vhost på port 443. Man märker också problemet att alla olika vhostar på port 443 pekar på samma sida.

För att fixa lägg till &lt;code&gt;NameVirtualHost *:443&lt;/code&gt; i din &lt;code&gt;ports.conf&lt;/code&gt; eller &lt;code&gt;httpd.conf&lt;/code&gt; fil.
&lt;syntaxhighlight lang=apache&gt;
 &lt;IfModule mod_ssl.c&gt;
     # If you add NameVirtualHost *:443 here, you will also have to change
     # the VirtualHost statement in /etc/apache2/sites-available/default-ssl
     # to &lt;VirtualHost *:443&gt;
     # Server Name Indication for SSL named virtual hosts is currently not
     # supported by MSIE on Windows XP.
     NameVirtualHost *:443
     Listen 443
 &lt;/IfModule&gt;
&lt;/syntaxhighlight&gt;

[[Category:Guider]]</text>
      <sha1>bxsbmgmh3fl8oalbd3gls0p67r8dug0</sha1>
    </revision>
  </page>
  <page>
    <title>Apt</title>
    <ns>0</ns>
    <id>96</id>
    <revision>
      <id>1972</id>
      <parentid>1709</parentid>
      <timestamp>2016-07-25T11:52:17Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4117">Apt står för Advanced Package Tool och är ett user interface för installera och ta bort program på Linux. Apt var från början ett user-interface mot dpkg (Debian package) men har sedan dess modifierats att fungera på RPM baserade system som Red hat tex. Apt följer med från start på alla Debian-baserade distar.

===File locations===
* /etc/apt/sources.list: Locations to fetch packages from.
* /etc/apt/apt.conf: APT configuration file.
* /etc/apt/preferences: "pinning", i.e. a preference to get certain packages from a separate source or from a different version of a distribution.
* /var/cache/apt/archives/: storage area for retrieved package files.

== Kommandon ==
Apt är en programsvit med flera olika program för att managera dina program.

Lista installerade paket och deras versioner:
 apt list --installed

== apt-get ==
Apt-get är programmet som tar hand om nerladdning och installation av ett program.

==== update ====
Uppdatera din lista med paket.
 apt-get update

==== install ====
Installera ett paket. Hämtar alltid senaste versionen som finns i din lista.
 apt-get install &lt;paket&gt;

Installera en specifik version av ett program. Mer info på [[Apt#show|apt-cache show]] om hur du ser vilka versioner som finns.
 apt-get install &lt;paket&gt;=&lt;version&gt;

==== upgrade ====
Kolla om det finns en ny version av ett program du har installerat och uppgradera det. 
 apt-get upgrade
 apt-get -s upgrade #Dry run

För att uppgradera hela din dist från tex Debian 7 till Debian 8 kör.
 apt-get dist-upgrade

==== remove ====
Ta bort ett program. Config filer finns fortfarande kvar.
 apt-get remove &lt;paket&gt;

Ta bort ett program och config filer.
 apt-get purge &lt;paket&gt;

Oftast så är ett paket beroende av ett annat paket för att fungera och då installeras det paketet också. Men sen om du väljer att ta bort paketet du ville installera så finns fortfarande dom andra paketen kvar. Om du vill ta bort paket som inte behövs så kör.
 apt-get autoremove

== apt-cache ==
apt-cache är ett program för att söka och få fram information om ett paket i din lista.

==== search ====
För att söka efter program.
 apt-cache search &lt;paket&gt;

==== show ====
Få en kort beskrivning av ett program. Samt vilka olika versioner som finns att hämta.
 apt-cache show &lt;paket&gt;

För att endast se vilka versioner det finns av ett program.
 apt-cache show &lt;paket&gt; | grep Versions:

==== showpkg ====
Ta på mer information om ett program. Tex vilka versioner finns att hämta, vilka program den är beroende av och vilka program som är beroende av den.
 apt-cache showpkg &lt;paket&gt;

== apt-mark ==
Bestämmer ett program/pakets framtid.

==== hold ====
Markerar ett paket så det inte kan bli automatiskt installerat, uppgraderat eller tas bort.
 apt-mark hold &lt;paket&gt;

==== unhold ====
Tvärtemot hold.
 apt-mark unhold &lt;paket&gt;

==== auto ====
Markerar att ett paket blivit installerat automatiskt. Paketet kommer då att tas bort automatiskt när inget paket som installerats manuellt finns kvar.
 apt-mark auto &lt;paket&gt;

==== manual ====
Markerar ett paket som att det blivit installerat manuellt. Paketet kommer inte tas bort automatiskt.
 apt-mark manual &lt;paket&gt;

==== show ====
Tre kommandon där man ser på namnet vad som händer.
 apt-mark showauto
 apt-mark showmanual
 apt-mark showhold

==Apt Proxy==
För att spara bandbredd kan man sätta upp en egen cache av Ubuntus repo och peka sina servrar mot den.&lt;br/&gt;
På cachen:
 sudo apt-get install apt-cacher-ng
På övriga maskiner
 sudo nano /etc/apt/apt.conf
 Acquire::http { Proxy "http://10.0.0.500:3142"; };

==Ansible==
[[Ansible]] update-playbook
&lt;syntaxhighlight lang="yaml"&gt;
---
- hosts: servers
  sudo: true
  tasks:
   - name: apt-get update
     apt: update_cache=yes
   - name: apt-get upgrade
     apt: upgrade=full
   - name: apt-get --dry-run autoremove
     command: apt-get --dry-run autoremove
     register: check_autoremove
     changed_when: False
   - name: apt-get autoremove
     command: apt-get -y autoremove
     when: "'packages will be REMOVED' in check_autoremove.stdout"
&lt;/syntaxhighlight&gt;

[[Category:Tools]]</text>
      <sha1>r1txwwn8lg3jw22tautjm9mrht8asa7</sha1>
    </revision>
  </page>
  <page>
    <title>Arista BGP</title>
    <ns>0</ns>
    <id>208</id>
    <revision>
      <id>2811</id>
      <parentid>1288</parentid>
      <timestamp>2018-08-13T10:30:51Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1020">Se även [[Cisco_BGP|Cisco BGP]]

=Konfiguration=
 router bgp 65001
   neighbor 20.20.20.20 remote-as 65001
   neighbor 20.20.20.20 description vEOS20
   neighbor 20.20.20.20 password 7 gqWjIYItRuw=
   neighbor 20.20.20.20 maximum-routes 12000
   network 210.210.210.0/24

'''ECMP'''
 router bgp 65001
  maximum-paths 4 ecmp 4

'''Show'''
 show ip bgp summary
 show ip bgp neighbor

'''Reset'''
 clear ip bgp *
 clear ip bgp &lt;address&gt; soft

===BGP-LU===
BGP kan annonsera unicast routes med en associated mpls label (RFC 3107). Det kan t.ex. användas för att tunnela genom andra provider backbones och på så sätt binda ihop multipla IGP-instancer över stitchade LSP paths. BGP-LU advertisements påverkar endast edge/border routers och inte P routers.
 router bgp 65001
  neighbor 2.2.2.2 remote-as 65001
  neighbor 2.2.2.2 update-source Loopback0
  neighbor 2.2.2.2 maximum-routes 12000
 
  address-family ipv4 labeled-unicast
   neighbor 2.2.2.2 activate

Verify
 show ip bgp labeled-unicast

[[Category:Arista]]</text>
      <sha1>gw0fw0kunpedn6qv7pn35lqbrt8hjps</sha1>
    </revision>
  </page>
  <page>
    <title>Arista EOS</title>
    <ns>0</ns>
    <id>189</id>
    <revision>
      <id>3099</id>
      <parentid>3079</parentid>
      <timestamp>2020-08-14T06:23:59Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4015">Arista Extensible Operating System är ett Linux-based network operating system. EOS levereras som en image som kan köras på alla plattformar, även som virtuel maskin. EOS är väldigt Cisco IOS likt i sina kommandon. 

=vEOS=
vEOS fungerar på de flesta virtualiseringsplattformar inklusive [[EVE-NG]], [[KVM]], VirtualBox, [[VMware_ESXi|ESXi]] och Hyper-V. vEOS-lab har en drivrutin som heter Elba, den emulerar hårdvara. En del features saknar vEOS-lab stöd för, t.ex. storm-control och IPsec.

===Installation===
För nyare vEOS (4.15) vill man ha 2GB RAM. 

'''ESXi'''
 https://eos.arista.com/running-veos-on-esxi-5-5/

'''Virtualbox'''
 vboxmanage createvm --name vEOS02 --ostype Fedora_64 --register
 VBoxManage modifyvm vEOS02 --memory 2048
 VBoxManage modifyvm vEOS02 --nic1 intnet
 VBoxManage modifyvm vEOS02 --intnet1 Mgmt1
 VBoxManage modifyvm vEOS02 --nicpromisc1 allow-vms
 VBoxManage modifyvm vEOS02 --cableconnected1 on
 VBoxManage storagectl vEOS02 --name "IDE Controller" --add ide
 VBoxManage storageattach vEOS02 --storagectl "IDE Controller" --port 0 --device 0 --type hdd --medium /path/vEOS-lab-4.15.2.1F.vmdk
 VBoxManage storageattach vEOS02 --storagectl "IDE Controller" --port 1 --device 0 --type dvddrive --medium /path/Aboot-veos-2.1.0.iso

'''Credentials'''&lt;br/&gt;
admin: &lt;no password&gt;

=Konfiguration=
Grundkonfiguration
 hostname vEOS-01
 logging console notifications
 logging monitor informational
 logging synchronous
 logging buffered 2000
 username wizkid privilege 15 secret &lt;password&gt;
 
 show user-account

Management interface
 interface Management1
  ip address 10.0.0.10/24
  no shut
 
 lldp management-address Management1

===SSH===
SSH är påslaget default, det som behöver konfas är användare och IP-adress. Ska man använda EOS som scp-server måste det user-konto man loggar in med ha "full access", dvs privilege 15.
 management ssh
  idle-timeout 1800

Autentisering med SSH-nyckel
 copy scp:user@jumphost/home/user/.ssh/id_rsa.pub flash:
 username ''user'' sshkey file flash:id_rsa.pub

===Management VRF===
 vrf definition MGMT 
  rd 100:100
Första porten är Ma1
 interface ma1 
  vrf forwarding MGMT 
  ip address 10.0.0.10 255.255.255.0

===eAPI===
En user behövs för att kunna använda eAPI. URL till API sandbox: https://&lt;mgmt-ip&gt;:443
 management api http-commands
  no shutdown
  !
  vrf MGMT
   no shutdown
 
 show management api http-commands 

Det finns även stöd för netconf och restconf
 management api netconf
   transport ssh MGMT
 !
 management api restconf
   transport https MGMT

=Diverse=
Show the current running-config for this sub mode
 show active
Show diff between running and startup
 show running diff
Backa till startup-konfig
 configure replace startup-config
CLI history
 show history
Slå på loggmeddelanden i SSH terminal.
 terminal monitor

'''Syslog'''
 logging buffered 10000 notifications
 logging host 10.0.0.12
 show logging
 show logg last 10 min

'''NTP'''
 ntp server 10.0.0.12

'''DNS'''
 ip name-server 8.8.8.8
 show hosts

'''SCP Server'''
 aaa authorization exec default local

===Port mirroring===
 monitor session 1 source interface &lt;interface&gt; [ rx | tx | both ]
 monitor session 1 destination &lt;interface&gt;
Begränsa på IP vad som ska speglas.
 monitor session 1 ip access-group &lt;ACL name&gt;

===Iperf===
[[Iperf]] finns inbyggt i EOS. Dock tillåts inte tcp 5001 default.
 bash
 sudo iptables -I INPUT -p tcp -m tcp --dport 5001 -j ACCEPT
 iperf -s
Klient
 iperf -c 10.0.0.10

===Yum===
Yum finns inbyggt i EOS men det finns inga repos default.
 bash
 sudo nano /etc/yum.repos.d/fedora.repo
 [fedora]
 name=Fedora 14 – i386
 failovermethod=priority
 baseurl=http://dl.fedoraproject.org/pub/archive/fedora/linux/releases/14/Everything/i386/os/
 exclude=kernel,fedora-logos
 enabled=1
 gpgcheck=0

 sudo yum install iftop

===Maintenance Mode===
Sätt hela switchen i maintenance mode, då graceful stängs allt utom management.
 maintenance
  unit System
   quiesce
 show maintenance

[[Category:Arista]]</text>
      <sha1>aj9502pav6ir482pb6srzpzb8ke8hjd</sha1>
    </revision>
  </page>
  <page>
    <title>Arista EVPN</title>
    <ns>0</ns>
    <id>512</id>
    <revision>
      <id>2767</id>
      <timestamp>2018-04-06T16:38:05Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Ethernet VPN (RFC 7432) är en modernare variant än [[Cisco_VPLS|VPLS]] för att tillhandahålla Ethernet multipoint services över IP ([[Arista_VXLAN|VXLAN]]) eller MPLS (me..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3023">Ethernet VPN (RFC 7432) är en modernare variant än [[Cisco_VPLS|VPLS]] för att tillhandahålla Ethernet multipoint services över IP ([[Arista_VXLAN|VXLAN]]) eller MPLS (med eller utan [[Arista_SR|SR]]). BGP EVPN är en ny adressfamilj som används för att distribuera lokala MAC-adresser och MAC/IP bindings till VTEP:s. Next-hop i EVPN-uppdateringarna är antingen egress Label Switch Router eller VXLAN Tunnel Endpoint. EVPN har bl.a. features för att hålla koll på hostar som flyttar mellan datacenter (sekvensnummer i annonseringarna) och kan då konvergera snabbt. Ett EVPN-nätverk kan göra både bridging och routing och har inbyggd support för multi-tenancy. Protokollet är öppet så det finns interoperability med andra network vendors, se t.ex. [[Cisco_EVPN|Cisco]], [[Cumulus_EVPN|Cumulus]] och [[Quagga#EVPN|Quagga]] EVPN. 

'''Route types'''&lt;br/&gt;
# Ethernet Auto-Discovery Route
# MAC/IP Advertisement Route
# Inclusive Multicast Ethernet Tag Route
# Ethernet Segment Route
# IP Prefix Route

=Konfiguration=
EVPN kan konfigureras på olika sätt beroende på hur designen ser ut däremot måste man byta BGP agent ifrån GateD till arBGP. 
 service routing protocols model multi-agent
EOS kan än sålänge inte auto-derivera RD eller RT.

===Underlay===
Underlay routing kan göras med IGP, iBGP eller eBGP. Alla VTEP:s måste kunna nå varandra. Simpelt exempel:
 ip routing
 
 interface Loopback0 
  description VTEP
  ip address 1.1.1.1/32 
 
 router ospf 1
  redistribute connected
  network 0.0.0.0/0 area 0.0.0.0

===Overlay===
 interface Vxlan1  
  vxlan source-interface Loopback0
  vxlan udp-port 4789 
 
 router bgp 65000
   no bgp default ipv4-unicast
   neighbor 172.16.0.2 remote-as 65000
   neighbor 172.16.0.2 send-community extended
   !
   address-family evpn
     neighbor 172.16.0.2 activate
Verify
 show bgp evpn summary

====Bridging====
 vlan 100-101
 
 interface Vxlan1  
  vxlan vlan 100 vni 10100
  vxlan vlan 101 vni 10101
 
 router bgp 65000
  vlan 100
    rd 1.1.1.1:100
    route-target both 65000:10100
    redistribute learned
  vlan 101
    rd 1.1.1.1:101
    route-target both 65000:10101
    redistribute learned
Verify
 show bgp evpn route-type mac-ip

====L3====
Arista implementerar EVPN VXLAN routing i symmetric mode. För att få fram RMAC samt ha ett interface in mot fabricen (logisk) autoskapar EOS ett SVI per VRF som har ett L3VNI knytet till sig. Det man måste konfa är VRF, knyta till L3VNI och få in i BGP.
 vrf definition Tenant1
 
 ip routing vrf Tenant1
 
 interface Vxlan1
  vxlan vrf Tenant1 vni 30001
 
 router bgp 65000
  vrf Tenant1
    rd 1.1.1.1:1009
    route-target import 65000:30001
    route-target export 65000:30001

'''Anycast GW'''
 ip virtual-router mac-address 0000.1111.2222
 
 interface Vlan100
  vrf forwarding Tenant1
  ip address virtual 10.0.0.1/24

'''Skicka lokala IP prefix, route type 5
 router bgp 65000
  vrf Tenant1
   redistribute connected

Verify
 show bgp evpn route-type ip-prefix ipv4

[[Category:Arista]]</text>
      <sha1>7n68wm6xb4wk0pl7o08i4opwk5ymxh7</sha1>
    </revision>
  </page>
  <page>
    <title>Arista OSPF</title>
    <ns>0</ns>
    <id>193</id>
    <revision>
      <id>1167</id>
      <timestamp>2015-10-26T11:45:01Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Open Shortest Path First. Se även [[Cisco_OSPF|Cisco OSPF]]  ==Konfiguration==  router ospf [process-id]  router-id for this OSPF process (in IP address format)  router-id [O..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="793">Open Shortest Path First. Se även [[Cisco_OSPF|Cisco OSPF]]

==Konfiguration==
 router ospf [process-id]

router-id for this OSPF process (in IP address format)
 router-id [OSPF router-id] 

 log-adjacency-changes

Enable routing on an IP network
 network [network-number] [wildcard-mask] area [area-id]

Suppress routing updates on an interface
 passive-interface [interface]

 default-information originate

 interface [interface]
 ip ospf priority [number]
 exit

ABR Summarization
 router ospf 1
 area 10 range 10.10.0.0 255.255.252.0
 exit

ASBR Summarization
 router ospf 1
 summary-address 10.10.0.0 255.255.252.0
 exit

 router ospf 1
 auto-cost reference-bandwidth 1000
 exit

==Troubleshoot==
 show ip ospf neighbor
 ping 224.0.0.5
 show ip ospf interface brief

[[Category:Arista]]</text>
      <sha1>l3pkewytni3d580l63f6dkfl4vhgtwd</sha1>
    </revision>
  </page>
  <page>
    <title>Arista VXLAN</title>
    <ns>0</ns>
    <id>367</id>
    <revision>
      <id>2776</id>
      <parentid>2766</parentid>
      <timestamp>2018-04-12T08:45:57Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2875">Virtual Extensible LAN (VXLAN) är en network virtualization technology. VXLAN bridging tillhandahåller layer 2 konnektivitet för end systems över en routad infrastruktur. För att koppla ihop end systems i olika subnät krävs antingen centralized routing eller VXLAN routing. Det senare kan göras både symmetriskt och asymmetriskt, dvs om samma VNI används i båda trafikriktninger eller ej. Default för enkapsulerade paket mellan VTEP:ar används UDP port 4789. Däremot kan control plane göras på olika sätt, se nedan. Aristas VXLAN går att kombinera med [[Arista_MLAG|MLAG]]. Se även [[Cisco_VXLAN|Cisco VXLAN]].

=Konfiguration=
Initial setup. VTEP-IP måste vara nåbar från alla andra VTEP:ar.
 interface Loopback0
  description VTEP
  ip address 10.0.0.10/32
 
 interface Vxlan1
  vxlan source-interface Loopback0
  vxlan udp-port 4789

Skapa vlan och mappa med VNI.
 vlan 100
 
 interface Vxlan1
  vxlan vlan 100 vni 10100

Verify
 show interface vxlan 1
 show vxlan address-table

==Flood and Learn==
Med denna setup görs MAC learning med hjälp av flooding. Multidestinationstrafik (BUM) hanteras med Head-End Replication i underlay. Man måste konfa IP-adresser till alla VTEP:ar på alla VTEP:ar. Man kan även ange den lokala vtep-ip:n i flood-listan, den kommer att accepteras i konfen men ignoreras i praktiken. Flood and Learn är simpelt men inte det mest skalbara alternativet.
 interface Vxlan1
  vxlan vlan 100 flood vtep 10.0.0.11 10.0.0.12

Verify
 show vxlan flood vtep

==CVX==
CloudVision eXchange (CVX) kan automatiskt synkronisera VTEP:arna och deras state samt nödvändiga HER flood-lists. CVX synkroniserar alla MAC-adresser så fort en switch lärt sig dem på någon lokal port, dvs leafs publicerar sin mac table till CVX. Man kan sätta upp ett HA-kluster för resiliency. Det finns även stöd för third-party VTEP:s.

Leaf
 interface vxlan1
  vxlan source-interface Loopback0
  vxlan udp-port 4789
  vxlan control-service
 
 management cvx
  source-interface lo0
  server host 10.0.0.100
  no shut

Standalone CVX VXLAN service on EOS
 interface Loopback0
  ip address 10.0.0.100/32
 
 config
  cvx
   no shutdown
   service vxlan
    no shutdown

Verify
 show cvx 
 show cvx connections
 show vxlan controller status
 show vxlan controller address-table received

==EVPN==
Se [[Arista_EVPN|Arista EVPN]].

=Multitenancy routing=
Anycast gateway
 hardware tcam profile vxlan-routing
 
 vrf definition Tenant1
  rd 100:1
 
 ip routing vrf Tenant1
 ip route vrf Tenant1 0.0.0.0/0 10.0.0.1
 
 interface Vlan100
  vrf forwarding Tenant1
  ip address virtual 10.0.0.10/24
 
 interface Vlan101
  vrf forwarding Tenant1
  ip address virtual 10.0.101.1/24

=NSX=
Arista-switchar kan agera VTEP:s för [[VMware_vCenter|VMware]] NSX. Ta certet och importera i NSX Manager.
 show hsc certificate
 show hsc status

[[Category:Arista]]</text>
      <sha1>d34w8m1nhv2my9gclg30rl6na9j23ax</sha1>
    </revision>
  </page>
  <page>
    <title>AutoFS</title>
    <ns>0</ns>
    <id>50</id>
    <revision>
      <id>802</id>
      <parentid>613</parentid>
      <timestamp>2015-07-23T20:03:53Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2305">autofs är ett program för att automatiskt mounta kataloger efter behov när det behövs. Auto-mounts är endast mountade när de används, och umountas efter en period av inaktivitet. Mount av en remote share genom fstab förblir mountad såvida du inte umountar den. Automounting NFS/Samba-shares sparar bandbredd och ger bättre prestanda jämfört med statiska mounts genom fstab. fstab kan dessutom orsaka problem om sharen blir otillgänglig, vilket resulterar i inaktuella mounts. Till exempel kan filservern du ansluter till krascha eller nätverket kan gå ner.

==Installation==
 sudo apt-get install autofs
 sudo yum install autofs

==Konfiguration==
Skapa en mount point eller välj en befintlig katalog, t.ex. /mnt eller /media. Du kommer att behöva definiera mount points för att ange hur du ansluter till din nätverksresurs. 
 sudo mkdir /nfs-share
 sudo mkdir /smb-share
Redigera konfigurationsfilen för autofs:
 sudo nano /etc/auto.master
 /nfs-share   /etc/auto.nfs-share
 /smb-share   /etc/auto.smb-share
Skapa en ny fil i /etc/.

'''SMB'''
 sudo nano /etc/auto.smb-share
 filserver -fstype=smbfs,rw,username=buenos,password=nachos,file_mode=0777,dir_mode=0777 ://192.168.0.50/share
Där "filserver" anger den mapp som ska skapas under /share som host för dina shares

'''NFS'''
 sudo nano /etc/auto.nfs-share
 filserver -fstype=nfs,rw,soft,tcp,nolock 192.168.0.50:/mnt/ProdPool
Klienten behöver samma ändringar i /etc/default/nfs-common för att ansluta till en NFSv4-server. 
 NEED_IDMAPD = yes
 NEED_GSSD = no # no är default

'''CIFS'''&lt;br/&gt;
Får man inte säga, http://blog.fosketts.net/2012/02/16/cifs-smb/

=== Home Folder ===
För att mounta hem-mapparna med autofs enkelt och slippa att skapa en rad för varje användare i autofs filerna eller att man mountar alla hem mappar som finns på sharen kan man använda sig av wildcard.
 echo * -fstype=nfs,user,auto,rw,async,hard,intr 192.168.1.200:/mnt/zfs/Home/&amp; &gt; /etc/auto.home
 echo /home /etc/auto.home &gt;&gt; /etc/auto.master
Där "*" och "&amp;" är wildcard.

==Felsökning==
Reboota och försök komma åt din share.
 ls /nfs-share
 cd /smb-share
Om det inte fungerar, måste du felsöka. Stoppa autofs demonen
 sudo service autofs stop
Kör automount i förgrunden med verbose
 sudo automount -f -v

[[Category:Guider]]</text>
      <sha1>pq9rg3dlha6srdicowyrgq8oao0kznp</sha1>
    </revision>
  </page>
  <page>
    <title>BIND</title>
    <ns>0</ns>
    <id>84</id>
    <revision>
      <id>1716</id>
      <parentid>1715</parentid>
      <timestamp>2016-04-27T17:50:55Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* dnstracer */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8580">BIND är ett open source, flexibelt och fullt utrustat DNS-system.

Mjukvaran består av tre delar:
* Domain Name Resolver
* Domain Name Authority server
* Tools

==Installation==
 apt-get install bind9 bind9utils bind9-doc dnsutils

==Konfiguration==
===Domain Name Resolver===
===Domain Name Authority server===
====Zone transfers====
Har man flera servrar kan det vara smidigt att vid ändring i en zone att den syncas över till de andra bind servarna.

Skapa en ACL på master servern i &lt;code&gt;named.conf.local&lt;/code&gt;.
 acl slave {
    172.22.0.0/24;
    172.22.0.10;
 };

I zonen lägg till följande:
 zone "hackernet.se" {
    ....
    type master;
    allow-transfer { slave; };
 };

På din slav server lägg till följande i zonen:
 zone "hackernet.se {
    ....
    type slave;
    masters { 192.168.1.10; };
 }

Starta sedan om tjänsten på båda servarna.

=====TSIG=====
Transaction Signature (TSIG) kan användas för att säkra upp zone transfern.

Starta med att generera nykeln som ska användas på master DNS'n.
 dnssec-keygen -a HMAC-SHA512 -b 512 -n HOST -r /dev/urandom tsigkey

Två filer kommer att skapas. I private filen finns nykeln efter '''Key:'''. Kopiera nykeln och skapa filen:
 vim /etc/bind/named.conf.tsigkeys

Med följande info:
 key "my-tsig" {
  algorithm HMAC-SHA512;
  secret "&lt;key&gt;";
 };

Säg till bind att läsa in filen. Lägg till följande i slutet på '''named.conf''':
 include "/etc/bind/named.conf.tsigkeys";

För att säkra upp en zone skriv följande.
  zone "hackernet.se" {
    ....
    allow-transfer { key "my-tsig"; };
 };

Starta sedan om tjänsten.

På DNS slaven skapa samma tsigkeys fil:
 vim /etc/bind/named.conf.tsigkeys

Och kopiera in samma innehåll från master servern, men lägg till följande i slutet. För att säga till vilken nykel den ska använda:
 .....
 server 192.168.2.254 {
  keys { my-tsig; };
 };

Lägg till följande rad i '''/etc/bind/named.conf'''
 include "/etc/bind/named.conf.tsigkeys";

Och starta om tjänsten. Zone transfer ska nu funka, för att prova köra följande på slaven.
 dig @{master-dns-ip} hackernet.se axfr

Om du fick följande error:
 ; &lt;&lt;&gt;&gt; DiG 9.8.4-rpz2+rl005.12-P1 &lt;&lt;&gt;&gt; @ns1 hackernet.se axfr
 ; (1 server found)
 ;; global options: +cmd
 ; Transfer failed.

Så visar det att en zone transfer gick inte att köra utan en tsig nykel.

För att använda tsig nykeln kör följande kommando:
 dig @{master-dns-ip} hackernet.se axfr -k /etc/bind/named.conf.tsigkeys

==SRV record==
Med hjälp av service record('''SRV''') så kan man peka ut på vilken port och bakom vilket hostnamn en tjänst körs tex LDAP, SIP, Lync.

Ett SRV record ser ut på följande sätt.
 _service._proto.name. TTL class SRV priority weight port target.

*service: namnet på tjänsten.
*proto: vilket transport protokoll som ska användas, vanligast är TCP eller UDP.
*name: vilket domän namn recordet är till för.
*TTL: time to live.
*class: standard DNS klass. Denna är alltid '''IN'''.
*priority: hosten med lägst prioritet används i första hand.
*weight: används vid lastbalansering. Om 2 hostar har samma priority så har den host med högre weight större chans att bli vald.
*port: port på tjänsten.
*target: hostnamnet på servern.  

===LDAP autodiscovery===
Skriv följande i din zonefil.
 _ldap._tcp.hackernet.se.   IN      SRV     10 0 389 ldap1.hackernet.se.
 _ldap._tcp.hackernet.se.   IN      SRV     20 0 389 ldap2.hackernet.se.

==Dynamic DNS==
===ISC DHCP===
Sätt upp DDNS så att lokala klienter som får IP från en dhcp server uppdaterar din lokala forward och reverse zone.

=====Generera en nykel=====
 dnssec-keygen -a HMAC-MD5 -b 128 -r /dev/urandom -n USER DDNS_UPDATE

Öppna filen '''*.private''' och kopiera allt efter '''Key:'''

Skapa en ny fil som heter '''ddns.key''' som ser ut som följande och kopiera in texten från '''*.private''' filen:
 key DDNS_UPDATE {
         algorithm HMAC-MD5.SIG-ALG.REG.INT;
         secret "&lt;key&gt;";
 };

Kopiera sedan '''ddns.key''' filen till bind mappen och dhcp serverns mapp.
 install -o root -g bind -m 0640 ddns.key /etc/bind/ddns.key
 install -o root -g root -m 0640 ddns.key /etc/dhcp/ddns.key

=====Bind konfiguration=====
Lägg in följande rad i din '''named.conf.local''' fil:
 include "/etc/bind/ddns.key";

Lägg till denna raden '''allow-update { key DDNS_UPDATE; };''' i varje zone som ska uppdateras.
 zone "example.org" {
      type master;
      notify no;
      file "/var/cache/bind/db.example.org";
      allow-update { key DDNS_UPDATE; };
 };
 zone "1.168.192.in-addr.arpa" {
      type master;
      notify no;
      file "/var/cache/bind/db.192.168.2";
      allow-update { key DDNS_UPDATE; };
 };

=====DHCP konfiguration=====
Följande globala inställningar behövs i din '''dhcpd.conf'''' fil:
 option domain-name "example.org";
 
 ddns-updates           on;
 ddns-update-style      interim;
 ignore                 client-updates;
 update-static-leases   on;

'''option domain-name:''' Specificerar vilket domän namn som delas ut, används också av DDNS. &lt;br&gt;
'''ddns-update-style:''' Bör alltid vara interim. Adhoc finns som val också men är utdaterat.&lt;br&gt;
'''client-updates:''' Om du använder '''allow client-updates''' så låter du klienter registrera sitt domän namn på DNS servern själv. Default är '''ignore client-updates'''.&lt;br&gt;
'''update-static-leases:''' Default så uppdaterar inte DHCP-servern DNS rader som är statiska leases.

Lägg också till följande rader i din '''dhcpd.conf''' fil:
 include "/etc/dhcp/ddns.key";
 
 zone example.org. {
   primary 127.0.0.1;
   key DDNS_UPDATE;
 } 
 
 zone 1.168.192.in-addr.arpa. {
   primary 127.0.0.1;
   key DDNS_UPDATE;
 }

Se till att bind har skrivrättigheter i mappen där zone filen finns sparad annars kan den inte uppdatera.

Starta sedan om tjänsterna.
 /etc/init.d/isc-dhcp-server restart
 /etc/init.d/bind9 restart

==Tips n Trix==
===Chroot===
För att öka säkerheten bör man lägga tjänsten i en chroot-miljö.
 yum install bind-chroot -y
 service named restart

===Serial number reset===
Har man råkat sätta för högt serienummer i en zon kan man resetta det med följande metod. Sätt serienumret till:
 4294967295
Låt det propagera till slavarna och sedan kan man sätta vad man vill.

===Statistics===
Vill du se lite statistik på din DNS-server kan konfa följande och sedan surfa in på http://&lt;IP&gt;:8080
 acl "trusted" {
   192.168.1.0/24;
 };
 statistics-channels { 
   inet *  port 8080 allow { trusted; }; 
 };

===Response Rate Limiting===

==Tools==
Kör igenom toolsen för att få en känsla för dem.&lt;br/&gt;
Short output
 dnsget hackernet.se
 dig hackernet.se +short
Kolla SOA på alla namnservrar
 dig hackernet.se +nssearch
Kolla om records finns mot wordlist
 dnsmap hackernet.se
Kolla version på DNS-server
 ldns-chaos hackernet.se
Monitor queries
 sudo dnstop eth0
Capture queries
 sudo dnscap -g
Visualisera
 sudo tcpdump -i eth0 -w dnsdump.pcap port 53
 dnspktflow dnsdump.pcap
 eog out.png

=== rndc ===
Är ett program för att uppdatera dnservern med nya zoner eller uppdatera befintliga zoner. Fördelen med att använda rndc är att man behöver inte ladda om alla zoner om man bara gör ändringar i en zone. Har man många stora zoner kan DNS sluta svara under några sekunder.
 rndc reconfig - Används om du gjort någon ändring i .conf filerna eller för att läsa in nya zoner. Den kommer inte bry sig om du gjort någon ändring i nån zone fil.
 rndc reload - För att ladda om alla zone filer.
 rndc reload &lt;zone name&gt; - För att enbart ladda om den zonen du gjort en ändring på.

=== dnstracer ===
[[Dnstracer]] följer alla dns servrar tills man hittar den servern man letar efter.
 dnstracer -o4s . hackernet.se

===Felsök===
Se hur långt i resolve-processen det funkar
 dig hackernet.se +trace
Kolla efter syntax-errors alla inladdade zoner
 named-checkconf -z

==DNSSEC==

==Known errors==
===Journal out of sync error===
Om man har en dynamisk zone som uppdateras från tex en DHCP och denna zonen skulle uppdateras manuellt så kommer den inte längre laddas korrekt och ger följande meddelande. 
 zone hackernet.se/IN: journal rollforward failed: journal out of sync with zone
 zone hackernet.se/IN: not loaded due to errors.

Lösningen är att ta bort '''.jnl''' filen som tillhör zonen. Efter det är det bara att starta om BIND.

Om du skulle behöva uppdatera en zone manuellt börja med att frysa zonen.

 rndc freeze hackernet.se
 '''(ändra i zonefilen)'''
 rndc reload hackernet.se
 rndc thaw hackernet.se

[[Category:Guider]]</text>
      <sha1>7yorf4ibkgwplmyz6hyyum6xfhq926p</sha1>
    </revision>
  </page>
  <page>
    <title>BIRD</title>
    <ns>0</ns>
    <id>204</id>
    <revision>
      <id>1299</id>
      <parentid>1277</parentid>
      <timestamp>2015-11-22T17:21:05Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>BGP</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2240">Bird Internet Routing Daemon. 
Senaste version: 1.5.0 (22.4.2015)

=Installation=
 sudo apt-get update &amp;&amp; sudo apt-get install bird 
 sudo dnf install bird

=Konfiguration=
'''Ubuntu'''

Enable IPv4 and IPv6 Forwarding: 
 echo "net.ipv4.conf.all.forwarding=1" | sudo tee -a /etc/sysctl.conf 
 echo "net.ipv4.conf.default.forwarding=1" | sudo tee -a /etc/sysctl.conf 
 sed 's/#net.ipv6.conf.all.forwarding=1/net.ipv6.conf.all.forwarding=1/g' /etc/sysctl.conf | sudo tee /etc/sysctl.conf 
 echo "net.ipv6.conf.default.forwarding=1" | sudo tee -a /etc/sysctl.conf 
 sudo sysctl -p 

Backup the configuration files: 
 sudo cp /etc/bird/bird.conf /etc/bird/bird.conf.original 
 sudo cp /etc/bird/bird6.conf /etc/bird/bird6.conf.original 

Create the configuration files: 
 sudo nano /etc/bird/bird.conf 
 sudo nano /etc/bird/bird6.conf 

Restart the daemons: 
 sudo service bird restart 
 sudo service bird6 restart 

'''Fedora'''

Backup
 sudo cp /etc/bird.conf /etc/bird.conf.original
Edit
 sudo nano /etc/bird.conf
Restart
 sudo systemctl restart bird

==CLI==
Gå till cli
 sudo birdc
 bird&gt; show route
Quit
 bird&gt; exit

==OSPF==
 show ospf interface 
 show ospf neighbors 
 show ospf state 
 show ospf topology

==BGP==
 protocol bgp {
 #       disabled;
         description "My BGP uplink";
         local as 65002;
         neighbor 172.22.0.90 as 65000;
 #       multihop;
         hold time 240;
         startup hold time 240;
         connect retry time 120;
         keepalive time 80;      # defaults to hold time / 3
         start delay time 5;     # How long do we wait before initial connect
         error wait time 60, 300;# Minimum and maximum time we wait after an error (when consecutive
         error forget time 300;  # ... until this timeout expires)
         path metric 1;          # Prefer routes with shorter paths (like Cisco does)
         default bgp_med 0;      # MED value we use for comparison when none is defined
         default bgp_local_pref 0;       # The same for local preference
         source address 172.22.0.19;     # What local address we use for the TCP connection
 #       password "secret";      # Password used for MD5 authentication
 }

Birdc
 show protocols all bgp1

[[Category:Network]]</text>
      <sha1>83m94v58dmvdxs0sinh9ldnptqzddxl</sha1>
    </revision>
  </page>
  <page>
    <title>Bash</title>
    <ns>0</ns>
    <id>536</id>
    <revision>
      <id>2957</id>
      <parentid>2956</parentid>
      <timestamp>2019-03-25T18:12:20Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Bash scripting */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2626">Bash är den allra vanligaste kommandotolken man möts av i Linux.
=Bash sensible=
[https://github.com/mrzool/bash-sensible| Bash sensible] är ett script som försöker sätta bättre bash default inställningar. Precis som Vim sensible försöker göra åt vim.

Sensible fixar bla hur bash hanterar history
* Adderar till historiken istället för att skriva över.
* Sparar multi-line kommandon som ett kommando.
* Större historik.
* Tar bort dubbletter.
* Sparar inte onödiga kommandon som exit, ls, bg, fg och history.

 git clone https://github.com/mrzool/bash-sensible/blob/master/sensible.bash

För att installera kan man kopiera hela '''sensible.bash''' eller delar av filen in i sin '''bashrc''' fil eller source in filen i sin '''bashrc''' fil:
&lt;syntaxhighlight lang=bash&gt;
if [ -f ~/bash-sensible/sensible.bash ]; then
   source ~/bash-sensible/sensible.bash
fi
&lt;/syntaxhighlight&gt;
=Awesome bash=
Awesome bash är en lista med massa länkar till olika bash saker. Allt från böcker, custom environment, frameworks, spel. 
 https://github.com/awesome-lists/awesome-bash
=Bash scripting=
Att skriva bash script kan vara väldigt enkelt och kan spara mycket tid, här under kommer en del tips som kan vara bra att känna till.
==Shebang==
Man öppnar alltid alla script med en så kallad shebang. Detta för att systemet ska veta av hur den ska köra filen.
&lt;syntaxhighlight lang=bash line&gt;
 #!/usr/bin/env bash
&lt;/syntaxhighlight&gt;
==Variabler==
Variabler i bash skrivs på följande sätt &lt;code&gt;'''variable-name='''''&lt;value&gt;''&lt;/code&gt;
&lt;source lang=bash line highlight=2&gt;
#!/usr/bin/env bash
HW="Hello World"
echo $HW
&lt;/source&gt;
&lt;source lang=bash&gt;
sparco@jumpgate:~$ ./script
Hello World
&lt;/source&gt;
==Argument==
Att kunna skicka in argument i sitt bash script för att göra det mer dynamiskt kan vara bra ibland. Första argumentet mappas mot &lt;code&gt;$1&lt;/code&gt; medans resten bara fortsätter enligt &lt;code&gt;$2,$3,$4...&lt;/code&gt;.
&lt;source lang=bash line&gt;
#!/usr/bin/env bash
echo $1 $2
&lt;/source&gt;
&lt;source lang=bash&gt;
sparco@jumpgate:~$ ./script Hello World
Hello World
&lt;/source&gt;
==Debuga scripts==
Att kunna debuga scripts kan göras på olika sätt genom att köra &lt;code&gt;echo&lt;/code&gt; på variabler eller sätta på en växel i bash som gör att den printar allt i sdout.
Att köra scriptet med &lt;code&gt;bash -x&lt;/code&gt;
&lt;source lang=bash&gt;
sparco@jumpgate:~$ bash -x ./script Hello world
+ echo Hello world
Hello world
&lt;/source&gt;
Ett annat sätt om man vill debuga delar av ett script istället för allt kan man använda sig av följande sätt:
&lt;source lang=bash line start="30"&gt;
set -x
......
set +x
&lt;/source&gt;




[[Category:Tools]]</text>
      <sha1>qqtzpe09snhm4p8z7awi44857q7l4kc</sha1>
    </revision>
  </page>
  <page>
    <title>Batch script</title>
    <ns>0</ns>
    <id>148</id>
    <revision>
      <id>965</id>
      <parentid>960</parentid>
      <timestamp>2015-08-26T12:16:39Z</timestamp>
      <contributor>
        <username>Zunken</username>
        <id>3</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="306">Batch script är ett script språk som man kan använda i Windows. Men nu används Powershell

== Olika Batch Script ==
Ändra decimalavskiljaren i Windows. Scriptet nedan sätter decimalavskiljaren till .
 reg add "HKCU\Control Panel\International" /v sDecimal /t REG_SZ /d . /f






[[Category:Windows]]</text>
      <sha1>2ogkzchbmup6dz6sg2i4jqakmp6p6bh</sha1>
    </revision>
  </page>
  <page>
    <title>Bcache</title>
    <ns>0</ns>
    <id>229</id>
    <revision>
      <id>1455</id>
      <parentid>1444</parentid>
      <timestamp>2016-01-17T12:59:18Z</timestamp>
      <contributor>
        <username>Bat</username>
        <id>4</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="724">Bcache är en Linux kernel block layer cache. 

=Installation=
 sudo add-apt-repository ppa:g2p/storage
 sudo apt-get update &amp;&amp; sudo apt-get -y install bcache-tools

=Konfiguration=
Först skapar man caching devices, SSDer.
 sudo make-bcache -C /dev/sdc1

Sedan skapar man backing devices, HDDer.
 sudo make-bcache -B /dev/sdb1

Registrera samtliga devices. (Endast om inte udev används på systemet)
 sudo echo /dev/sdX1 &gt; /sys/fs/bcache/register

Skapa filsystem och mounta.

Attach
 ls /sys/fs/bcache
 echo bcache-UUID &gt; /sys/block/bcache0/bcache/attach

===Writeback===
Default är det read cache (writethrough), för att slå på write cache.
 echo writeback &gt; /sys/block/bcache0/bcache/cache_mode

[[Category:Guider]]</text>
      <sha1>igsqcif83mcaktvz3timkrov6vwgnoj</sha1>
    </revision>
  </page>
  <page>
    <title>Beeswarm</title>
    <ns>0</ns>
    <id>72</id>
    <revision>
      <id>803</id>
      <parentid>479</parentid>
      <timestamp>2015-07-23T20:07:04Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2516">Beeswarm är ett IDS-projekt som ger enkel konfiguration, driftsättning och hantering av honeypots. Med honeypots kan man upptäcka om man har [http://www.imdb.com/title/tt0113243/ Hackers] i sitt nätverk.&lt;br/&gt;
Projektets hemsida: http://www.beeswarm-ids.org/

[[Image:Beeswarm_overview.png]]

* '''Server:''' Managerar och tar in rapporter från honeypots och klienter.
* '''Honeypot:''' Lyssnar på olika tjänster t.ex. SSH, SMTP, FTP, HTTP
* '''Klient:''' Försöker logga in på honeypotsen med fake-credentials, om någon annan försöker logga in med samma credentials vet man att trafik har avlyssnats.

==Installation==
''Ubuntu''
 sudo apt-get install libffi-dev build-essential python-dev python-pip libssl-dev libxml2-dev libxslt1-dev ntp
 sudo pip install pydes --allow-external pydes --allow-unverified pydes
 sudo pip install beeswarm
''OBS om följande händer: "The required version of setuptools (&gt;=6.0.1) is not available, and can't be installed while this script is running. Please install a more recent version first, using 'easy_install -U setuptools'"''&lt;br/&gt;
Kör:
 sudo easy_install -U setuptools
 sudo pip install beeswarm
'''På server:'''
 mkdir server_workdir &amp;&amp; cd server_workdir
 beeswarm --server --customize
Svara på frågorna samt kopiera lösenordet, webgui next.
 https://10.1.2.3:5000
 +Drone -&gt; 2 minuter på dig att registrera drone
'''På honeypot:'''
 sudo su -
 mkdir /root/drone_workdir &amp;&amp; cd /root/drone_workdir
 beeswarm --config https://10.1.2.3:5000/ws/drone/add/f12345
På honeypoten måste beeswarm köras som root för att kunna binda portar.&lt;br/&gt;
Resten görs i webguit

==Autostart==
 sudo touch /root/beeswarm.sh &amp;&amp; sudo chmod 700 /root/beeswarm.sh &amp;&amp; sudo nano /root/beeswarm.sh
'''Server'''
 #!/bin/sh
 su - user1 -c "/usr/local/bin/beeswarm --server --workdir /home/user1/server_workdir"
'''Honeypot'''
 #!/bin/sh
 /usr/local/bin/beeswarm --workdir /root/drone_workdir
'''Klient'''
 #!/bin/sh
 su - user1 -c "/usr/local/bin/beeswarm --workdir /home/user1/drone_workdir"
Lägg in följande i rc.local
 /root/beeswarm.sh &gt; /dev/null 2&gt;&amp;1 &amp;

==Uppgradering==
 sudo pip install --upgrade beeswarm --allow-external pydes --allow-unverified pydes

==NTP==
Tidssynk är mycket viktigt och om klockorna går fel slutar det att funka. Detta kan hända till och med när NTP är installerat, om man kör default-inställningar. Så trimma dem.
 sudo nano /etc/ntp.conf 
 server 0.ubuntu.pool.ntp.org minpoll 6 maxpoll 6
''6 betyder var 64 sekund''

[[Category:Guider]]</text>
      <sha1>dnkx56dtqgwubeebz9774fwxvi9ime5</sha1>
    </revision>
  </page>
  <page>
    <title>BitLocker</title>
    <ns>0</ns>
    <id>17</id>
    <revision>
      <id>806</id>
      <parentid>570</parentid>
      <timestamp>2015-07-23T20:17:24Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8275">”Krypterar du dina data går de inte att läsa utan att knäcka krypteringen. Det kräver betydligt mer av den som är ute efter dina data, och har du en stark kryptering är det möjligen organisationer som svenska FRA eller amerikanska NSA som kan knäcka den.” – Stiftelsen för internetinfrastruktur

BitLocker Drive Encryption (BDE) är en Microsoft-produkt och erbjuder datakryptering på volymnivå för Windowsklienter och servrar. 

OBS Endast BitLocker för Windows Server 2008 R2/Windows 7 behandlas i denna artikel.

==Krypteringsnivåer==
BitLocker har stöd för två olika krypteringsnivåer, AES med 128-bitars nyckel och AES med 256-bitars nyckel (AES är ett blockschiffer och för ökad säkerhet används CBC). NSA klassar AES-128 som ”SECRET” och AES-256 som ”TOP SECRET”. 

https://www.nsa.gov/ia/programs/suiteb_cryptography/

'''Diffuser'''
En Diffuser-algoritm hjälper till att skydda mot manipulation av skiffertexten. Dessa typer av attacker används för att försöka hitta mönster eller svagheter i den krypterade datan. BitLocker har stöd för Elephant-Diffuser-algoritmen och AES-128 med Diffuser är default.

==Begreppsförklaring: TPM==
Trusted Platform Module är en öppen standard. En tpm-krets är en liten processor på moderkortet med eget minne. Den kan bland annat generera och lagra egna nycklar, skapa och verifiera signaturer med publika nycklar. En nackdel med en separat kryptoprocessor som en tpm-krets är att informationen till och från kretsen inte är skyddad.
Den senaste versionen (1.2) kom för första gången år 2006 (Version 2.0 är i skrivande stund i draft-stadie). BitLocker stödjer endast version 1.2 och högre.


=Upplåsningsmetod=
Det finns tre metoder att välja på för att låsa upp krypteringen och därmed kunna starta operativsystemet:

'''TPM:''' Använder funktionerna i TPM-hårdvara (1.2) för att ge en transparent användarupplevelse. Nyckeln som används för diskkryptering är krypterad i TPM-kretsen och kommer endast att släppas till bootloadern om bootfilerna verkar vara omodifierade. 
Denna metod kan knäckas med en så kallad ”cold boot”-attack. http://en.wikipedia.org/wiki/Cold_boot_attack

'''Användarautentisering:''' Detta läge kräver att användaren matar in en PIN-kod för att kunna starta operativsystemet.
Denna metod måste användas i kombination med någon annan upplåsningsmetod.

'''USB-nyckel:''' Användaren måste sätta i ett USB-minne innehållandes kryptonyckeln i datorn för att kunna boota från den skyddade hårddisken.
Denna metod kan förbipasseras om en angripare får tillgång till USB-minnet.

'''Kombinationer'''
TPM only är default men dessa varianter kan kombineras för att öka säkerheten, t.ex. TPM + PIN, TPM + USB, TPM + PIN + USB.

'''Best Practice'''
Microsoft rekommenderar TPM + PIN. 
https://technet.microsoft.com/en-us/library/ee706531(v=ws.10).aspx


=Återställningsstrategi=
Ett krypteringsverktyg som BitLocker kräver en solid återställningsstrategi, och BitLocker tvingar dig att definiera en metod under installationen. Detta gör att du kan komma åt data på en krypterad enhet när enheten inte kan låsas upp med någon metod i föregående avsnitt.
På en operativsystemenhet behöver du en återställningsmetod när en användare glömmer PIN-koden, förlorar USB-minnet eller om TPM registrerar integritetsändringar i systemfilerna. Hur vanligt det är att TPM registrerar integritetsändringar vet jag inte men har aldrig hört talas om det. BitLocker stödjer tre återställningsmetoder: lösenord, nyckel och en dataräddningsagent (DRA).

Ett återställningslösenord är ett numeriskt lösenord på 48-bitar som genereras under installationen av BitLocker. Man kan spara lösenordet till en fil, som sedan lagras på ett säkert ställe eller konfigurera att det sparas automatiskt i AD:t. 
Om man vill spara lösenordet i AD:t måste man se till att datorerna kan ansluta till domänkontrollanten när man aktiverar BitLocker. Lagring av BitLocker-lösenord i AD:t är baserad på ett tillägg som skapar ett extra attribut till varje datorobjekt i AD:t, däri lagras lösenordet. Domänkontrollanter på Server 2008 och Server 2008 R2 inkluderar detta tillägg som standard. 

För lösenordshantering i AD:t tillhandahåller Microsoft en MMC-snapin som tillför en BitLocker-flik på datorobjekt. Fliken visar alla lösenord för datorobjektet. För Server 2008 R2 är BitLocker Active Directory Recovery Password Viewer ett verktyg som ingår i Remote Server Administration Toolkit (RSAT). 
Den andra metoden använder en 256-bitars återställningsnyckel som man kan spara på ett USB-minne eller annan plats. Precis som ett återställningslösenord, möjliggör en återställningsnyckel att användare kan avkryptera den systemdisken utan ingripande från administratörer, förutsatt att användaren har tillgång till nyckeln. När man använder en återställningsnyckel måste man sätta i ett USB-minne eller peka ut en annan plats där nyckeln finns.
Den tredje metoden är med hjälp av en dataåterställningsagent (DRA) och kräver ingripande av IT-avdelningen. Denna metod utnyttjar ett särskilt intyg som utfärdas till en dedikerad DRA-administratör i organisationen. DRA-certifikatets signatur distribueras till alla BitLocker-krypterade enheter med GPO-inställningar. Detta för att säkerställa att endast administratören med ett matchande DRA-certifikat och privat nyckel kan avkryptera disken.
Man använder GPO-inställningar för att konfigurera vilka metoder som krävs, är otillåtna, eller kan göras frivilligt. 


=Group Policy=
Följande inställningar bedömer författaren vara relevanta att titta på för en implementation.

Generella BitLocker-inställningar
 Choose drive encryption method and cipher strength
 Provide the unique identifiers for your organization
TPM-inställningar
 Turn on TPM backup to Active Directory Domain Services
Specifika inställningar för systemdiskkryptering.
 Choose how BitLocker-protected operating system drives can be recovered
 Configure TPM platform validation profile
 Require additional authentication at startup

Författarens rekommendationer:
Ställ in GPO så att det automatiskt tas backup på kryptonycklarna till AD:t, samt kryptera inte datorer som inte har nyckeln sparad i AD:t.


=Utrullningsmetod=
I större IT-miljöer kan man automatisera utrullning och konfiguration med ett script som Microsoft tillhandahåller. Scriptet heter EnableBitLocker.vbs och finns på: https://gallery.technet.microsoft.com/scriptcenter/780d167f-2d57-4eb7-bd18-84c5293d93e3 
Man kan använda scriptet som det är, eller skräddarsy det för att bättre möta organisationens behov. För att köra scriptet kan man använda ett startscript som appliceras med hjälp av GPO-inställningar eller ett distributionsverktyg som till exempel System Center Configuration Manager (SCCM). 

Före systemdiskkrypteringen kan man behöva kontrollera partitionerna på målsystemen. På en systemdisk kräver BitLocker en separat och aktiv systempartition. Detta är en okrypterad partition som innehåller de filer som behövs för att starta operativsystemet. I Windows 7, skapas en sådan systempartition automatiskt som en del utav installationen av Windows. På system som har uppgraderat från en tidigare Windows-version eller på system som kommer förkonfigurerade med en enda partition, kommer inställningsguiden automatiskt att konfigurera om målenheten för BitLocker genom att skapa en separat och aktiv systempartition.
Att använda manuell handläggning på varje dator blir snabbt opraktiskt när man ska förbereda hundratals eller tusentals system med en partition för BitLocker. Vi vill använda Microsofts WMI- script för att aktivera BitLocker.

'''Prestandapåverkan'''

Verkar inte finnas någon nämnvärd prestandapåverkan: http://lanoe.dyndns.org/index.php/howto1/bitlocker/2395-performance-hit-of-full-disk-encryption

'''Övriga tankar'''

Har användarna möjlighet att stänga av systemdiskkrypteringen utan administratörernas kännedom?

En diskkryptering kan ta flera timmar, kan datorn stängas av och sättas på under tiden utan att det förstör något?

[[Category:Windows]]</text>
      <sha1>722uibohvrfh18htirhtmy7i37ppd1w</sha1>
    </revision>
  </page>
  <page>
    <title>Bridge</title>
    <ns>0</ns>
    <id>104</id>
    <revision>
      <id>2584</id>
      <parentid>1620</parentid>
      <timestamp>2017-06-11T17:25:33Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1376">Linux Bridge är en kernel-modul som introducerades i kernel 2.2 och administreras med kommandot brctl. Man kan göra om portar på en Linuxmaskin till switchportar. Se även [[Open_vSwitch|Open vSwitch]] och [[Iproute2#VXLAN|Linux VXLAN]].

==Installation==
 sudo apt-get install bridge-utils
 sudo yum install bridge-utils

==Konfiguration==
 ifconfig eth0 0.0.0.0
 ifconfig eth1 0.0.0.0
 brctl addbr bridge1
 brctl addif bridge1 eth0 eth1
 brctl show

 brctl delif bridge1 eth0

'''/etc/network/interfaces'''
 auto bridge
 iface bridge
  bridge-vlan-aware yes
  bridge-ports eth0 eth1 eth7
  bridge-vids 3 4 6-10   #allowed vlan
  bridge-pvid 1          #native vlan
  bridge_waitport 0      #portfast
  bridge-stp on
  mstpctl-treeprio 20480

'''VLAN'''
 aptitude install vlan ifenslave
 echo "8021q" &gt;&gt; /etc/modules

'''Spanning-Tree'''
 sudo brctl stp bridge1 on 

'''/etc/network/interfaces'''
 auto bond0
 iface bond0 inet manual
        up ifconfig bond0 0.0.0.0 up
        slaves eth0 eth1
        bond-mode 4       #bond-mode 4 = 802.3ad
        bond-miimon 100
        bond-downdelay 200
        bond-updelay 200
        bond-lacp-rate 1
        bond-xmit-hash-policy layer2+3
Kolla packet
 cat /proc/net/bonding/bond0

===MAC Table===
Man kan kolla MAC-tabellen på en brygga med följande kommando:
 brctl show
 brctl showmacs &lt;bridge_name&gt;

[[Category:Network]]</text>
      <sha1>l8n3mh6fzwpwa3g6pbbw8kekzwwdtkj</sha1>
    </revision>
  </page>
  <page>
    <title>Cacti</title>
    <ns>0</ns>
    <id>7</id>
    <revision>
      <id>1871</id>
      <parentid>1474</parentid>
      <timestamp>2016-06-18T19:38:00Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5950">Cacti är en grafningslösning för nätverk. http://www.cacti.net/

==Installation==
Ubuntu 14.04

 sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get -y install snmpd snmp mysql-server \
 apache2 libapache2-mod-php5 php5-mysql php5-cli php5-snmp php5-gd ntp

 sudo apt-get -y install cacti

“libphp-adodb” = “Ok”. 
“Configuring Cacti” = “Apache2”
“Configuring cacti” = dbconfig-common
MySQL = lösenordet du skapa tidigare

=Konfiguration=
Logga in på webbgränsnittet, där görs den mesta konfigurationen.
 http://[serverip]/cacti
admin/admin

'''1 minute polling''' &lt;br/&gt;
OBS "Fix the RRA settings first, because this is the one thing you must get right from the start. Once you start collecting data with bad RRA settings, it is extremely difficult to correct it. And by “extremely difficult”, I mean “just throw it away and start over”."

http://www.tolaris.com/2013/07/09/cacti-and-1-minute-polling/

Tänk på:
* Både in och out under stycket: Adjust “Step” and “Heartbeat” on all Data Source templates
* Starta om crond för att ändringarna ska läsas in

VM-snapshots är din vän.

'''Spine''' &lt;br/&gt;
Spine Polling Daemon är en ersättare för polling-scriptet som körs default.
 sudo apt-get install cacti-spine
“Settings” -&gt; “Configuration” -&gt; “Poller” -&gt; “Poller Type” och välj “Spine”.

'''Visual''' &lt;br/&gt;
Höj vissa standardvärden för att kunna se längre descriptions. “Settings” -&gt; “Visual”
* Maximum Title Length
* Maximum Field Length

'''Interface Description'''
 |host_description| - |query_ifName| - |query_ifAlias|

==Plugins==
Cacti har ett pluginsystem där man kan lägga de plugins man vill. Exempel på användbara plugins:
* [http://docs.cacti.net/plugin:aggregate Aggregate]
* [http://docs.cacti.net/userplugin:intropage Intropage]

'''Templates'''
* [http://www.tolaris.com/2015/07/11/advanced-ping-with-cacti/ Advanced Ping]

=Weathermap=
En av de absolut coolaste grejerna med cacti är en plugin som heter weathermap. Det funkar som plugin för Cacti eller MRTG men går också att integrera med Observium. Den senaste versionen av weathermap är från Apr 10, 2013, var beredd på att nästan hälften av knapparna i det grafiska gränssnittet inte fungerar som det ska, man får testa sig fram.

[http://maps.harsbo.se Exempel]

Download and unzip php-weathermap-latest.zip
&lt;syntaxhighlight lang="bash"&gt;
 wget http://network-weathermap.com/files/php-weathermap-0.97c.zip
 sudo apt-get install unzip
 unzip php-weathermap-0.97c.zip
 sudo mv weathermap /usr/share/cacti/site/plugins
 sudo sed -i '63i$plugins = array();' /usr/share/cacti/site/include/config.php
 sudo sed -i '64i$plugins[] = 'weathermap';' /usr/share/cacti/site/include/config.php
 sudo sed -i -r 's/ENABLED=false/ENABLED=true/g' /usr/share/cacti/site/plugins/weathermap/editor.php
 sudo touch /usr/share/cacti/site/plugins/weathermap/configs/wmap.conf
 sudo chown www-data /usr/share/cacti/site/plugins/weathermap/{output,configs}
 sudo chown www-data /usr/share/cacti/site/plugins/weathermap/configs/wmap.conf
&lt;/syntaxhighlight&gt;
Nästa steg görs i det grafiska gränssnittet. Först ska "wmap" enableas sedan görs resten i Weathermap GUI Editor.

Bakgrundsbilder laddas upp till /usr/share/cacti/site/plugins/weathermap/images/ och kan sedan väljas i editorn.

'''wmap.conf''' &lt;br/&gt;
Storlek i pixlar
 WIDTH 1900
 HEIGHT 900
Tidsstämpel
 TIMEPOS 1300 40 Created: %b %d %Y %H:%M:%S
Template nodes
 NODE DEFAULT
  LABELBGCOLOR 169 5 10
  LABELFONTCOLOR 216 248 3
  MAXVALUE 100
Template links
 LINK DEFAULT
  WIDTH 5
  BANDWIDTH 1000M
'''Noder'''
 NODE Firewall01
  LABEL Firewall01
  LABELOFFSET W   #Sätt label i förhållande till nod. N, S, W, E, C
  ICON images/Firewall.png
  POSITION 500 500
'''Länkar'''
 LINK Switch01-Firewall01
  WIDTH 8   #i pixlar
  INFOURL /cacti/graph.php?rra_id=all&amp;local_graph_id=101
  OVERLIBGRAPH /cacti/graph_image.php?local_graph_id=101&amp;rra_id=0&amp;graph_nolegend=true&amp;graph_height=100&amp;graph_width=300
  BWSTYLE angled   #skriv längs med istället för horisontellt
  BWLABEL bits   #byt från procent till bits
  BWFONT 106   #måste finnas definierade 
  BWLABELPOS 75 25   #placera label
  TARGET /var/www/cacti/rra/traffic_in_1000.rrd
  NODES Switch01 Firewall01
  BANDWIDTH 100M
  ARROWSTYLE compact
'''Aggregera länkar'''
 TARGET /var/www/cacti/rra/traffic_in_1000.rrd /var/www/cacti/rra/traffic_in_1001.rrd
'''Multiple via'''
 VIA x y
 VIA x2 y2

'''Visningssida för Weathermap''' &lt;br/&gt;
Detta är ett exempel på en simpel visningssida för den nyskapade Weathermap:n Med lite html-kunskaper och fantasi går detta att utveckla väldigt mycket. [http://forums.cacti.net/about24433.html Inspiration]
 sudo ln -s /usr/share/cacti/site/plugins/weathermap/output /var/www/html/
&lt;syntaxhighlight lang="html4strict"&gt;
 sudo dd of=/var/www/html/index.html &lt;&lt; EOF
 &lt;html&gt;
 &lt;head&gt;
 &lt;title&gt;Internet Load Map&lt;/title&gt;
 &lt;META HTTP-EQUIV="REFRESH" CONTENT="60"&gt;
 &lt;/head&gt;
 &lt;body bgcolor="#000000"&gt;
 &lt;img src="../output/12345.png"&gt;&lt;/img&gt;
 &lt;/body&gt;
 &lt;/html&gt;
 EOF
&lt;/syntaxhighlight&gt;
 sudo sed -i "s/12345/$(find /usr/share/cacti/site/plugins/weathermap/output/ \
 -name "*.thumb.png" -exec basename \{} .thumb.png \;)/g" /var/www/html/index.html

'''Felsökning''' &lt;br/&gt;
Om error codes i loggen:
http://network-weathermap.com/manual/0.97b/pages/errorcodes.html 

==Extern hemsida==
Visa cacti-grafer på en extern hemsida.

1) Enable guest access
Console -&gt; Settings -&gt; Authentication 
* Guest User : guest

Console -&gt; User Management -&gt; guest
* Enabled : on
* Realm Permissions : View Graphs = on

2) Logga in med Guest usern en gång

3) Lägg in en img src i din html kod där är X.X.X.X ipadressen till cactin
 &lt;.img src="http://X.X.X.X/cacti/graph_image.php?action=edit&amp;local_graph_id=55&amp;rra_id=1"&gt;
&amp;local_graph_id=55 där 55 är IDet på grafen, &amp;rra_id=1 1an betyder att den kör på en dag 2 är 1 vecka osv.

[[Category:Guider]]</text>
      <sha1>o01rutr4iz5jkruhztrgxq6bn4rfn8q</sha1>
    </revision>
  </page>
  <page>
    <title>Certbot</title>
    <ns>0</ns>
    <id>558</id>
    <revision>
      <id>3117</id>
      <parentid>3116</parentid>
      <timestamp>2021-03-21T21:04:58Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Hooks */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4354">[[Category:Guider]]
Certbot används för att enkelt kunna automatisera nya cert ifrån [[Let%27s_Encrypt|Let's Encrypt]].

=Installation=
&lt;ul class="nav nav-tabs"&gt;
   &lt;li class="active"&gt;&lt;btn data-toggle="tab" class=""&gt;#tab1|CentOS 7&lt;/btn&gt;&lt;/li&gt;
   &lt;li&gt;&lt;btn data-toggle="tab" class=""&gt;#tab2|Ubuntu 18.04&lt;/btn&gt;&lt;/li&gt;
 &lt;/ul&gt;

 &lt;div class="tab-content"&gt;
   &lt;div id="tab1" class="tab-pane fade in active"&gt;
Börja med att installera EPEL repot.
 yum -y install epel-release yum-utils

Installera sedan Certbot
 yum install certbot python2-certbot-nginx

   &lt;/div&gt;
   &lt;div id="tab2" class="tab-pane fade"&gt;
Börja med lägga till nya repon.
 apt-get update
 apt-get install software-properties-common
 add-apt-repository universe
 add-apt-repository ppa:certbot/certbot
 apt-get update

Installera sedan certbot.
 apt-get install certbot python-certbot-nginx
   &lt;/div&gt;
 &lt;/div&gt;

==Konfiguration==
Certbot körs första gången som en oneliner. Efter det skapas en config fil under '''/etc/certbot/renewal/''' med alla inställningar du valde. 

Certifikat sparas under '''/etc/letsencrypt/live/&lt;domän&gt;'''

==Signera certifikat==
===Renew===
Om du en gång skapat ett certifikat och vill signa om det för att det är på väg att gå ut kan du köra:
 certbot renew

Om du vill göra en dry run gör du det med:
 certbot renew --dry-run

Certifikat kommer inte renewas om det är mer än 30 dagar kvar tills dom går ut by default .

===Webroot===
Webroot signering fungerar genom att certbot lägger en fil i en viss mapp som sedan Let's Encrypts ACME server kommer försöka hämta för att validera att domänen du vill signa för pekar mot dig och att det är du. 

Följande kommando kommer att signera ett cert för hackernet.se och www.hackernet.se.
 certbot certonly --webroot --agree-tos --no-eff-email --email dinmail@hackernet.nu -w /path/to/webfolder -d hackernet.se, www.hackernet.se

===DNS-01===
Man kan använda sig av DNS record för att verifera sitt cert. Med DNS challenge kan man också signa wildcard certifikat.

Börja med att skapa filen '''/etc/letsencrypt/dns-01.ini''' med följande innehåll:
 # Target DNS server
 dns_rfc2136_server = &lt;din dns server&gt;
 # Target DNS port
 dns_rfc2136_port = 53
 # TSIG key name
 dns_rfc2136_name = &lt;namnet på din ddns nykel&gt;.
 # TSIG key secret
 dns_rfc2136_secret = &lt;din hashade nykel&gt;
 # TSIG key algorithm
 dns_rfc2136_algorithm = HMAC-SHA512

Kör sedan följande kommando:
 certbot certonly --agree-tos --no-eff-email --email dinmail@hackernet.nu --dns-rfc2136 --dns-rfc2136-credentials /etc/letsencrypt/dns-01.ini -d *.subdomain1.hackernet.se,*.subdomain2.hackernet.se,*.subdomain3.hackernet.se

==Automatisera certifikat==
===Renew===
Med hjälp av systemd timers kan man köra '''certbot renew''' med mellanrum för att se till att alla ens certifikat är giltiga.

Börja med att skapa följande service fil:
{| class="wikitable"
|-
! /etc/systemd/system/certbot-renewal.service
|-
|[Unit]
Description=Certbot Renewal

[Service]&lt;br&gt;
ExecStart=/usr/bin/certbot renew
|}
Skapa sedan timer filen som kommer trigga servicen.
{| class="wikitable"
|-
! /etc/systemd/system/certbot-renewal.timer
|-
|[Unit]
Description=Timer for Certbot Renewal

[Timer]&lt;br&gt;
OnBootSec=300&lt;br&gt;
OnUnitActiveSec=1w

[Install]&lt;br&gt;
WantedBy=multi-user.target
|}
Tjänsten kommer köras en gång i veckan och 300 sekunder efter boot. Eftersom certbot by default inte signerar nya cert om dom det är mer än 30 dagar kvar så räcker det med 1 gång i veckan. 

Starta sedan timern:
 systemctl start certbot-renewal.timer
Enable timern så att den startas vid boot:
 systemctl enable certbot-renewal.timer
För att visa alla aktiva timers körs:
 systemctl list-timers

===Hooks===
Certbot kan kalla på olika script före, under och efter en körning.

{| class="wikitable"
!Path
!Help
|-
|/etc/letsencrypt/renewal-hooks/deploy
|Körs enbart efter ett lyckat renewal av ett cert.
|-
|/etc/letsencrypt/renewal-hooks/pre
|Körs alltid före en renew.
|-
|/etc/letsencrypt/renewal-hooks/post
|Körs alltid efter en renew.
|}

Ett exempel på en fil under deploy för att starta om nginx:
&lt;syntaxhighlight lang=bash&gt;
#!/bin/bash                   
systemctl reload nginx.service
&lt;/syntaxhighlight&gt;
{{ambox
|nocat=true
| type  = notice
| text  = Se till att filen är körbar med '''chmod +x''' för att det ska fungera. 
}}</text>
      <sha1>1uciqazeeybdlfs7b7u1a55vuk2lywh</sha1>
    </revision>
  </page>
  <page>
    <title>Chocolatey</title>
    <ns>0</ns>
    <id>128</id>
    <revision>
      <id>1505</id>
      <parentid>956</parentid>
      <timestamp>2016-02-15T14:35:26Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="829">Chocolatey är en pakethanterare för Windows, som [[apt]] och yum.

==Installation==
Du kan installera via cmd eller powershell.
===CMD===
Kör cmd som admin.
 @powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SETPATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin

===Powershell===
Kör powershell som admin.
&lt;syntaxhighlight lang=powershell&gt;iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))&lt;/syntaxhighlight&gt;

Se till att &lt;code&gt;Get-ExecutionPolicy&lt;/code&gt; är satt till bypass.
 Set-ExecutionPolicy bypass

==Exempel==
'''Installera'''

Starta cmd som admin och skriv,
 choco install git 7zip vlc firefox -y

'''Söka'''
 choco search firefox

==GUI==
 choco install chocolateygui
[[Category:Windows]]</text>
      <sha1>fxamivhqedo0tsxpy1rj5ijaesu1rar</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco ACI</title>
    <ns>0</ns>
    <id>531</id>
    <revision>
      <id>3164</id>
      <parentid>3161</parentid>
      <timestamp>2023-03-10T07:04:24Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4959">Cisco aci är en av Ciscos senaste innovationer inom hur man bygger datacenter och är egentligen ett orkestreringsverktyg för Nexus serien men inte med IOS utan APIC mjukvara i grunden på switcharna. Det är ett software defined network där man från en kontroller kan man då styra sitt fabric och integrera andra system med det för att göra automation mot sitt datacenter nedan är några exempel på hur ACI fungerar. ACI står för Application Centric Infrastructure men man är inte tvingad att köra just applikationer utan det kan vara annat som exempel l2 eller l3 integrationer internt i fabricen eller göra integrationer externa också mot både nät och applikationsresurser.

==Datacenter Design==
Det finns garanterat annan dokumentation på design av hur man bör bygga datacenter baserat på olika leverantörer eller preferenser men här beskriver vi grundläggande hur designen ser ut med spine och leaf uppsättning och vad som är viktigt att tänka på när man bygger och integrerar sina system.&lt;br/&gt;

https://hackernet.se/images/0/08/ACI-Fabric_layers.png

'''Spine'''&lt;br/&gt;
Spine kallas de Nexus switchar som sitter på toppen av de andra fabric switcharna för att tänket man skall ha är att alla Leaf switchar skall alltid kopplas till alla spines för att få redundans och funktion genom hela fabricen.&lt;br/&gt;
'''Leaf'''&lt;br/&gt;
Leaf är de switcharna som kopplas in till faktiska resurser så som upklinks till spines och downlinks mot antingen UCS enheter "bare metal" servrar alternativt annan nätverksutrustning om peering sker utanför ditt fabric eller om man kör med en annan leverantör för brandväggs leverans.&lt;br/&gt;
'''Apic'''&lt;br/&gt;
'''Stretch Fabric'''&lt;br/&gt;
'''Multi-POD'''&lt;br/&gt;

==Mjukvara==
Mjukvaran i aci är ett eget typ av operativ för just Apicen som har möjlighet att styra de olika fabric enheterna.&lt;br/&gt;

'''APIC'''&lt;br/&gt;
'''Nexus'''&lt;br/&gt;

==Hårdvara==
Hårvaran har utvecklats med tiden för att ha stöd för tyngre och större fabrics med mer resurser.&lt;br/&gt;
'''Generationer'''&lt;br/&gt;
'''Asic'''&lt;br/&gt;
'''Begränsningar'''&lt;br/&gt;

==Integration==

'''UCS'''&lt;br/&gt;
'''Vmware'''&lt;br/&gt;

==Troubleshooting==
On apic:
 #apic
 acidiag verifyapic
 cat /data/data_admin/sam_exported.config
 cat /proc/net/bonding/bond0
 moquery -c ipv4Addr | grep 100.64.0.20
 
 #fabric
 show versions
 show switch
 show endpoints vlan 100
 show vpc map
 show oob-mgmt
 show firmware upgrade status
 show stats granularity 15min leaf 101 interface ethernet 1/5
 show epg EPG1 detail
 show interface bridge-domain BD1 detail
 show acllog permit l3 flow tenant Tenant1 vrf vrf1 

On leaf:
 show vlan extended
 iping -V Tenant1:vrf1 20.0.0.1 -S 10.0.0.1
 show system internal epm vlan 100
 show port-channel extended
 show endpoint vrf Tenant1:vrf1
 show bgp sessions vrf TEST:L3VRF
 show bgp vpnv4 unicast vrf TEST:L3VRF
 show bgp vpnv4 unicast 10.0.101.1/32 vrf TEST:L3VRF
 show interface | grep -E "Ethernet1|MTU"
 show isis dteps vrf overlay-1
 vsh_lc -c "show system internal epm endpoint ip 10.12.2.11"
 vsh_lc -c "show system internal epm endpoint mac 00:50:56:8A:20:00"
 vsh_lc -c "show system internal epm vrf TEST:L3VRF detail"

DHCP Relay
 show ip dhcp relay
 show dhcp internal info relay address interface vlan XX
 show dhcp internal info relay discover
 show dhcp internal errors
 show dhcp internal event-history traces

==APIC API==
'''python'''
&lt;syntaxhighlight lang="Python"&gt;
import requests
import os

username = os.environ.get('USERNAME')
password = os.environ.get('PASSWORD')
hostname = 'apic1.hackernet.se'

# Build payload with userid/password and create a session object
payload = {"aaaUser": {"attributes": {"name": username, "pwd" : password }}}
session = requests.session()

# Issue the login request. The cookie will be stored in session.cookies.
login_url = f'https://{hostname}/api/aaaLogin.json'
response = session.post(login_url, json=payload, verify=False)

# Use the session object to get ACI objects
if response.ok:
    response = session.get(f'https://{hostname}/api/node/class/fvTenant.json', verify=False)
else:
    print(f"HTTP Error {response.status_code}:{response.reason} occurred.")
&lt;/syntaxhighlight&gt;

'''curl''' &lt;br/&gt;
Login and save to COOKIE
 curl -s -k -d "&lt;aaaUser name=admin pwd=password/&gt;" -c COOKIE -X POST https://10.0.0.11/api/mo/aaaLogin.xml
Get tenants xml
 curl -s -k -X GET https://10.0.0.11/api/node/class/fvTenant.xml -b COOKIE | xmllint --format -
Post xml from file
 curl -s -k -X POST -d @xml2aci.xml https://10.0.0.11/api/mo/uni.xml -b COOKIE

==Default Authentication Domain != Local==
Om man har t.ex. radius eller tacacs som default authentication realm men vill ändå kunna logga in med lokala konton så måste man ange det mha sitt username vid login. 

API: '''apic#fallback\\username'''&lt;br/&gt;
SSH: '''apic#fallback\\username'''&lt;br/&gt;
GUI: '''apic:fallback\\username'''&lt;br/&gt;

== Collecting Metrics - Example ==

[[File:Cisco_ACI_Metrics.PNG|800px]]

[[Category:Cisco]]</text>
      <sha1>il1lcxlvn0kouhffdvzwhr1p6sgk34z</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco ASA</title>
    <ns>0</ns>
    <id>163</id>
    <revision>
      <id>3092</id>
      <parentid>1909</parentid>
      <timestamp>2020-04-15T08:22:38Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11401">Adaptive Security Appliance är Ciscos VPN- och brandväggsenhet. Detta är skrivet för 8.4 och senare. &lt;br/&gt;
Hårdvara och mjukvara [http://www.cisco.com/c/en/us/td/docs/security/asa/compatibility/asamatrx.html kompatibilitet]

==Konfiguration==
Grunder
 conf t
  hostname ASA
IP adress
 int e0/0
  mac-address 0011.2233.4455
  security-level 100
  nameif inside
  ip address 10.0.0.1 255.255.255.0
  no shut
Default route och DNS
 route outside 0.0.0.0 0.0.0.0 190.10.160.1 1
 same-security-traffic permit inter-interface
 dns domain-lookup outside
 dns name-server 8.8.8.8

===ASDM===
ASDM är en javamjukvara man kan använda för GUI till ASA. 
 asdm image disk0:/asdm-752.bin
 show asdm image
Slå på det och vitlista IP/nät som får ansluta.
 http server enable
 http 10.0.0.0 255.255.255.0 inside
Skapa användare så att det går att logga in. Peka autentisering mot lokal databas.
 username admin password cisco privilege 15
 aaa authentication http console LOCAL

===SSH===
 ssh 10.0.0.0 255.255.255.0 inside
 ssh timeout 60
 ssh version 2
 aaa authentication ssh console LOCAL
 domain-name inhouse.local
 crypto key generate rsa modulus 2048

===Mgmt VRF===
Man kan sedan 9.5 lägga management-interface i en egen routingtabell.
 int gi0/1
  management-only
 show route management-only
 show asp table routing management-only

===Management access===
Vill man managera sin brandvägg genom en VPN-tunnel måste man komplettera ssh/http-kommandon med:
 management-access inside

===Upgrade===
 copy http://&lt;webbserver.se&gt;/filer/asa952-smp-k8.bin disk0:/
 boot system disk0:/asa952-smp-k8.bin
 show bootvar
 wr
 reload

===Reset===
 clear configure all
 crypto key zeroize rsa
Setup basic firewall
 configure factory-default

==Diverse==
'''ICMP-inspection''' &lt;br/&gt;
Default så är inte icmp-inspection påslaget.
 fixup protocol icmp
Alternativt
 policy-map global_policy
  class inspection_default
   inspect icmp

'''Traceroute''' &lt;br/&gt;
Tillåt traceroute genom en ASA
 access-list ACL extended permit icmp any any time-exceeded
 access-list ACL extended permit icmp any any unreachable

'''Accelerated Security Path'''
 show asp drop
 capture asp-drop type asp-drop all
 show capture asp-drop

'''ARP Inspection''' &lt;br/&gt;
Static entries
 arp inside 193.10.161.37 0c0c.0c0c.0c03 alias
 ---

'''Botnet Filtering'''
 #köp licens
 #Enable DNS Client

'''NTP'''
 clock timezone CEST 1 0
 clock summer-time CEDT recurring last Sun Mar 2:00 last Sun Oct 3:00 60
 ntp server 94.199.180.200 source outside
 show ntp status

'''uRPF'''
 ip verify reverse-path interface outside
 show run ip verify reverse-path

'''Logging'''
 logging enable
 logging console 4
Om man kör syslog med TCP så slutar ASA:n att forwarda trafik om anslutning till syslog-servern tappas, ändra detta.
 logging permit-hostdown

'''Jumbo Frames'''
 jumbo frame-reservation
 mtu inside 9000
 mtu outside 9000

'''Global Timeouts'''
 timeout xlate 10:00:00
 timeout uauth 10:00:00 absolute
 timeout uauth 09:00:00 inactivity

'''Certificate Management'''
 show crypto ca certificate
 (config) crypto ca export
 show crypto key mypubkey rsa

'''Permanent Self-Signed Certificate'''
 crypto ca trustpoint ASDM_TrustPoint0
 id-usage ssl-ipsec
 no fqdn
 subject-name CN=ASA
 enrollment self
 crypto ca enroll ASDM_TrustPoint0 noconfirm

==SNMP==
 snmp-server host inside 10.0.0.50 community PUBLIC version 2c
 show snmp-server oidlist   #"hidden command"
Se även [[Cisco_SNMP|Cisco SNMP]].

==DHCP==
[[Cisco DHCP]]

===Klient===
 int e0/0
  ip address dhcp setroute
 exit
 dhcp-client client-id interface outside

===Server===
 dhcpd address 10.0.0.50-10.0.0.60 inside
 dhcpd enable inside
 dhcpd dns 8.8.8.8 interface inside
''OBS ASA doesn't respond to unicast dhcp requests''

===Relay===
 dhcprelay server 192.168.10.11 inside
 dhcprelay enable DMZ

Verify
 show dhcpd state

==NAT==
Se även [[Cisco_NAT|Cisco NAT]].
===PAT===
 nat (inside,outside) 1 source dynamic any interface

===Dynamic===
 object network outside-pool
  range 193.10.161.190 193.10.161.199
 object network inside_10
  subnet 10.0.0.0 255.255.255.0
  nat (inside,any) dynamic outside-pool

===Static===
 object network dmz_global
  host 193.10.161.31
 object network dmz_server
  host 172.16.0.5
  nat (dmz,outside) static dmz_global

===Exempt===
 object network LAN1
  subnet 1.1.1.0 255.255.255.0
 object network LAN2
  subnet 2.2.2.0 255.255.255.0
 nat (inside,outside) 1 source static LAN1 LAN1 destination static LAN2 LAN2
''1an är viktig så att regeln hamnar först''

'''Verify'''
 show run nat
 show nat proxy-arp

==Port Forwarding==
 object network websrv 
  host 10.1.1.3
  nat (inside,outside) static interface service tcp 80 80
 exit
 access-list outside_access_in permit tcp any object websrv eq http

===ACL===
 access-list ACL1 permit tcp any object dmz_server eq http
 access-list ACL1 line 15 permit tcp any object dmz_server eq https
 access-group ACL1 in interface outside
 show access-list ACL1
Matcha på DNS-namn
 object network hackernet.se
  fqdn v4 hackernet.se

==Routing==
Se även [[Cisco_Routing|Cisco Routing]].

===Static===
 route inside 10.0.1.0 255.255.255.0 {next hop address} 10

===OSPF===
 router ospf 1
  area 1
  network 10.0.0.0 255.255.255.0 area 1

===RIP===
 router rip
  no auto-summary
  version 2
  network 10.0.0.0

===EIGRP===
 router eigrp 1
  network 10.0.0.0 255.255.255.0

===BGP===
Ska man köra BGP genom en ASA måste man stänga av att TCP option 19 strippas vilket det gör default. Samt måste TCP sequence number randomization stängas av.

 access-list BGP extended permit tcp any eq bgp any
 access-list BGP extended permit tcp any any eq bgp
 tcp-map BGP
 tcp-options range 19 19 allow
  class-map BGP
   match access-list BGP
 policy-map global_policy
  class BGP
   set connection advanced-options BGP
   set connection random-sequence-number disable

==Modular Policy Framework==
Application Inspection
 access-list dmz_ftp permit tcp any any eq ftp
Class Map
 class-map FTP-class-MAP
 match access-list dmz_ftp
Policy Map
 policy-map FTP-policy-MAP
 class FTP-class-MAP
 inspect ftp
Service Policy
 service-policy FTP-policy-MAP interface dmz

===QoS===
 priority-queue inside
Class Map
 class-map VOIP
 match dscp 46
Policy Map
 policy-map inside-policy
 class VOIP
 priority
Service Policy
 service-policy inside-policy interface inside
Se även [[Cisco_QoS|Cisco QoS]].

===Tweaking Connections===
 access-list ACL1 permit tcp any object dmz_server eq http
 class-map TCP-Sessions
 match access-list ACL1
 policy-map Conn-Limits
 class TCP-Sessions
 set connection conn-max 500 embryonic-conn-max 50
 set connection timeout embryonic 0:05:00 half-closed 0:10:00
 service-policy Conn-Limits interface outside

===TCP Intercept===
 access-list ACL1 permit tcp any object dmz_server eq http
 class-map no-syn-flood-class
 match access-list ACL1
 policy-map NO-SYN-FLOOD
 class no syn-flood-class
 set connection embryonic-conn-max 50
 service-policy NO-SYN-FLOOD interface outside 

===Advanced Application Inspection - HTTP===
 policy-map type inspect http http-inspect-pmap
 parameters
 protocol-violation action dropconnection log
 match req-resp content-type mismatch
 drop-connection log
 policy-map global_policy
 class inspection_default
 inspect http http-inspect-pmap

===VLAN - !5505===
 int e0/2
  no shut
 int e0/2.10
  vlan 10
  security-level 100
  nameif VLAN10
  ip add 10.0.10.1 255.255.255.0
  no shut
 exit

==EtherChannel==
Se även [[Cisco_EtherChannel|Cisco EtherChannel]].
 interface e0/2
  channel-group mode Active
 interface e0/3
  channel-group mode Active
 interface port-channel1
  port-channel load-balance src-port
  port-channel min-bundle 1
  lacp max-bundle 8
  duplex auto
  speed auto
  nameif DMZ
  security-level 50
  ip add 10.0.10.1 255.255.255.0
  no shut

===Redundancy===
Samma som etherchannel fast endast ett ben är aktivt i taget. Användbart om asan är kopplad till 2 switchar utan [[Arista_MLAG|MLAG]] (t.ex. [[Nexus_vPC|vPC]]).
 interface e0/4
  no shut
 interface e0/5
  no shut
 interface redundant1
  member interface e0/4
  member interface e0/5
  nameif outside
  security-level
  ip address 193.10.161.31
  no shut

==Transparent - 5505==
 firewall transparent
 int BVI 1
 ip add 193.10.161.38 255.255.255.0
 exit
 int e0/0
 switchport access vlan 1
 no shut
 int e0/1
 switchport access vlan 2
 no shut
 interface vlan 1
 security-level 100
 nameif inside
 bridge-group 1
 no shut
 interface vlan 2
 security-level 0
 nameif outside
 bridge-group 1
 no shut

==AAA==
 aaa-server OUR-GROUP protocol radius
 aaa-server OUR-GROUP (inside) host 10.0.0.50
  key ********
  radius-common-pw *********
  exit

===Cut-through User AAA===
 access-list outside_authentication permit tcp any object dmz-server eq http
 username bob password cisco priv 2
 username bob attributes
 service-type remote-access
 exit
 aaa authentication match outside_authentication outside LOCAL

==Failover==
 #Criteria
 ASA1
 int e0/0
 ip address 193.10.161.38 255.255.254.0 standby 193.10.161.39
 int e0/1
 ip address 10.0.0.1 255.255.255.0 standby 10.0.0.2
 failover lan interface Fail-1 e0/3
 failover interface ip Fail-1 10.1.1.1 255.255.255.252 standby 10.1.1.2
 failover key cisco
 failover link Fail-2 e0/4
 failover interface ip Fail-2 10.2.2.1 255.255.255.252 standby 10.2.2.2
 failover replication http
 failover lan unit primary
 failover mac address e0/0 0000.1111.2222 0000.3333.4444
 failover
 
 ASA2
 int e0/3
 no shut
 exit
 failover lan interface Fail-1 e0/3
 failover interface ip Fail-1 10.1.1.1 255.255.255.252 standby 10.1.1.2
 failover key cisco
 failover lan unit secondary
 failover

==Virtual Firewall==
 mode multiple
 changeto context admin
 changeto system
 mac-address auto
 class silver
 limit resource asdm 3
 context newcontext
 member silver
 allocate-interface e0/3
 allocate-interface e0/4
 config-url disk0:/newcontext.cfg
Save in all contexts
 wr mem all

===Active/Active Failover===
 changeto system
 prompt hostname priority
 failover group 1
 primary
 preempt 120
 exit
 failover group 2
 secondary
 preempt 120
 exit
 context Ctx-1
 join-failover-group 1
 exit
 context Ctx-2
 join-failover-group 2
 exit
 int e0/4
 no shut
 int e0/5
 no shut
 exit
 failover lan unit primary
 failover lan interface Fail-1 e0/4
 failover interface ip Fail-1 10.1.1.1 255.255.255.252 standby 10.1.1.2
 failover link Fail-2 e0/4
 failover interface ip Fail-2 10.2.2.1 255.255.255.252 standby 10.2.2.2
 failover
 
 int e0/3
 no shut
 exit
 failover lan unit secondary
 failover lan interface Fail-1 e0/3
 failover interface ip Fail-1 10.1.1.1 255.255.255.252 standby 10.1.1.2
 failover

==SLA==
 route outside 0.0.0.0 0.0.0.0 1.1.1.1 1 track 1
 sla monitor 10
  type echo protocol ipIcmpEcho 1.1.1.1 interface outside
  num-packets 3
  frequency 5
 sla monitor schedule 10 life forever start-time now
 track 1 rtr 10 reachability

==VPN==
Se [[Cisco_ASA_VPN|ASA VPN]]

==REST API==
Man kan lägga till en agent så att ASAn får ett REST API.
 copy http://&lt;webbserver&gt;/asa-restapi-122-lfbff-k8.SPA disk0:
 rest-api image disk0:/asa-restapi-122-lfbff-k8.SPA
 rest-api agent
Sedan behöver webbservern konfigureras om inte det är gjort, se [[Cisco_ASA#ASDM|ASDM]]

Använd en REST-klient (Firefox/Chrome)
 https:&lt;asa-ip&gt;/api/objects/networkobjects

===Docs===
Följer med agenten
 https://&lt;asa-ip&gt;/doc/ 

[[Category:Cisco]]</text>
      <sha1>nc4esjh4rlxw95dq2qogd2u70gt6tqj</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco ASA VPN</title>
    <ns>0</ns>
    <id>227</id>
    <revision>
      <id>2786</id>
      <parentid>2054</parentid>
      <timestamp>2018-05-30T12:17:48Z</timestamp>
      <contributor>
        <username>Fondez</username>
        <id>13</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5795">Huvudartikel: [[Cisco_ASA|Cisco ASA]]. &lt;br/&gt; 
Se även [[Cisco_IPsec|Cisco IPsec]].

=Site-to-site=
==Policy-Based==
Förutsättningar för att sätta upp VPN-tunnlar är att klocka måste gå rätt och att NAT-regler måste ligga i rätt ordning.

Kolla hur man gör på aktuell version
 vpnsetup site-to-site steps
 vpnsetup ipsec-remote-access steps

===Fas 1===
 crypto isakmp policy 10
  authentication pre-share
  encryption aes-256
  hash sha
  lifetime 28800
  group 2
PSK
 tunnel-group &lt;other-side&gt; type ipsec-l2l
 tunnel-group &lt;other-side&gt; ipsec-attributes
  ikev1 pre-shared-key *****
 crypto map VPNMAP 10 set peer &lt;other-side&gt;

Visa befintlig PSK
 more system:running-config | i pre-shared-key|tunnel-group
 tunnel-group 1.3.3.7 type ipsec-l2l
 tunnel-group 1.3.3.7 ipsec-attributes
  ikev1 pre-shared-key hemlignyckeln2000

===Fas 2===
 crypto ipsec ikev1 transform-set SITE2-FAS2 esp-aes-256 esp-sha-hmac
 crypto map VPNMAP 10 set transform-set SITE2-FAS2
 access-list CRYPTO-to-SITE2 extended permit ip 172.16.20.0 255.255.255.0 172.16.40.0 255.255.255.0
 crypto map VPNMAP 10 match address CRYPTO-to-SITE2
 crypto map VPNMAP 10 set security-association lifetime seconds 3600
 crypto map VPNMAP 10 set pfs group5

Följande steg behöver endast göras vid första VPN-tunneluppsättningen.
 crypto map VPNMAP interface OUTSIDE
 crypto ikev1 enable OUTSIDE 

===NAT Exempt===
 object network LAN1
  subnet 172.16.20.0 255.255.255.0
 object network LAN2
  subnet 172.16.40.0 255.255.255.0
 nat (inside,outside) 1 source static LAN1 LAN1 destination static LAN2 LAN2

==Route-Based==
I ASA version 9.7 inplementerades stöd för route-based vpn med tunnel interface. &lt;br/&gt;
För IKEv2 krävs minst version 9.8.1!

Tunnel interface har ingen security level.

IKEv2 behåller inte riktigt nomenklaturen med faser men ändå.

===Fas 1===
 crypto ikev2 policy 5
  encryption aes-256
  integrity sha256
  group 19
  prf sha256
  lifetime seconds 86400

PSK
 tunnel-group 1.2.3.4 type ipsec-l2l
 tunnel-group 1.2.3.4 ipsec-attributes
  ikev2 remote-authentication pre-shared-key hemlig123
  ikev2 local-authentication pre-shared-key hemlig123

===Fas 2===
 crypto ipsec ikev2 ipsec-proposal IKEV2-PROPOSAL01
  protocol esp encryption aes-256
  protocol esp integrity sha-256

 crypto ipsec profile IKEV2-PROFILE01
  set ikev2 ipsec-proposal IKEV2-PROPOSAL01
  set pfs group19
  set security-association lifetime seconds 3600

Följande steg behöver endast göras vid första VPN-tunneluppsättningen. &lt;br/&gt;
 crypto ikev2 enable OUTSIDE

===Tunnel interface===
 interface Tunnel5
  nameif VPN-TUNNEL5
  ip address 169.254.2.1 255.255.255.0
  tunnel source interface OUTSIDE
  tunnel destination 1.2.3.4
  tunnel mode ipsec ipv4
  tunnel protection ipsec profile IKEV2-PROFILE01

Routa det som finns på andra sidan tunneln:
 route VPN-TUNNEL5 10.10.10.0 255.255.255.0 169.254.253.1
Next-hop kan vara vad som då en next-hop krävs (namnet på interface som styr).

===NAT===
Tunnel interface ej går att välja som interface i NAT får man se till att inte göra NAT Exempt som policy-based.
Detta då trafiken lämnar ASAn via tunnel interface och ej utsidan tex OUTSIDE.

===Access===
Antingen kan man tillåta trafik in från andra sidan genom att låta ASAn automatiskt lägga till allow regler för allt som det byggs tunnel för (inklusive ssl vpn) annars kan man styra det med outside-aclen (för tunnel interface acl per tunnel). Kolla om autoregler är påslaget:
 show run all | i permit-vpn

Notera att autoregler är påslaget som standard.
Stäng av autoregel för vpn:
 no sysopt connection permit-vpn


Tillåt trafik in från andra sidan med hjälp av ACL:&lt;br/&gt;
Policy-based
 access-list OUTSIDE-IN extended permit ip object LAN2 object LAN1
Route-based
 access-list ACL-VPN-TUNNEL5 extended permit ip object LAN2 object LAN1
 access-group ACL-VPN-TUNNEL5 in interface VPN-TUNNEL5


'''Troubleshoot'''
 show crypto isakmp sa detail
 show crypto ipsec sa
 show vpn-sessiondb detail l2l

'''Reverse route''' &lt;br/&gt;
Reverse route injection (RRI) tillåter att det installeras static routes för det som finns på andra sidan av tunneln i routingtabellen när tunneln blir aktiv. Kan t.ex. användas om man vill redistribuera VPN-routes till ett routingprotokoll.
 crypto map VPNMAP 10 set reverse-route

=Remote Access=
==AnyConnect==
AnyConnect SSL split tunnel &lt;br/&gt;
Objekt och pool
 ip local pool AnyConnect-Pool 172.20.0.51-172.20.0.100 mask 255.255.255.0
 object network VPN_POOL
  subnet 172.20.0.0 255.255.255.0
ACL
 access-list AnyConnect-SplitTunnel standard permit 10.0.0.0 255.255.255.0  # LAN
 access-list OUTSIDE-V1 remark ----- Allow AnyConnect to LAN
 access-list OUTSIDE-V1 extended permit ip object VPN_POOL object LAN
Enable anyconnect
 webvpn
  enable OUTSIDE
  anyconnect image disk0:/anyconnect-win-3.1.10010-k9.pkg 1
  anyconnect enable
  tunnel-group-list enable
  cache
   disable
  error-recovery disable
Group policy
 group-policy GroupPolicy_Hackernet internal
 group-policy GroupPolicy_Hackernet attributes
  wins-server none
  dns-server value 10.0.0.10
  vpn-tunnel-protocol ssl-client 
  split-tunnel-policy tunnelspecified
  split-tunnel-network-list value AnyConnect-SplitTunnel
  default-domain value hackernet.se
Tunnel group
 tunnel-group Hackernet type remote-access
 tunnel-group Hackernet general-attributes
  address-pool AnyConnect-Pool
  default-group-policy GroupPolicy_Hackernet
 tunnel-group Hackernet webvpn-attributes
  group-alias Hackernet enable
no nat
 nat (INSIDE,OUTSIDE) 5 source static any any destination static VPN_POOL VPN_POOL no-proxy-arp route-lookup
Skapa lokala users
 username juan password cisco
 username juan attributes
  service-type remote-access
  vpn-group-policy GroupPolicy_Hackernet

[[Category:Cisco]]</text>
      <sha1>ew2z6ajif39o3kon6aicuwcdb2scg87</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco BFD</title>
    <ns>0</ns>
    <id>199</id>
    <revision>
      <id>3045</id>
      <parentid>2996</parentid>
      <timestamp>2019-11-04T19:00:33Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8022">Bidirectional Forwarding Detection (RFC 5880) är ett protokoll som är framtaget för att snabbt kunna upptäcka problem med paketförmedling mellan två grannar. Det är från början utvecklat av Cisco och Juniper. Det är helt oberoende av vilken topologi, media eller routing-protokoll som används. Olika typer av kontrollplansprotokoll kan utnyttja BFD-protokollets feldetektering. Genom snabb feldetektering kan olika kontrollplansprotokoll agera på ett problem snabbare. BFD är en viktig komponent för att sänka konvergenstider (recovery) inom ett nätverk. Det har en gemensam interface-down-event-detection-mekanism som andra protokoll kan utnyttja för sin feldetektering, exempel på detta är routingprotokollen (även [[Cisco_IS-IS|IS-IS]] som inte är IP-baserat), [[Cisco_PIM|PIM]], HSRP och MPLS [[Cisco_VPLS|pseudowires]]. Samtidigt som det är mindre CPU-krävande än andra tekniker för feldetektering, t.ex. det traditionella att skicka och behandla Hello-paket. 

Beroende på IOS-version finns det stöd för BFD forwarding på point-to-point IPv4, IPv6 och [[Cisco_GRE|GRE]]-tunnlar. Det är ej supporterat på [[Cisco_IPsec#VTI|VTI]] och det bör ej köras på virtual-template eller dialer interfaces. BFD-paket matchar ej på [[Cisco_QoS|QoS]]-policy för self-generated packets. BFD är alltid unicast och [[Cisco_CEF|CEF]] är ett krav på de inblandade enheterna. 

===Paket===
&lt;div class="mw-collapsible mw-collapsed" style="width:210px"&gt;
Control packet:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_BFD_Control.PNG]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:210px"&gt;
Echo packet:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_BFD_Echo.PNG]]
&lt;/div&gt;
&lt;/div&gt;

=Konfiguration=
BFD finns i version 0 och 1. Den största skillnaden är att version 1 stödjer echo mode, se nedan. Cisco IOS kör version 1 default och kan inte konfigureras att köra version 0, men är bakåtkompatibel med det ifall det kommer in v0-paket från någon annan. BFD kan köras i asynchronous mode eller demand mode men IOS sätter alltid Demand bit till 0. 

'''Aktivera''' &lt;br/&gt;
Ange tröskelvärden per interface, detta måste göras innan BFD kan användas eftersom det inte finns några default (OBS ip unnumbered interfaces stöds ej). Dessa värden jämförs med andra sidan och de behöver inte matcha utan de högsta värdena är de som används. (Den första 50 är min_tx)
 interface gi2
  bfd interval 50 min_rx 50 multiplier 3

Sedan måste man registrera det protokoll som ska dra nytta av BFD. Detta görs per protokoll, se t.ex. BFD-konfiguration för [[Cisco_HSRP#BFD|HSRP]], [[Cisco_OSPF#BFD|OSPF]] och [[Cisco_BGP#BFD|BGP]]. Det är på så sätt BFD får reda på vad andra sidan har för adress så ett grannskap är möjligt. Efter att detta är gjort drar BFD igång och upprättar grannskap. Om andra sidan inte har slagit på BFD kommer varje BFD Control message besvaras med en ICMP (Type 3) Destination Unreachable och grannskapet förblir Down.

Verifiera genom att kolla grannskap och vilka protokoll som utnyttjar BFD.
 show bfd neighbors
 show bfd neighbors details | i Registered
 show bfd summary client

'''Felsök'''
 show monitor event cef bfd all
 show bfd drops
 debug bfd event
 debug bfd packet
IPv6, vissa plattformar har problem med att BFD-sessioner över IPv6 går ner med jämna mellanrum. En workaround för detta är att sätta automatisk refresh av ND-cachen.
 interface gi2
  ipv6 nd cache expire 120 refresh

'''Avaktivera''' &lt;br/&gt;
Man kan även avaktivera BFD per interface utan att ta bort konfigurationen, då skickas fem Control messages med code Admin Down till andra sidan.

 interface gi2
  ip ospf bfd disable

&lt;div class="mw-collapsible mw-collapsed" style="width:280px"&gt;
Admin Down:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_BFD_AdminDown.PNG]]
&lt;/div&gt;
&lt;/div&gt;

===Echo mode===
Om andra sidan är långsam på att svara pga överlastad CPU sätter BFD interfacet som down fast det inte är det. Vill man slippa detta kan man höja timers men då försvinner meningen med BFD. För att lösa det kan man använda Echo mode, då kommer inte BFD-paketen att gå till andra sidans CPU utan vända direkt på interfacet (i ASIC:en). Detta är default på Cisco-enheter. Eftersom echo-paket som inte påverkar CPUn används för feldetektering behövs inte BFD-kontrollpaketen skickas lika ofta. Detta går att ställa manuellt med slow-timers och påverkar inte hur ofta echos skickas. BFD control packets är UDP från 49152 till 3784 som kan skickas multihop. Echo packets är UDP till 3785 och fungerar endast single hop. 
 bfd slow-timers &lt;msec&gt;
 show bfd neighbors details

Stäng av echo mode på ett interface, inga BFD-echos skickas eller forwardas. ip redirects behövdes stängas av förr för echo mode men det är inte ett krav längre. Om man kör Unicast Reverse Path Forwarding på ett interface måste man stänga av echo mode eftersom echo packets rejectas av uRPF och grannskapet kommer att flappa kontinuerligt.
 no bfd echo

BFD kan köras i både mjukvara och hårdvara.
 show bfd neighbors details | i Session Host
 show bfd neighbors hardware

===Template===
Man kan skapa en template som man sedan använder på alla interface. Då kan man använda authentication och dampening samt få stöd för microsekunder.
 bfd-template single-hop BACKBONE
  interval microseconds min-tx 50000 min-rx 50000 multiplier 3
  authentication sha-1 keychain BFD
  dampening 10 1000 1000 10
 
 interface Gi2
  bfd template BACKBONE

Verify
 show bfd neighbors dampening 
 show bfd neighbors dampened

===Static routes===
BFD går faktiskt att använda med static routes, man måste bara berätta vilken next-hop som ska monitoreras. I associated mode associeras den statiska routen med den statiska BFD-grannen om routens next-hop matchar den. I unassociated mode kommer alltid grannen att requesta en BFD-session om interfacet har BFD-konfiguration, detta är användbart om det inte finns någon static route än.
 ip route static bfd gi2 1.1.1.1 [unassociate]
 ip route 10.0.0.0 255.255.255.0 gi2 1.1.1.1
 
 show ip static route

===EBGP Multihop===
 bfd-template multi-hop MH
  interval both 250 multiplier 3
 
 bfd map ipv4 2.2.2.2/32 1.1.1.1/32 MH
 
 router bgp 1
  neighbor 2.2.2.2 fall-over bfd multi-hop 
'''strict-mode''' - Grannskapet går inte upp om inte BFD lyckas, dvs hold down neighbor session tills BFD session är uppe.

===NX-OS===
Det mesta av ovan gäller [[Cisco_Nexus|Nexus]]-switchar också (med eventuell syntaxskillnad) men det finns funktioner som är unika. BFD timers kan konfas globalt och det finns default-värden, 50ms x 3. På vissa linjekort kan man ställa intervall ner till 15ms.
 feature bfd
 
 bfd interval 50 min_rx 50 multiplier 3 
 
 router ospf 1
  bfd

ICMP/ICMPv6 redirects bör stängas av på de interface (även SVI:er) där man kör BFD.
 interface e1/1
  no ip redirects 
  no ipv6 redirects 

'''Subinterface''' &lt;br/&gt;
BFD upprättar ju sessioner på alla subinterface som är konfade med BFD men man kan optimera det. Det subinterface med lägst vlan id blir master och kommer att använda huvudinterfacets inställningar medans övriga subinterface kör med slow timers. Om master får BFD timeout så markeras alla subinterface som down av BFD. Detta funkar endast mellan Cisco NX-OS devices och konfas på huvudinterfacet.
 interface ethernet 2/1
  bfd optimize subinterface

'''Port Channel''' &lt;br/&gt;
Detta är ingen Nexus-specifik feature men på en L3 port channel kan NX-OS låta BFD upprätta session över varje fysisk länk som ingår i LAG:en. Klienterna får det aggregerade resultatet dvs sålänge en länk är uppe så rapporterar BFD att länken är uppe. Man måste slå på LACP innan man enablear BFD.
 interface port-channel 20
  bfd per-link

===IOS-XR===
NCS5500
 bfd multipath include location 0/0/CPU0

OSPF
 router ospf 1
  bfd minimum-interval 100
  bfd fast-detect
  bfd multiplier 3

Verify
 show bfd session

[[Category:Cisco]]</text>
      <sha1>lw10zxn158dpkhv5vr36n9qtpiscwu2</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco BGP</title>
    <ns>0</ns>
    <id>153</id>
    <revision>
      <id>3074</id>
      <parentid>2984</parentid>
      <timestamp>2019-11-24T17:23:23Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="47695">Border Gateway Protocol (RFC 4271) är ett path vector routing protokoll. Det kommunicerar på TCP port 179 så routing måste vara på plats, man kan nästan se det som ett L4-protokoll. TCP tillhandahåller acknowledgement, retransmission, sequencing och update fragmentation. BGP kan få många vägar till samma destination. Bästa vägen väljs utifrån en ökänd [http://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/13753-25.html algoritm]. Den bästa pathen markeras valid/best och blir en kandidat till routingtabellen. Om next hop inte är reachable så blir aldrig en route best. Se även [[Cisco_Multicast#BGP|BGP Multicast]] och [[ExaBGP]].

'''Type:''' Path Vector

'''AD:''' 20, 200

'''Protocols:''' IP

'''Packets:''' 5

===Pakettyper===
'''OPEN''': Första paketet som skickas av varje sida används för att upprätta grannskap, innehåller grundläggande parametrar och capabilities. 
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_BGP_Open.PNG]]
&lt;/div&gt;
&lt;/div&gt;

'''UPDATE''': En update innehåller routinginformation. Varje NLRI skickas endast en gång. &lt;br/&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_BGP_Update.PNG]]
&lt;/div&gt;
&lt;/div&gt;

'''NOTIFICATION''': Errormeddelanden, kan skickas för att starta om ett grannskap. För alla error codes se [http://www.iana.org/assignments/bgp-parameters/bgp-parameters.xhtml IANAs lista] &lt;br/&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_BGP_Notification.PNG]]
&lt;/div&gt;
&lt;/div&gt;

'''KEEPALIVE''': Skickas regelbundet för att säkerställa att grannen lever. Peers måste komma överens om holdtime för keepalives, default är holdtime 180 sek och då skickas keepalives var 60 sek. &lt;br/&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_BGP_Keepalive.PNG]]
&lt;/div&gt;
&lt;/div&gt;

'''ROUTE REFRESH''': (RFC 2918) Båda sidor måste stödja denna capability.
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_BGP_RouteRefresh.PNG]]
&lt;/div&gt;
&lt;/div&gt;

==BGP table==
Källor till BGP table:
* Network command
* BGP updates
* Redistribution

Show BGP table
 show ip bgp
 show bgp &lt;AFI&gt; unicast update-sources 

==Path Selection==
Till skillnad från IGPer används inte enbart metric för att avgöra vilken som är bästa routen, istället används ett gäng Path Attributes för att komma fram till vad som ska annonseras vidare och installeras i routingtabellen. Dock sker ingen path selection för ogiltiga routes utan de ignoreras direkt (no valid next-hop, not synchronized, AS-looped). Kolla inkomna PA som inte stöds: ''show ip bgp path-attribute discard|unknown''

'''Well Known''' ska stödjas av alla BGP-implementationer
{| class="wikitable"
!Mandatory
!Discretionary
|-
|AS Path 
|Local Preference
|-
|Next Hop 
|Atomic Aggregate
|-
|Origin
|
|}
Allt som är Mandatory måste alltid skickas med i varje uppdatering, det är ej ett krav för Discretionary.

'''Optional'''
{| class="wikitable"
!Transitive
!Non transitive
|-
|Aggregator 
|MED
|-
|Community 
|Originator
|-
|
|Cluster ID
|}
Transitive betyder att PA ska forwarderas till andra även om routern själv inte har stöd för just det PA. Nontransitive PA ska tas bort från uppdateringar som lämnar det egna AS.

'''Path Selection Summary'''
{| class="wikitable"
!Attribute
!Description
!Preferens
|-
|Weight
|Administrativ 
|Högsta
|-
|LOCAL_PREF
|Skickas mellan peers inom AS
|Högsta
|-
|Self-originated
|Prefer paths originated locally 
|
|-
|AS_PATH
|Minimize AS hops
|Kortast
|-
|ORIGIN
|Prefer IGP-learned routes over unknown
|IGP
|-
|MED
|Used externally to enter an AS
|Lägsta
|-
|External
|Prefer eBGP routes over iBGP (AD)
|eBGP
|-
|IGP Cost
|Consider IGP metric to NEXT_HOP
|Lägsta
|-
|eBGP Peering
|Favor more stable routes
|Äldsta
|-
|Router ID
|Sista tie breaker
|Lägsta
|}

'''Best path selection''' &lt;br/&gt;
Det finns många sätt att ändra BGPs beteende med avseende på path selection.

Stänga av att oldest path kan ge best route. Compare router-id for identical EBGP paths
 bgp bestpath compare-routerid
Stänga av att AS path length kollas. OBS detta är ett dolt kommando.
 bgp bestpath as-path ignore
Ignore cost IGP metric in bestpath selection
 bgp bestpath igp-metric ignore
Ignore cost communities in bestpath selection
 bgp bestpath cost-community ignore
Allow comparing MED from different neighbors
 bgp always-compare-med
Treat missing MED as the least preferred one
 bgp bestpath med missing-as-worst
Compare MED among confederation paths
 bgp bestpath med confed
Pick the best-MED path among paths advertised from the neighboring AS
 bgp deterministic-med

===Multipath===
'''Maximum Paths''' &lt;br/&gt;
Flera paths kan hamna i routingtabellen men endast best path kan annonseras vidare (om inte add-path används). Default är EN path till skillnad från andra routingprotokoll. Default måste allt upp till IGP Cost vara lika för att maximum paths ska spela någon roll. Inte alla topologier stödjer multipath. '''bgp bestpath as-path multipath-relax''' används för att möjliggöra ECMP genom olika AS, detta är ett dolt kommando.

 router bgp 100
  maximum-paths 4        #eBGP
  maximum-paths ibgp 4   #iBGP
  maximum-paths eibgp 4  #MPLS

'''Additional Paths''' &lt;br/&gt;
Med iBGP kan man använda add-paths. Syftet är att tillhandahålla en backup route för snabbare konvergering. Det är en capability som skickas med i open message per adressfamilj. Add-paths lägger på ett unikt Path ID på varje prefix för att det ska kunna gå att skilja på dem. För att det ska funka måste next-hop på backup path skilja sig från det på primary path.

Det går att konfigurera per adressfamilj eller per neighbor.
 router bgp 100
  bgp additional-paths select all
  neighbor 1.1.1.1 additional-paths send receive
  neighbor 1.1.1.1 advertise additional-paths all
 
 show ip route repair-paths
Man kan välja additional paths och skicka vidare dem utan att installera det i RIB/FIB lokalt.
 bgp additional-paths install

'''Diverse Path'''&lt;br/&gt;
Diverse-Path säger åt en BGP-router att medvetet beräkna en 2nd-best path som har en annan next hop som den första pathen. Diverse-Path var en workaround innan Add-Path var supporterat. Det görs endast på route reflector. Diverse-Path är ej supporterat i IOS-XR.
 router bgp 1
  address-family vpnv4 unicast
   maximum-paths 2
   bgp bestpath igp-metric ignore
   bgp additional-paths select backup
   bgp additional-paths install
   neighbor IBGP advertise diverse-path backup

=Konfiguration=
För att byta från NLRI-format till AFI-format i konfigurationen
 bgp upgrade-cli 
Administrative Distance: eBGP, iBGP, local. Det går ändra distance per granne också med distance-kommandot och en acl.
 distance bgp 20 200 200

Synchronization is disabled by default in Cisco IOS post 12.2(8)T. Synchronization bör vara avstängt annars medföljer vissa begränsningar. T.ex. måste routes finnas i IGP innan det kan propagera vidare med BGP och OSPF RID måste vara samma som BGP RID om sync är på.
 no synchronization
IPv4 aktiveras default i BGP på IOS men det går att stänga av.
 no bgp default ipv4-unicast

==Neighbor==
För att kunna utbyta routinginformation måste grannskap upprättas, detta görs med en TCP-anslutning som det skickas BGP-meddelanden över. eBGP har TTL satt till 1 på alla BGP-paket som skickas ut, detta går att ändra med ''ebgp-multihop''. iBGP har inga sådana begränsningar utan skickar med TTL 255. eBGP byter även next-hop på den NLRI som kommer in, dock inte om next-hop finns i samma subnät som en själv. eBGP kan inte initiera peering med hjälp av en default route.

'''States''' &lt;br/&gt;
BGP har en finite state machine vilket betyder att grannskap kan befinna sig i olika tillstånd. &lt;br/&gt;
'''TCP''' &lt;br/&gt;
Idle State: ConnectRetry timer 120 sekunder &lt;br/&gt;
Active State: BGP speaker försöker nå peer med TCP &lt;br/&gt;
Connect State: TCP session established &lt;br/&gt;

'''BGP''' &lt;br/&gt;
OpenSent State: BGP version, AS number, hold time, BGP ID. Börja skicka keepalives &lt;br/&gt;
OpenConfirm State: Response recieved &lt;br/&gt;
Established State: Skicka uppdateringar. Neighbor up &lt;br/&gt;

Om ett grannskap är iBGP eller eBGP avgörs med remote-as som antingen är samma AS som en själv eller ett annat. Default accepteras all NLRI från eBGP-grannar, så fungerar ej IOS XR.
 router bgp 65000
  neighbor 1.1.1.1 remote-as 65001
  neighbor 1.1.1.1 description Other side
  neighbor fe80::a00:27ff:fe80:7008%GigabitEthernet1 remote-as 65001

When configuring iBGP always use loopbacks (advertised by your IGP) for peering. 
 neighbor 1.1.1.1 update-source Loopback0

md5 authentication görs med tcp option 19
 neighbor 1.1.1.1 password SECRET
 show ip bgp neighbors 1.1.1.1 | i state|Flags

Man kan konfigurera intervallet mellan uppdateringar till grannar där 0 är annonsera direkt. Default är 0 sek för iBGP, 0 sek för eBGP i en VRF och 30 sek för eBGP-sessioner i default-vrfen.
 neighbor 1.1.1.1 advertise-interval &lt;interval&gt;

Verify
 show ip bgp neighbor
 show ip bgp summary
 show tcp brief

Debug
 debug ip bgp events

===Peer Group===
För att förenkla konfen kan man gruppera flera grannar som ska ha likadan konfiguration i så kallade peer groups. Det blir även lite effektivare processing eftersom identiska Updates skickas till alla peers i gruppen. Man kan ju ha olika out policy per grannskap och då funkar inte identiska Updates till alla men IOS löser detta automatiskt genom att skapa fler update groups dynamiskt.
 neighbor GROUP01 peer-group
 neighbor GROUP01 remote-as 100 [alternate-as 50000]
 neighbor GROUP01 update-source Loopback0
 neighbor 1.1.1.1 peer-group GROUP01
 neighbor 2.2.2.2 peer-group GROUP01
Verify
 show ip bgp peer-group
 show ip bgp update-group
 show ip bgp replication

Eftersom peers kan svara segt (av någon anledning) finns det en dynamisk funktion för att splita peer-grupper och lägga dessa i slow-update groups. When “permanent” is not configured, the “slow peer” will be moved to its regular original update group, after it becomes regular peer (converges).
  bgp slow-peer split-update-group dynamic
 show ip bgp neighbors slow

'''Templates''' &lt;br/&gt;
Det går även att skapa policy och session templates. Detta går tyvärr ej att kombinera med bgp listen range eftersom den kopplas till en peer group. 
 template peer-session RR
  remote-as 101
  password SECRET
  update-source Loopback0
 exit-peer-session
 
 template peer-policy RR
  route-reflector-client
  send-community both
  additional-paths send receive
 exit-peer-policy
 
 neighbor 1.1.1.1 inherit peer-session RR
 neighbor 1.1.1.2 inherit peer-session RR
 
 address-family vpnv4
  neighbor 1.1.1.1 activate
  neighbor 1.1.1.1 inherit peer-policy RR
Verify
 show ip bgp template peer-session
 show ip bgp template peer-policy

===Dynamic Peering===
Det får ej finnas några statiska neighbor statements när man använder listen range.
 router bgp 100
  bgp listen range 10.1.123.0/24 peer-group AS_200
  bgp listen limit 15
  neighbor AS_200 peer-group
  neighbor AS_200 remote-as 200
 
  address-family ipv4
   neighbor AS_200 activate
   neighbor AS_200 send-community both

===Route Refresh vs Soft Reconfiguration===
Både Route Refresh och Soft Reconfiguration tillåter en router att ändra sin routing policy utan att starta om grannskapet (Hard reset). Soft reset skickar route-refresh message för att begära att all NLRI skickas igen medans Soft Reconfiguration lagrar all NLRI som kommer in från grannen i en separat tabell (adj-ribs-in) för att kunna köra om policyn lokalt när man clearar. Blir minne korrupt över tiden kan det dock ställa till problem. Soft Reconfiguration använder mer minne medans Route Refresh använder lite mer bandbredd. Route Refresh är rekommenderat nuförtiden tack vare att bandbredd sällan är ett problem samt att de flesta enheter har stöd för det. Vill man spara minne men ändå ha tillgång till Adj-RIB-In får man använda BMP (se BMP-stycket).
 show ip bgp neighbors 1.1.1.1 | s Neighbor capabilities
 Neighbor capabilities:
    Route refresh: advertised and received(new)
Route Refresh är en capability som finns i olika varianter och skickas i open message. Det IOS-XE kallar "new" decodar wireshark som "Cisco". En BGP-peer kan annonsera flera varianter.

[[File:Cisco_BGP_Route_Refresh_Capability.PNG]]

Om en router inte har stöd för Route Refresh får Soft Reconfiguration användas. Då måste man slå på det på grannskapet.
 neighbor 1.1.1.1 soft-reconfiguration inbound
 show bgp ipv4 unicast neighbors 1.1.1.1 policy
Alternativt använd soft reconfiguration som fallback om andra sidan inte stödjer route refresh.
 bgp soft-reconfig-backup
Kolla adj-ribs-in (alla prefix raw):
 show ip bgp neighbors 1.1.1.1 received-routes

Oavsett om reset eller reconfiguration används så kör man clear-kommandot för att göra det.
 clear ip bgp 1.1.1.1 soft [in]
 clear ip bgp * soft

'''eBGP Multihop''' &lt;br/&gt;
Ska man upprätta eBGP-grannskap om neighbor-IP ej är directly connected, t.ex. mellan loopbacks, behöver man öka TTLn på paketen som skickas ut.
 neighbor 1.1.1.1 ebgp-multihop 3
Alternativt godta TTL 1 genom att stänga av checken som kollar om grannen sitter på ett directly connected network genom att kolla routingtabellen. Grannen kan dock max vara ett hop bort för TTL är 1 med detta alternativ.
 neighbor 1.1.1.1 disable-connected-check

'''TTL Security''' &lt;br/&gt;
GTSM (RFC 3682) används för att skydda mot spoof attacks. Med GTSM (utan angiven "hops") lyssnar man bara på TCP/BGP-paket med ett TTL-fält på minst 254, det betyder att paketet inte kan ha routats och därmed inte kan komma ifrån någon på internet utan endast från närliggande granne, dvs den man peerar med. Notera att TTL security och eBGP multihop är mutually exclusive. Detta gäller endast för eBGP peers.
 neighbor 2.2.2.2 ttl-security hops 10
 show ip bgp neighbors 2.2.2.2 | i TTL|hop
T.ex. "hops 10" betyder att endast BGP-paket med TTL 245 eller högre kan accepteras. 

'''PMTUD''' &lt;br/&gt;
Förr i världen sattes max data segment på BGPs TCP-session till 536 bytes men nu finns PMTUD default. 
 bgp transport path-mtu-discovery
 show ip bgp neighbor | i Data|MTU|transport|MSS
Turn off per neighbor
 neighbor $PEER transport path-mtu-discovery disable

'''Multi Session TCP''' &lt;br/&gt;
Multi Session TCP Transport per AF togs fram för att stödja Multi Topology Routing. Multisession capability utbyts i OPEN message och indikerar att multisession BGP stöds.
 neighbor 1.1.1.1 transport multi-session
 show tcp brief

'''Passive Peer''' &lt;br/&gt;
Kan t.ex. behövas om grannskap går igenom en brandvägg. Default är såklart active.
 bgp neighbor transport connection-mode active/passive

'''GRE''' &lt;br/&gt;
Det går även att upprätta BGP-grannskap över [[Cisco_GRE|GRE]]-tunnlar. Det är dock viktigt att se till att next hop blir rätt.

===Next Hop===
Ändra så att annonserade uppdateringar har den egna IP-adressen (peer address) istället för det som står i uppdateringen från den granne man har lärt sig prefixet av.
 neighbor 10.0.0.10 next-hop-self
Alternativt
 neighbor 10.0.0.10 route-map OUT
 route-map OUT permit 10 
  set ip next-hop self | peer-address
Route Reflector Server ändrar inte next-hop när prefix skickas vidare till RR-klienter oavsett om man har konfigurerat next-hop-self eller en route-map. Sätt next-hop-self oavsett om det är reflected routes.
 neighbor 10.0.0.10 next-hop-self '''all'''
Det finns situationer då man kör eBGP men vill att next-hop ej ska ändras, t.ex. vid Inter-AS MPLS Option C.
 neighbor 10.0.0.10 next-hop-unchanged

===4 byte ASN===
Från början användes 2 bytes för ASN vilket ger 65535 stycken men det räcker inte. Nyare routrar skickar AS_PATH som innehåller 4 bytes ASN men det blir inte bakåtkompatibelt så därför har det i RFC 5396 skapats nya optional transitive path attributes: AS4_PATH, AS4_AGGREGATOR och extended communities som kan användas för att bära den korrekta informationen igenom gamla enheter. 4 byte ASN en capability som listas i OPEN message. Ska en ny router i ett AS högre än 65535 prata med en gammal router som inte har stöd för 4 byte ASN kan den ändå ta upp grannskapet men använder då det reserverade ASN 23456 som kallas AS_TRANS. Alla 4 byte ASN kommer att skickas som AS4_PATH medans i AS_PATH kommer de att bytas ut mot detta 23456 så att ändå path length stämmer. Om detta kommer till en ny router vid ett senare tillfälle kan den sätta ihop den korrekta as-pathen. 

Man kan konfigurera hur man vill att ASN ska presenteras i outputen från show-kommandon.
 bgp asnotation dot

===Diverse===
När BGP startar väntas en specificerad tidsperiod för att grannarna ska etablera sig själva innan de första uppdateringarna skickas. När perioden är slut räknas best path för varje prefix och detta annonseras. Detta förbättrar konvergeringstiden eftersom om det skickades uppdateringar direkt och det strax efter kom ny information och en annan best path hade det behövts skickas igen. Update-delay används för att konfigurera just denna tidsperiod, default är 120 sekunder. 
 bgp update-delay &lt;seconds&gt;

Update-delay kan användas i kombination med graceful restart. Detta är en capability som förhandlas mellan NSF-capable och NSF-aware peers i OPEN message när grannskap sätts upp. En router som är NSF-capable kan göra stateful switchover. BGP graceful restart är på default när IOS stödjer det. Defaultvärden som används om inget annat anges är restart-time: 120 sekunder och stalepath-time: 360 sekunder.
 bgp graceful-restart
 bgp graceful-restart extended

'''Backdoor''' &lt;br/&gt;
Eftersom eBGP har AD 20 är det preferred över IGPs. Om man kör IGP mellan AS och vill att det i första hand ska styra trafiken kan man manipulera BGP. Det man kan göra är att själv annonsera ut de prefix som de andra AS har. iBGP har AD 200 och blir således inte preferred. Dock blir då next-hop fel och det är där BGP Backdoor feature kommer in. Med backdoor annonseras inte några prefix till eBGP-grannar om man själv inte har det i sitt AS men AD lokalt blir fortfarande 200. 
 network 10.0.0.0 mask 255.0.0.0 backdoor
Går även manuellt att sätta högre distance på prefix från grannar.

'''DMZ Link över eBGP''' &lt;br/&gt;
Use DMZ Link Bandwidth as weight for BGP multipaths on single-hop EBGP peers. Bandwidth skickas med i uppdateringar som extended community och kan användas för lastdelning av trafiken. 
 router bgp 100
  maximum-path 4
  bgp dmzlink-bw
  neighbor 2.2.2.2 dmzlink-bw
 
 show ip bgp &lt;prefix&gt; | i DMZ
För att verifiera får man också kolla traffic share.

IOS-XR&lt;br/&gt;
 neighbor 1.1.1.1
  dmz-link-bandwidth
  ebgp-send-extcommunity-dmz
  ebgp-recv-extcommunity-dmz
För att köra multipath över olika AS.
 bgp bestpath as-path multipath-relax
 bgp bestpath as-path ignore

Have route-map set commands take priority over BGP commands such as next-hop unchanged.
 bgp route-map priority

Default annonseras routes som ej hamnar i RIB (RIB-failure) vidare till andra, ändra detta:
 bgp suppress-inactive
 show ip bgp rib-failure

==Path Manipulation==
'''Outbound from AS:'''
* Weight
* Local preference
* Communities (mer skalbart än LOCAL_PREF)

'''Inbound to AS:'''
* AS-prepend
* MED

===MED===
Multi-exit discriminator är ett konfigurerbart värde som kan användas för att välja var trafik komma in till sitt AS. Eftersom det är ett nontransitive attribute skickas det inom AS men lämnar ej. Det jämförs bara om flera olika paths kommer från samma AS, detta kan ändras med bgp ''always-compare-med''. 
 route-map MED_50 permit 10
  set metric 50
 neighbor 1.1.1.1 route-map MED_50 out
4,294,967,295 är max metric och räknas som infinity.

===Local Preference===
Local Preference är ett konfigurerbart värde som används för att välja var trafik ska lämna det egna AS. Det skickas med NLRI till iBGP-grannar men ej eBGP. När en uppdateringar kommer från en eBGP-peer sätts default preference (100) på prefixet innan det annonseras vidare till iBGP.
 bgp default local-preference 100
Eller stäng av det
 no bgp default local-preference

Högst preference vinner
 route-map LOCALPREF permit 10
  set local-preference 500
 neighbor 1.1.1.1 route-map LOCALPREF in

===AS-prepend===
För att ändra var man vill att trafik ska komma in till det egna AS kan man manipulera AS_PATH genom att lägga på sitt AS flera gånger för att göra pathen längre.
 route-map PREPEND permit 10
  set as-path prepend 100 100 100
 neighbor 1.1.1.1 route-map PREPEND out

===Weight===
Cisco proprietary och finns endast inom routern själv. 
 route-map WEIGHT permit 10
  match ip address prefix-list HEAVY
  set weight 2000
 neighbor 1.1.1.1 route-map WEIGHT in

Default weight per neighbor
 neighbor 1.1.1.1 weight &lt;0-65535&gt;

===Community===
Community Path Attribute är 32-bitars nummer som används för att tagga prefix. Då kan man använda taggen för att matcha på och sedan manipulera path eller filtrera. Routrar kan kolla efter taggen och sedan fatta routingbeslut. Detta PA bärs med i annonseringarna och kan därmed användas av enheter som befinner sig flera AS bort. Eftersom det är ett optional transitive PA så behöver inte ens routrarna emellan förstå det. Till exempel kan man konfigurera att prefix med en viss community ska få en viss LOCAL_PREF och man kan på så sätt styra trafiken. 

Både heltal och AA:NN accepteras i konfiguration och show-kommandon men outputen från show route-map går att ändra. Detta är best practice.
 ip bgp-community new-format
Verify
 show ip bgp community ?
Så står det antingen aa:nn eller 1-4294967295 beroende på format

För att Community ska funka måste det skickas i uppdateringarna, standard och extended
 neighbor [ip-address] send-community both
Skicka community
 route-map SETCOMMUNITY permit 10
  match ip address prefix-list COMMUNITY
  set community 5
Alternativt flera med eller utan additive beroende på om att lägga till community istället för att ersätta är önskvärt.
  set community 5 10 15
  set community 5 10 15 additive
Man kan även ta bort community.
  set community none
Delete anything starting with 300
 ip community-list expanded REGEXP permit 300:[0-9]+_
 route-map DELETE permit 10
  set comm-list REGEXP delete
Ta emot community
 ip community-list 6 permit 5
 route-map CHANGEPREF permit 10
  match community 6
  set local-preference 250
Vill man matcha med regex måste man använda en extended community list. Community Internet (0:0) kan användas i community lists och betyder match any.
 ip community-list 101 permit &lt;regex&gt;

Show
 show ip bgp community

Några kända communities, ''set community ?''
* Internet: 0:0
* no-export: Annonsera inte utanför eget AS
* no-advertise: Annonsera inte till någon
* gshut: graceful shutdown
* local-as (NO_EXPORT_SUBCONFED): Annonsera inte utanför eget confederation sub-AS
 show ip bgp community no-advertise no-export local-AS

'''Graceful BGP session shutdown''' &lt;br/&gt;
GRACEFUL_SHUTDOWN är en well-known community som används i samband med BGP Graceful Shutdown feature. Man skickar ut communityn till de grannar som man vill ska sluta använda länkarna till den router som man t.ex. ska ha underhåll på. För att vara compliant med denna community måste man ha en ingress policy som säger "match community gshut -&gt; make path least prefered". IOS XE har en inbyggd macro för detta community-utskick och man anger hur många sekunder det tar innan man bryter grannskapet.

Exempel:
 neighbor 10.0.1.1 shutdown graceful 30
Då skickas det ut UPDATE + ROUTE REFRESH som har community value 0xFFFF0000. 30 sekunder senare skickas det NOTIFICATION med admin shutdown. Då hamnar även "neighbor 10.0.1.1 shutdown" i running conf.

Man kan även skicka med en egen community eller local pref (funkar såklart inte på ebgp).
 neighbor 10.0.1.1 shutdown graceful 30 community 100 local-preference 150

Det går även att aktivera community-utskicket + admin shutdown för alla grannskap samtidigt. Oavsett om man använder peer-groups eller inte så hamnar shutdown på alla enskilda neighbors. Det finns ingen macro för unactivate utan "neighbor shutdown" får man ta bort själv efteråt.
 bgp graceful-shutdown all neighbors activate

===AS Manipulation===
Man kan konfigurera sig själv att skicka ett helt annat ASN i OPEN message än vad man egentligen har så att man ser ut som ett annat AS för externa partar, detta görs med ''local-as''. Man kan även välja om detta "fake" AS ska läggas på eller ej på det som tas emot beroende på hur ens AS är uppdelat, dvs anledningen till att man ens kör local-as. Man kan också ställa in att det enda som andra sidan ser är fake AS, ''replace-as''. Under en övergångsperiod kan man acceptera två AS och grannen kan då peera med valfritt, ''dual-as''.
 neighbor 1.1.1.1 local-as 601 no-prepend [replace-as] [dual-as]

Kan användas för att dölja ASN, Override matching AS-number while sending update, dvs det är en egress feature.
 neighbor 1.1.1.1 as-override

Acceptera as-path som innehåller det egna ASN, kan behövas i vissa fall där ens AS är uppdelat. Default får ens AS förekomma 3 gånger i AS_PATH.
 neighbor 1.1.1.1 allowas-in 

Ta bort private AS number från utgående uppdateringar, detta AS måste finnas i början av AS path för att detta ska funka.
 neighbor 1.1.1.1 remove-private-as [all]

'''Attribute-map''' &lt;br/&gt;
Attribute map kan användas för att manipulera AS och/eller attributes från AS-sets.
 set origin egp 22

==Filtering==
BGP kan filtrera AS, NLRI och PA i alla inkommande och utgående uppdateringar antingen per granne eller per peer group. För att en filterändring ska gå igenom krävs clear-kommandot.

'''Maximum prefixes'''
 neighbor 1.1.1.1 maximum-prefix 1000 
Only give warning message when limit is exceeded
 neighbor 1.1.1.1 maximum-prefix 1000 warning-only
 show ip bgp neighbors 1.1.1.1 | i Maximum|Threshold

===AS===
Regular Expressions
* .* = Any
* ^$ = Local AS
* _200$ = Originated in AS 200
* _200_ = Transited AS 200
* ^200_ = Learned from 200
* [0-9]+ = Any AS

AS-path ACL
 ip as-path access-list 100 deny _120$
 ip as-path access-list 100 permit .*
 neighbor 1.1.1.1 filter-list 100 in

Maximum number of ASes in the AS-PATH attribute
 bgp maxas-limit &lt;1-254&gt;

===Network===
Distribute-list, standard ACL
 access-list 1 permit 10.10.10.0 0.0.0.255 
 neighbor 1.1.1.1 distribute-list 1 in

Extended ACL tolkas av BGP som:
 access-list 100 permit ip &lt;subnet&gt; &lt;wildcard for subnet&gt; &lt;mask&gt; &lt;wildcard for mask&gt;
 neighbor 1.1.1.1 distribute-list 100 in

Prefix-list, det rekommenderade sättet.
 ip prefix-list ACCEPT seq 10 permit 10.10.10.0/24 le 24
 neighbor 1.1.1.1 prefix-list ACCEPT in
Verify
 show ip bgp prefix-list ACCEPT

'''ORF''' &lt;br/&gt;
Outbound route filtering kan användas för att berätta för sina neighbors vilka prefix man tillåter in så de dynamiskt kan sätta samma prefix-lista som outbound prefix filter och inte ens behöver skicka något annat. Båda sidor måste stödja ORF för att det ska kunna användas.
 neighbor 1.1.1.1 prefix-list ALLOW in 
 neighbor 1.1.1.1 capability orf prefix-list both
 
 show ip bgp neighbors 1.1.1.1 | s Outbound
 show ip bgp neighbors 1.1.1.1 received prefix-filter
 clear ip bgp 1.1.1.1 soft in prefix-filter

===RT===
Filtrera inkommande routes genom att vitlista specifikt route-target

 ip extcommunity-list standard FILTER-AS400-VPNV4-IN permit rt 1337:10
 route-map FILTER-AS400-VPNV4-IN permit 10
  match extcommunity FILTER-AS400-VPNV4-IN
 
 address-family vpnv4
  neighbor 172.16.99.2 route-map FILTER-AS400-IN in
Verify
 show ip extcommunity-list
 show bgp vpnv4 unicast all extcommunity-list FILTER-AS400-VPNV4-IN

==Convergence==
BGP är inte designat för att vara det snabbaste protokollet, detta för att kunna fungera i stor skala men det finns flera tekniker för att sänka konvergeringstid (recovery). Även om routes tas bort från routingtabellen snabbt så väntar BGP-processen på att TCP-sessionen ska timea ut eller hold-down ska gå ut innan konvergeringsprocessen börjar. Hold-down timer är default 3 minuter. Det är också så att BGP inte skickar uppdateringar direkt till grannar utan det sker periodvis baserat på peering-typ, 0 sekunder för iBGP-grannar och 30 sekunder för eBGP. BGP verifierar next-hop reachability med hjälp av IGP, detta görs var 60:e sekund. Allt detta leder till att BGP kan ta väldigt lång tid på sig att konvergera. 

Timers
 timers bgp &lt;keepalive&gt; &lt;holdtime&gt; &lt;minimum hold time from neighbor&gt;
 timers bgp 10 30 20
I IOS-XE verkar ''keepalive'' vara verkningslöst, det är holdtime delat med tre som blir aktivt.

'''Next Hop Tracking''' &lt;br/&gt;
NHT is an on-by-default feature that notifies BGP to a change in routing for BGP prefix next-hops. This is important because previously this only happened as part of the BGP Scanner process, which runs every 60 seconds by default. The bgp nexthop trigger delay defines how long for the NHT process to delay updating BGP. This timer is here to prevent BGP from being beaten up by a flapping IGP route. At default value 5 seconds, the BGP process can't get bogged down from unnecessary updates.
 bgp nexthop trigger enable
 bgp nexthop trigger delay 5

'''Scan interval''' &lt;br/&gt;
Hur ofta IGP ska scannas efter uppdateringar, default är 60 sekunder. OBS ''bgp scan-time configuration less than 15 seconds can cause high cpu usage by BGP Scanner.''
 router bgp 100
  bgp scan-time &lt;5-60&gt;
 show ip bgp summary | i scan
Kolla VRF:er om det finns nya routes att annonsera med MP-BGP.
  address-family vpnv4 unicast
   bgp scan-time &lt;5-60&gt;
 show bgp vpnv4 unicast all summary | i scan
Man kan reducera konvergenstiden när BGP paths förändras genom att konfigurera policyn för vad som ska dra nytta av BGP Event-Based VPN Import feature. 
 address-family ipv4 vrf Cust_A
  import path selection all

'''eBGP neighbor loss detection''' &lt;br/&gt;
BGP-grannskap rivs direkt när länken mellan går ner vilket leder till att BGP-routsen flushas direkt och det sökes efter alternativ. Detta är default i IOS sedan länge.
 bgp fast-external-fallover  #Global
 ip bgp fast-external-fallover  #Per interface

'''iBGP neighbor loss detection''' &lt;br/&gt;
Så fort en grannens IP-address försvinner från routingtabellen (på grund av IGP) så tas grannskapet ner och konvergering kan börja direkt. Ingen hold-down eller delay i deaktivering av BGP-session används. Är IGPn det minsta långsam på att hitta en alternativ route till grannen så hinner grannskapet tas ner. Det går även att använda detta för eBGP t.ex. om man peerar med loopbacks och det fungerar på samma sätt.
 neighbor 1.1.1.1 fall-over

====BFD====
Se även [[Cisco_BFD|Cisco BFD]].
 neighbor 1.1.1.1 fall-over bfd
 show bfd neighbor
The C-Bit is set by the BFD process itself, and isn't something you can toggle. However, you can tell your BFD process whether to ignore the setting or not. The default is to ignore.
 neighbor 2.2.2.2 fall-over bfd check-control-plane-failure

===PIC===
Prefix Independent Convergence är en CEF/FIB-feature framtagen för att snabba upp data-plane recovery när man har FIB med väldigt många routes och next-hop blir unreachable men det finns en annan gångbar next-hop. Traditionellt byggdes FIB med Prefix -&gt; Interface/Next-Hop. Ändras next-hop måste FIB:en uppdateras för varenda prefix vilket kan ta lång tid ifall det finns många. Med PIC Core lägger man in en pointer emellan, Prefix -&gt; Pointer -&gt; Interface/Next-Hop. Ändras next-hop behöver endast en pointer pekas om, alla prefix kan fortfarande peka mot samma pointer. BGP FRR precomputes en näst bästa väg i BGP och ger den till RIB som en backup/alternate path och CEF programmerar det i line cardsen. BGP PIC feature supporterar prefix för IPv4, IPv6, VPNv4 och VPNv6. Kör man BGP Multipath så finns support för PIC. Har man route reflector endast i control plane behöver man inte slå på PIC eftersom det handlar om data plane recovery.

'''PIC Core'''&lt;br/&gt;
Hierarchical FIB, local only mechanism.
 bgp additional-paths install
 
 cef table output-chain build favor convergence-speed
Stänga av PIC
 cef table output-chain build favor memory-utilization  

'''PIC Edge'''&lt;br/&gt;
Eftersom PIC Edge precomputes en alternate path försvinner poängen med CEF recursion så därför kommer det att disableas för prefix med /32-mask eller som är directly connected när man slår på BGP PIC. ''bgp recursion host'' enableas för VPNv4 och VPNv6 address families och disableas för IPv4 och IPv6 address families.
 bgp additional-path install
 bgp recursion host
 bgp advertise-best-external

'''IOS-XR'''&lt;br/&gt;
 route-policy PIC-EDGE
  set path-selection backup 1 advertise
 end-policy
 
 router bgp 1
  address-family vpnv4 unicast
   additional-paths selection route-policy PIC-EDGE

==Default route==
Send default route, görs per adressfamilj och måste finnas i routingtabellen.
 network 0.0.0.0
eller använd '''default-information originate''' (det kräver också redistribution)

Skicka default route villkorslöst, görs per neighbor. Detta går förbi output filtering och kräver inte gateway of last resort i RIB.
 neighbor 1.1.1.1 default-originate

==Summarization==
Auto-Summary är avstängt default och bör vara det. Om det är påslaget påverkar det network och redistribution.
* network-kommando: classful and more specific
* redistribution: only classful

För att skicka summerade routes används aggregate-address och en null route installeras automatiskt. Inget annonseras om inte det inte finns någon component route i BGP-tabellen. Om component routes har olika AS_SEQ så kan inte de slås samman utan då kommer aggregeringen att skickas med AS_SEQ null. aggregate-address skickas med PA: Atomic Aggregate.
 aggregate-address 10.0.0.0 255.0.0.0 [summary-only] [as-set]
summary-only = suppress detailed routes. AS-set innebär att alla ASN från de mer specifika prefixen ska sättas ihop och inkluderas i summeringen, ett set räknas som ett AS hopp och används för loop prevention. Övrig information från de mer specifika prefixen slås också ihop och en del information då vara överlappade. Man kan manipulera detta själv genom att välja ut enskilda prefix som ska utgöra källan för de attribut som aggregeringen ska ha. Detta görs med route-map som konfigureras efter as-set, '''advertise-map ADVERTISE_MAP'''.

Alternativt
 ip route 10.0.0.0 255.0.0.0 null 0
 router bgp 100
  network 10.0.0.0 255.0.0.0

'''Suppress-map''' &lt;br/&gt;
Med aggregate-address skickas en summary och de mer specifika prefixen. Detta går att styra med en suppress-map som fungerar som en svartlista.
 ip prefix-list DONT-SUPPRESS-THIS permit 10.0.2.0/24
 route-map SUPPRESS deny 10
  match ip address prefix-list DONT-SUPPRESS-THIS
 route-map SUPPRESS permit 20
 
 router bgp 100
  aggregate-address 10.0.0.0 255.255.0.0 suppress-map SUPPRESS

'''Unsuppress-map''' &lt;br/&gt;
Används om man vill skicka mer specifika prefix till en granne trots att man använder summary-only, fungerar som en vitlista.
 ip prefix-list UNSUPPRESS-THIS permit 10.0.2.0/24
 route-map UNSUPPRESS permit 10
  match ip address prefix-list UNSUPPRESS-THIS
 
 router bgp 100
  aggregate-address 10.0.0.0 255.255.0.0 summary-only 
  neighbor 1.1.1.1 unsuppress-map UNSUPPRESS

==Multiprotocol BGP==
För att kunna skicka NLRI om annat än IPv4, t.ex. VPN routes för olika VRF:er,  behövs fler path attributes. MP-BGP (RFC 4760) är ett extension till BGP som ger två nya optional nontransitive attributes. Multiprotocol Reachable NLRI (MP_REACH_NLRI) annonserar MP-routes och Multiprotocol Unreachable NLRI (MP_UNREACH_NLRI) drar tillbaka MP-routes. Dessa innehåller AFI, Next-hop och NLRI. NLRI står för lägga till eller ta bort routes och next-hop. MP-BGP listas som capability i Open-paketen och körs för det mesta inom samma AS. Se även [[Cisco_MPLS|Cisco MPLS]].

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_BGP_MP.png]]
&lt;/div&gt;
&lt;/div&gt;

IPv4 unicast aktiveras så fort man konfigurerar MP-BGP.
 router bgp 100
  no bgp default ipv4-unicast
  address-family vpnv4
   neighbor 1.1.1.1 activate
   neighbor 1.1.1.1 send-community extended
  exit-address-family
BGP send-community slås på automatiskt när man aktiverar en granne för det är ett måste för att MP-BGP ska fungera.

Se routes som skickas från en VRF (adj-ribs-out)
 show ip bgp vrf Name neighbors 10.10.10.10 advertised-routes 
 clear ip bgp 10.10.10.10 vrf Name

==Route Reflector==
Routes lärda av iBGP skickas ej vidare till iBGP-grannar per default. En route reflector (RFC 1966) bryter denna regel så full mesh iBGP-grannskap behövs ej och iBGP blir mer skalbart. Dock skickar en RR endast vidare routes som anses "best" i den egna BGP-tabellen, detta håller nere antalet annonserade routes. Den enda gången en RR inte skickar vidare NLRI när det ska till en icke-klient då NLRI är mottagen från en icke-klient, dvs vanlig iBGP. För att hålla nätverket loopfritt används Path Attribute, RR sätter CLUSTER_LIST och det innehåller egna cluster-id som skickas med Updates. Innehåller en mottagen update det egna cluster-id så kommer prefixet discardas. ORIGINATOR_ID, RID på iBGP-routern som först annonserade prefixet, skickas även med. Ser en router ett prefix med sitt egna RID som ORIGINATOR_ID kommer inte prefixet att annonseras vidare. För high availability och resiliency används fördelaktigt ett eller flera RR-kluster. 

'''Utmaningar''' &lt;br/&gt;
På grund av att RR endast annonserar vidare en path blir det reduced path diversity och om inte klienterna får additional path visibility i förväg kan RR introducera högre konvergeringstid samt att man tappar multi-pathing. Detta går att lösa med Additional Paths. Eftersom RR kör best path utifrån sitt eget perspektiv (IGP cost) kan det även leda till sub-optimal routing. Om man kör IP forwarding istället för label forwarding kan även forwarding loopar skapas i vissa scenarier på grund av RR-placering. Som generell regel kan man säga att BGP-sessionerna inte ska avvika för mycket ifrån forwarding topology. Detta gäller alltså inte när man använder mpls vpn för all data plane, då spelar placering i princip ingen roll.

Man måste också bestämma om det ska vara vanlig iBGP eller route-reflector-client till andra kluster och det beror på vilken redundansdesign man valt. Kör man non-client finns det vissa failure-situationer som kan leda till traffic black holes. Väljer man client kommer man att få in uppdateringar med det man själv annonserar ut dvs feedback loop. Detta är inga problem med små BGP-tabeller men kan ställa till det med stora.

RR-server
 router bgp 65000
  neighbor 1.1.1.1 remote-as 65000
  neighbor 1.1.1.1 update-source lo0
  neighbor 1.1.1.1 route-reflector-client

Kluster konfigureras på RR-server, sätt samma cluster-id på de RR som ska ingå i klustret. Man kan ha flera kluster.
 router bgp 65000
  bgp cluster-id 5

RR-klienter känner inte till RR-konceptet så de konfigureras som vanlig iBGP.
 router bgp 65000
  neighbor 2.2.2.2 remote-as 65000
  neighbor 2.2.2.2 update-source lo0

Verify
 show ip bgp update-group

Det är inte alltid RR finns i forwarding path, då kan man använda "Selective RIB Download" för att spara lokala resurser. All NLRI finns i BGP-tabellen som vanligt för best-path och annonsering men det behöver ju aldrig läggas in entries i RIB/FIB. En table-map är en route-map för BGP-tabellen istället för per grannskap.
 table-map BORD filter

==Confederations==
BGP confederations (RFC 5065) delar upp ett AS i flera sub-AS. Routrar inom samma sub-AS är confederation iBGP-grannar medans mellan sub-AS är confederation eBGP-grannar. iBGP fungerar precis likadant, dvs routes lärda från iBGP annonseras ej vidare till iBGP-grannar och det behövs således full mesh grannskap alternativt en route reflector inom varje sub-AS. För att undvika loopar används path attributet AS_PATH. Istället för de vanliga AS_SEQ och AS_SET används AS_CONFED_SEQ och AS_CONFED_SET. Confed-AS räknas som ett AS vid path selection. Finns en grannes sub-AS redan med i AS_CONFED_SEQ så kommer prefixet inte att annonseras till den. När det gäller confederation eBGP används TTL 1 precis som med vanlig eBGP däremot ändras inte NEXT_HOP default mellan sub-AS. Om ett prefix ska annonseras ut från en confederation tas confederation ASN bort från AS_PATH så utsidan ser endast ett AS.
 router bgp 65000
  bgp confederation identifier 123

För att routern ska veta att det är ett confederation eBGP-grannskap och inte ett vanligt ange ''bgp confederation peers''. Detta behövs inte på routrar som ej har confederation eBGP-grannskap. 
 router bgp 65000
  bgp confederation peers 65001
  neighbor 10.0.0.20 remote-as 65001

==Redistribution==
Man måste vara försiktig när man redistribuerar mellan IGP och BGP eftersom BGP klarar så mycket fler routes än någon IGP. Default så redistribueras endast eBGP till andra protokoll pga att iBGP inte har någon egen loop prevention mekanism. Man kan ändra detta men det bör man inte göra. 
 bgp redistribute internal

'''OSPF''' &lt;br/&gt;
Only internal OSPF routes will be redistributed into BGP by default.
 redistribute ospf 1 
 redistribute ospf 1 route-map SET-ORIGIN  # betyder allt i rib dvs externals följer med

==Dampening==
Förutom att använda route aggregation för att minska risken att CPU går i taket på alla enheter när något flappar kan dampening användas. 
 route-map DAMPENING permit 10
  set dampening 5 1900 2000 10
5=half-life, 1900=reuse-limit, 2000=suppress-limit, 10 max-suppress-limit
 router bgp 100
  bgp dampening route-map DAMPENING
Route flap
 show ip bgp flap-statistics
 show ip bgp dampening parameters

==Conditional Route Injection==
The ability to insert more specific prefixes into BGP without having them in the IP routing table. Routemap which specifies prefixes to inject and routemap which specifies exist condition (Det går även köra med non-exist om man vill vända på det)
 ip prefix-list INJECT-THIS permit 110.0.1.0/24
 ip prefix-list INJECT-THIS permit 110.0.2.0/24
 ip prefix-list AGGREGATE permit 110.0.0.0/8
 ip prefix-list SOURCE permit 1.1.1.1/32
 
 route-map INJECT
  set ip address prefix-list INJECT-THIS
 
 route-map EXIST
  match ip address prefix-list AGGREGATE
  match ip route-source prefix-list SOURCE
 
 router bgp 100
  bgp inject-map INJECT exist-map EXIST
The less-specific prefix MUST come from a BGP neighbor. No insertion of more-specific prefixes of a locally-originated prefix.

Verify
 show ip bgp injected-paths
 show ip bgp neighbors 1.1.1.1 | i status

===Conditional Advertisement===
Conditional advertisement tillåter att man per neighbor endast annonserar utvalda prefix om vissa prefix existerar/inte existerar i den lokala BGP-tabellen, som kollas av BGP scanner/NHT.

 route-map ADVERTISE_MAP permit 10
  match as-path 1
 
 ip prefix-list PREFIX permit 10.0.10.0/24
 
 route-map NON_EXIST_MAP permit 10
  match ip address prefix-list PREFIX
 
 router bgp 100
  neighbor 1.1.1.1 advertise-map ADVERTISE_MAP non-exist-map NON_EXIST_MAP

==Flowspec==
BGP flow specification är en feature som man kan använda för att propagera filter- och policy-funktionalitet till sina BGP-noder. Det kan användas för att mitigera DDoS-attacker. Med flowspec går det att filtrera mycket mer granulärt än med Remote Trigger Blackhole (RTBH). Man har även fler möjligheter för vad man vill göra med attacken, t.ex. drop eller police, next-hop eller VRF redirect, DSCP Markings. Flowspec implementeras som en adressfamilj. IOS XE har stöd för flowspec client function men som flowspec controller behövs något annat. Controllern som t.ex. kan lyssna på ett DDoS-detekteringssystem skickar ut flowspec NLRI till klienterna, detta säger vad som ska göras med vilken trafik. Ju fler och ju mer avancerade regler man skjuter ut ju mer TCAM går åt. 

Det finns flera mjukvaror som kan agera controller, t.ex. [[Cisco_IOS-XR|IOS-XR]], GoBGP eller [[ExaBGP]].

IOS XE
 flowspec
  address-family ipv4
   local-install interface-all
 
 router bgp 100
  address-family ipv4 flowspec
   neighbor 10.1.1.1 activate

Verify
 show flowspec summary 
 show bgp ipv4 flowspec 

==BMP==
The BGP Monitoring Protocol (BMP) feature supports functionality to monitor Border Gateway Protocol (BGP) neighbors. Det kan t.ex. användas för BGP Looking glass och/eller advanced route analytics. Det kan även underlätta vid route-policy troubleshooting. BMP devices (routers) skickar BMP messages till en BMP collector/daemon, t.ex. [https://github.com/OpenBMP/openbmp OpenBMP].
 router bgp 65000
  neighbor 30.1.1.1 bmp-activate server 1
  bmp server 1
   address 10.0.0.10 port-number 8000
   activate

Verify
 show ip bgp bmp server 1
 show ip bgp bmp server summary

==RPKI==
"Resource Public Key Infrastructure allows IP address holders to specify which Autonomous Systems (AS’s) are authorized to originate their IP address prefixes." RPKI ökar dock komplexitet. Konfigurera RPKI Cache-server, RPKI Prefix Validation, BGP Prefix Validation och RPKI Bestpath Computation.

'''IOS'''
 router bgp 100
  bgp rpki server tcp 10.0.10.10 port 1333 refresh 600

Slå av Validation of BGP Prefixes men ladda ner RPKI Information.
 bgp bestpath prefix-validate disable
Tillåt Invalid Prefixes som Best Path.
 bgp bestpath prefix-validate allow-invalid
Announce RPKI information mha Extended Community
 neighbor 1.1.1.1 announce rpki state

Verify
 show ip bgp rpki servers
 show ip bgp rpki table
 clear ip bgp rpki server

'''IOS-XR'''&lt;br/&gt;
Fr.o.m. XR 6.5.1 är origin-as validation disabled by default.
 router bgp 1
  rpki server 10.0.0.10
   transport tcp port 3323
   refresh-time 600
 !
 bgp bestpath origin-as use validity
 bgp bestpath origin-as allow invalid
 address-family ipv4 unicast
  bgp origin-as validation signal ibgp

Verify
 show bgp rpki summary

==Route Server==
BGP route server är feature designad för internet exchange (IX) operators som ger ett alternativ till full eBGP mesh peering inne på IXP. Det tillhandahåller route reflection med support för unik policy per service provider. Route server ger transparens för AS-path, MED och next-hop så SPs som peerar med varandra fortfarande kan göra det som directly connected men IX route server medlar denna peering. Detta är osynligt utanför IX. Route server leder till mindre konfiguration samt CPU/minnesanvändning på varje border router.

 router bgp 1337
  neighbor 10.0.0.1 remote-as 100
  neighbor 10.0.0.2 remote-as 200
 
  address-family ipv4 unicast
   neighbor 10.0.0.1 activate
   neighbor 10.0.0.1 route-server-client
   neighbor 10.0.0.2 activate
   neighbor 10.0.0.2 route-server-client
 
 show ip bgp ipv4 unicast route-server all summary

Default så nekar en router uppdateringar från en eBGP-peer som inte har det egna ASN i början av as-path. Detta gör att en route servers beteende inte är okej så denna check måste stängas av på alla border router.

 router bgp 100
  no bgp enforce-first-as
  neighbor 10.0.0.137 remote-as 1337

[[Category:Cisco]]</text>
      <sha1>78ytdlgupqb90nqctl8f6pbxxvk9gat</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco BIER</title>
    <ns>0</ns>
    <id>543</id>
    <revision>
      <id>2988</id>
      <timestamp>2019-06-13T08:55:33Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Bit Indexed Explicit Replication (RFC 8279). En router som supporterar BIER kallas Bit-Forwarding Router (BFR).   Några fördelar med BIER: * No Reverse Path Forwarding (RPF)..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="399">Bit Indexed Explicit Replication (RFC 8279). En router som supporterar BIER kallas Bit-Forwarding Router (BFR). 

Några fördelar med BIER:
* No Reverse Path Forwarding (RPF) checks
* No Rendezvous Points
* No shared tree -&gt; source tree switchover
* No receiver driven tree building
* State is in the packet and not in the network.

Se även [[Cisco_Multicast|Cisco Multicast]].

[[Category:Cisco]]</text>
      <sha1>j73os4mchlmksv4hhkfzwssxys5z9oi</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco CEF</title>
    <ns>0</ns>
    <id>233</id>
    <revision>
      <id>2225</id>
      <parentid>2142</parentid>
      <timestamp>2017-01-23T13:39:30Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3249">Cisco Express Forwarding är switchingteknik som är framtagen för att öka prestandan på Ciscos routrar och L3-switchar. I tidernas begynnelse fanns endast process switching, då behövde varenda paket kollas upp i routingtabellen vart det skulle. L2-information för next-hop (som finns i en annan tabell) behövde också tas fram. Ibland krävs rekursiva iterationer av lookupen för att identifiera rätt next-hop och egress interface. Detta kan vara väldigt intensivt för CPU så en variant med cachefunktion utvecklades. Med fast switching behandlas det första paket på samma sätt som med process switching men resultatet av lookupen sparas i en route cache, designad för att vara snabb. Den innehåller destination IP, next-hop information och L2 information till framen som ska skickas. Route once, forward many times. Den stora nackdelen är att om det kommer in många nya paket blir det ändå tungt för CPU och entries i cachen timear ut ganska fort för annars skulle cachen kunna gå full och allt skulle bli process switched igen. CEF löser detta genom att proaktivt lägga entries i en cache som programmeras på ASIC. Routing-information från Routing Information Base (RIB), Route Processor (RP) och line card (LC) databases används för express forwarding. CEF har även möjlighet att göra rekursiva uppslag i RIB, dvs när primary path går ner kan next longest matching path användas, detta är användbart om next-hop finns multipla hopp bort och det går att nå via flera vägar. I nyare IOS:er finns det inte stöd för unicast fast switching. When IPv6 routing is enabled, CEFv6 is automatically enabled.
 show cef state

===FIB===
CEF har två nyckelkomponenter, FIB och Adjacency. L2 address resolution tas direkt från CEF med '''ip cef optimize neighbor resolution''', det är på default.
 show ip cef
 show ipv6 cef
 clear cef table ipv4
Adjacency
 show adjacency
Kolla en specifik route 
 show ip cef exact-route ''source'' ''destination''
 show ip cef exact-route 10.0.0.5 172.16.1.2

Consistency
 test cef table consistency
 show cef table consistency-check 

===Load Sharing===
Per-destination load balancing används default. Ett problem med att alla använder samma metod för att välja väg uppstår när hash algoritmen på flera noder väljer en viss väg och redundanta vägar därmed inte används, detta kallas CEF polarization. För att undvika detta använder numera CEF default en algoritm som väljer ett slumpat Universal ID som sedan används som seed för hashen. 
 ip cef load-sharing algorithm
  include-ports  Algorithm that includes layer 4 ports
  original       Original algorithm
  tunnel         Algorithm for use in tunnel only environments
  universal      Algorithm for use in most environments

===Interface===
CEF
 ip cef
 show ip interface | i protocol|CEF
Fast-switched
 int gi1
  no ip route-cache cef
Process-switched
 int gi1
  no ip route-cache
Debug
 debug ip packet detail
För detta krävs att CEF stängs av, ''no ip route-cache''

===dCEF===
Med Distributed CEF så har alla line cards egna kopior av FIB och adjacency table, på så sätt kan de göra express forwarding själva och behöver inte fråga main processor.
 show cef linecard

[[Category:Cisco]]</text>
      <sha1>nilwsh2murj87oz399d8gilo8u8nmab</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco CSR</title>
    <ns>0</ns>
    <id>224</id>
    <revision>
      <id>2575</id>
      <parentid>2246</parentid>
      <timestamp>2017-05-23T11:15:28Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3617">Cisco Cloud Services Router 1000V är en mjukvarurouter. CSR har DPDK integrerat i dataplane och kör [[Cisco_IOS|IOS-XE]], samma OS som ASR 1000. Unlicensed Cisco IOS XE 3.13S och senare har en throughput begränsad till 100 kbps ('''show platform hardware throughput level''').

==Installation==
Ladda ned mjukvaran från Ciscos hemsida, [https://software.cisco.com/download/type.html?mdfid=284364978&amp;flowid=39582 download]

* '''[[VMware_ESXi|VMware ESXi]]:''' Deploy OVF template.

* '''[[KVM]]:''' Qemu image (.qcow2) finns att ladda ner direkt.

'''Licens''' &lt;br/&gt;
Ladda ner licens från cisco (http:/www.cisco.com/go/license) och lägg in på bootflash på enheten. Det finns 60 dagars eval-licens.
 license install bootflash:lic25ax.lic
 show license detail

==Konfiguration==
Här listas CSR-specifik info, för övrig konfiguration se [[Cisco_IOS|Cisco IOS]].

Nyare CSR har ett modernt webbgränssnitt som man kan använda för att managera och monitorera enheten.
 ip http server
 http://10.0.10.1/webui/

===Resurser===
'''CPU''' &lt;br/&gt;
Show processes inside the IOS daemon.
 show processes cpu sorted
Show processes for the underlying operating system.
 show processes cpu platform sorted
Increase the control-plane CPU
 platform resource control-plane-heavy

'''Memory'''
 show memory platform
Increase the Cisco IOS XE memory
 platform memory add 3286

'''NIC'''
 show platform software vnic-if interface-mapping

===Uppgradering===
För att uppgradera en CSR laddar man ner nyare bin-fil och lägger på local storage.
 copy http://''fileserver''/csr1000v-universalk9.03.16.04b.S.155-3.S4b-ext.SPA.bin bootflash:
 verify bootflash:csr1000v-universalk9.03.16.04b.S.155-3.S4b-ext.SPA.bin
 
 boot system flash bootflash:csr1000v-universalk9.03.16.04b.S.155-3.S4b-ext.SPA.bin
 show bootvar
 reload

==REST API==
Standard port for IOS XE REST API: 55443
 virtual-service csr_mgmt
  ip shared host-interface GigabitEthernet1
  activate

Verify
 show virtual-service
 show virtual-service detail | i API
 show remote-management status

'''URL-exempel''' &lt;br/&gt;
{| class="wikitable"
! URL || Method 
|-
| /api/v1/global/running-config || GET
|-
| /api/v1/global/save-config || PUT
|-
| /api/v1/global/cli || PUT
|-
| /api/v1/vrf || GET
|-
| /api/v1/routing-svc/bgp/100/neighbors || GET
|}

'''CURL''' &lt;br/&gt;
 curl -X POST https://10.0.10.1:55443/api/v1/auth/token-services -H "Accept:application/json" -u "cisco:cisco" --insecure
 curl -X GET https://10.0.10.1:55443/api/v1/interfaces -H "X-auth-token:+gcg41pecdAvyeBPGmvOPN4yfLIZ55D+sdYPJKPzlT8=" --insecure
Tokens automatically expire after 15 minutes.

===NETCONF===
Legacy NETCONF, port 22.
 netconf ssh

Enable NETCONF/YANG support, port 830.
 netconf-yang

Discover capabilities
 from ncclient import manager
 m = manager.connect(host='192.168.1.21', port=830, username='cisco',
                    password='cisco', device_params={'name': 'CSR'})
 print m.server_capabilities

==Hypervisor==
IOS-XE har numera stöd för att själv köra virtuella maskiner, dvs agera hypervisor. Om man kör på en CSR glöm ej Hardware Assisted Virtualization.

Förberedelser, lägga in OVA på routerns lokala storage samt:
 virtual-service
  signing level unsigned

Installera paket
 virtual-service install name Fedora package bootflash:Fedora.ova
 show virtual-service list

För att ge VM:en konnektivitet med outside world skapar man en Virtual Port Group.
 int virtualportGroup 1
  ip add 10.0.10.1 255.255.255.0

Starta VM
 activate

Anslut till console på VM
 virtual-service connect name Fedora console

Aktivera shell
 guestshell enable

[[Category:Cisco]]</text>
      <sha1>rtx352129pfrlbhgrwug17jcqzaqslt</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco DHCP</title>
    <ns>0</ns>
    <id>209</id>
    <revision>
      <id>2985</id>
      <parentid>2972</parentid>
      <timestamp>2019-06-05T07:26:57Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11267">Dynamic Host Configuration Protocol (RFC 2131) är ett protokoll som dynamiskt distribuerar nätverkskonfiguration. 

'''Bakgrund''' &lt;br/&gt;
DHCP har utvecklats från Bootstrap protocol (RFC 951) som i sin tur har utvecklats pga tillkortakommanden hos Reverse ARP. Alla tre protokoll bygger på att klienten initialt broadcastar en discovery och servern svarar med en IP-adress. RARP fungerar precis som ARP men frågar efter sin egen MAC-adress och har satt IP till 0.0.0.0. Servern måste vara förkonfigurerad med klientens MAC-adress och en IP-adress. Servern måste även befinna sig i samma L2-domän som klienten. BOOTP togs fram för att förbättra processen med adresstilldelning till klienter. Det använder helt egna meddelanden och rullar på IP och UDP. Den stora fördelen mot RARP är att det går att tilldela klienterna subnätmask, default gateway, DNS-servrar och boot-server (hörs på namnet att det funkar). BOOTP-discovery går även att forwarda till andra subnät. Den stora nackdelen är att det har samma administrativa börda som RARP, dvs alla MAC-adresser och IP-adresser måste förkonfigureras på servern. Nästa steg är i utvecklingen är DHCP.

DHCP använder samma format som BOOTP, dvs servrar lyssnar på UDP port 67 och klienter kommunicerar från UDP port 68, men har satsat mer på att vara dynamisk. Det uppnås med pooler, leasing och adressåtervinning. Det finns även extensions för att registrera klienters FQDN till DNS.

===Paket===
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Discover
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_DHCP_Discover.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Offer
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_DHCP_Offer.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Request
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_DHCP_Request.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* ACK
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_DHCP_ACK.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Release
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_DHCP_Release.png]]
&lt;/div&gt;
&lt;/div&gt;

=Server=
''Cisco IOS DHCP server'' &lt;br/&gt;
Default är DHCP-tjänsten på och besvarar alla förfrågningar från nät som det finns en pool för men det går att stänga av helt.
 no service dhcp
 ip dhcp bootp ignore

'''Konfiguration''' &lt;br/&gt;
Exclude IP Addresses, Create DHCP Address Pool, Specify the Network, Set DNS Server, Set the Default Gateway
 ip dhcp excluded-address [start ip-address] [end ip-address]
 ip dhcp pool [poolname]
  network [ip-address] [subnet-mask]
  dns-server [ip-address of primary dns-server] [ip-address of secondary dns-server]
  default-router [ip-address]
  lease 1  #days
 exit

Enskild klient, man måste matcha på client id.
 ip dhcp pool R1
  host 10.0.0.11 255.255.255.0 
  client-identifier 0052.31

Man kan lägga databasen på flash.
 ip dhcp database flash:/
 show ip dhcp database

Verify
 show ip dhcp pool
 show ip dhcp binding
 show ip dhcp import
Clear
 clear ip dhcp binding *

Låt en IOS DHCP server acceptera requests med tomt giaddr-fält, t.o.m. om option 82 är satt (se nedan).
 ip dhcp relay information trust-all

IOS kommer att arpa/pinga en pool-adress innan den assignas till en klient. Om det inte besvaras antar DHCP-servern att adressen är ledig och kan därmed dela ut den till en klient. Default är 2 stycken pings men det går att stänga av.
 ip dhcp ping packets 0

'''IOS AutoInstall''' &lt;br/&gt;
 ip dhcp pool SWITCH-DEPLOY
  network 10.0.0.0 255.255.255.0
  option 150 ip 10.1.1.10
  option 67 ascii configs/base_config.txt

=Klient=
Client-Identifier är default en kombination av hardware address, interface name och cisco. Detta id görs om till en HEX-sträng som presenteras för servern. 
 interface Ethernet 1
  ip dhcp client client-id ascii R1
  ip address dhcp
Verify
 show dhcp lease

'''Release &amp; Renew''' &lt;br/&gt;
Release-kommandot gör att det skickas 3 stycken Release-meddelanden unicast till DHCP-servern. När renew-kommandot används skickar klienten en unicast DHCP Request, gällande samma IP, till servern som då kan välja att acka det eller ej.
 release dhcp ethernet 3/1
 renew dhcp ethernet 3/1

'''Broadcast''', bestäm om broadcastbiten ska vara satt till 1 eller 0, dvs att DHCP-svaren skickas tillbaka med broadcast eller unicast. Default är detta påslaget till skillnad från många andra operativsystem.
 ip dhcp-client broadcast-flag
'''AD''', konfigurera vad default routen man får med DHCP ska ha för administrative distance. Default är 254.
 ip dhcp-client default-router distance &lt;1-255&gt;

=Relay=
Gör om broadcast till unicast vilket möjliggör att man kan ha en central DHCP-server istället för en på varje nät. Relay måste ha interface-konf ''ip dhcp relay information trusted'' för att acceptera paket med option 82 satt, av t.ex. en switch.
 interface Ethernet 1
  ip helper-address 10.0.0.10

Allows the DHCP relay agent to switch the gateway address (giaddr field of a DHCP packet) to secondary addresses when there is no DHCPOFFER message from a DHCP server.
 ip dhcp smart-relay

Verify
 show ip helper-address

=Snooping=
DHCP snooping är en säkerhetsmekanism för att filtrera bort untrusted DHCP-paket och hålla koll på klienter genom att lyssna på DHCP-trafik och bygga en DHCP snooping binding database. Snooping hindrar rogue DHCP servers från att svara på requests och skyddar mot klienter som begär väldigt många leases, dvs DOS-attack. Det kollar också att MAC-adressen i DHCP-paketet matchar adressen det kommer ifrån samt kollar om release och decline kommer in på rätt portar enligt binding database. Paket som inte kommer från rätt port filtreras. Vissa andra säkerhetsmekanismer använder sig av informationen i snooping binding database, se [[Cisco_L3_Security#IPSG|IP Source Guard]] och [[Cisco_L2_Security#DAI|Dynamic ARP Inspection]].

Man måste slå på Switch DHCP snooping och sedan DHCP snooping för varje vlan man vill skydda.
 ip dhcp snooping
 ip dhcp snooping vlan 10
Globala default-inställningar
 no ip dhcp snooping information option allow-untrusted
 ip dhcp snooping information option
 no ip dhcp snooping database 
 ip dhcp snooping database write-delay 300
 ip dhcp snooping database timeout 300
 ip dhcp snooping verify mac-address
 ip dhcp snooping verify no-relay-agent-address

De interface som har en legit DHCP-server måste trustas. Man kan även sätta en rate limit på DHCP-paket.
 interface gi1
  ip dhcp snooping trust
  ip dhcp snooping limit rate 10

Stäng av option 82 om servern ej accepterar requests med giaddr 0.0.0.0. Om en router ser option 82 förväntar den sig non-zero giaddr.
 no ip dhcp snooping information option

Lägg databasen i en fil
 ip dhcp snooping database flash:/snooping.db

Har man flera switchar i sin topologi måste downstream-portas trustas också (alternativt att option 82 stängs av).
 ip dhcp snooping information option allow-untrusted

Verify
 show ip dhcp snooping

Recovery
 errdisable recovery cause dhcp-rate-limit 

===Option 82===
DHCP Relay Agent Information Option (RFC 3046) är framtaget för att låta relay agent skicka med circuit specific information i requesten som forwardas till DHCP-servern. Det som skickas med är exempelvis vilken ethernetport i switchen som requesten kom in på och mac-adress på relayen. Det är påslaget default om man kör DHCP snooping vilket innebär att denna information samt giaddr 0.0.0.0 läggs till DHCP-paketen men det går att stänga av med ''no ip dhcp snooping information option''.

[[File:Cisco_DHCP_Option82.png]]

=DHCPv6=
Med DHCPv6 används UDP port 546 för klienter och port 547 för servrar. Default gateway annonseras inte av DHCP utan det sköts av RA. DHCP-paketen har också uppdaterade namn:
* '''Solicit:''' Sent by a client to locate servers (FF02::1:2).
* '''Advertise:''' Sent by a server in response to a Solicit message to indicate availability.
* '''Request:''' Sent by a client to request addresses or configuration settings from a specific server.
* '''Reply:''' Sent by a server to a specific client in response to a Solicit, Request, Renew, Rebind, Information-Request, Confirm, Release, or Decline message.

DHCPv6 rapid configuration only uses the Solicit and Reply message. 
 ipv6 dhcp server DHCP_POOL rapid-commit

All_DHCP_Servers multicast group FF05::1:3.
 ipv6 dhcp server join all-dhcp-servers

===Stateful===
Functions exactly the same as IPv4 DHCP in which hosts receive both their IPv6 address and additional parameters from the DHCP server.
 ipv6 dhcp pool STATEFUL
  address prefix 10::/64
  dns-server 2001:4860:4860::8888
  domain-name hackernet.se
Interface
 interface gi2
  ipv6 address 10::1/64
  ipv6 dhcp server STATEFUL
  ipv6 nd managed-config-flag
  ipv6 nd prefix 10::/64 14400 14400 no-autoconfig
'''managed-config-flag''' sätter en flagga i RA som säger att hostarna kan använda DHCPv6. '''no-autoconfig''' säger att stateless configuration inte ska användas.

===Stateless===
SLAAC is used to get the IP address and DHCP is used to obtain “other” configuration options, usually things like DNS, NTP, etc.
 ipv6 dhcp pool STATELESS
  dns-server 2001:4860:4860::8888
  domain-name hackernet.se
Interface
 interface gi2
  ipv6 address 10::1/64
  ipv6 dhcp server STATELESS
  ipv6 nd other-config-flag
Verify
 show ipv6 dhcp pool

===Client===
DHCPv6 client, server, och relay-funktionalitet är mutually exclusive på ett interface.
 interface gi3
  ipv6 enable 
  ipv6 address dhcp
Verify
 show ipv6 dhcp interface

===Prefix Delegation===
DHCPv6 Prefix Delegation kan användas för att mangera adresser på länkar och subnät och använder sig av prefix delegation options i DHCP-paketen. DHCPv6 client application frågar efter PD, det fungerar både med stateful och stateless. Man har vanligtvis /56-prefix på servern och sedan kan klienten dela upp det och använda för att assigna /64-nät på flera av sina interface. 

* '''IANA''': Identity Association for Non Temporary address
* '''IAPD''': Identity Association for Prefix Delegation

Server
 ipv6 local pool PREFIX1 2001:192:168::/48 56
 ipv6 dhcp pool POOL
  prefix-delegation pool PREFIX1
 
 interface gi2
  ipv6 dhcp server POOL

Klient
 interface gi2
  description Uplink to DHCP server
  ipv6 dhcp client pd SERVER_PREFIX
 
 interface gi3
  ipv6 address SERVER_PREFIX ::1:0:0:0:101/64
 interface gi4
  ipv6 address SERVER_PREFIX ::2:0:0:0:101/64

=NX-OS=
 feature dhcp

'''Relay'''
 interface vlan 15
  ip dhcp relay address 10.0.0.10
Verify
 show ip dhcp relay
Smart relay
 ip dhcp smart-relay global
NX-OS har stöd för olika Option 82 suboptions när DHCP-paket skickas till DHCP-server.
 ip dhcp relay information option
 ip dhcp relay sub-option type cisco
 ip dhcp relay information option vpn

=Authorized ARP=
Man kan låta DHCP-processen populera ARP-cachen, dvs ta MAC-IP-mappningar från DHCP-databasen. Med Authorized ARP stängs den vanliga dynamiska ARP:n av på interfacen.
 ip dhcp pool NAME
  update arp
 int gi2
  arp authorize
  arp timeout &lt;seconds&gt;

[[Category:Cisco]]</text>
      <sha1>dolu1wrx18qb9e7zs4ov43plxigwlau</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco DMVPN</title>
    <ns>0</ns>
    <id>261</id>
    <revision>
      <id>2929</id>
      <parentid>2604</parentid>
      <timestamp>2019-02-06T15:26:23Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13065">Dynamic Multipoint VPN är en skalbar VPN-teknik som kan bygga tunnlar dynamiskt. Målet är att tillhandahålla any-to-any kommunikation utan att behöva en manuellt konfigurerad full-mesh av point-to-point tunnels. Tekniker som används är [[Cisco_GRE|mGRE]], NHRP och [[Cisco_CEF|CEF]] som används i kombination med routingprotokoll och [[Cisco_IPsec|IPsec]]. Det har bl.a. stöd för [[Cisco_Routing#VRF|VRF]], [[Cisco_Multicast|Multicast]], [[Cisco_QoS|QoS]] och load balancing. Det går köra IPv6 över tunnlar som byggs med IPv4, dvs private address = IPv6, NBMA address = IPv4.

===Topologier===
'''Hub and spoke'''
* single hub single dmvpn
* dual hub dual dmvpn
* server load balancing

'''Dynamic Mesh'''
* dual hub single dmvpn
* multihub single dmvpn
* hierarchical

Varje DMVPN är ett IP-nät och man kan designa det på olika sätt. T.ex. med dual hub single dmvpn så är hub2-router hubb men konfas också som klient till hub1-router. 

==NHRP==
Next Hop Resolution Protocol (RFC 2332). NHRP-processen på hubben agerar server och håller databasen med de externa IP-adresserna som alla spokes har. Varje spoke registrerar sin IP som en klient till hubben. Behöver en spoke skicka paket till något bakom en annan spoke frågar den hubben om den andres externa IP-adress så den kan bygga en tunnel (förslagsvis med IPsec) direkt. För detta krävs alltså inget routingprotokoll utan det sköts av NHRP. Man kan se NHRP som ARP fast det mappar IP till NBMA IP istället för IP till MAC.

NHRP har stöd för autentisering, detta konfigureras under tunnel-interfacet.
 ip nhrp authentication NHRP_AUTH_STRING

&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
Registration request:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_NHRP_Registration_Request.png]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
Registration reply:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_NHRP_Registration_Reply.png]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
Resolution request:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_NHRP_Resolution_Request.png]]
&lt;/div&gt;
&lt;/div&gt;

=Konfiguration=
DMVPN kan fungera på olika sätt och detta kallas olika faser.

==Fas 1==
Hub and Spoke: Med Fas 1 används mGRE på hubb och p2p GRE på spokes. Inga tunnlar sätts upp dynamiskt och all trafik går igenom hubben, enda fördelen är något simplare konfiguration. 

'''Static mapping''' &lt;br/&gt;
Hub
 interface Tunnel0
  ip nhrp map multicast 172.16.15.X
  ip nhrp map 192.168.0.X 172.16.15.X
Spoke
 interface Tunnel0
  ip nhrp map 192.168.0.X 172.16.15.2
  tunnel destination 172.16.15.2

'''Dynamic mapping''' &lt;br/&gt;
Hub
 interface Tunnel0
  ip nhrp map multicast dynamic
Spoke
 interface Tunnel0
  ip nhrp map 192.168.0.1 172.16.15.2
  ip nhrp nhs 192.168.0.1
  tunnel destination 172.16.15.2

Verify
 show dmvpn

==Fas 2==
Hub and Spoke with Spoke-to-Spoke tunnels: Routingprotokollet på spokes lär sig prefix direkt av varandra på tunneln. Forwarding görs spoke-to-spoke, man använder IGP istället för NHRP. Det finns scenarion då CEF kan behövas stängas av på spokes. Med Fas 2 används mGRE. Fas 2 går också att köra som static och då nhrp-mappas alla grannskap manuellt.

Hub
 interface Tunnel0
  ip address 192.168.0.1 255.255.255.0
  ip nhrp map multicast dynamic
  ip nhrp network-id 1
  tunnel source 172.16.15.2
  tunnel mode gre multipoint

Spoke
 interface Tunnel0
  ip address 192.168.0.2 255.255.255.0
  ip nhrp network-id 1
  ip nhrp nhs 192.168.0.1 nbma 172.16.15.2 multicast
  tunnel source 10.10.10.10
  tunnel mode gre multipoint

Verify
 show dmvpn
 show ip nhrp
 show ip nhrp nhs redundancy
 clear ip nhrp
''Kolla ip nhrp registration timeout ifall recovery tar lång tid efter en clear''

==Fas 3==
Scalable Infrastructure: Routingprotokoll på spokes pratar med hubben för att lära sig prefix samt ha som next-hop men NHRP kickar in och redirectar trafiken direkt mellan spokes. Med Fas 3 används mGRE. Det är mest skalbart och CEF behöver aldrig stängas av tack vare NHRP Shortcut eftersom CEF entry skrivs om efter redirect message. Det är inte ett unikt meddelande i sig utan hub skickar vidare resolution request till den spoke som är lämplig. &lt;br/&gt;
Hub: ''ip nhrp redirect'' &lt;br/&gt;
Spoke: ''ip nhrp shortcut'' 

Hub
 interface Tunnel0
  ip address 192.168.0.1 255.255.255.0
  ip nhrp map multicast dynamic
  ip nhrp network-id 1
  '''ip nhrp redirect'''
  tunnel source 172.16.15.2
  tunnel mode gre multipoint

Spoke
 interface Tunnel0
  ip address 192.168.0.2 255.255.255.0
  ip nhrp network-id 1
  ip nhrp nhs 192.168.0.1 nbma 172.16.15.2 multicast
  '''ip nhrp shortcut'''
  tunnel source 10.10.10.10
  tunnel mode gre multipoint

Verify
 show dmvpn
 show ip nhrp
 show ip nhrp nhs redundancy
 clear ip nhrp
''Kolla ip nhrp registration timeout ifall recovery tar lång tid efter en clear''

==IPv6==
Både underlay och overlay kan köras med IPv6. Detta är oberoende av fas.

Hub
 interface Tunnel0
  ipv6 address 192:168:1::1/64
  ipv6 nhrp map multicast dynamic
  ipv6 nhrp network-id 1
  tunnel source 2000:192:168:1::1
  tunnel mode gre multipoint '''ipv6'''

Spoke
 interface Tunnel0
  ipv6 address 192:168:1::2/64
  ipv6 nhrp network-id 1
  ipv6 nhrp nhs 192:168:1::1 nbma 2000:192:168:1::1 multicast
  tunnel source 2000:10:10::10
  tunnel mode gre multipoint '''ipv6'''

Verify
 show dmvpn ipv6
 show ipv6 nhrp 

=IPsec=
Vill man skydda sin trafik kan man kryptera all tunneltrafik. Se även [[Cisco_IPsec|Cisco IPsec]].
 crypto isakmp policy 10
  encryption aes 256
  authentication pre-share
  hash sha512
  group 14
 
 crypto isakmp key SECRET address 0.0.0.0 0.0.0.0
 
 crypto ipsec transform-set AES256_SHA512 esp-sha512-hmac esp-aes 256
  mode transport
 
 crypto ipsec profile DMVPN
  set transform-set AES256_SHA512
 
 interface Tunnel0
  tunnel protection ipsec profile DMVPN

Verify
 show crypto isakmp sa
 show crypto ipsec sa
 show crypto socket
 show crypto map

För att effektivisera krypteringen på en hub när man kör dual dmvpn kan man använda en delad socket för crypto-anslutningarna.
 tunnel protection ipsec profile DMVPN '''shared'''

==GDOI-based DMVPN==
Med vanlig DMVPN sätts det upp en permanent IPsec-tunnel mellan hubb - spoke och dynamiska tunnlar mellan spokes. När en spoke-to-spoke tunnel sätts upp blir det lite delay pga IPSec negotiation, för att slippa det kan man använda GDOI. Då är hubb och spokes Group Members. Group Keys och security policies distribueras till GMs av Key Server som t.ex. kan vara en separat IOS-router bakom hubb. Se även [[Cisco_IPsec#GET_VPN|GET VPN]].

Key Server
 crypto key generate rsa general-keys label GDOI modulus 2048 exportable
 
 crypto isakmp policy 10
  authentication pre-share
 
 crypto isakmp key 0 SECRET address 2.2.2.2
 crypto isakmp key 0 SECRET address 3.3.3.3
 crypto isakmp key 0 SECRET address &lt;next spoke&gt;
 
 crypto ipsec transform-set PHASE2 esp-aes esp-sha-hmac
 
 crypto ipsec profile GDOI_PROFILE
  set transform-set PHASE2
 
 ip access-list extended ACL_GRE
  permit gre any any 
 
 crypto gdoi group GDOI_GROUP
  identity number 123
  server local
   rekey transport unicast
   rekey authentication mypubkey rsa GDOI
   rekey retransmit 60 number 2
   sa ipsec 1
    profile GDOI_PROFILE
    match address ipv4 ACL_GRE
    replay time window-size 5
   address ipv4 1.1.1.1 

Hubb och Spoke
 crypto isakmp policy 10
  authentication pre-share
 
 crypto isakmp key 0 SECRET address 1.1.1.1
 
 crypto gdoi group GDOI
  identity number 123
  server address ipv4 1.1.1.1 
 
 crypto map DMVPN local-address Loopback0
 crypto map DMVPN 10 gdoi
  set group GDOI
 
 interface Gi2
  description Tunnel Source
  crypto map DMVPN

Verify
 show crypto gdoi

=Routingprotokoll=
'''EIGRP''' &lt;br/&gt;
Med Fas 1 kan man antingen stänga av split-horizon eller skicka en default route från hub.

Med EIGRP i Fas 2 måste man stänga av split-horizon och next-hop-self på tunnel-interfacet för att uppdateringar och routing mellan spokes ska funka. Nackdelen är att man inte kan summera routes på hub utan att bryta spoke-to-spoke-kommunikation utan då måste allt gå igenom hub.
 interface Tunnel0
  no ip next-hop-self eigrp 100
  no ip split-horizon eigrp 100

Med fas 3 kommer endast det första paketet att gå via hub tack vare nhrp redirect/shortcut och man kan skicka ut aggregerade routes på hub utan att påverka spoke-to-spoke. Detta är bra design.

'''OSPF''' &lt;br/&gt;
Det går att använda point-to-multipoint på hubbens tunnel-interface och p2p på spoksen bara man ser till att timers matchar. Alternativt kan man köra ''ip ospf network non-broadcast'' på alla. Alternativt ''broadcast'' bara man ser till att hubb är DR. Det man bör ha i åtanke är att beroende på nätverkstyp så ändras next-hop eller ej. OSPF är inget optimalt protokoll för DMVPN.

Hub
 interface Tunnel0
  ip ospf network broadcast
  ip ospf priority 255
Spoke, ska inte vara med i DR-election.
 interface Tunnel0
  ip ospf network broadcast
  ip ospf prio 0

'''BGP''' &lt;br/&gt;
Med Fas 1 och BGP måste next-hop-self användas på alla grannskap.

Fas 2 och BGP-konfiguration är som vanligt men för eBGP mellan spokes måste multihop användas.
 neighbor 2.2.2.2 ebgp-multihop 2

'''RIP''' &lt;br/&gt;
Med Fas 1 och RIP behöver split horizon stängas av på hubb.

=Others=
===Monitoring===
Man kan övervaka sitt DMVPN med hjälp av [[Cisco_SNMP|SNMP]].
 snmp-server enable traps nhrp nhs
 snmp-server enable traps nhrp nhc
 snmp-server enable traps nhrp nhp

När man använder ''if-state nhrp'' på en spoke kan den kolla om NHRP-registreringen fungerar och på så sätt veta om interfacet ska vara up eller ej när man kör fas 2 eller 3. Detta fungerar ej på hub interface för det gör ingen registrering utan är alltid up.
 interface tun0
  if-state nhrp 

På nyare IOS (XE 16.3) kan man även använda [[Cisco_BFD|BFD]] för snabbare feldetektering och NHRP kan då registrera sig som klient till BFD-processen.
 interface Tunnel0
  bfd interval 1000 min_rx 1000 multiplier 5
 
 router eigrp 1
  bfd interface Tunnel0
 
 show nhrp interfaces   #hidden

===NAT===
Man kan köra all sorts nat på spokes men på hubb fungerar endast static nat. Om en spoke befinner sig bakom dynamisk nat, dvs att dennes NBMA-adress kan ändras så kan man stänga av unique flag i NHRP-registreringen. Detta görs med ''ip nhrp registration no-unique'' på spoke vilket gör att den registrerade NBMA-adressen får ändras i efterhand vilket inte är fallet default. Befinner sig två spokes bakom PAT så kommer de ej att kunna upprätta någon spoke-to-spoke tunnel mellan varandra. När man kör NAT med DMVPN så måste IPsec transport mode användas. Se även [[Cisco_NAT|Cisco NAT]].

 interface tun0
  ip nhrp registration no-unique

===VRF===
Man kan bygga det precis som man vill routingmässigt genom att separera underlay och overlay i olika VRF:er (detta kallas också front door VRF). Detta möjliggör t.ex. att ha default route över DMVPN utan att få problem med recursive routing. I övrigt görs konfiguration som vanligt. 

 vrf definition UNDERLAY
  address-family ipv4
  exit
 
 crypto keyring VRF_AWARE_PSK vrf UNDERLAY
  pre-shared-key address 0.0.0.0 0.0.0.0 key DMVPN
 
 interface Tunnel0
  tunnel vrf UNDERLAY

Verify
 show crypto session fvrf UNDERLAY
 show crypto session ivrf 

===MPLS===
Man kan köra [[Cisco_MPLS|MPLS]] över DMVPN och därmed MPLS VPN, detta kallas 2547oDMVPN. Det man ska tänka på är att label switch path måste vara hub-to-spoke, dvs om man vill ha kommunikation mellan två spokes måste det gå spoke-hub-spoke. T.ex. om man kör BGP får man använda ''next-hop-self all'' för att säkerställa att MPLS VPN-trafik alltid går igenom hub. Man förlorar dynamiska tunnlar men man kan ha riktig PE-funkionalitet över DMVPN. 
 mpls ip
 mpls ldp router-id loopback0
 
 interface tunnel0
  mpls ip

===Per-Tunnel QoS===
Med Per-Tunnel QoS feature kan man ha en egress QoS-policy på hubb på tunnelinstansen som man kan konfigurera antingen per endpoint eller per spoke. Detta gör att man kan shapea trafiken till enskilda spokes med en parent policy och sedan skilja på de individuella dataflödena i tunneln med en child policy. Innan man konfigurerar detta måste man ha en fungerande DMVPN-uppsättning.

Class default shaper policy map får endast innehålla class class-default och shape-kommando.
 policy-map Parent1
  class class-default
   shape average 1000000   
    service-policy Child1

Man kan använda NHRP för att bära information om vilken spoke som ska ha vilken QoS-policy. Definiera en NHRP-grupp på spokes och mappa sedan den till en policy på hubb.

Spoke 1
 interface Tunnel0
  ip nhrp group GROUP1
Hub
 interface Tunnel0
  ip nhrp map group GROUP1 service-policy output Parent1
  ip nhrp map group GROUP2 service-policy output Parent2

Verify
 show policy-map multipoint 
 show dmvpn detail
 show tunnel endpoints | i Endpoint|QoS

[[Category:Cisco]]</text>
      <sha1>g47lx60okw6h3lug6vzd1n3mreu7u5c</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco EIGRP</title>
    <ns>0</ns>
    <id>156</id>
    <revision>
      <id>2894</id>
      <parentid>2614</parentid>
      <timestamp>2018-11-16T08:55:38Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="34523">EIGRP är ett avancerat distance vector routingprotokoll. Det är utvecklat av Cisco och har varit helt properitärt men är sedan 2013 släppt, dock bara som Informational RFC. EIGRP använder ett eget IP-protokoll (88) på lager 4, Reliable Transport Protocol. Det finns flera skillnader som gör EIGRP avsevärt mycket bättre än legacy-protokollet IGRP. IGRP stödjer inte VLSM, discontiguous networks, manuell summering eller grannskap. Det kan uppstå routing loopar, konvergerar långsamt och retransmittar inte tappade paket. IGRP fattar inte heller 0.0.0.0/0 som en default route. För topologiuträkningar används DUAL och EIGRP använder både unicast och multicast. Kolla versioner på EIGRP-komponenter: ''show eigrp plugins''

'''Type:''' Distance Vector

'''Algorithm:''' DUAL

'''AD:''' 90, 170

'''Protocols:''' IP

'''Packets:''' 7

==Packets==
EIGRP använder 7 olika typer av RTP-paket för att kommunicera. EIGRP-paket byggs med TLV:er för att göra det flexibelt. Förutom route entries innehåller de även fält för DUAL-processen, multicast-sekvensering och IOS-version.

* '''Hello:''' Skickas till multicast 224.0.0.10/FF02::A var 5:e sekund för keepalive samt innehåller grundläggande info så som AS, IP-nät, K-värden, authentication för att grannskap ska kunna upprättas.

* '''Acknowledgement:''' De flesta typer av paket är viktiga att de kommer fram som de ska, därför finns det en Acknowledgement-mekanism i EIGRP. Följande pakettyper kommer att besvaras med en Ack: Update, Query, Reply, SIA-query och SIA-reply. Pga detta kallas de paketen för Reliable Packets. Acknowledgement skickas alltid med unicast och om det är ett Hello-paket så är det ett tomt Hello som endast innehåller sekvensnumret för Acken. Det går även att skicka med sekvensnumret för acken med andra paket, t.ex. om en router både behöver skicka en uppdatering och acka ett paket kan det göras i samma utskick. Alla paket kan användas för Ack sålänge de är unicast.

* '''Update:''' Under den första fasen i ett grannskap när hela databasen ska utbytas används unicast. Därefter används multicast, förutom på point-to-point och med statiska grannar. Alla Updates ackas.

* '''Query:''' Med Query-paket kan en router ta hjälp av sina grannar för att hitta bästa routen till en destination. Det skickas default ut med multicast på multiaccess-segment. Om en granne inte ackar Queryn kommer Queryn att skickas till den med unicast. Det är även unicast på point-to-point-länkar eller ifall man har manuellt konfigurerade grannar. 

* '''Reply:''' Används som svar på Query-paket och innehåller info om distance till det som har frågats efter.

* '''Stuck-in-Active Query:''' Om en granne tar lång tid på sig att svara på en Reply kan man ta reda på om grannen är död eller jobbar på Replyen genom att skicka en SIA-Query. En SIA-Query kommer alltid att svaras på omedelbart även om det sker routing-omräkningar. 

* '''Stuck-in-Active Reply:''' Ett svar på en SIA-Query kallas SIA-Reply och får man tillbaka ett sånt vet man att grannen lever och då resettas timern för computation, detta ger grannen lite mer tid. Man kan konfigurera hur länge en route kan vara aktiv, default är 3 minuter:
 timers active-time &lt;minutes&gt;
 show eigrp protocols | i Active

Verify
 show ip eigrp traffic

Default får 50% av interfacebandbredden användas för EIGRP-trafik.
 ip bandwidth-percent eigrp 100 50

=Path Selection=
'''Computed Distance:''' den totala metricen för att nå destination via en särskild granne, dvs reported distance från granne plus distance till grannen.

'''Feasible Distance:''' en "notering" av den lägsta kända computed distance sedan routens senaste övergång från Active till Passive. FD behöver med andra ord inte nödvändigtvis vara samma som nuvarande CD. FD har routrarna koll på lokalt för att säkerställa loopfria vägar, det skickas aldrig till någon annan.

'''Advertised/Reported Distance:''' hur långt en granne rapporterar (metric) att det är till en destination router, dvs grannens bästa väg.

'''Feasibility Condition:''' Om FD är satt till t.ex. 2000 så vet routern att någongång fanns det en gångbar och loopfri väg till destination med distance så lågt som 2000. Det betyder att alla grannar som tillhandahöll denna väg måste ha varit ännu närmare destinationen, dvs RD måste ha varit lägre än 2000. Alla grannar som hade distance 2000 eller lägre måste ha varit säkra att använda eftersom de aldrig skulle skicka tillbaka det, varken direkt eller via någon annan. Om RD är mindre än FD så vet man att det är en loopfri väg. Detta är en requirement som måste uppfyllas för att en route ska kunna hamna i routingtabellen.

'''Successor:''' de bästa routesen och som hamnar i routingtabellen. Default är detta de med lägst metric och som uppfyller feasibility condition.

'''Feasible Successor:''' alternativa (inte de bästa) routes som uppfyller feasibility condition. EIGRP får använda dessa men gör inte det default. 

Kolla CD, FD och RD.
 show ip eigrp topology

Kolla grannar som inte uppfyller feasibility condition.
 show ip eigrp topology all-links

===DUAL===
När EIGRP tappar en successor kollas det genast i topologitabellen efter en Feasible Successor. Finns det en blir den successor och det meddelas till övriga grannar. Detta kallas local computation och går fort samt är CPU-snålt. Finns det däremot ingen skickas det ut queries till alla grannar efter alternativa vägar. Routen blir aktiv och detta kallas diffused computation. Har grannen kännedom om en annan path svarar den på queryn men om den inte har det får den i sin tur fråga sina grannar, och så vidare. Om mottagande router inte har några andra grannar att fråga svarar den direkt med metric satt till inifinty. En route är aktiv tills alla har svarat. Det bästa sättet att lösa Stuck-in-Active problem är en strukturerad IP-plan för att kunna summera manuellt så mycket som möjligt. Ju mer summering ju mindre måste EIGRP jobba vid konvergens.
 show ip eigrp topology active

Stuck in active?
 debug eigrp packet terse

Med named mode kan slå graceful restart för stuck-in-active neighbors.
 address-family ipv4 as 100
  soft-sia

==Metrics==
EIGRP använder flera typer av metrics, så kallade ''component metrics''. De klassiska är bandwidth, load, delay, reliability, MTU och hop count. De första fyra kan användas för att räkna fram composite metric aka cost eller distance. 

'''Bandwidth:''' är en statisk metric som sätts per interface med ''bandwidth''-kommandot. Sätter man ingen bandwidth manuellt så kollar routern på vad ethernet har länkat upp i. För att räkna ut bandwidth-metricen till en destination tar man den lägsta bandwidthen längst vägen. Man jämför vad grannen har skickat för bandwidth med ens egen bandwidth till den grannen och använder det lägre värdet till DUAL samt vidareannonsering. På så sätt känner man till den lägsta bandbredden längs vägen. Det är inte rekommenderat att påverka path selection med hjälp av manuell bandwidth-konfiguration i produktionsmiljö!
 interface gi0/3
  bandwidth &lt;kbps&gt;

'''Load:''' är ett dynamiskt värde som IOS sätter på interface. Eftersom ingress och egress kan vara olika lastade hålls två skilda värden för detta. För att räkna på detta till composite metric används högsta Txload, routern jämför värdet den får in med sin Txload på det interfacet och väljer det högre värdet. Det triggas ingen uppdatering ifall load plötsligt skulle ändras. Denna metric används ej default.
 show interface gi0/3 | i load

'''Delay:''' är en statisk metric som sätts per interface med ''delay''-kommandot. Detta är inget som dynamiskt ändras, t.ex. utifrån paketstorlek, utan är en uppskattning av genomsnittlig fördröjning. Sätter man inte detta manuellt så assignar IOS ett värde på varje interface. För att räkna ut totalen till en destination så adderar man värdet man får av sin granne med delayen på interfacet till grannen, dvs all delay längs vägen adderas ihop. Med klassisk metric kan detta ha 1-167772214 tiotal mikrosekunder. 167772215 är infinite distance och med detta kan man annonsera ut unreachable network. Det är så man löser Split Horizon with Poisoned Revered och withdrawing a route, man skickar det med delay 167772215 tiotal mikrosekunder.
 interface gi0/3
  delay &lt;tens of microseconds&gt;
 show interface gi0/3 | i DLY
OBS Output är i microseconds.

'''Reliability:''' är ett dynamiskt värde som IOS sätter på interface. 255 är högsta och betyder 100% reliability. Detta skickas med i EIGRP-paketen och det lägsta värdet är det som gäller till composite metric, dvs man jämför värdet man får in med det man själv har på det interfacet. Dock triggas ingen uppdatering ifall reliability plötsligt skulle ändras. Denna metric används ej default.
 show interface gi0/3 | i reliability

'''MTU''' skickas med i EIGRP-paketen men används ej på något sätt. 

'''Hop Count:''' används som en säkerhetsmekanism. Går hop count över 100 (default) så är det unreachable vilket gör att oändliga loopar ej uppstår. Det används ej på något sätt för path selection eller composite metric.

'''Composite metric''' &lt;br/&gt;
Kolla composite och alla component metrics för ett prefix.
 show ip eigrp topology 10.2.2.0/28 | b Composite
      Composite metric is (130816/128256), route is Internal
      Vector metric:
        Minimum bandwidth is 1000000 Kbit
        Total delay is 5010 microseconds
        Reliability is 255/255
        Load is 1/255
        Minimum MTU is 1500
        Hop count is 1

'''Wide Metrics''' &lt;br/&gt;
Det finns Classic metrics och Wide metrics. De gamla metricen fungerar för hastigheter upp till 1Gbps eftersom då är bandwidth satt till högsta värdet och delay till det lägsta. Detta leder till att classic metrics inte kan skilja på t.ex. 1G och 10G. Wide Metrics löser detta och stöds i Named Mode och om det används är Metric Version = 64bit samt att det finns en K6.
 show ip protocols | i Metric

Eftersom wide metrics kan producera metrics som är större än 32-bitar och RIBen stödjer metrics upp till 32-bitar dividerar man det med 128 innan det hamnar i RIBen samt presenteras av IOS show-kommandon. Detta går att ändra per adressfamilj.
 address-family ...
  metric rib-scale 128

'''Throughput:''' (bandwidth) fungerar på exakt samma sätt men nu är referensbandbredden 655.36 Tbps.

'''Load:''' Samma som classic.

'''Latency:''' (delay) fungerar på samma sätt men nu används picosekunder istället för mikrosekunder.

'''Reliability:''' Samma som classic.

'''MTU:''' Samma som classic.

'''Hop Count:''' Samma som classic.

'''Extended Metrics:''' reserverad för framtida extensions. Finns Jitter, Energy och Quiescent Energy men de används inte. 

'''Computation formula'''
* k1 = bandwidth
* k2 = load
* k3 = delay
* k4 = reliability
* k5 = MTU

Simplified default metric, legacy = 256 * (10^7/bandwidth + delay/10) &lt;br/&gt;
Simplified default metric, wide = 65536 * (10^7/bandwidth + delay/1000000)
 show eigrp protocols | i Metric

Ändra vilka metrics som ska användas för EIGRP-processen
 metric weights 0 1 0 1 0 0

=Konfiguration=
Ändrar man AD kommer alla grannskap att droppas och sättas upp på nytt.
 router eigrp 100
  distance eigrp 90 170
Logging av neighbor changes är på default
 show ip eigrp events type

Modernare konfigurationsformat
  eigrp upgrade-cli

'''Router ID''' &lt;br/&gt;
Alla EIGRP-instanser måste ha ett router id, dock kan flera processer ha samma 32 bitars nummer (till skillnad från OSPF). Från början användes RID för att förhindra routingloopar vid multipoint redistribution eftersom man skickar med sin RID med de externa routes som man annonserar in i EIGRP och på så sätt identifierar det originating router. Har alla redistributionsroutrar samma RID blir det ingen loop eftersom om man får in en route med samma RID som man själv har discardas den. Numera används det också för intern EIGRP och man kan alltid se Originating router på alla prefix. 

ID väljs enligt följande ordning och interfacen behöver inte vara nåbara eller ha något med EIGRP att göra utan alla interface jämförs.
# router-id kommandot
# Högsta IP-adressen på ett no-shut loopback interface 
# Högsta IP-adressen på ett no-shut interface

ID ändras endast när processen startas om eller router-id-kommandot körs men alla grannskap resettas vid RID-byte.
 show eigrp protocols | i Router-ID

Kolla om routes droppas pga duplicate RID
 show eigrp address-family ipv4 events

Debug
 debug eigrp packets hello
 debug eigrp fsm

==Adjacency==
EIGRP upptäcker grannar dynamiskt och AS, K-values och authentication måste matcha. Så fort man slår på EIGRP på ett interface börjar det skickas Hello-paket till multicast 224.0.0.10/FF02::A var 5:e sekund. Så fort ett Hello har tagits emot sätts grannen i pending state för att man inte ska acceptera routing-uppdateringar innan man är säker på att det finns bidirectional connectivity. Om det finns en EIGRP-router på andra sidan kommer den att svara med ett Hello, sedan skickas en null update som har satt initialization bit för att signalera att dra igång initialization process. Då kommer en null update med init bit skickas tillbaka som även ackar den första. När sedan den andra updaten har ackats går grannskapet till "Up" och databassynkroniseringen drar igång. När den är klar kommer endast inkrementella uppdateringar att skickas i fortsättningen. log-neighbor-changes är påslaget default.

Interface vars IP-adress träffas av network-kommandot blir EIGRP-enabled.
 network [ip-address] [wildcard-mask]
Designate passive interfaces. Passive interfaces stoppar grannskap och därmed inlärning av routes.
 passive-interface default
 no passive-interface gi2
 show ip eigrp interfaces detail

Det går även att ändra timers per interface. Hold time säger hur länge en router maximalt ska vänta mellan två EIGRP-paket från en granne. Kommer inget paket blir grannen unreachable och DUAL informeras. Default är denna tid tre gånger Hello interval, dvs 15 eller 180 sekunder beroende på interfacetyp. Hold time ändras dock inte automatiskt ifall man ändrar Hello time. Notera att detta inte är en inställning som används lokalt utan ett "advertised value", om man sätter hold time lägre än hello time kommer grannar att flappa.

 int gi0/0
  ip hello-interval eigrp 100 &lt;sekunder&gt; 
  ip hold-time eigrp 100 &lt;sekunder&gt;
 show ip eigrp 100 interfaces detail | i time

Vissa nätverk stödjer inte broadcast eller multicast då måste man manuellt konfigurera grannar och unicast används. När man konfigurerar en granne så disableas multicast på det interfacet som används för unicasten. Det går därför inte att kombinera unicast- och multicastgrannskap på ett delat segment.  
 router eigrp 10
  neighbor 10.0.1.1 gi0/0 

'''Verify'''
 show ip eigrp neighbor

Outputen innehåller flera tal.
* H (Handle): lokalt löpnummer för grannar.
* SRTT (Smooth Round Trip Time): tid det tar att få tillbaka en ACK från granne, i millisekunder.
* RTO (Retransmit Time Out): hur länge eigrp väntar på ack innan ett paket i kön skickas om, i millisekunder. Efter 16 omskickade paket utan ack blir det RETRY LIMIT EXCEEDED.
* Q Cnt Num: paket som inte har ackats hamnar i kön. Detta är 0 i ett stabilt nätverk.

Om en router skickar en multicast-uppdatering som inte ackas av någon kommer den att vänta RTO och sedan skicka en sequence TLV som instruerar den routern att inte lyssna efter multicast-paket mer. Sedan skickar den allt med unicast till den grannen tills den har ackat ifatt och då skickas återigen en sequence TLV som säger att den ska lyssna på multicast igen.

Route hold-timer bestämmer hur länge NSF-routrar som kör EIGRP ska hålla routes för inaktiva grannar.
 timers graceful-restart purge-time 60

===Authentication===
MD5 authentication måste matcha för grannskap. Med Named mode finns även stöd för SHA-256. 
 interface [interface]
  ip authentication mode eigrp md5
  ip authentication key-chain eigrp [ASN] [name-of-chain]

'''Key rotation''' &lt;br/&gt;
Key chain kan innehålla flera nycklar men endast lägsta aktiva nyckeln används i EIGRP Hellos, Key ID måste därmed matcha.
 key chain ROTATION
  key 10
   key-string CISCO10
   accept-lifetime 00:00:00 Jan 1 1993 00:15:00 Jan 1 2030
   send-lifetime 00:00:00 Jan 1 1993 00:05:00 Jan 1 2030
  key 20
   key-string CISCO20
   accept-lifetime 00:00:00 Jan 1 2030 infinite
   send-lifetime 00:00:00 Jan 1 2030 infinite
 
 show key chain

===Troubleshoot===
* Uncommon subnet: de sitter inte i samma subnät.
* K value mismatch: måste vara samma på båda sidor.
* AS mismatch: måste vara samma på båda sidor.
* Layer 2 issues.
* Access-list issues.
* NBMA. 
* Authentication issues.
* Secondary addresses. 
 ping 224.0.0.10
Subnet mask behöver inte matcha för att grannskap ska bildas men däremot blir topologitabellen felaktig vilket kan ställa till det routingmässigt.

Clearing routing process. Behöver göras vid t.ex. byten av K-values.
 clear ip eigrp neighbors

==Unequal-Cost Load Balancing==
Att det är möjligt med unequal-cost LB i EIGRP är pga att det finns feasible successors. De har inte bästa vägen till destination men de är garanterat loopfria. Variance multiplicerat med lowest metric blir gränsen för hur dålig metricen får vara för att pathen ändå ska kunna användas för load-sharing. Dvs variance säger hur många gånger sämre en path får vara för att användas. För att ta reda på andelen trafik som går över en viss länk måste man räkna högsta installerade metricen delat med metricen på alla paths som används för närvarande och skriva ihop dem för att få respektive andel. 
 router eigrp 100
  variance &lt;multiplier&gt;
  maximum-paths 4  #Max är 32
  traffic-share balanced
Default är variance 1 och det betyder equal-cost load balancing. Det går även begränsa antalet parallella paths som används. Använd ''traffic-share balanced'' (som är default) annars blir det equal-cost LB ändå.
 show ip protocols | i Maximum
Verifiera per IP
 show ip route 90.0.0.1 | i share

=Summarization=
Man kan manuellt aggregera routes var som helst eftersom EIGRP är ett distance vector routingprotokoll (''auto-summary'' är avstängt default sedan IOS 15 och bör aldrig användas). När en summary route annonseras ut måste den finnas i routingtabellen för att undvika att det forwarderas trafik för destinationer i summeringen som det inte finns någon mer specifik route för så det skapas automatiskt en null route med AD 5. Denna distance går att ändra i named mode med summary-metric under topology base men sätt ej 255 då kommer inget att annonseras ut om inte samma route
kommer ifrån någon annan källa. Detta går därmed att nyttja som conditional advertisment. För metric till summary route väljs den lägsta metricen bland component routsen som ingår i summaryn. Försvinner den component routen måste alla gås igenom igen för att välja en ny och skicka ut, detta kan vara CPU-intensivt ifall det finns många component routes. För att undvika detta kan man ställa en fast metric på varje summary, detta görs under topology base med summary-metric också. 

Summarization med EIGRP innebär en gräns för Queries eftersom en granne till en router som summerar inte känner till de mer specifika näten och när en router får in en Query för ett nät som inte finns i topologitabellen så skickas det direkt tillbaka en Reply med unreachable. Detta gör att en Query aldrig floodas vidare vilket leder till att load och konvergeringstid minskar. En Query modifieras inte heller någonstans.

Eftersom det är ett distance vector routingprotokoll görs summary per interface. ''Classic mode''
 interface gi2
  ip summary-address eigrp 100 192.168.0.0 255.255.0.0

'''Leak-map'''
 access-list 1 permit 192.168.2.0 0.0.0.0
 route-map LEAK permit 10
  match ip address 1
 int gi2
  ip summary-address eigrp 100 192.168.0.0 255.255.0.0 leak-map LEAK
Finns det ingen route-map än som heter LEAK kommer endast summeringen att annonseras.

Verify
 show ip protocols | s Summ
 show ip route eigrp | i Null

'''Poisoned Floating Summarization'''
 router eigrp 100
  summary-metric 10.1.0.0/23 distance 255

===Default route===
Annonsera en default route ut på ett interface, inget annat kommer att skickas på detta interface.
 interface gi2
  ip summary-address eigrp 100 0.0.0.0 0.0.0.0

Acceptera default routing information, detta är på default.
 default-information allowed

Acceptera endast default route från specifik källa
 access-list 6 permit 10.0.0.0
 router eigrp 100
  default-information in 6
Skicka ej default route
 no default-information allowed out

Legacy
 router eigrp 100
  network 10.0.0.0
  ip default-network 10.0.0.0

=Convergence=
Optimization &amp; Scalability. Detecting, notifying, calculating and installing new routes.

===Stub Routing===
Stub routing är designat för att göra EIGRP mer skalbart och stabilt. Det används vanligtvis i hub-and-spoke topologier och konfigureras endast på spokes. Då kommer spoke att lägga till en ny TLV i Hello-paketen som säger stub router status. Det gör att spoken aldrig kommer att annonsera ut något som den lär sig av någon EIGRP-granne för att inte kunna riskera att bli Feasible Successor för något nätverk. Det enda den annonserar ut är det man specificerar. I och med att grannarna till en stub känner till att den är en stub router kommer de aldrig att skicka EIGRP-Queries. Men en stub router skickar ut Queries som vanligt. Det kan dock komma in Queries ändå, t.ex. en gammal IOS-enhet som inte känner till stub kommer fortfarande skicka Queries eller om alla routrar på ett segment är stub kommer det att skickas Queries som om ingen var stub. När en Query kommer in behandlas den som vanligt om det som Queryn handlar om faller inom det som är tillåtet för stub routern. Gör det inte det så kommer det ändå att besvaras men med infinite metric oavsett om routern känner till nätverket eller ej. Har man ett mixat segment kommer EIGRP endast att skicka Queries till icke-stubs antingen genom att unicasta till icke-stubs eller så kommer Conditional Receive mode användas, det beror på antalet icke-stubs på segmentet. 

Fördelar med Stub är att man undviker suboptimal routing i hub-and-spoke topologier, routrar med dålig bandbredd blir aldrig transit router och antalet Queries reduceras vilket leder till snabbare konvergens och mindre SIA. Defualt för stub är (CONNECTED SUMMARY ) och grannskap resettas vid omkonfiguration. 
 router eigrp 100
  eigrp stub ?
     connected   
     receive-only 
     redistributed 
     static  
     summary 
Undantag läggs med en leak-map. Man får hålla koll på route-aggregeringar när man kör stub för de mer specifika routsen annonseras default.
  router eigrp 100
   eigrp stub leak-map ''NAME''
Verify
 show ip protocols | i EIGRP|Stub
 show eigrp address-family ipv4 100 neighbors detail | i Stub
 show ip eigrp neighbors detail

===Fast Reroute===
EIGRP använder DUAL för att räkna fram successors och feasible successors där successor används som primary path och feasible successors som repair paths eller LFAs. EIGRP har alltid haft backup paths för snabb konvergens men det LFA FRR ger är en möjlighet att styra vilka backup paths som ska användas, detta kan göras per primary path per prefix. Man kan t.ex. sätta regler för att inte använda LFAs där outgoing interface, linecard eller SRLG är samma. EIGRP använder alltid prefix-based LFAs.

''Named mode only''
 address-family ipv4 unicast autonomous-system 100
  topology base
   fast-reroute per-prefix all
ECMP använder alla equal cost paths men för att kontrollera vilka LFAs som används kan man stänga av load-sharing och istället låta FRR använda tie-breaking rules.
  fast-reroute load-sharing disable
  fast-reroute tie-break linecard-disjoint 2
Verify
 show ip eigrp topology frr 

===BFD===
Se [[Cisco_BFD|BFD]]
 router eigrp 100
  bfd interface gi2   #Enable BFD on specific interface
  bfd all-interfaces  #Enable BFD on all interfaces

=Filtering=
Med EIGRP går det att filtrera routes på många olika sätt. T.ex. kan router-id användas för att filtrera bort routes från en viss granne. När man applyar en distribute-list under EIGRP-processen skickas en ROUTE FILTER CHANGED och grannskapet resettas för att topologitabellen ska synkas om.

===Prefix-Lists===
 ip prefix-list FILTER seq 5 deny 172.16.10.0/24
 ip prefix-list FILTER seq 10 permit 0.0.0.0/0 le 32
 router eigrp 100
  distribute-list prefix FILTER in
Det går även använda prefix-listor för att filtrera på neighbor (gateway).

===ACL===
Standard
 access-list 3 deny 30.0.0.0
 access-list 3 permit any
 router eigrp 100
  distribute-list 3 in gi0/0
Extended
 access-list 103 deny ip host 10.0.0.10 host 172.20.1.0
 access-list 103 deny ip host &lt;next-hop&gt; host &lt;prefix&gt;
 access-list 103 permit ip any any
 router eigrp 100
  distribute-list 103 in gi0/0

===Administrative Distance===
Per prefix filtering med AD (255 = UNKNOWN)
 access-list 7 permit 20.0.0.0
 router eigrp 100
  distance 255 0.0.0.0 255.255.255.255 7
''Träffar alla grannar''

AD för internal routes går att ändra per prefix men ej external.

===Route Map===
Med route-maps kan man matcha på metrics, tags och acler.
 route-map RM deny 10
  match tag 4
 route-map RM permit 20
 router eigrp 100
  distribute-list route-map RM in

===Prefix Limit===
Per process
 maximum-prefix 1000
Max antal prefix från granne.
 neighbor 10.0.1.1 maximum-prefix 100

'''Övrigt''' &lt;br/&gt;
Ändra hop-count limit. Prefix med högre hop-count kommer att filtreras ut.
 metric maximum-hops 2

Med Offset Lists kan man addera metric (Delay) när routes kommer in eller skickas ut. Det fungerar med EIGRP men är inte rekommenderat pga komplexiteten hos EIGRPs metric, det finns andra enklare sätt att manipulera routes.

=Redistribution=
För redistribution måste man sätta en seed metric eftersom default är infinity. Man kan sätta samma router-id på två EIGRP-routrar för att blockera ut externa routes vid redistribution för att undvika loopar.
 router eigrp 100
  default-metric 1000000 10 255 1 1500

'''Static''' &lt;br/&gt;
Med static och connected behövs ingen seed metric.
 redistribute static
'''[[Cisco_RIP|RIP]]'''
 redistribute rip metric 1500 100 255 1 1500
'''[[Cisco_OSPF|OSPF]]'''
 redistribute ospf 1

Route flapping kan upptäckas genom att kolla events, 500 lines hålls i minnet.
 show ip eigrp events

Route-tag notation dotted decimal
 eigrp default-route-tag  #internal only
 show route-tag list

'''Wide metrics''' &lt;br/&gt;
När man kör named mode måste man tänka på vilken metric man sätter när man redistribuerar. Följande exempel kommer inte att fungera eftersom named mode använder wide metrics och då kommer denna redistribution resultera i infinity metric och inget kommer att annonseras i EIGRP, utan man måste sätta något mer realistiskt. 
 redistribute ospf 1 metric 1 1 1 1 1

=EIGRPv6=
Det finns några skillnader mot klassiska IPv4-EIGRP värda att notera. Man måste no shuta EIGRP-processen för att den ska starta. Default route kan endast annonseras med hjälp summarization eller redistribution. Unequal-cost load balancing stöds för närvarande inte med IPv6 EIGRP pga [[Cisco_CEF|CEF]]-begränsningar. Defualt så sätter routern alltid sig själv som next-hop, även när routes annonseras ut på samma interface som de kom in på, detta går att stänga av med ''no ipv6 next-hop-self eigrp''.
 ipv6 unicast-routing
 ipv6 router eigrp 1
  eigrp router-id 2.2.2.2
  maximum-paths 16  #Max är 32
  no shutdown
Per interface
 interface gi2 
  no ip address  
  ipv6 address 2001::2/64  
  ipv6 eigrp 1
 
  ipv6 authentication mode eigrp 1 md5
  ipv6 authentication key-chain eigrp 1 EIGRPV6
  ipv6 summary-address eigrp 1 2001::/64 leak-map LEAKS
''leak-map för IPv6 summary är en relativt ny feature''

Verify, finns både gammal och ny syntax för show-kommandona.
 show ipv6 route eigrp
 show ipv6 eigrp interfaces
 show ipv6 eigrp 100 interfaces detail | i Hello|Split|Authentication
 
 show eigrp address-family ipv6 neighbors
 show eigrp address-family ipv6 topology

=Named mode=
Om IOS stödjer Named Mode är det rekommenderat att använda det (IOS fr.o.m. 15.0(1)M). Detta ändrar inte på något sätt hur EIGRP fungerar (förutom wide metrics!) utan är endast ett annat mer konsekvent sätt att konfigurera det på. Man kan på samma router ha Classic och Named EIGRP-instanser samtidigt. Alla kommandon läggs nu under ''router eigrp &lt;namn&gt;'', även sånt som förut låg på interfacen t.ex. timers, summarization och Split Horizon. Lägger man EIGRP-konfiguration på interfacen kommer den att ignoreras. EIGRP använder automatiskt wide metrics om andra sidan också kör named mode. 

Konfigurationen är uppdelad i tre sektioner.

'''Address Family section'''
 router eigrp HACKER
  address-family ipv4 unicast autonomous-system 100
   eigrp router-id 1.1.1.1
   network 10.0.0.0 0.0.0.255
 
  address-family ipv4 unicast vrf EXAMPLE autonomous-system 101
   eigrp router-id 1.1.20.1
   network 10.0.20.0 0.0.0.255
OBS med ''address-family ipv6 unicast'' så enableas alla ipv6-interface för EIGRP automatiskt.

'''Per-AF-interface section'''
  af-interface default
   passive-interface
   bfd
  exit-af-interface
  !
  af-interface Gi3
   no passive-interface
   authentication mode hmac-sha-256 SECRET_KEY
   summary-address 10.10.0.0/24
  exit-af-interface

'''Per-AF-topology section''' &lt;br/&gt;
Base är det som finns om man inte slår på Multi Topology Routing.
  topology base
   redistribute connected
   distance eigrp 90 170
  exit-af-topology

Automagically convert classic EIGRP configuration into Named EIGRP configuration.
 eigrp upgrade-cli

Show commands har också ny syntax
 show eigrp address-family ipv4 ?

Man kan också tagga routes. För att ändra format finns den globala inställningen: '''route-tag notation dotted-decimal'''
 eigrp default-route-tag 1.2.3.4

===Add-Path===
Fr.o.m. IOS 15.3(2)T har EIGRP stöd för tillägget Add-Path som låter en router skicka ut uppdateringar som innehåller flera equal-cost vägar till samma destination. Detta är användbart i [[Cisco_DMVPN|DMVPN]]-setuper där flera branch offices är dual homed. För att kunna skicka ut multipla routes måste de finnas i routingtabellen samt att Split Horizon är avstängt på multipoint tunnel-interfacet mot alla spokes. 

Detta går bara att konfigurera i named mode och sätts per interface.
 af-interface Tunnel0
  no split-horizon 
  no next-hop-self
  add-paths &lt;1-4&gt;
 exit-af-interface
 
 topology base
  variance 1
  maximum-paths 4 
 exit-af-topology
Maximum-paths måste vara satt till samma eller högre än add-paths annars kommer det inte att finnas fler equal-cost routes i routingtabellen. Next-hop-self måste deaktiveras annars kommer alla routes som annonseras ha samma next-hop. Detta är inte kompatibelt med Unequal Cost LB utan variance måste vara satt till 1. Spokes behöver inte konfigurera någonting annat än maximum-paths.

 no-ecmp-mode
Är rekommenderat om huben använder flera tunnel-interface för att nå spokes.

===IPv6 VRF-Lite===
EIGRP IPv6 [[Cisco_Routing#VRF|VRF-Lite]] är endast tillgängligt med Named configurations. 
 vrf definition VRF1
  rd 100:1
  address-family ipv6
  exit
 
 router eigrp MULTI
  address-family ipv6 vrf VRF1 autonomous-system 200

=Over the ToP=
EIGRP Over the ToP (OTP) gör att man kan skapa multipoint overlay VPN:er över vanlig L3/L3 VPN. Nyckeln är att [[Cisco_LISP|LISP]]-enkapsulering (UDP port 4343) används men EIGRP används för control plane istället för LISPs vanliga mapping service. Man uppnår en del liknande funktionalitet som med [[Cisco_DMVPN|DMVPN]] men det fungerar inte på samma sätt. Om man kör OTP över MPLS VPN behöver man inte köra någon dynamisk routing med Provider däremot måste alla CE kunna nå varandra. OTP-trafik kan krypteras med [[Cisco_IPsec#GET_VPN|GET VPN]]. Eftersom grannskap måste konfigureras manuellt blir det omständigt när miljön växer lite. Detta har lett till att man tagit fram Route Reflector även för EIGRP, som ger samma funktionalitet som i BGP. 

Man konfigurerar ip, max-hops och lisp-id.
 neighbor 1.1.1.1 Gi2 remote 10 lisp-encap 1 
Verify and show OTP learned routes
 show interface lisp 1
 show ip route eigrp | i LISP

Route Reflector har en listen feature (likt BGP) som kan använda sig av en ACL för att begränsa vilka som får ansluta. På route reflector bör även split-horizon och next-hop-self stängas av.
 remote-neighbors source gigabitethernet 0/1 unicast-listen lisp-encap allow-list ''ACL''

===VRF Support===
Man kan även köra OTP i default vrf:en och låta EIGRP bära info om flera vrf:er. Man binder dem till ett Topology ID. Detta fungerar även på RR. Alla grannskap etableras i en enskild EIGRP-process. En process hanterar multipla, separata grannskap i olika vrf:er på lan-sidan samtidigt som det har grannskap på wan-sidan med OTP peers. Mottagande peer väljer routes till de olika topologierna som finns lokalt och routes för andra topologier droppas. LISP Id (LISP Instance ID) mappas till VRF och TID. Eftersom LISP bär paket för olika vrf:er på olika virtuella LISP-interface måste LISP ID per vrf vara unikt men samma på alla CE devices där vrf:en finns.

 router eigrp AF
  address-family ipv4 autonomous-system 10
   topology vrf vrf1 tid 10 lisp-instance-id 122
 
   topology vrf vrf2 tid 11 lisp-instance-id 123

=NX-OS=
Här följer Nexus-specifik syntax. Några grundläggande skillnader mot IOS är att det saknas stöd för UCMP och unicast neighbors. Default väljer NX-OS Lo0 som Router-ID. Har man ingen manuellt satt RID och konfar Lo0 så kommer EIGRP direkt att byta till Lo0 och processen startas om.
 feature eigrp
 
 router eigrp 1
  log-adjacency-changes
  autonomous-system 100
  bfd
 
 interface loopback0
  ip router eigrp 1
 
 interface Ethernet1/1
  ip router eigrp 1
  ipv6 router eigrp 1

Maintenance mode
 router eigrp 1
  isolate
Verify
 show run eigrp
 show ip eigrp neighbors

[[Category:Cisco]]</text>
      <sha1>hzyqjtozcyj1xej4l6xjikyuzkfnnwe</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco EVPN</title>
    <ns>0</ns>
    <id>514</id>
    <revision>
      <id>2997</id>
      <parentid>2961</parentid>
      <timestamp>2019-08-21T08:13:57Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="20805">Ethernet VPN (RFC 8365) är en modernare variant än [[Cisco_VPLS|VPLS]] för att tillhandahålla Ethernet multipoint services över IP ([[Cisco_VXLAN|VXLAN]]) eller [[Cisco_MPLS|MPLS]] (RFC 7432) utan att behöva en central controller. EVPN är en adressfamilj i [[Cisco_BGP|BGP]] som används för peer discovery och för att distribuera lokala MAC-adresser och MAC/IP bindings till andra tunnel endpoints. Man använder både L2 och L3 forwarding information och det fungerar ihop med externa IP-prefix. Next-hop i EVPN-uppdateringarna är antingen egress Label Switch Router eller VXLAN Tunnel Endpoint. EVPN skalar bra och har bl.a. features för att hålla koll på hostar som flyttar mellan datacenter (sekvensnummer-community i annonseringarna) och kan då konvergera snabbt. Ett EVPN-nätverk kan göra både bridging och routing och har inbyggd support för multi-tenancy (VPN). [[Cisco_DHCP#Snooping|DHCP Snooping]] supporteras inte på VXLAN VLAN.

EVPN är ett öppet protokoll så det finns interoperability med andra network vendors, se t.ex. [[Arista_EVPN|Arista]], [[Cumulus_EVPN|Cumulus]] och [[Quagga#EVPN|Quagga]] EVPN. 

'''Route types'''&lt;br/&gt;
# Ethernet Auto-Discovery Route
# MAC/IP Advertisement Route
# Inclusive Multicast Ethernet Tag Route
# Ethernet Segment Route
# IP Prefix Route


'''Type 5 Routes format''' &lt;br/&gt; 
{| class="wikitable"
| '''Encapsulation:'''
| '''MPLS'''
| '''VXLAN'''
|-
| RT-5 Route:
| IP Prefix
| IP Prefix
|-
| RD:
| L3 RD
| L3 RD
|-
| IP Length:
| prefix length
| prefix length
|-
| IP Address:
| IP
| IP
|-
| Label:
| BGP MPLS Label
| L3VNI
|-
| Ext Communities:
| RT for IP-VRF
| RT for IP-VRF, Tunnel Type VxLAN, Router MAC
|-
|}

=Underlay=
Underlay routing kan göras med IGP, iBGP eller eBGP. Alla VTEP:s måste kunna nå varandra med jumbo frames. Alla hårdvaruplattformar har inte stöd för Head-end Replication (aka Ingress Replication) för att lösa tenant BUM så t.ex. med Nexus 5k måste man även köra PIM Bidir i underlay. Notera att IGP-annonsering av NVE loopback address efter boot default kommer att suppressas under 300 sekunder för att overlay ska hinna konvergera. Detta går att ställa in under interface nve 1.

Simpelt NX-OS exempel
 feature ospf
 
 interface loopback0
  description VTEP
  ip address 1.1.1.1/32
  ip router ospf 1 area 0
 
 interface Ethernet1/1
  description Uplink
  no switchport
  medium p2p
  mtu 9216
  ip address 10.0.2.2/30
  no shutdown
  ip router ospf 1 area 0
Det går även köra upplänkarna IP unnumbered.

=Overlay=
EVPN-peering för DC VXLAN-overlay kan göras både med iBGP och eBGP, det är designen som avgör. 

Konfig för leafs oavsett iBGP eller eBGP overlay.
 feature bgp
 feature vn-segment-vlan-based
 feature nv overlay
 nv overlay evpn
 
 interface nve1
  no shutdown
  host-reachability protocol bgp
  source-interface loopback0

===IBGP===
Den simplaste EVPN fabricen är IBGP overlay med IGP underlay. 

 router bgp 65000
  address-family l2vpn evpn
  neighbor 2.2.2.2
   remote-as 65000
   update-source loopback0
   address-family l2vpn evpn
     send-community
     send-community extended

'''Route Reflector''' &lt;br/&gt;
Precis som med övriga adressfamiljer kan man med hjälp av route reflector öka skalbarhet och förenkla konfigurationen. Spine-switchar kan t.ex. stå för denna roll i en IBGP EVPN setup. 

 router bgp 65000
  address-family l2vpn evpn
  neighbor 1.1.1.0/24
    remote-as 65000
    update-source loopback0
    address-family l2vpn evpn
      send-community extended
      route-reflector-client

===EBGP===
Om man bygger sin fabric med EBGP EVPN så måste next-hop-unchanged konfas på spines peeringar mot leaf. Om man kör med autoderiverade RTs måste man skriva om dem innan de når leaf samt att spine switches inte har någon VRF-konfig så man måste slå på retain route-target.

 route-map NH-Unchanged permit 10
  set ip next-hop unchanged
 
 router bgp 65000 
   address-family l2vpn evpn
     retain route-target all
   neighbor 1.1.1.0/24
     remote-as 65001  
     address-family l2vpn evpn
       route-map NH-Unchanged out
       rewrite-evpn-rt-asn

'''All leaf same ASN''' &lt;br/&gt;
Spine
 router bgp 65000
  neighbor 1.1.1.1 remote-as 65001
   address-family l2vpn evpn
    disable-peer-as-check
Leaf
 router bgp 65001
  neighbor 2.2.2.2 remote-as 65000
   address-family l2vpn evpn
    allowas-in

===Verify Overlay===
 show nve int nve1
 show nve peers detail
 show bgp l2vpn evpn summary
 show nve internal platform interface nve 1 detail 

==Bridging==
På varje leaf switch mappas local VLAN till ett VNI (VLAN-based mode).
 vlan 100
  vn-segment 10100
 vlan 101
  vn-segment 10101

&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
VLAN modes:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco-EVPN-VLAN-mode.PNG]]
&lt;/div&gt;
&lt;/div&gt;

HER mha EVPN route typ 3
 interface nve1
  member vni 10100
    ingress-replication protocol bgp
  member vni 10101
    ingress-replication protocol bgp

RD och RT för bridging. RT-import/export görs automatiskt utifrån ASN och VNI.
 evpn 
  vni 10100 l2 
   rd auto 
   route-target import auto 
   route-target export auto
   exit
  vni 10101 l2 
   rd auto 
   route-target import auto 
   route-target export auto
   exit

Verify
 show nve vni
 show nve peers data-plane detail
 show l2route evpn mac-ip all
 show forwarding nve l3 peers
 show mac address-table
 show system internal l2fwder mac     #Nexus 9000v

===vPC===
Om man kör [[Nexus_vPC|vPC]] får man sätta upp sina VTEP-interface (loopback) med dubbla IP-adresser där secondary IP address används för all VXLAN-trafik. Secondary ska vara samma på både vPC-peers och det är så dom presenterar sig själva som en enda VTEP till remote NVE peers. CFS dubbelkollar att man har gjort rätt. Sista oktetten i loopbacks primära IP-adress används för att generera RMAC när man kör vPC. Varje vPC-peer har separata BGP-sessioner till spine. I övrigt måste de ha identisk konfiguration när det gäller VLAN, VNI och NVE (''show vpc consistency-parameters vni'').

 interface loopback0
  ip address 100.0.0.11/32
  ip address 100.0.0.100/32 secondary

vPC Domain best practice när man kör EVPN.
 vpc domain 1
  peer-switch
  peer-keepalive destination 10.0.0.2 source 10.0.0.1
  peer-gateway
  ipv6 nd synchronize
  ip arp synchronize

'''vPC Fabric Peering''' &lt;br/&gt;
I nyare NX-OS på N9k behövs ingen fysisk peer-link längre utan man kan köra CFSoIP över fabricen, detta sparar portar och kallas vPC Fabric Peering. Data plane traffic görs över en VXLAN-tunnel. Man berättar för switchen vilka som är fabric-länkar och dessa trackas då.

 hardware access-list tcam region in-flow-redirect 512
 vpc domain 1
  peer-keepalive destination 10.0.0.2 source 10.0.0.1
  virtual peer-link destination 10.0.10.2 source 10.0.10.1/32 
  peer-switch
  peer-gateway
  ip arp synchronize
  ipv6 nd synchronize

Verify
 show vpc
 show vpc fabric-ports
 show vpc virtual-peerlink vlan consistency

'''advertise-pip''' &lt;br/&gt;
Default annonseras alla Layer-3 routes med secondary IP address (VIP) på VTEP. Prefix routes och leaf switch generated routes synkas ej mellan vPC leaf switches. Om t.ex. vPC-switch och dennes peer har asymmetric external Layer-3 connections och vissa routes endast är nåbara via den ena eller om man ska agera [[Cisco_DHCP#Relay|DHCP Relay]] åt tenants så kan traffic blackholing uppstå med default beteendet. Man kan därför konfa att route type 5 routes ska annonseras med primary IP address så det blir next-hop för fabricen. 

 router bgp 65000
  address-family l2vpn evpn
   advertise-pip

'''Backup routing''' &lt;br/&gt;
Om den ena vPC-peeren tappar sina upplänkar till spine och man inte har någon backup routing så uppstår traffic blackholing. Detta kan man motverka genom att bygga en backup-väg över peer-linken till den andra peeren.
 vlan 99
 
 interface vlan99
  ip address 10.99.99.1/30
  ip router ospf 1 area 0.0.0.0
  ip pim sparse-mode

Nexus 5600
 vpc nve peer-link-vlan 99

===BD-oriented mode===
I VLAN-based mode är VNI-to-VLAN mapping switch wide men om man lägger in bridge domains emellan så kan man uppnå att VNI-to-VLAN mapping endast är port wide. Dvs man kan använda samma 802.1Q tag på flera portar men de är mappade till olika VNI:er. Konfen ser lite annorlunda ut men både bridging och routing funkar.

Nexus 7k
 feature vni
 feature-set fabric
 feature fabric forwarding
 
 vni 10000
 
 system bridge-domain 100
 bridge-domain 100
  member vni 10000
 
 encapsulation profile vni Tenant1-101
  dot1q 101 vni 10000
 
 interface e2/1
  no switchport
  service instance 1 vni
   no shutdown
   encapsulation profile Tenant1-101 default
 
 interface Bdi 100
  vrf member Tenant1
  ip address 10.0.0.1/24

==Routing==
NX-OS gör endast symmetric vxlan routing, dvs EVPN-routes har både L2VNI och L3VNI. Man anger NVE overlay VLAN:s. Dessa ska ej användas som vanliga VLAN.
 system vlan nve-overlay id 3001-3200

RT-import och export görs automatiskt utifrån ASN och VNI.
 vrf context Tenant1
  vni 30001
  rd auto
  address-family ipv4 unicast
   route-target both auto
   route-target both auto evpn

Varje tenant VRF behöver ett VRF overlay VLAN och ett SVI för VXLAN routing.
 interface nve1
  member vni 30001 associate-vrf
 
 vlan 3001
  vn-segment 30001
 
 interface Vlan3001
   no shutdown
   mtu 9216
   vrf member Tenant1
   ip forward
   ipv6 forward

Verify
 show nve vrf
 show nve internal bgp rnh database vni 30001

Exempel, tenant routing table
 routing-context vrf Tenant1
 show ip route
 
 10.1.0.10/32, ubest/mbest: 1/0
    *via 100.64.0.11%default, [200/0], 00:02:44, bgp-65000, internal, tag 65000 (evpn) segid: 30001 
     tunnelid: 0xa000003 encap: VXLAN

Troubleshooting
 show troubleshoot l3 ipv4 10.0.0.10 src-ip 10.0.0.20 vrf Tenant1

====Anycast GW====
Om man slår på anycast gateway feature för ett VNI så måste det enableas på alla VTEP:s där VNI finns.
 fabric forwarding anycast-gateway-mac 0000.1111.2222
 
 interface Vlan100
  vrf member Tenant1
  ip address 10.0.0.1/24
  fabric forwarding mode anycast-gateway
  no shut

====ARP Suppression====
Man kan låta en lokal ARP-proxy hantera requests för att suppressa ARP flooding över VXLAN så mycket som möjligt. Notera att ARP Suppression inte jobbar med något IPv6-relaterat.
 interface nve1
  member vni 10100
   suppress-arp
  member vni 10101
   suppress-arp

 show ip arp suppression-cache detail

OBS på vissa plattformar måste man karva TCAM för att kunna konfigurera arp-suppression. Här är ett exempel för [[Cisco_Nexus#Nexus_9000v|Nexus 9000v]].
 show run all | inc "hardware access-list tcam region"
 
 hardware access-list tcam region span 0
 hardware access-list tcam region racl 512
 copy run start
 reload
 
 hardware access-list tcam region arp-ether 256 double-wide
 copy run start
 reload

====External Connectivity====
Prefix-based routing (Type-5 Routes) används primärt för destinations utanför DC. IP-VRF till IP-VRF görs enligt interface-less model dvs routsen har en RMAC attached.

 router bgp 65000
   address-family l2vpn evpn
    maximum-paths ibgp 4
 
   vrf Tenant1
    address-family ipv4 unicast
      advertise l2vpn evpn
      redistribute direct route-map ALLOW-ALL

Verify
 show bgp ip unicast vrf Tenant1

Exempel på släppa ut en tenant (10.0.0.0/24) ifrån evpn-vxlan-fabricen. Vanlig OSPF pratas mellan border leaf och external device. På border leaf:
 router ospf 100
   vrf Tenant1
     redistribute bgp 65000 route-map ALLOW-ANY
 
 router bgp 65000
   vrf Tenant1
     address-family ipv4 unicast
       advertise l2vpn evpn
       redistribute ospf 100 route-map ALLOW-ANY
       aggregate-address 10.0.0.0/24

==DHCP Relay==
VXLAN EVPN har stöd för DHCP relay-funktionalitet. I en multi-tenant-lösning används tre suboptions av [[Cisco_DHCP#Option_82|Option 82]].
* Sub-option 151 - Virtual Subnet Selection
* Sub-option 11 - Server ID Override
* Sub-option 5 - Link Selection

 feature dhcp
 
 service dhcp
 ip dhcp relay
 ip dhcp relay information option
 ip dhcp relay information option vpn
 ipv6 dhcp relay

Om DHCP-server är nåbar i default-VRFen.
 interface Vlan1001
  description Tenant facing SVI
  ip dhcp relay address 100.0.1.10 use-vrf default
Om DHCP-server finns i tenant-VRF måste man skapa ett unikt tenant-loopback per VTEP eftersom det måste vara en unik IP-adress som source för de relayade DHCP-paketen för att servern ska kunna svara till rätt relay agent.
 interface loopback11
  vrf member Tenant1
  ip address 11.11.11.11/32
 
 interface Vlan1001
  description Tenant facing SVI
  ip dhcp relay address 100.0.1.10 
  ip dhcp relay source-interface loopback11

==Multicast==
EVPN kan lösa IPv4 routed multicast för tenants (TRM). Man kör MVPN ovanpå vxlan-fabricen för att förhindra onödig multicast-forwardering, samma som i MPLS-nät fast utan [[Cisco_PIM|PIM]]. Man använder ngMVPN, det behövs ingen RP och designated router är distribuerad (Anchor DR). Inga PIM- eller IGMP-paket skickas alltså över fabricen utan BGP gör jobbet. PIM ASM och PIM SSM funkar i overlay men inte PIM BiDir. Man har en multicastgrupp i underlay per vrf (coret måste vara multicast-baserat). L2 only mode finns också när man t.ex. inte har någon VRF. Med TRM så är inte advertise-pip och advertise virtual-rmac supporterat. 
 feature ngmvpn
 ip igmp snooping vxlan
 advertise evpn multicast
 ip multicast overlay-spt-only

Tenant
 interface loopback 300
  vrf member Tenant-TRM
  ip address 1.1.1.1/32
  ip pim sparse-mode
 
 vrf context Tenant-TRM
  vni 30000
  ip pim rp-address 1.1.1.1 group-list 224.0.0.0/4
  ip pim ssm range 232.0.0.0/8
  address-family ipv4 unicast
   route-target both auto
   route-target both auto mvpn
   route-target both auto evpn
IP 1.1.1.1 ska finnas på alla VTEPs samt att "ip pim sparse-mode" ska läggas på tenants L3SVI:er.

Verify
 show fabric multicast vrf all
 show fabric multicast globals

=VXLAN EVPN Multi-Site=
Man kan bygga en multisite lösning genom att upprätta eBGP-sessioner mellan så kallade border gateways och låta dem skriva om next-hop i EVPN-uppdateringarna, dvs reoriginera EVPN-routes. VTEPs ser endast neighbors och border gateways i sin egen fabric. Alla externa routes har border gateway som next-hop och BGW gör data plane decapsulation och re-encapsulation. Det går alltså att sträcka L2 mellan siter men man får åtminstone protection och enforcement points i form av BGWs och storm-control. BGW-rollen går även att kombinera med vanlig VRF-Lite, t.ex. om det kommer in back-to-back VRF kopplingar för tenants.

Varje sites border gateways sätts upp som anycast (virtual IP), för lastdelning och redundans, och BGWs pratar VIP till VIP med varandra mellan siterna. Utöver VIP har varje BGW en PIP (man använder primary VTEP IP), den används för L2 BUM. Mellan siter är det endast ingress replication för BUM-transport men inom siterna kan det vara PIM ASM eller ingress replication. Det behöver heller inte matcha mellan siterna. BGWs blir BUM-DF per L2VNI, på så sätt distribueras trafiken. Election process görs och DF synkas med hjälp av Route Type 4 (Ethernet segment route) mellan BGWs inom siten. BGW har flera inbyggda split horizon regler för att kunna flooda till alla samtidigt som loopar undviks. Det finns även pseudo-BGW, dvs leaf utan spine. Då har man ingen internal site vtep neighbor. Det är t.ex. användbart vid migreringar in i en EVPN/VXLAN fabric.

 evpn multisite border-gateway &lt;id&gt;
 
 interface loopback 100
  description Anycast BGW IP
 
 interface nve 1
  source-interface loopback 0
  host-reachability protocol bgp
  multisite border-gateway interface loopback 100
  
  member vni 200    #Every L2VNI that needs stretch
   multisite ingress-replication
 
 
 interface ethernet1/1
  description DCI
  evpn multisite dci-tracking
  
 interface ethernet1/2
  description Spine
  evpn multisite fabric-tracking
 
 router bgp 65000
   address-family l2vpn evpn
   neighbor 10.0.0.2
    remote-as 65001
    peer-type fabric-external
    address-family l2vpn evpn
      rewrite-evpn-rt-asn
Tracking är mandatory annars reorigineras inga EVPN routes, det görs endast om det finns DCI/fabric links som är uppe. Man konfar heller inte next-hop-self, detta händer av sig själv eftersom EVPN fungerar så default.

 show nve multisite
 show nve ethernet-segment
 show nve multisite dci-links
 show nve multisite fabric-links
För "show nve ethernet-segment" notera att L3VNI alltid står som aktiv på alla BGWs eftersom designated-forwarder election inte görs för dem. 

'''Storm-control'''
 evpn storm-control broadcast level 10

==Overlay Stitching==
Man kan binda ihop overlays med hjälp av EVPN, t.ex. VXLAN &lt;-&gt; MPLS VPN. 

'''IOS-XE'''
 vrf definition Tenant1
  rd 125:101
  
  address-family ipv4
   route-target export 65000:30001
   route-target import 65000:30001
   route-target export 65000:30001 stitching
   route-target import 65000:30001 stitching
  exit-address-family
 
 bridge-domain 3001
  member vni 30001
 
 interface BDI3001 
  vrf forwarding Tenant1
  ip address 169.254.0.1 255.255.255.0
  encapsulation dot1Q 3001
  no shut
 
 interface nve1
  no ip address
  no shutdown
  source-interface Loopback0
  host-reachability protocol bgp
  member vni 30001 vrf Tenant1
 
 router bgp 65000
  bgp log-neighbor-changes
  no bgp default ipv4-unicast
  no bgp default route-target filter
  neighbor 10.0.0.11 remote-as 65000
  neighbor 10.0.0.11 update-source Loopback0
  neighbor 10.0.0.250 remote-as 65000
  neighbor 10.0.0.250 update-source Loopback0
 
  address-family vpnv4
   import l2vpn evpn re-originate 
   neighbor 10.0.0.250 activate
   neighbor 10.0.0.250 send-community extended
  exit-address-family
 
  address-family l2vpn evpn
   import vpnv4 unicast re-originate
   neighbor 10.0.0.11 activate
   neighbor 10.0.0.11 send-community both
  exit-address-family

Detta autoskapas på ASR.
 interface Tunnel0
  ip unnumbered Loopback0
  no ip redirects
  ip mtu 9216
  tunnel source 10.0.0.25
  tunnel mode udp multipoint
  tunnel src-port 4789

'''NXOS'''
 vrf context Tenant1
   vni 30001
   rd auto
   address-family ipv4 unicast
      route-target both auto
      route-target both auto evpn 
 
 router bgp 65000
   neighbor 10.2.2.2 remote-as 65000
     address-family vpnv4 unicast
       import l2vpn evpn reoriginate
   neighbor 10.10.10.201 remote-as 65000
     address-family l2vpn evpn
       import vpn unicast reoriginate

=IOS-XR=
MPLS Data Plane

===Multihoming===
Man har en label för unicast och en multicast label för BUM. Label allocation görs per BD. Det finns också en label som används för split-horizon. För unicast är det all active men för BUM så finns det en DF. Route type 4 används för DF election, detta görs lastdelat udda/jämna EVI-ID. Både RD och RT autogenereras. 

'''Leaf'''
 interface TenGigE0/0/0/1
  description "Link to Host"
  bundle id 1 mode active
  load-interval 30
 !
 interface Bundle-Ether 1
  lacp system mac 1101.1111.1111
  load-interval 30
 !
 evpn
  evi 100
   advertise-mac   &lt;- enable RT 2 mac-only
  !
  interface Bundle-Ether 1
   ethernet-segment
    identifier type 0 11.11.11.11.11.11.11.11.11
    bgp route-target 1111.1111.1111
   !
  !
  l2vpn
   bridge group Cust1
    bridge-domain 100
     interface BE1
     evi 100
  !
 !
 router bgp 1
  address-family l2vpn evpn
  !
  neighbor-group RR
   address-family l2vpn evpn

Verify
 show evpn ethernet-segment detail 
 show evpn evi
 show evpn evi mac

'''Bring down AC''' &lt;br/&gt;
För att undvika traffic blackholing när man tappar upplänkar kan man ange att AC ska stängas när noden är isolerad.
 evpn
  group 1
   core interface &lt;uplink1&gt;
   core interface &lt;uplink2&gt;
  !
  core-isolation-group 1

'''Single-Active Multihoming'''
 evpn
  interface Bundle-Ether 1
   ethernet-segment
    load-balancing-mode single-active

===Routing===
 cef adjacency route override rib
 !
 interface BVI100
  host-routing    &lt;- enable RT 2 mac+IP
  vrf Cust1
  ipv4 address 10.0.0.1 255.255.255.0
  mac-address 0000.0000.0111
 !
 router bgp 1
  address-family vpnv4 unicast
  !
  vrf Cust1
   rd auto
   address-family ipv4 unicast
    additional-path receive
    maximum-paths ibgp 2
    redistribute connected

'''VPN Stitching''' &lt;br/&gt;
EVPN&lt;-&gt;VPNv4/6 interconnect
 route-policy rt2-filter
  if destination in (0.0.0.0/0 ge 32) then
   drop
  else
   pass
  endif
 end-policy
 !
 router bgp 1
  address-family l2vpn evpn
   import stitching-rt re-origiante
   advertise vpnv4 unicast re-originated stitching-rt
  !
  address-family vpnv4 unicast
   import re-originate stitching-rt
   route-policy rt2-filter out
   advertise vpnv4 unicast re-originated

[[Category:Cisco]]</text>
      <sha1>pshj25wq89795enpz2uw78lk1svahqd</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco EtherChannel</title>
    <ns>0</ns>
    <id>215</id>
    <revision>
      <id>2806</id>
      <parentid>2613</parentid>
      <timestamp>2018-08-08T05:42:18Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5236">EtherChannel bundlar individuella Ethernet-länkar till en logisk länk. Linkaggregering motverkar två problem som medföljer en ensam kabel, bandbreddsbegränsning och brist på feltolerans. EtherChannel tillhandahåller lastdelning per frame och adderar bandbredd för de aktiva interfacen, t.ex. med tre aktiva 100 mbps members blir interface-bandbredden 300 mbps. För [[Cisco_STP|STP]] är en etherchannel en länk och BPDUer skickas på en av member ports. För en etherchannel måste alla interface ha samma speed, duplex och STP port cost. Är det en VLAN-trunk måste också native och allowed [[Cisco_VLAN|VLAN]] vara samma. För access port-channel måste access-vlan vara samma. 

Se även [[Nexus_vPC|vPC]]

==Konfiguration==
Static
 interface range gi0/1 - 2
  channel-group 1 mode on
 interface port-channel 1
  switchport mode trunk
Verify
 show etherchannel summary

===L3===
Det är viktigt att man konfigurerar L3 etherchannel i rätt ordning. När ''channel-group''-kommandot exekveras tas attributen från member interfacen till port-channel-interfacet. Det betyder att ''no switchport'' måste slås först annars blir port-channel-interfacet en switchport och detta går inte ändra i efterhand.
 interface range gi0/1 - 2
  '''no switchport'''
  channel-group 1 mode [mode]
 interface port-channel 1
  '''no switchport'''
  ip address [ip address] [subnet mask]

===Load-balancing===
Global inställning. EtherChannel tillhandahåller lastdelning per frame.
 port-channel load-balance [method]
 show etherchannel load-balance

Kolla vilket interface en viss frame skickas på.
 test etherchannel load-balance interface port-channel 1 ip &lt;Source-IP&gt; &lt;Destination-IP&gt;
 ''Would select Gi1/0/4 of Po1''

===Misconfiguration Guard===
Misconfiguration guard är en feldetekteringsmekanism som jobbar lokalt per switch. Duplex och speed måste överensstämma på alla portar samt att alla BPDUer som kommer in har samma source MAC-adress. Detta är en global inställning som automatically error-disables alla portar som är felkopplade.
 spanning-tree etherchannel guard misconfig
 show spanning-tree summary | i EtherChannel

==LACP==
Link Aggregation Control Protocol (802.3ad) är ett IEEE kontrollprotokoll för etherchannels. En EtherChannel bildas endast om man lyckas förhandla med andra sidan. Fördeler med en mekanism som håller koll på länkarna är att failover görs automatiskt och kabel/konfigurationsmisstag löper mindre risk att ställa till oönskat beteende i nätverket. Destination mac adress för LACP-frames är 01:80:c2:00:00:02. När LACP ska upptäcka andra sidan initialt skickas LACPDU varje sekund. Sedan ändras det beroende på keepalive mode, slow (30 sek interval) är default. Att ändra görs per interface, '''lacp rate fast''', men alla switchmodeller stödjer inte fast rate (1 sek interval).

&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
LACPDU
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_LACP.png]]
&lt;/div&gt;
&lt;/div&gt;

===Konfiguration===
För att initiera LACP används nyckelordet active. Det finns också passive mode = speak when spoken to.
 interface range gi0/1 - 2
  channel-group 1 mode active

Enable LACP auto on interface.
  channel-group auto

Maximalt kan 16 interface konfigureras i en EtherChannel men endast 8 kan vara aktiva samtidigt. Vilka länkar som ska vara aktiva bestäms av den switch med lägst LACP ID som utgörs av MAC-adress och prioritet. Den använder de portar med lägst prio i första hand, detta är lokala värden.
 lacp system-mac 0011.2233.4455
 lacp system-priority 32768
 
 interface gi0/2
  lacp port-priority 0

Verify
 show etherchannel protocol
 show lacp ?
 show lacp neighbor

====PAgP====
Port Aggregation Protocol är ett Ciscoproperitärt protokoll för samma funktionalitet som LACP. Det använder destination mac 01:00:0C:CC:CC:CC. Kommandot per interface är istället: '''channel-group 1 mode auto/desirable'''

==Link State Tracking==
Man kan konfigurera portar mot servrar att disablas om uplink går ner. Detta är användbart om man har multihomed servers för då märker de att de ska sluta använda sitt primära NIC. 

 link state track 1
 
 int range gi0/1 - 2
  switchport trunk encapsulation dot1q
  switchport mode trunk
  channel-group 1 mode active
  link state group 1 upstream
 
 int po1
  description Uplink
  switchport trunk encapsulation dot1q
  switchport mode trunk
  link state group 1 upstream
 
 int gi0/10
  description Server
  switchport mode access
  switchport access vlan 10
  link state group 1 downstream

Verify
 show link state group detail

==Flex Links==
Tekniskt sett inte etherchannel men kan användas istället för det i vissa situationer. Det som händer när primären går ner är att alla dynamiska MAC entries flyttas till backupinterfacet och det hamnar i forwarding state. Inga BPDUer inblandade. Bör användas tillsammans med [[Cisco_UDLD|UDLD]].
 interface po2
  switchport backup int gi0/5
  switchport backup int gi0/5 preemption mode forced
  switchport backup int gi0/5 preemption delay 10

Verify
 show interface po2 switchport backup
Antingen står det Backup Standby eller Backup Up beroende på status på port-channeln.

[[Category:Cisco]]</text>
      <sha1>np9v13goqzlzxf747j1wcdhmtuec614</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco FC</title>
    <ns>0</ns>
    <id>539</id>
    <revision>
      <id>3104</id>
      <parentid>2979</parentid>
      <timestamp>2021-01-07T08:05:22Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10842">Fibre channel är ett data transport protocol som ger in-order och lossless transfer av blockdata. FC lämpar sig bra för block based storage. Se även [[Cisco_FCoE|Cisco FCoE]].

'''Termer'''
* pWWN/WWPN: 64-bitars portadress på HBA (typ MAC-adress fast finns ej i data plane)
* nWWN/WWNN: 64-bitars HBA-adress
* sWWN: Switch WWN
* Sequence: en eller flera data frames som hör ihop (SEQ_ID) och skickas i en enkelriktad ström mellan två N ports
* FCID: Logisk adress
* Principal switch: har bl.a. hand om domain ID distribution och RSCN, finns en per SAN
* FCNS: Fibre Channel Name Server (typ DNS), körs på den utvalda Principal switch
* RSCN: Registered State Change Notification är en tjänst som N ports kan subscriba på för att få uppdateringar om vad som händer i fabricen
* FSPF: Fabric Shortest Path First är det routingprotokoll som körs i fabricen (motsvarighet till OSPF för IP)

'''Layers''' &lt;br/&gt;
* FC-0: physical layer
* FC-1: enconding and error control
* FC-2: signaling protocol med frame structure och byte sequences
* FC-3: vilka services finns i fabricen, t.ex. time distribution och säkerhet
* FC-4: Mappning mellan FC och det som körs ovanpå, t.ex. SCSI eller IP

Initiators och targets har Host Bus Adapters (HBA), dessa kallas Node Ports. N ports kopplas till Fabric Ports (F ports) på FC-switcharna. Switchportar som kopplas ihop med varandra kallas Expansion (E) Ports, det är på dessa som FSPF körs. Default räknas FSPF cost: 1000 delat med link speed i Gbps, t.ex. 10G = 100. FSPF har default stöd för ECMP. Har man t.ex. Ciscoswitchar finns det stöd för VSAN (motsvarigheten till [[Cisco_VLAN|VLAN]] + VRF) kan man trunka dem över dessa E ports, då kallas det Trunking Expansion Ports (TE Ports).

Det första som händer när man kopplar in en server är att den skickar en Fabric Login (FLOGI). Detta görs till FFFFFE	(well-known fibre channel address for a fabric F_Port). Switchen tar emot detta meddelande och registrerar denna unika WWPN med FCNS. FCNS svarar tillbaka med en unik 24-bitars Fibre Channel Identifier (FC_ID eller N_Port_ID). FCID består av Domain ID, Area ID, Port ID och är routbar inom FC-domänen. Varje switch har ett eget domain ID som måste vara unikt i fabricen, detta går att konfa manuellt och börjar då gälla när man startar om processen (fcdomain restart). När en initiator har fått ett FCID så skickar den Port Login (PLOGI). Detta görs till FFFFFC (well-known fibre channel address for a directory server). Då registreras WWPN och det assignade FCID till FCNS. FCNS svarar då tillbaka med FCID:n för de targets som initiatorn har rätt att accessa enligt zoningpolicyn. När PLOGI är klart kan initiatorn börja sin discovery process för att hitta targets och deras capabilities och operating parameters. Detta görs mellan upper layer protocols och kallas PRLI. Sedan kan man hitta Logical Unit Numbers (LUNs). 

FLOGI-databasen är alltså locally significant inom switchen. Där finns endast WWPN och FCID:n för de directly connected initiators och targets. FCNS-databasen är distribuerad över alla switchar i fabricen och där finns alla nåbara WWPN och FC_ID:n.

Eftersom FC är lossless data transport så finns det inbyggd flow control mekanismer. Detta är credit-based vilket betyder att mottagaren alltid kontrollerar flödena och sändaren får endast skicka data om den vet att mottagaren har tillräckligt med resurser för att ta emot det. Man berättar för andra sidan hur mycket buffer som finns tillgängligt (BB_Credit) och sändaren räknar sedan hur mycket som har skickats (BB_Credit_CNT). Counten får ej överstiga BB_Credit. Varje gång en buffer blir ledig så skickas ett R_RDY message över till sändaren som då sänker BB_Credit_CNT. Detta görs hela tiden mellan alla portar i fabricen.

'''Zoning''' &lt;br/&gt;
En zone är en samling N ports i fabricen som känner till varandra men inget utanför zonen, ett slags VPN. Detta används för att få storage access control. Varje medlem kan definieras av port på switch, WWN, FCID eller ett operator configured alias. Zoning kan göras på två olika sätt, soft och hard zoning. Soft betyder att members endast ser varandra i name server queries medans hard görs med "ACL:er" i hårdvaran i hela fabricen. Nuföritden finns endast hard zoning. 

En eller flera zoner kan aktiveras som en grupp och kallas då zone set. En fabric kan ha flera zone sets men endast en kan vara aktiv åt gången. För att ha hand om detta finns det en Zone Server. 

'''VSAN''' &lt;br/&gt;
Med virtuella SAN kan man köra flera SAN i samma hårdvara. VSAN är en emulering av en FC fabric, dvs man partitionerar upp sitt SAN. Varje VSAN kör sin egen Name Server, Zone Server, Login Server etc. VSAN Manager är en NX-OS process som håller koll på VSAN attribut och porttillhörighet. Alla portar på en Cisco-switch ligger default i VSAN 1. Man kan förlänga VSAN genom att trunka dem över E ports, som då kallas TE_port. Alla frames taggas då med en VSAN header. Det går även att aggregera länkar som trunkar VSAN. FSPF cost ändras inte när en member i en port-channel går ner. Man kan låta PCP agera kontrollprotokoll för länkaggregeringar likt LACP för ethernet. Man kan modifiera MTU per VSAN, det kommer att förhandlas vid FLOGI. 

===Konfiguration===
Nexus 5000. Default pratar bara Nexus-switchar FC med Cisco FC-switchar, detta går att ändra med interoperability mode.

Prereqs
 feature fcoe
 
 slot 1 
  port 44-48 type fc
 
 copy run start
 reload

Verify
 show int br  
 show int e1/44 trans

VSAN och trunk
 feature fport-channel-trunk
 
 vsan database
  vsan 100
  vsan 100 interface fc1/44 - 48
 
 interface fc1/44 - 45
  channel-group 10 
 
 interface san-port-channel 10
  channel mode active
  switchport trunk mode on
  switchport trunk allowed vsan 100
Noter att båda sidor bör konfas klart innan man gör no shutdown på port-channel. 

 show san-port-channel database

TE port
 interface fc1/1 - 2
  switchport speed 8000
  switchport mode E
  switchport trunk allowed vsan 101

TE Port-channel
 interface fc2/1 - 2
  switchport speed 8000
  switchport mode E
  channel-group 11 force
  no shutdown
 
 interface san-port-channel 11
  channel mode active
  switchport mode E
  switchport trunk allowed vsan 101

'''Verify''' &lt;br/&gt;
 show flogi database
 show fcns database
 show fcdomain domain-list
 show fcroute unicast

Traffic Engineering
 interface fc1/24
  fspf cost 50 vsan 100
 
 show fspf vsan 100

Persistent FC ID
 fcdomain fcid persistent vsan 100
 fcdomain fcid database
  vsan 100 wwn 11:22:11:22:33:44:33:44 fcid 0x66ee00
 
 show fcdomain fcid persistent vsan 100

====Zoning====
Zoning är en central del i FC, det är access control i fabricen. Ett zoneset är en eller flera zones. Zone-rekommendation är single target, single initiatior och att man använder pwwn eller alias. Det kan vara bra att känna till att vissa system är case sensitive när det gäller WWN:er. Hard zoning går ej att stänga av på Nexus. 

 zoneset name PROD-A vsan 100
  zone name Server1-to-SAN
   member pwwn 10:00:00:23:45:00:00:10
   member pwwn 10:00:00:23:45:00:00:20
 
 zoneset activate name PROD-A vsan 100

Show
 show zone status vsan 100
 show zoneset active

Permit all
 zone default-zone permit vsan 100

'''Enhanced Zoning''' &lt;br/&gt;
Gör att varje gång man konfar det så låses konfen fabric wide av CFS. Om t.ex. ett vsan isoleras på en länk kolla att zoning mode överenstämmer (tänk VTP).
 zone mode enhanced vsan 100
 zone confirm-commit
 zoneset overwrite-control vsan 100
 zone commit vsan 100
Verify
 show zone status vsan 100

Man kan även distribuera sitt zoneset över fabricen
 zoneset distribute full vsan 100

'''Smart Zoning''' &lt;br/&gt;
För att förenkla sin konfig lite kan man använda taggar för att ange vilka pwwn som är initiators kontra targets. Detta måste vara påslaget på alla switchar i fabricen.
 zone smart-zone enable vsan 100
 zone convert smart-zone vsan 100

ACLTCAM usage MDS
 show system internal acl tcam-usage
 show system internal acltcam-soc tcam-usage

'''Alias''' &lt;br/&gt;
Man bör använda alias för att förenkla zonhantering och felsökning. Även detta kan distribueras mha CFS, det kallas då enhanced device aliases och valfri nod kan göra ändringar som propagerar genom nätet. 
 device-alias mode enhanced 
 device-alias database
  name Server1-HBA1 pwwn 00:11:11...
  name SAN-Array1-port1 pwwn 00:22:22...
 
 device-alias commit 
 show device-alias status

'''Zone Merge''' &lt;br/&gt;
Om man ska koppla ihop två SAN kan man skydda sig mot felkonfad zoning genom att ställa merge-control till restrict. Kopplar man ihop två SAN med olika zonesets blir ISL:en isolated för de vsan som har mismatch.

 zone merge-control restrict vsan 100

====Port Security====
FC Port Security är utökad säkerhet jämfört med zoning, man låter inte ens obehöriga logga in i fabricen. Login requests från obehöriga FC devices (Nx ports) och switchar (xE ports) nekas. Alla nekade inloggningsförsök loggas genom system messages. Man kan använda pWWN, nWWN eller sWWN för att vitlista vem som får vara med i fabricen. Konfigurationen går att distribuera med hjälp av CFS, det är dock avstängt default. 

Man kan även låta switcharna lära sig port security konfigurationen automatiskt över tid. Detta kan man använda när man aktiverar port security första gången eftersom det sparar arbete genom att man inte måste gå igenom alla portar manuellt, detta konfas per VSAN. När man aktiverar port security så aktiveras auto-learn automatiskt. 

 feature fc-port-security
 fc-port-security activate vsan 1
Lock vsan for new entries
 no fc-port-security auto-learn vsan 1
Diff
 fc-port-security database diff active vsan 1

Verify
 show fc-port-security status
 show fc-port-security database active
 show fc-port-security database config
 show fc-port-security violations
CFS
 fc-port-security distribute

==NPV==
N-Port Virtualisation är en teknik för att öka skalbarhet och simplicitet i FC-SAN. Man låter en enskild fysisk N_Port ha multipla WWPN. NPV-enheten gör en FLOGI och sedan kan den registrera fler WWPN och då få fler N_Port_ID. En NPV-enhet har F-portar downstream och NP-port upstream. En NPV-switch kopplas till F-port i SAN. HBA:er märker inte av NPV. 

Det finns ingen funktionell skillnad mellan fysiska WWPN och virtuella, man använder dem för zoning och LUN masking som vanligt. Däremot gör man ingen zoning i NPV-enheten, den har ingen preferens i frågan utan slussar bara vidare inlogg till ovanliggande switch. Notera att ovanliggande switch måste ha NPIV enableat. Nested NPV är inte möjligt. Notera att "feature npv" kräver en write erase och reload.

 feature fcoe-npv
 feature npv

Ovanliggande switch
 feature npiv</text>
      <sha1>2csok8ckpy4ow1uwndwh5rjm282tbzn</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco FCoE</title>
    <ns>0</ns>
    <id>518</id>
    <revision>
      <id>2931</id>
      <parentid>2901</parentid>
      <timestamp>2019-02-26T08:33:47Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7761">Fibre Channel over Ethernet är en teknik för att enkapsulera Fibre Channel frames över lossless Ethernet. FCoE fungerar som vanlig FC men FC0 och FC1 görs av ethernet istället. Se även [[Cisco_FC|Cisco FC]]. Genom att konsolidera nätverk och storage behövs inte lika mycket kablage i datacentret. Servrar som ska nyttja FCoE behöver converged network adapters dvs de har fysiska ethernet-portar men de innehåller funktionsmässigt både HBA och NIC. FCoE har en dedikerad Ethertype, 0x8906, och fungerar med 802.1Q taggar. Fibre Channel är ett stängt point-to-point medium medans Ethernet är öppet multi-access medium. Trots detta kan ethernet (med hjälp av vissa enhancements) användas för att bära FC. Fibre Channel traffic kräver lossless transport. FCoE har en egen EtherType (0x8906). 

'''Termer''' &lt;br/&gt;
* End Node (E-Node): de noder som har CNA.
* FCF: Fibre Channel Forwarder är en switch som förstår både FC och FCoE.

'''Overview''' &lt;br/&gt;
[[File:Cisco-FCoE-CNA.png]]

'''Data Center Bridging''' &lt;br/&gt;
Ett DCB-nätverk tillhandahåller I/O consolidation. Det betyder att SAN- och LAN-trafik går i samma nätverk. DCB kallas även DCE eller CEE. Switcharna måste supportera CoS-based traffic differentiation. Fibre Channel är känsligt för packet drops och är beroende av att paketen kommer fram i samma ordning som de skickades. I ett DCB-nätverk används virtuella länkar (VLs) för att differentiera trafik-klasser. VLs är en extension av CoS vilket gör att trafik i en klass inte påverkar trafik i en annan. Det finns 8 CoS värden. DCBX är på default på Nexus-switchar.

'''Priority Flow Control''' &lt;br/&gt;
PFC (IEEE 802.1bb) är ett subprotokoll till DCB. Det är en mekanism som förhindrar frame loss pga congestion. Det är likt 802.3x Flow Control (pause frames) men det jobbar på en per CoS basis. När en buffer threshold överstigs pga congestion så skickas en pause frame till andra sidan för att den ska sluta skicka frames med ett visst CoS-värde på den länken under en viss tid. När sedan trafik går ner under ett visst gränsvärde så skickas en resume frame för att dra igång dataflödet på länken igen. PFC kommunicerar genom att skicka frames till well-known multicast address 01:80:C2:00:00:01. 

Det första som händer när länken mellan FCoE-switch och CNA kommer upp är att DCBX (Data Centre Bridging capabilities eXchange protocol) berättar för CNA hur den ska vara konfad med avseende på PFC &amp; ETS (enhanced transmission selection). ETS jobbar med priority groups som man kan assigna bandbredd till. DCBX transporteras on the wire av LLDP. När DCBX är klart kan FIP ta vid.

'''FCoE Initiation Protocol''' &lt;br/&gt;
FIP är en väsentlig del i FCoE. Det används för att upptäcka och initiera FCoE-kapabla enheter som är kopplade till ethernetnätverket. FIP har hand om vlan och FCF discovery samt FLOGI och Fabric Discovery. Det är FIP som sätter upp virtuella FC-länkar. På varje FCoE Ethernet port på FCF skapas en virtuell FC-port (vfc). Varje virtuell FC-länk identifieras av FCoE VLAN ID samt MAC-adresserna i varje ände på länken. Under FIP så får alltså CNA reda på vilken mac-adress man ska prata med på FCF. Det betyder också att varje FC-paket måste vara taggat med det vlan som vsanet är mappat med, detta vlan kan ej användas till något annat än FCoE. Notera dock att FIP använder native vlan först men gör en vlan discovery så man får en lista av FCoE-vlan.

FIP bygger även länkar FCF till FCF för multihop FCoE samt håller koll på länkar mha periodiska maintenance messages. E-Nodes använder olika MAC-adresser för FIP och FCoE. FIP sourcas med burned in address medans FCoE sourcas med den MAC-adress som fabricen tillhandahållit, Fabric Provided MAC Address. FPMA utgörs av FCoE MAC address prefix (24 bitar) plus FC_ID (24 bitar). För att rymma den maximala FC-framen är qos class-fcoe definierad med MTU 2240 bytes. FIP har en dedikerad Ethertype (0x8914). Protokollet finns i två versioner (CIN-DCBX &amp; CEE-DCBX) och Nexus har stöd för båda.

===Konfiguration===
Nedan följer FCoE-specifik konfiguration, för övrig konfiguration se [[Cisco_FC#Konfiguration|Cisco FC]]. Eftersom FCoE och FIP använder ett taggat FCoE-vlan så måste ethernetport på FCF mot servrar vara vlan-trunk. 

'''QoS''' &lt;br/&gt;
Kontrollera att QoS är konfat med minst en no-drop klass. Default används CoS 3 för FCoE.
 show policy-map system type network-qos

'''VSAN''' &lt;br/&gt;
Default mappas vsan till vlan med samma ID.
 vsan database
  vsan 100
 
 vlan 100
  fcoe vsan 100

'''F-port'''
 interface 1/15
  switchport mode trunk
  switchport trunk allowed vlan 1,100-105
  spanning-tree port type edge trunk
 
 interface vfc 315
  bind interface e1/15
  switchport mode f

'''Verify'''
 show flogi database
 show fcns database
 show vlan fcoe
 show fcoe database
 show topology vsan 100

'''PFC''' &lt;br/&gt;
 interface ethernet 1/15
  priority-flow-control mode auto
 
 show interface priority-flow-control
 show qos dcbxp interface
auto betyder att no-drop CoS values ska annonseras och förhandlas med hjälp av DCBXP. En successful negotiation slår på PFC på no-drop CoS. Medans om det t.ex. är en mismatch i capabilities så kommer inte förhandlingen att lyckas och PFC förblir avstängt.

'''FC-Map''' &lt;br/&gt;
Man kan identifiera FC-fabricen mha MAC-adresser eftersom detta används till FPMA. FC-Map är en isoleringsteknik. Frames som inte har detta prefix discardas, dvs alla switchar i fabrien måste ha samma FC-map. Default value är 0E.FC.00.
 fcoe fcmap 0xefc10

'''Fabric Priority''' &lt;br/&gt;
Nexus 5000 annonserar sin prioritet, den används av CNA:er för att bestämma vilken som är den bästa switchen att ansluta till. 
 fcoe fcf-priority 128

====Multihop FCoE====
Precis som det finns virtuella F-portar finns det även virtuella E-portar.

 interface vfc 15
  bind interface ethernet 1/15
  switchport mode e
  no shut
 
 interface ethernet 1/15
  switchport mode trunk
  no shut

====Enhanced vPC====
Man kan kombinera FCoE med [[Nexus_vPC|Enhanced vPC]] men man måste separera A- och B-sidan. Detta kan man göra genom att konfa FEX:arna att pinna FCoE-trafik till endast den ena parent. Först bygger man vPC och sedan FCoE på det. FCoE-vlan får ej traversera vPC peer-linken men detta sköts default. Host facing vfc-interfaces binds till fysiska ethernetport och inte port-channel interface.

Nexus1
 fex 101
  fcoe 
 
 interface vfc 10
  bind interface ethernet101/1/1
  no shutdown

Nexus2
 fex 102
  fcoe
 
 interface vfc 10
  bind interface ethernet102/1/1
  no shutdown

Show
 show fex detail | i FCoE
 show system internal dcbx info interface ethernet 101/1/1

====Nexus 7k====
FCoE görs med hjälp av Storage VDC.
 license fcoe module 2
 
 system qos
  service-policy type network-qos default-nq-7e-4q8q-policy
 
 vdc SAN type storage
  allocate interface e2/1-8
  allocate fcoe-vlan-range 100-101

==iSCSI==
iSCSI har egentligen inte mycket med switchar att göra men man bör göra det lossless.

 class-map type qos match-all class-iscsi
  match protocol iscsi
  match cos 6
 
 policy-map type qos qos_fcoe_and_iscsi
  class class-iscsi
   set qos-group 2
  class class-fcoe
   set qos-group 1
 
 policy-map type network-qos network_fcoe_and_iscsi
  class type network-qos class-iscsi
   mtu 9216
   pause no-drop
  class type network-qos class-fcoe
   mtu 2158
   pause no-drop
  class type network-qos class-default
   mtu 9216
 
 system qos
  service-policy type queuing input fcoe-default-in-policy
  service-policy type queuing output fcoe-default-out-policy
  service-policy type qos input qos_fcoe_and_iscsi
  service-policy type network-qos network_fcoe_and_iscsi

[[Category:Cisco]]</text>
      <sha1>r17fspzrhaakugz8yierx211b1p5ec0</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco FHRP</title>
    <ns>0</ns>
    <id>231</id>
    <revision>
      <id>2641</id>
      <parentid>2252</parentid>
      <timestamp>2017-11-15T07:00:15Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3353">First Hop Redundancy Protocol används för att skydda gateway-tillgängligheten genom att låta flera enheter agera backup för varandra. Se även [[Cisco_HSRP|Cisco HSRP]].

=VRRP=
Virtual Router Redundancy Protocol (RFC 3768) är ett öppet FHRP. Det fungerar väldigt likt HSRP men med några skillnader. Preemption är påslaget default till skillnad från HSRP, båda protokollen kan dock ha det på eller av. VRRP använder den inbyggda trackingfunktionen i IOS. Source-IP för VRRP-paket är interface IP, destination-IP är 224.0.0.18 och protokoll är 112. Hellos skickas default varje sekund. Man kan till skillnad från HSRP ha samma virtual ip som interface ip. Konfigurerar man det ändras VRRP-prio till 255 på den enheten som har samma IP som VIP. Backupenheter har 100 som default. 

MAC-adress: 00:00:5E:00:01:XX

'''VRRPv3''' &lt;br/&gt;
För att stödja IPv6 togs VRRPv3 (RFC 5798) fram. Det är inkompatibelt med VRRPv2 men har stöd för både IPv4 och IPv6. Det har även stöd för mer fintrimmade timers. Dessa anges i millisekunder och default hello interval är 1000ms. Timer learning är också enabled default. Transport görs med IP protocol 112 och skickas till multicast address 224.0.0.18 och FF02:0:0:0:0:0:0:12. I v2 görs preemption till den med högst interface IP om två noder har samma prio, så funkar inte v3 utan det är endast högst prio som ändra rollerna.

Slå på VRRPv3 och Virtual Router Redundancy Service (VRRS) globalt. När man växlar till VRRPv3 stängs VRRPv2 av.
 fhrp version vrrp v3

===Konfiguration===
Konfiguration görs per interface. VRRP tillåter inte virtual router group 0 och har därmed aldrig en tom grupp.
 interface gi0
  vrrp 1 description HA-gateway
  vrrp 1 priority &lt;1-254&gt;
  vrrp 1 timers advertise [msec] interval
Timers måste matcha och man kan låta VRRP-gruppen lära sig advertisement interval från master virtual router.
  vrrp 1 timers learn

Preempt delay
 vrrp delay minimum 30
 vrrp delay reload 60

Autentisering
 vrrp 1 authentication cisco

'''Verify'''
 show vrrp brief
 show vrrp interface gi0
 show vrrp all

=GLBP=
Gateway Load Balancing Protocol är ett Ciscoproperitärt protokoll. Det togs fram för att kunna ha alla noder aktiva samtidigt. Default lastdelas det och varje AVF används i round-robin. GLBP Forwarder preemption är på default med en delay på 30 sekunder. Om en AVF blir unreachable så kommer AVG att redirecta trafiken genom att besvara requests för den gamla MAC-adressen med nya AVF:er. Source-IP för GLBP-paket är interface IP, destination-IP är 224.0.0.102 och transport är UDP port 3222. Använd GLBP load balancing method host-dependent när varje host alltid ska använda samma router och använd weighted när man vill ha unequal load balancing, t.ex. om routrarna har olika forwarderingskapacitet.

 interface gi2
  glbp 1 ip 10.0.0.10
  glbp 1 priority 150
  glbp 1 preempt
  glbp 1 weighting 50
  glbp 1 load-balancing weighted
'''Verify'''
 show glbp brief

'''Authentication''' &lt;br/&gt;
En router ignorerar alla GLBP-meddelanden som har fel autentisering.

Plain-text
 glbp 1 authentication text secret
MD5
 glbp 1 authentication md5 key-string GLBP-Key

'''Stateful NAT''' &lt;br/&gt;
Om GLBP används i kombination med [[Cisco_NAT#Stateful_NAT|SNAT]] måste load-balancing vara satt till host-dependent. 

[[Category:Cisco]]</text>
      <sha1>g3dt30bv9jtfcbjz3dlegzs03egzr53</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco FTD</title>
    <ns>0</ns>
    <id>504</id>
    <revision>
      <id>2709</id>
      <timestamp>2017-12-27T23:56:05Z</timestamp>
      <contributor>
        <username>Kessemess</username>
        <id>15</id>
      </contributor>
      <comment>Created page with "Firepower Threat Defense (FTD) är Ciscos Next-Generation Firewall-erbjudande. Denna serie kommer att vara i fokus framåt och på sikt ersätta ASA-brandväggarna. Firepower-..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3163">Firepower Threat Defense (FTD) är Ciscos Next-Generation Firewall-erbjudande. Denna serie kommer att vara i fokus framåt och på sikt ersätta ASA-brandväggarna. Firepower-hårdvaran kan köras antingen med ren ASA-kod eller med NGFW-koden; FTD. Alla ASA-brandväggar ur 5500-X-serien kan reimage:as till FTD också, förutom 5585-X.

Till skillnad från ASA är FTD inte CLI-drivet utan manageras via antingen ett lokalt webbgränssnitt, FDM (2100-serien och mindre) eller Firepower Management Center (FMC), en centraliserad management-server för en eller flera brandväggar (motsvarande PAN Panorama och CheckPoint Tracker). De CLI-kommandon som finns används för grundläggande installation och debugging.

==Grundkonfiguration av FTD==
Logga in i konsolen med admin/Admin123 och fyll i IP, hostname m.m. i setup-wizarden. För att sedan kunna managera enheten via FMC kör följande kommando: 
 configure manager add &lt;hostname | IPv4_address | IPv6_address | DONTRESOLVE&gt;  reg_key &lt;nat_id&gt;
Exempel
 configure manager add 10.11.12.13 my_reg_key
&lt;code&gt;Hostname/IP&lt;/code&gt; används för att peka ut FMC.

&lt;code&gt;reg_key&lt;/code&gt; är en sträng som används likt en shared secret för att ansluta FTD och FMC (denna anges senare i FMC).

&lt;code&gt;nat_id&lt;/code&gt; används bara om NAT används mellan FTD och FMC, ange då ett unikt ID tillsammans med &lt;code&gt;DONTRESOLVE&lt;/code&gt; istället för hostname.

Exempel med NAT
 configure manager add DONTRESOLVE my_reg_key my_nat_id

==Firepower Management Center==
FMC används för att centralt managera FTD-brandväggar, FMC finns både som virtuell och fysisk appliance. För de större FTD-brandväggarna krävs FMC för management.
===Licensing &amp; Evaluation Period===
FMC kan testköras i 90 dagar, detta aktiveras under samma meny som används för Smart Licenses. För att aktivera din Smart License eller Evaluation Period, gör såhär:

	1. Klicka eller hovra på System-fliken i övre höger hörn.

	2. Under Licenses-fliken, välj Smart Licenses.

	3. Aktivera din Evaluation Period eller registrera dina Smart Licenses.

===Managera FTD===
Logga in i FMC via din webbläsare och gör följande för att lägga till din FTD-enhet för managering:

	1. Klicka på Devices-fliken längst upp på sidan.

	2. Klicka på Add...-knappen längst till höger, välj Add Device.

	3. Fyll i IP/Hostname i Host-fältet.

	4. Fyll i samma registration key som konfigurerats på FTD-enheten.

	5. Tilldela/skapa en Access Control Policy till enheten.

	6. Bocka för önskade licenser under Smart Licensing.

	7. Om nat_id använts i FTD, fyll i detta efter Unique NAT ID under Advanced.

	8. Tryck Register.

===Omstart av FMC===
Under System -&gt; Configuration -&gt; Process finns möjlighet att starta om FMC-konsolen eller FMC-servern samt stänga av FMC-servern.

===Packet Tracer===
Finns under Devices -&gt; Device Management, klicka sedan på "verktygsikonen" för att komma Health Monitor-vyn. Starta härifrån Advanced Troubleshooting, så finner du Packet Tracer som en separat flik. Det går även att nå Packet Tracer via System -&gt; Health -&gt; Monitor, för att sedan klicka sig fram till enheten.

[[Category:Cisco]]</text>
      <sha1>h5nh0k3mdfwiyluinkb2fzehkkmt3j1</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco GRE</title>
    <ns>0</ns>
    <id>211</id>
    <revision>
      <id>3125</id>
      <parentid>3076</parentid>
      <timestamp>2021-10-21T06:36:49Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8987">Generic Routing Encapsulation (RFC 2784) är ett tunnlingsprotokoll utvecklat av Cisco, det är IP-protokoll 47. Enkapsulering görs genom att sätta på en 4 byte GRE-header på L3-paketen och sedan sätts en ny IPv4/IPv6-header på det så att det kan routas till andra änden av tunneln och dekapsuleras. Diverse protokoll kan tunnlas, t.ex. [[Cisco_MPLS|MPLS]] och [[Cisco_IPsec|IPsec]]. Eftersom det är enkapsulering påverkas MTU så det bör man hålla koll på. Däremot om man ändrar tunnel mode till "IPIP" så reducerar man overheaden litegrann för då läggs det endast på en header istället för två. Och vill man öka overhead kan man köra tunnel i tunnel, man kan enkapsulera ett paket upp till fyra gånger. GRE kan även köras multipoint, t.ex. i [[Cisco_DMVPN|DMVPN]]. 

===Tunnel Key===
GRE Tunnel Key feature kan användas för att logiskt särskilja mellan flera tunnlar mellan samma noder. Det gör att encapsulation router lägger till en 4-bytes identifier i GRE-headern (tänk VLAN-taggning). Om mottagande router ser att det är en mismatch i key value kommer paketet att droppas.

Utan key, 4 bytes header. &lt;br/&gt;
[[File:Cisco_GRE.png]]

Med key, 8 bytes header. &lt;br/&gt;
[[File:Cisco_GRE_key.png]]

=Konfiguration=
'''R1'''
 interface Tunnel0
  ip address 10.0.0.1 255.255.255.252
  ip mtu 1400
  ip tcp adjust-mss 1360
  tunnel source &lt;local-ip&gt;
  tunnel destination &lt;R2-ip&gt;
Väljer man ett interface som source används primary IP på det interfacet.

'''R2'''
 interface Tunnel0
  ip address 10.0.0.2 255.255.255.252
  ip mtu 1400
  ip tcp adjust-mss 1360
  tunnel source &lt;local-ip&gt;
  tunnel destination &lt;R1-ip&gt;

Verify. Utan keepalives är ett tunnel-interface UP/UP sålänge det inte är administratively shutdown.  
 show ip int br
 show interface | i Tunnel protocol

===Keepalive===
Eftersom en GRE-tunnel går över andra enheter och länkar måste en keepalive skickas hela vägen mellan tunnel-interfacen för att routern ska kunna veta om det är uppe. Detta är ej påslaget default. Standardvärden för keepalive är 10 sekunders interval med 3 retries. Detta fungerar med GRE-tunnlar men inte med mGRE eftersom det då inte finns någon enskild destination att skicka keepalives till så de interfacen är alltid UP/UP.

En keepalive är ett tomt GRE-paket till sig själv som enkapsuleras och skickas till andra sidan. När paketet packas upp kommer destinationsadressen att kollas upp för att avgöra vart det ska skickas vilket resulterar i att det skickas tillbaka. &lt;br/&gt;
[[File:Cisco_GRE_Keepalive.png]]

 interface Tunnel0
  keepalive &lt;interval&gt; &lt;retries&gt;
Verify
 show interface tunnel 0 | i Keepalive

===VRF===
Man kan ha tunnel-interfacet i en VRF medans tunneln själv terminerar i en annan VRF.
 interface Tunnel0
  vrf forwarding VRF-1
  ip address 10.0.0.1 255.255.255.252
  tunnel vrf VRF-2
  tunnel source &lt;vrf2-ip&gt;
  tunnel destination &lt;vrf2-ip&gt;

===Recursive Routing===
Tunnel Source och Destination bör alltid läras utanför tunneln. Om det är problem med Recursive Routing kan man antingen disallow tunnel source att annonseras med hjälp av en prefix-lista eller lägga statiska routes med lägre AD. 
 ''Tunnel0 temporarily disabled due to recursive routing''

===QoS===
När paket enkapsuleras och krypteras kan inte QoS-funktioner se original-headern och klassificera det korrekt eftersom VPN och tunnel operations appliceras innan QoS policy. Med QoS pre-classify för VPN:er ändrar man denna ordning och paket kan klassificeras innan de tunnlas. Man kan även klassa på annat än IP-prec eller DSCP. Se även [[Cisco_QoS|Cisco QoS]].

Enable QoS for VPNs feature:
 interface Tunnel0
  qos pre-classify

===Others===
Man kan koppla ihop loopback-interface med hjälp av GRE genom att sätta tunnelinterfacen som unnumbered.
 interface Tunnel0
  ip unnumbered Loopback0

Drop corrupted and out-of-order VPN packets
 tunnel checksum  
 tunnel sequence-datagrams

=IPv6=
IPv6 går att tunnla och enkapsulering av IPv6 är IP protokoll 41. IPv6-paket går även att tunnla över ett IPv4-nätverk med hjälp av flera olika tekniker, IPv4 end-to-end reachability är det som krävs.

'''Protokoll 41:''' &lt;br/&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
Över IPv6, "tunnel mode ipv6"
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_GRE_IPv6.PNG]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
Över IPv4, "tunnel mode ipv6ip"
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_GRE_IPv6IP.PNG]]
&lt;/div&gt;
&lt;/div&gt;

====Manual tunnel====
IPv6-IP-tunnlar använder IP-protokoll 41 och vill man filtrera det i en acl får man använda protokollnumret. Detta har något lägre overhead än GRE.
 interface Tunnel0
  ipv6 address 10::1/64
  tunnel source loopback0
  tunnel destination 10.0.0.20
  tunnel mode ipv6ip

====Automatic 6to4====
Tanken med automatiska 6to4-tunnlar är att lösa IPv6-routing över ett IPv4-nätverk baserat på next-hop adresser inbakade i IPv6-adressen. IPv6-prefixet 2002::/16 är reserverat för detta ändamål och lösningen blir point-to-multipoint natively. Destination för tunneln anges inte manuellt utan det fås fram för varje flow som ska forwarderas genom att ta ut 32 bitar från destination IPv6 address på de paket som kommer in och ska till en annan IPv6-site. Det betyder att alla site prefix inklusive adressen på tunnel-interfacet måste tas ut från den range som är en kombination av det reserverade IPv6-prefixet och 6to4 border routerns för övriga nåbara IPv4-adress, dvs 2002:&lt;32-bitar ipv4&gt;::/48. 

 interface Loopback0
  description Border Router IPv4 Address
  ip address 192.168.0.1 255.255.255.255
 
 interface Tunnel0
  tunnel source Loopback0
  tunnel mode ipv6ip 6to4
  ipv6 address 2002:C0A8:0001::10/64
 
 ipv6 route 2002::/16 tunnel 0

====ISATAP====
Intra-Site Automatic Tunnel Addressing Protocol (RFC 5214) är framtaget för möjliggöra IPv6-kommunikation mellan IPv4-only hosts och IPv6-enheter. IPv4-domänen fungerar som ett multi-access segment för IPv6 där IPv4-adresserna är endpointsen. Klienter som vill använda ISATAP frågar sin DNS-server om A record för "ISATAP", som bör peka på ISATAP-routern. Hosten tunnlar sedan ett router discovery packet (med hjälp av IPv6-in-IPv4 encapsulation) och skickar det till ISATAP-routern. Routern svarar med en RA som innehåller prefixet som ska användas och då kan klienten sätta ihop sin egna gångbara IPv6-adress utifrån ISATAP identifier (0000:5efe) och sin egen IPv4-adress. Adress måste tas med hjälp av EUI-64 och då genereras interface ID automatiskt. ISATAP är också point-to-multipoint natively

Man behöver ej ange destination address manuellt.
 interface Tunnel0
  ip address 2001:0:0:500::/64 eui-64
  no ipv6 nd suppress-ra
  tunnel mode ipv6ip isatap

Ett äldre alternativ till ISATAP är "IPv6 Automatic IPv4-compatible" (''tunnel mode ipv6ip automatic'') men det är inte rekommenderat att köra.

====6RD====
IPv6 Rapid Deployment (RFC 5969) är en generalisering av automatic 6to4 tunneling mechanism. Det är en stateless transition mechanism som kör IPv4 protocol 41 (IPv6 in IPv4). Notera att MTU i en 6RD-domän måste vara välmanagerat. 

Definitioner&lt;br/&gt;
* 6RD CE: "Customer Edge" router som sitter mellan IPv6-enabled LAN site och IPv4-enabled SP network. Denna router har ett 6rd tunnel interface som agerar endpoint för IPv6-in-IPv4 enkapsuleringen och forwarderingen. 
* 6RD Border Relay (BR): Border Relay router står hos service provider. Den har ett IPv4-interface, ett 6rd tunnel interface för multi-point tunneling och ett IPv6-interface som når IPv6-internet. 
* 6RD Delegated Prefix: Detta-IPv6 prefix bestäms av CE och används av hostarna på LAN site. Det funkar motsvarande DHCPv6 PD prefix.
* 6RD Prefix: Detta IPv6-prefix bestäms av SP och används av hela 6rd-domänen. 
* BR IPv4 address: Border Relays IPv4-adress. Denna adress används av varje CE för att skicka paket till BR som ska till IPv6-destinationer utanför 6rd-domänen. 
* CE IPv4 address: IPv4-adress på CE som används för IPv4 internetaccess (t.ex. DHCP-assignad), denna kan vara global eller privat inom 6rd-domänen. Denna adress används för att skapa 6rd delegated prefix samt skicka och ta emot IPv6-paket. 

'''Konfiguration'''&lt;br/&gt;
Tunnel 6rd ipv4 prefix-len 0 är default.

BR
 ipv6 general-prefix RD 6rd Tunnel0
 !
 interface Tunnel0
  no ip address
  ipv6 address RD ::/128 anycast
  tunnel source Loopback0
  tunnel mode ipv6ip 6rd
  tunnel 6rd prefix 2002::/32
 ! 
 ipv6 route 2002::/32 Tunnel0

CE
 ipv6 general-prefix RD 6rd Tunnel0
 !
 interface Tunnel0
  no ip address
  ipv6 enable
  tunnel source Loopback0
  tunnel mode ipv6ip 6rd
  tunnel 6rd prefix 2002::/32
  tunnel 6rd br 4.4.4.4
 !
 ipv6 route 2002::/32 Tunnel0
 ipv6 route ::/0 Tunnel0 2002:0:404:404::
 !
 interface GigabitEthernet1
  description LAN
  ipv6 address RD ::/64 eui-64

Verify
 show tunnel 6rd

[[Category:Cisco]]</text>
      <sha1>24vxf8sf8m0bp8z6km7fmrkocmbo2lw</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco HSRP</title>
    <ns>0</ns>
    <id>173</id>
    <revision>
      <id>2903</id>
      <parentid>2773</parentid>
      <timestamp>2018-12-07T12:58:09Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7393">Hot Standby Router Protocol (RFC 2281) är ett standardiserat men Ciscolicensierat FHRP. HSRP låter två routrar dela på en virtuell IP och MAC-adress så att andra system kan använda samma IP/MAC och skicka paket till fast adressen kan vara aktiv på olika enheter. Tanken är att de inte ens märker när ena routern går ner. Den virtuella IPn måste vara i samma subnät som interface-IPn. Endast en router är aktiv i taget medans standby-routern lyssnar efter Hellos som default skickas var 3:e sekund från den aktiva. Uteblir dessa tar standby-enheten över och blir aktiv. Den router med högst prioritet blir aktiv, 100 är default för IOS, och vid lika avgör högsta interface IP-adress. Preempt är inte påslaget default. Autentisering går att göra med clear-text eller MD5. 

HSRP går att använda tillsammans med [[Cisco_NAT#HSRP|NAT]]. Se även [[Cisco_FHRP|FHRP]].

===Version===
HSRP finns i två versioner som använder olika paketformat. Version 2 använder TLVer och är inte kompatibel med version 1. I version 1 (som är default) kan man ha standby-grupp 0-255 medans i v2 är detta utökat till 0-4095. Version 2 skickar med en 6-byte identifier field som innehåller MAC-adressen på avsändaren så man vet vem som är originator. Det skickas även med timer values i millisekundformat så andra sidan kan synka med. HSRP version 2 har stöd för IPv6. 

{| class="wikitable"
! HSRP version || Protocol !! Group address !! UDP Port !! Virtual MAC address range
|-
| 1 || IPv4 || 224.0.0.2 (all routers) || 1985 || 00:00:0c:07:ac:XX
|-
| rowspan=2|2 || IPv4 || 224.0.0.102 (HSRP) || 1985 || 00:00:0c:9f:fX:XX
|-
| IPv6 || ff02::66 || 2029 || 00:05:73:a0:0X:XX
|}

===States===
* Initial: HSRP körs inte.
* Learn: Routern känner inte till VIP utan väntar på att den aktiva enheten ska prata. 
* Listen: Routern känner till VIP men är varken active eller standby.
* Speak: Routern skickar HSRP hellos och är med i valet för active.
* Standby: Routern håller koll på hellos från active och är beredd att ta över. 
* Active: Routern forwarderar paket som virtuell router.

==Packets==
'''Version 1'''
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Advertise:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_Advertise.png‎]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Hello Speak:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_Speak.png‎]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Hello Standby:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_Standby.png‎]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Hello Active:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_Active.png‎]]
&lt;/div&gt;
&lt;/div&gt;

'''Version 2'''
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Advertise:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_v2_Advertise.png‎]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Hello Speak:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_v2_Speak.png‎]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Hello Standby:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_v2_Standby.png‎]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
* Hello Active:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_v2_Active.png‎]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:830px"&gt;
För att ta över active-rollen skickas ett Coup message, detta används vid preemption.
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_v2_Coup.png‎]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:830px"&gt;
När ett interface shutas på active device skickas det ut ett Resign message så att standby kan bli active direkt.
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_HSRP_v2_Resign.png‎]]
&lt;/div&gt;
&lt;/div&gt;

=Konfiguration=
 interface [interface]
  standby version 2
  standby 1 ip [virtual ip]
  standby 1 priority &lt;0-255&gt;
  standby 1 preempt
  standby 1 timers [hold] [dead]

'''Verify'''
 show standby brief
 show standby

Initialisation delay. Man kan konfigurera en delay för när HSRP ska aktiveras efter omboot och interface link up.
  standby delay minimum 30
  standby delay reload 60
 
 show standby delay
Använd burned in MAC address
 standby use-bia
Configure sending of ICMP Redirect messages with an HSRP virtual IP address as the gateway IP address
 standby redirects enable
 
 show standby redirect

Man kan slå på att HSRP ska skicka en gratuitous ARP från aktiva grupper. Default skickas det en när en grupp blir aktiv, en 2 sekunder senare och sedan en ytterligare 2 sekunder senare.
 standby arp gratuitous

==Autentisering==
HSRP måste ha en authentication-sträng som skickas i paketen och default så ligger "cisco" (''standby X authentication cisco''), dvs cisco i klartext används men det syns inte i konfigen.

Plain text
 standby 1 authentication text SECRET
MD5
 standby 1 authentication md5 key-string SECRET
 standby 1 authentication md5 key-chain HSRP-CHAIN

==Tracking==
HSRP kan hålla koll på interface för att veta vilken enhet som bör vara aktiv. Man kan automatiskt sänka HSRP priority när line protocol på utvalt interface blir down, default decrement är 10.
 standby 1 track Gi0/0 30
 show standby | i Track

'''IP SLA''' &lt;br/&gt;
Allt som går att tracka med [[Cisco_Routing#IP_SLA|IP SLA]] kan HSRP använda sig av. Man kan även ha flera objekt som man trackar och med decrement valus styra att flera saker måste vara nere för att aktiv enhet ska bytas.
 track 100 interface gi0/1 line-protocol
 standby 1 track 100 decrement 30

==Secondary VIP==
Man kan ha secondary virtual IP address med HSRP. Denna VIP eller info om den skickas inte i något HSRP-paket, dvs det hålls ingen egen state för det utan det följer helt enkelt rollen som HSRP-gruppen har. 
 interface gi2
  standby 1 ip 10.0.0.1 secondary

==BFD==
HSRP [[Cisco_BFD|BFD]]

Global
 standby bfd all-interfaces
Per interface
 interface gi2
  standby bfd

==MHSRP==
Multiple HSRP. Man kan ha flera HSRP-grupper på samma interface vilket möjliggör en variant av lastdelning. För att MHSRP ska kunna lastdela kan inte alla hostar i subnätet ha samma default gateway utan några måste använda den ena virtuella IPn och några mot en för en annan HSRP-grupp, dock fortfarande i samma subnät. På Nexus-plattformen går det att lösa så att alla enheter är aktiva för samma VIP, se [[Nexus_FabricPath#Anycast_HSRP|Anycast HSRP]].

==NX-OS==
Switch 1
 feature hsrp
 
 interface e1/1
  ip 10.0.0.2/24
  hsrp bfd
  hsrp version 2
  hsrp 1
   ip 10.0.0.1
   follow master1

Switch 2
 feature hsrp
 
 interface e1/1
  ip 10.0.0.3/24
  hsrp bfd
  hsrp version 2
  hsrp 1
   ip 10.0.0.1
   priority 110
   name master1
Det är rekommenderat att köra BFD istället för att ändra HSRP-timers.

För att stödja HSRP under ISSU (In-Service Software Upgrades) så kan man aktivera förlängda kontrollmeddelanden för HSRP. 
 hsrp timers extended-hold

Man kan låta HSRP lära sig VIP av andra HSRP-noder. 
 interface vlan 10
  hsrp 10
   ip
Med IPv6 kan man auto-konfigurera VIP, då görs EUI-64 på HSRP-gruppens MAC-adress.
 interface vlan 10
  hsrp 10 ipv6
   ip autoconfig

[[Category:Cisco]]</text>
      <sha1>281lz4xqhh3onbi2y9av7o27x8xgmxx</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco IGMP</title>
    <ns>0</ns>
    <id>276</id>
    <revision>
      <id>2902</id>
      <parentid>2814</parentid>
      <timestamp>2018-12-04T11:31:17Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13241">Internet Group Management Protocol används mellan end systems och routrar för att ta reda på om segmentet ska ha multicast-trafik och isåfall vilken. En router håller inte reda på vilka hostar som är med i vilka grupper utan endast om gruppen är aktiv eller ej. Hostar använder det för att joina och lämna multicastgrupper. Switchar kan lyssna på det för att ta reda på vilka switchportar som ska ha vilken trafik. IGMP slås på när man konfar multicast routing och [[Cisco_PIM|PIM]] på routrar.

Se även [[Cisco_Multicast|Cisco Multicast]].

==Versioner==
IGMP härstammar från Host Membership Protocol och finns i flera versioner, IGMPv1 (RFC 1112) är dock förlegat men det finns bakåtkompatibilitet. När en IGMPv2-router får in en IGMPv1 Query slutar den skicka v2-queries och en Version 1 Router Present Timeout startas som resettas varje gång det kommer in en v1-query. Efter 400 sekunder går den ut och routern återgår till IGMPv2. Routrar avgör om det är en IGMPv1-Query som kommer in genom att kolla om Maximum Response Time är satt.

* '''IGMPv2''' (RFC 2236) är bakåtkompatibel med IGMPv1 och är defaultversion på Cisco IOS. Version 2 har en förbättrad Leave-mekanism och nu finns det även möjlighet att fråga efter specifika grupper istället för alla. 

* '''IGMPv3''' (RFC 3376) är en nyare revision av IGMP som har en egen multicastadress, 224.0.0.22. Den stora nyheten är att end systems kan berätta för routrar vilken source de vill ha multicasttrafik från, Source-Specifik Multicast. Det är bakåtkompatilbelt med IGMPv1 och v2. 

 show ip igmp interface

=Packets=
IGMP-paket skickas med IP och har TTL satt till 1.

* '''Host Membership Query:''' är en generell Query som skickas default var 60:e sekund till 224.0.0.1 på LAN interface för att kolla om någon är intresserad av multicast. Default har hostar 10 sekunder på sig att besvara detta.

* '''Host Membership Report:''' skickas antingen som svar på en Query och innehåller då alla grupper som hosten är med i eller när en host vill joina en ny grupp.

* '''Leave group message:''' skickas till 224.0.0.2 och används av hostar för att meddela routrar att de lämnar en grupp.

* '''Group-Specific Query:''' när en router får in ett Leave message skickar den ut en gruppspecifik Query (destinationsadress är den multicastgruppen) för att se om det fortfarande finns någon på segmentet som är intresserad. Detta innehåller Last Member Query Interval som default säger att members har 1 sekund på sig att svara, det skickas två av dessa när ett Leave kommer in. Om det var den sista hosten som skickade Leave message reducerar detta tiden det tar innan onödig multicasttrafik slutar skickas från flera minuter till ca 3 sekunder. 

'''IGMP Querier Election''' &lt;br/&gt;
Finns det flera multicast-routrar på ett segment kommer endast en vara aktiv och skicka General Queries. När en router får in en General Query jämförs source-adressen mot det egna interfacets adress och den med lägst vinner och blir vald IGMP Querier. En nonquerier är inte aktiv själv men lyssnar efter Queries och när det slutar komma in kan den ta över. Tiden det tar innan en vald Querier anses död är 2 gånger Query Interval plus en halv Query Response Interval, default är detta 255 sekunder.
 show ip igmp interface | i querying

Med IGMPv1 finns det inget inbyggt sätt för hostarna att avgöra vem som ska stå för Queries. Därför väljer routrarna en som blir DR och den kommer att skicka IGMP Queries, routern med högst IP vinner.
 show ip igmp interface | i DR 

==Timers==
Man kan konfigurera hur ofta queries ska skickas ut. Varje membership query message innehåller ett timer-värde (8 bit field) som anger hur lång tid hostarna har på sig att besvara meddelandet, det räcker att en host svarar på det så kommer inte multicast-strömmen att upphöra.
 interface gi2
  ip igmp query-max-response-time 10
  ip igmp query-interval 60

Querier
  ip igmp querier-timeout 120

Verify
 show ip igmp interface | i IGMP

'''Last Member'''
 interface gi2
  ip igmp last-member-query-count 2
  ip igmp last-member-query-interval 1000

Man kan även ange att strömmen ska upphöra direkt om det kommer in ett Leave group message.
  ip igmp immediate-leave group-list IMMEDIATE_LEAVE

==Filtering==
IGMP filtering tillåter att man konfigurerar filter för IGMP-trafik på SVI, per-port eller per-VLAN per-port. Det är ett komplement till IGMP Snooping, som är ett prereq för filtering. Med IGMPv1-2 discardas hela paketen ifall filtret träffas medans i IGMPv3 kan man filtrera och skriva om fält i paketen. Man kan styra minimum IGMP-version och på en trunk kan man filtrera per VLAN.

ACL Group and channel access control &amp; limit (per interface)
 access-list 12 permit 224.10.10.0 0.0.0.255
 interface Gi0/0
  ip igmp access-group 12
  ip igmp limit 10

Profile, only allow the specific multicast range
 ip igmp profile 1
  permit
  range 224.0.O.O 224.255.255.255
 int Gi0/0
  ip igmp filter 1

IGMP minimum version (global)
 ip igmp snooping minimum-version 2

Verify
 show ip igmp snooping filter
 show ip igmp profile

=IGMP Snooping=
Switchar kan använda IGMP snooping för att avlyssna IGMP-meddelanden och ta reda på vilka switchportar som ska ha vilka mac-adresser, dvs är med i vilken multicastgrupp. Om inte IGMP snooping är på floodas multicast-frames av switchar precis som broadcast och unknown unicast eftersom en multicast-MAC-adress aldrig finns i CAM då de aldrig används som source utan endast destination. På de flesta L3-switchar är IGMP Snooping påslaget default. Switchar behöver veta om det finns flera multicast-routrar på segmentet och på vilka portar de sitter därför lyssnas det efter ett flertal paket-typer: IGMP General Query (01:00:5e:00:00:01), OSPF (01:00:5e:00:00:05/6), PIMv1 och HSRP (01:00:5e:00:00:02), PIMv2 Hellos (01:00:5e:00:00:0d) och DVMRP probes (01:00:5e:00:00:04). IGMP snooping kontrollerar endast distribution av multicast-trafik till hostar medans routrar får frames för alla grupper.

När det kommer in en IGMP Report på en port tas Group Destination Address och läggs som forwarding på porten samt router-porten i CAM-tabellen, på så sätt har man fungerande multicast-forwarding. Kommer det in en annan IGMP Report med samma GDA läggs även den porten med som forwarding. Kommer det ett Leave-meddelande tas porten bort från forwarding och det kollas om det var den sista nonrouter-porten som var forwarding. Om det var den sista porten skickas Leave vidare till routern annars discardas det eftersom det är ointressant att skicka vidare. Eftersom switchar interceptar IGMP Reports får inte hostar varandras Reports utan alla måste skicka det, detta påverkar Report Suppression.

Global
 ip igmp snooping
 no ip igmp snooping vlan 10
Immediately remove a VLAN from multicast forwarding when an IGMP leave is received.
 ip igmp snooping vlan 11 immediate-leave

Verify 
 show ip igmp snooping
 show ip igmp snooping groups
 show ip igmp snooping mrouter

'''L2 only environment''' &lt;br/&gt;
Om en switch inte har någon mrouter port, t.ex. om det är en L2 only environment, kommer inte multicast-trafik att forwarderas vilket kan leda till blackholing. En mrouter port kan vara statically assigned eller dynamically learned. När det finns en mrouter port kommer IGMP reports att skickas på den. Man kan även ändra detta beteende så att en switch agerar proxy och själv skickar ut membership queries för att komma runt detta problem så att det forwarderas multicast-trafik.
 ip igmp snooping querier
 show ip igmp snooping mrouter 

===CGMP===
Cisco Group Management Protocol är ett protokoll som används av L3-enheter för att berätta för Cisco-switchar vilka hostar som ska ha multicast-trafik (OBS CGMP är gammalt och har spelat ut sin roll, IGMP Snooping är att föredra). Routrar lär sig vilka mac-adresser som är med i vilka multicast-grupper genom IGMP så de kan skicka ut CGMP-meddelanden som switchar lyssnar på. Då kan de ställa sina CAM-tabeller utifrån den informationen och inga hostar som inte ska ha multicast-trafik får det. CGMP skickas till 01:00:0c:dd:dd:dd så alla switchar får meddelandena. När en router kopplas till en switch skickar den ett CGMP-Join med Group Destination Address satt till 0 och Unicast Source Address satt till sig själv, då vet switchen var det finns en multicast-router. Detta skickas ut var 60:e sekund sålänge routern vill annars skickas ett CGMP-Leave med samma GDA och USA. Det som är skillnad mot vanlig IGMP är att även L2-informationen kollas på när en router får in ett IGMP Join och CGMP är konfigurerat. Denna mac-adress och multicast-grupp kan nu annonseras ut med CGMP-Join. När en switch får in ett CGMP-Join kollar den sin CAM-tabell efter USA och kan då lägga in multicast-mac-adressen (GDA) på samma interface, då blir den porten forwarding även för multicasttrafiken som den hosten har skickat IGMP Join för. Vill en host inte vara med i en viss grupp längre skickar den IGMP Leave och routern använder även här L2-informationen och det skickas ut ett CGMP Leave och switcharna kan ta bort GDA från porten där hosten sitter. Alla enheter som ska använda CGMP måste konfigureras för det, detta funkar ej om RGMP används.

L3-enhet
 interface gi2
  ip cgmp

Clear, skicka ut ett CGMP Leave med USA = 0 och GDA = 0 då kommer alla switchar att rensa alla CAM-entries som de satt tack vare CGMP.
 clear ip cgmp

'''RGMP''' &lt;br/&gt;
Router-Port Group Management Protocol (RFC 3488) är ett annat Cisco-protokoll som routrar kan använda för att kommunicera till switchar vilken multicast-trafik de vill ha. Genom att begränsa oönskad multicast-trafiken som routrar får in minskar man overhead. Alla RGMP-paket går till 01-00-5e-00-00-19, 224.0.0.25. Konfigurerar man RGMP disableas CGMP och vice versa.

* '''Hello:''' skickas var 30: sekund. När en switch får in ett RGMP Hello på en port slutar all multicast-forwardering på den porten.
* '''Join:''' för att en router ska få multicast-trafik av en switch måste den skicka RGMP Join för de grupper den vill ha.
* '''Leave:''' när en router inte längre vill ha trafik för en viss grupp skickar den ett RGMP Leave.
* '''Bye:''' när man slår av RGMP skickas ett RGMP Bye och switchen återgår till att forwardera all multicast-trafik.

 interface gi2
  ip rgmp

=IGMP Proxy=
IGMP proxy låter hostar i unidirectional link routing (UDLR) miljöer som inte har någon direktkoppling till någon downstream router att joina multicast-grupper.

 interface gi2
  ip igmp unidirectional-link 
 interface gi3
  ip igmp mroute-proxy lo2
 interface lo2
  ip igmp helper-address udl gi2 
  ip igmp proxy-service 

Verify
 show ip igmp udlr

=MVR=
Multicast VLAN Registration finns till för att effektivisera trafiken på switchens upplänkar om det finns många multicast-mottagare för samma grupper i olika VLAN. MVR använder ett dedikerat VLAN genom alla switchar som används för att leverera multicast feeden till alla receivers. Man måste ange detta, dvs i vilket VLAN källan för trafiken befinner sig. MVR går ej att köra samtidigt som multicast routing är påslaget.

 no ip multicast-routing
 mvr
 mvr vlan 200
 mvr group 239.1.1.10
 mvr mode dynamic  #skapa mroute states dynamiskt
 
 interface gi1
  description Uplink
  mvr type source
 
 interface gi2
  mvr type receiver

Verify
 show mvr
 show mvr interface
 show mvr members

=MLD=
Med IPv6 är multicast en central del eftersom broadcast inte finns och nu heter det Multicast Listener Discovery istället för IGMP. Det är inte ett eget protokoll utan en del av ICMPv6. MLD slåss på default när man slår på ipv6 multicast-routing på en router. Alla paket använder link-local adresser med TTL 1 och har Router Alert option satt. MLDv1 motsvarar IGMPv2 och MLDv2 motsvarar IGMPv3 för Source-Specific Multicast, RFC 4604. 

* '''Query:''' samma som IGMP. 0 är för generella queries annars specifik gruppadress. Skickas till FF02::1.
* '''Report:''' samma som IGMP och innehåller en specifik gruppadress.
* '''Done:''' motsvarar Leave message och innehåller en specifik gruppadress. Skickas till FF02::2.

Gå med i grupp manuellt
 ipv6 mld join-group FF08::10
Gå med i SSM-grupp
 ipv6 mld join-group FF36::8 2001::25

Verify
 show ipv6 mld interface
 show ipv6 mld snooping querier

Defaults per interface
 ipv6 mld query-max-response-time 10
 ipv6 mld query-timeout 255
 ipv6 mld query-interval 125

Membership limit on interface
 ipv6 mld limit 100

=NX-OS=
Här följer [[Cisco_Nexus|Nexus]]-specifik information. En skillnad mot IOS är att det saknas stöd för IGMP version 1 och Version 3 Lite. IGMP Snooping är på default och gör IP lookups default. En annan skillnad är att IGMP snooping querier inte konfas på L3 interface utan under VLAN:et. Se även [[Cisco_PIM#NX-OS|PIM]] för NX-OS.
 interface Ethernet1/1
  ip address 192.168.10.1/24
  ip pim sparse-mode
  ip igmp version 3
 
 vlan configuration 10
  ip igmp snooping querier 192.168.1.1

Verify
 show ip igmp snooping
 show ip igmp snooping querier
 show ip igmp route

[[Category:Cisco]]</text>
      <sha1>e0qnl4gmmsztlc2tcne2pnge64nij88</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco IOS</title>
    <ns>0</ns>
    <id>200</id>
    <revision>
      <id>3131</id>
      <parentid>3008</parentid>
      <timestamp>2021-11-10T13:37:28Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8173">IOS är den mjukvara som används av de flesta routrar och switchar av märket Cisco. Se även [[Cisco_Nexus|NX-OS]] och [[Cisco_IOS-XR|IOS XR]].

'''IOS-XE''' &lt;br/&gt;
IOS är ett monolithic operativsystem som är till åren därför har IOS-XE utvecklats som är betydligt modernare uppbyggt. Det kör en linuxkärna i botten och sedan ligger IOS som en daemon. Sedan kan ytterliggare processer köras för sig. Denna moduläritet gör systemet mer feltolerant, t.ex. ett fel i en process behöver inte påverka kärnan. IOS-XE har även APIer för control plane processer. Se även [[Cisco_CSR#Konfiguration|Cisco CSR]].

=Konfiguration=
'''Grundläggande'''
 hostname [hostname]
 enable secret [password]
 service password-encryption
 service nagle
 no ip domain lookup
 no ip http server
Se även Cisco [[Cisco_Logging|Logging]], [[Cisco_Services|Services]] och [[Cisco_Security|Security]].

Slå på loggmeddelanden i SSH terminal.
 terminal monitor

'''Resurser'''
 show platform resources  
 show platform hardware fed switch 1 fwd-asic resource tcam utilization

'''Line'''
 line con 0
  logging synchronous
  exec-timeout [minutes] [seconds]
  login
 line vty 0 15
  logging synchronous
  exec-timeout [minutes] [seconds]
  login #local
 
 show line vty

Reload
 reload in 3
 reload cancel

'''NETCONF'''
 netconf ssh
 ssh -s cisco@10.0.0.10 netconf

I nyare IOS-XE finns även restconf (XML eller JSON)
 restconf

'''Users''' &lt;br/&gt;
Kolla vilka som är inloggade.
 show users  /  who
 show tcp brief

Auto enable
 line vty 0 15
  privilege level 15

CLI history, lägg till '''all''' för att se alla kommandon dvs det som finns i crashinfo.
 show history   

Disable Express Setup (mode button for 3 seconds)
 no setup express

Conditional Debugging är bra på busy routers.
 debug condition int gi2
 debug ip rip

'''COPP'''
 cpp system-default
 show policy-map control-plane
 show policy-map system-cpp-policy
 show platform hardware fed switch 1 qos queue stats internal cpu policer

==Inbyggda Funktioner==
'''Meny''' &lt;br/&gt;
Man kan skapa menyer med menu-kommandot och sedan binda users till menyn.
 menu Menu01 line-mode
 menu Menu01 prompt ^R1#^
 menu Menu01 single-space
 menu Menu01 title ^Actions for restricted user^
 menu Menu01 text 1 Show routes
 menu Menu01 command 1 show ip route
 menu Menu01 text 2 Exit
 menu Menu01 command 2 exit
 
 username User01 autocommand menu Menu01

'''Macro''' &lt;br/&gt;
Med macros kan konfigurera att ett kommando gör många saker.
 define interface-range SERVERPORTS gi 0/3-9
 show parser macro

'''Schemaläggning''' &lt;br/&gt;
Funkar endast med exec mode kommandon
 kron occurrence OCC in 1 recurring
  policy-list TEST
 kron policy-list TEST
  cli show vers
 
 show kron schedule

'''Views'''
 enable view
 parser view SHOWONLY
 show parser view

'''Auto-install''' &lt;br/&gt;
Auto-install är en feature som kan hämta konfiguration från en filserver första gången en enhet startar. Det går att göra med [[Cisco_DHCP|DHCP]] eller RARP, preference är: sname, option 66, option 150, siaddr. Det försöker på alla tillgängliga interface. OBS för att auto-install ska triggas måste NVRAM vara helt tomt på konfigurationsfiler, '''erase nvram:'''.
 show auto install status

'''Linux shell''' &lt;br/&gt;
Man kan göra IOS lite mer likt ett Linux-skal och då får man tillgång till några basic linuxkommandon. Detta är en IOS 15 feature.
 terminal shell
Eller om man alltid vill ha det på. 
 shell processing full
Verify
 show terminal | grep Shell

'''XMCP'''
 service-routing xmcp listen 
  client username username password password 
  domain domain-number {default | only}
 show service-routing xmcp clients 
 show service-routing xmcp server 

Character Generator Protocol, port 19
 service tcp-small-servers

==EEM==
Cisco IOS Embedded Event Manager är ett subsystem som möjliggör event detection och onboard automation. Det är flexibelt och kan triggas vid kommando, händelse eller klockslag, '''show event manager version'''.

Exempel:
 event manager applet CLI_logger
  event cli pattern "show.*" sync no skip no
  action 01 syslog msg "$_cli_host executed: $_cli_msg"
 
 event manager applet NO_SH_RUN
  event cli pattern "show run" sync yes
  action 01 puts "CAN´T DO THAT"
 
 event manager applet Never_Back_Down
  event timer watchdog time 5
  action 01 cli command "enable"
  action 02 cli command "conf t"
  action 03 cli command "interface gi2"
  action 04 cli command "no shut"
 
 debug event manager action cli 

Verify
 show event manager policy registered

Trigga manuellt
 event manager run APPLET

EEM kan använda sig utav environment variable, t.ex. för att konfigurera en mailserver som flera applets kan dra nytta av.
 event manager environment _mail_server 172.22.0.10
Kolla alla inbyggda variabler, det finns en hel del.
 show event manager detector all detailed | i \$_

==Konfigurationshantering==
'''Archive and rollback'''
 archive
  path tftp://1.2.3.4/test
  write-memory 
  time-period 1440
 show archive

Kolla skillnad mellan running och startup config.
 show archive config differences
 
 alias exec '''diff''' show archive config differences
 alias configure '''diff''' do show archive config differences

'''Automatic Rollback''' &lt;br/&gt;
Prereq.
 archive
  path bootflash:/
  maximum 1
Ta en snapshot av konfigen när man går in i global configuration mode. Tappar man konnektivitet så rullas konfigen tillbaka efter 1 minut. 
 configure terminal revert timer idle 1
 
 configure confirm

'''Parser''' &lt;br/&gt;
Parser cache är påslaget default för att göra konfig-hantering snabbare.
 parser cache
 show parser statistics

Man kan reducera tiden det tar för ett kommando att exekvera. 
 parser config cache interface

Man kan begränsa så att endast en user i taget kan managera en enhet. 
 parser command serializer

'''Resilient Configuration'''
 secure boot-image
 secure boot-config
 show secure bootset
Restore
 secure boot-config restore flash:archived-config
 configure replace flash:archived-config

=Ethernet=
 show controllers ethernet-controller
 show interfaces counters errors
Default är Ethernet autonegotiation påslaget på switchportar. För att slå av det måste både speed och duplex ställas manuellt.
 int gi0/1
  speed 1000
  duplex full

CDP kan upptäcka duplex mismatch men ej fixa det. Ifall fel kabel (korsad eller rak) används finns Auto-MDIX för att upptäcka detta och ändra rx och tx på switchporten. 

Testa kabel, Time Domain Reflection
 test cable-diagnostics tdr interface gi 0/1
 show cable-diagnostics tdr interface gi 0/1

==CDP==
CDP är ett l2-protokoll för att upptäcka och utbyta information med directly connected Cisco-enheter, destination address är 01:00:0c:cc:cc:cc och det skickas var 60:e sekund. CDP går att använda för reliable policy routing och är ett prereq för Layer 2 traceroute. Aktuell version är CDPv2.
 cdp run
 cdp timer 60
 cdp holdtime 180
Slå på per interface
 interface gi2
  cdp enable
Verify
 show cdp
 show cdp neighbor

Det finns även stöd för den öppna standarden LLDP som använder 01:80:c2:00:00:0e. LLDP advertisements skickas var 30:e sekund och TTL är 120 sekunder.
 lldp run
 show lldp

CDP/LLDP kan användas för att sätta interface descriptions automatiskt utifrån neighbor hostname och port-id.
 event manager applet AUTOMATIC-PORT-DESCRIPTION
  event neighbor-discovery interface regexp GigabitEthernet.* cdp add
  action 10 cli command "enable"
  action 11 cli command "config t"
  action 12 cli command "interface $_nd_local_intf_name"
  action 13 cli command "description $_nd_cdp_entry_name:$_nd_port_id"
  action 14 syslog msg "Updated description $_nd_cdp_entry_name:$_nd_port_id on $_nd_local_intf_name"

=DNAC=
Cisco DNA Center är en kontroller- och analysplattform för Catalystnät. 

'''Reset switch''' &lt;br/&gt;
För att nollställa en switch som har varit managerad av DNAC måste man ta bort de certifikat som DNAC har installerat.
 conf t
  crypto key zeroize
  yes
  no crypto pki certificate pool
  yes
  end
 delete /force vlan.dat
 delete /force nvram:*.cer
 delete /force nvram:pnp*
 delete /force flash:pnp*
 write erase
 reload

[[Category:Cisco]]</text>
      <sha1>m0hi3nd2f9wl2ehklpgbh7fa80p3sdm</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco IOS-XR</title>
    <ns>0</ns>
    <id>265</id>
    <revision>
      <id>3139</id>
      <parentid>3077</parentid>
      <timestamp>2021-12-10T07:42:27Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8671">IOS XR är Ciscos OS framtaget för de större enheterna (främst mot service provider) tex CRS serien, 12000 serien och ASR9000 serien.

XR bygger på en micro-kernel arkitektur och är framtaget för att att utöka tillgängligheten på enheter t.ex. genom att ha redundant hårdvara (linjekort, cpu), felhantering som t.ex. skyddat minnesutrymme och med möjlighet att starta om specifika processer (kan ske per automatik). XR använder liknande modell som tex. Cisco Nexus där med distribuerad modell där man kan aktivera de delar man önskar tex. multicast eller MPLS.

IOS XR är likt Juniper's [[Juniper_JunOS|JunOS]] uppdelat i två lägen, admin-läge och "operations"-läge och XR har ett inbyggt system för hantera användare och grupper. Även i XR behöver man använda commit precis som i JunOS.

'''Security'''&lt;br/&gt;
IOS-XR har ICMP redirects disabled by default samt att directed-broadcast packets droppas. Cisco har mycket dokumentation kring security, [https://www.cisco.com/c/en/us/about/security-center/service-provider-infrastructure-security.html Service Provider Security]

==Konfigurationshantering==
Till skillnad från IOS så ändras inget innan man kör commit. Kommandon kopplat till konfigurationshantering.

Visa ändringar som kommer att installeras vid commit:
 show configuration
 alias config diff show commit changes diff

Visa hur hela konfiguration kommer se ut efter commit:
 show configuration merge

Göra commit med en märkning av konfigurationen:
 commit label add-loopback1337

Visa misslyckad commit tex. om något i konfiguration saknas eller är inkompatiblet (detta meddelas vid en vanlig commit)
 show configuration failed

Lista historiska förändringar:
 show configuration history

Backa konfiguration till specifik konfiguration:
 rollback configuration to add-loopback1337

Backa konfiguration till senaste konfiguration:
 rollback configuration last 1

Är man inte helt säker på sin commit kan man köra commit confirmed, då måste man aktivt skriva commit confirm annars görs automatiskt en rollback.
 commit confirmed
 commit confirm 

Export configuration on commit.
 configuration commit auto-save filename tftp://10.0.0.11/router1

Man kan använda regex-baserad replace av konfiguration, t.ex. om man ska döpa om en policy eller acl.
 replace pattern 'POLICYMAP-WRONG_NAME' with 'POLICYMAP-RIGHT_NAME'

Run silently without the user being prompted for yes/no.
 service cli interactive disable
 copy running-config disk0:test_config.txt

Default listas interface i bokstavsordning, detta går att ändra. 
 configuration display interface slot-order

To prevent the re-application of the commands which are already present in the running configuration.
 service cli commit-optimized enable

'''Konfigurationslås''' &lt;br/&gt;
Vid konfigurering kan konfigurationsläget göras exklusivt:
 configure exclusive

Visa låst konfiguration:
 show configuration lock

Visa vem som låst konfigurationen:
 show configuration sessions

==Admin==
Gå till admin läge, här kan man styra användares behörigheter, ändra config-register, installera funktioner etc.
Kommandon för admin-läget kan alltid köras genom tex "admin show running-config"
 admin

Visa konfiguration (enbat för Admin läge)
 (admin)#show running-config

Skapa användare
 admin
 conf t
 username juan
  group root-system
  secret cisco

====Fördefinierade grupper====
*root-system: Fullständig access

*netadmin:  Möjliggör konfiguration av tex OSPF eller EIGRP

*sysadmin: Möjliggör systemändringar tex dump av konfig eller tex. konfiguration av NTP

*operator: Kan titta i konfigurationen men je göra förändringar

*cisco-support: För Cisco TAC support

====Egna grupper====
I XR kan man skapa egna grupper för specifika ändamål

 taskgroup BGP
  task execute bgp
  task read bgp
  task write bgp

 taskgroup ISIS
  task execute isis
  task read isis
  task write isis

 taskgroup BGPISISTasks
  inherit taskgroup BGP
  inherit taskgroup ISIS

 usergroup BGPISISAdmins
 taskgroup BGPISISTasks

 username juan_bgp
  group BGPISISAdmins
  secret cisco

==Grundkonfiguration==
 hostname XR-01
 !
 ipv4 netmask-format bit-count
 !
 line console
  exec-timeout 30 0
 !
 line default
  exec-timeout 30 0
  access-class ingress ACL-MGMT-ACCESS
  transport input ssh

'''SSH'''
 crypto key generate rsa general-keys
 How many bits in the modulus [1024]: &lt;enter&gt;
 ssh server v2
 ssh server logging
 line default transport input ssh

SSH Package behövs.
 show install active | include k9

'''Logging'''
 logging on
  logging buffered 200000
  logging 10.0.10.12
Skicka godtyckligt loggmeddelande
 logmsg HEJ

'''NTP'''
 clock timezone CET Europe/Stockholm
 
 ntp
  server 79.136.86.176
  update-calendar

'''Tidszon'''
 clock timezone CET 1
 clock summer-time CEST recurring last sunday march 02:00 last sunday october 03:00

'''SNMP'''&lt;br/&gt;
För att spara lite CPU-cykler kan man slå på statsd caching. Detta är generellt rekommenderat.
 snmp-server ifmib stats cache

'''pyIOSXR''' &lt;br/&gt;
Enable XML agent
 xml agent tty iteration off

'''CDP''' &lt;br/&gt;
CDP är default avstängt globalt och per inteface i XR.
För att slå på CDP på XR måste det slås på globalt och per interface:

 cdp
  interface GigabitEthernet0/0/0/0
   cdp

'''MTU''' &lt;br/&gt;
MTU i IOS-XR räknas lite annorlunda kontra IOS eftersom L2 headern är inkluderad. Default har IOS och IOS-XR dock samma MTU på Ethernet-interface (L3: 1500B) men ska man köra jumbo frames och vill matcha är IOS-XR = IOS + 14, exempel:

IOS
 mtu 9216
IOS-XR
 mtu 9230

==Plattform==
 top
 show redundancy 
 show platform
 show install active summary
 show install committed summary
 show fpd package

Upgrade
 fpd auto-upgrade enable
 
 sysadmin-vm:0_RSP0# show install health
 install add source harddisk: asr9k-mini-x64-6.5.3.iso

===CoPP===
Control Plane Policing (CoPP) skyddar kontrollplanet för att säkerställa stabilitet, nåbarhet och paketleverans. CoPP i IOS-XR implementeras med hjälp av Local Packet Transport Services. LPTS är ett koncept med reflexsiva ACL:er, punt policers och en slags intern FIB. Detta skydd är på default med fördefinierade värden. Cisco rekommenderar att dessa lämnas default initialt för att eventuellt modifieras vid ett senare tillfälle utifrån behov. IOS-XR kan även hantera viss trafik direkt i linjekorten för att avlasta CPU, t.ex. BFD, Netflow och ARP kommer LPTS instruera lokal CPU att hantera istället för RSP CPU.
 show lpts bindings brief

'''MPP'''&lt;br/&gt;
Management Plane Protection är på default men alla TCP- och UDP-portar kan accessas ifrån alla interface. Detta går att strypa ner för både inband och OoB.
 control-plane
  management-plane
   out-of-band
    interface MgmtEth0/0/CPU0/0
     allow SSH peer
      address ipv4 10.0.0.0/24

===RPL===
När man editerar en existerande policy och commitar kommer det automatiskt att skickas BGP REFRESH, förutsatt att granne har denna capability. Det görs också en full table refresh eftersom förändringen kanske innebär att prefix som inte tidigare importerades nu ska importeras. Man behöver alltså inte göra någon soft reset som med IOS. Detta går att stänga av.
 bgp auto-policy-soft-reset disable

Troubleshooting - dry run
 show bgp route-policy &lt;ROUTE-POLICY-NAME&gt;

Kolla hur lång tid olika route-policy entries tar för en viss peering
 debug pcl profile detail
 !clear bgp peering
 show pcl protocol bgp speaker-0 neighbor-in-dflt &lt;neighbor&gt; policy profile

==HSRP==
 interface GigabitEthernet 0/0/0/0
  ip address 10.32.0.3 255.255.255.0
 router hsrp
  interface GigabitEthernet 0/0/0/0
  hsrp 1 ipv4 10.32.0.1
  hsrp 1 priority 95
  hsrp 1 preempt
  hsrp 1 track GigabitEthernet 0/0/0/1

==VRRP==
 interface GigabitEthernet 0/0/0/0
  ip address 10.32.25.3 255.255.255.0
 router vrrp
  interface GigabitEthernet 0/0/0/0
   address-family ipv4
    vrrp 1
     address 10.32.25.1
     priority 95
     track interface GigabitEthernet 0/0/0/0 10

==VRF==
Nedan exempel används ihop med MPLS och BGP.
 vrf 1337
  address-family ipv4 unicast
   import route-target
    1337:10
   export route-target
    1337:10
 
 router bgp 1337
  vrf 1337
   rd 1337:10
   address-family ipv4 unicast
    redistribute static

Protip: I XR när man kör "show run vrf xx" ser man bara det som finns konfigurerat under "vrf xx", inte tex det som rör vrf under bgp konfigurationen.
För att se allt i konfugrationen som rör en specifik vrf kan följande kommando användas:
 show run formal | i vrf 10

'''CEF''' &lt;br/&gt;
 show cef ipv6 exact-route 2001::2:2 2001::1:1 protocol icmp ingress-interface GigabitEthernet0/0/0/0.101

[[Category:Cisco]]</text>
      <sha1>r6grmp2nfhpepovhy2ac3nhmewd7no7</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco IPsec</title>
    <ns>0</ns>
    <id>267</id>
    <revision>
      <id>3094</id>
      <parentid>2803</parentid>
      <timestamp>2020-04-23T11:59:37Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13505">IPsec (RFC 4301) är en teknik för att skydda datakommunikation och räknas som en secure VPN. Det finns i tunnel och transport mode beroende på om det ska tunnlas och krypteras eller endast krypteras. IPsec funkar med IPv4/IPv6 och kan köras över en [[Cisco_GRE|GRE]]-tunnel. Virtual Tunnel Interface (VTI) är routebara interface som används för att terminera IPsec-tunnlar, detta gör IPsec flexibelt och det kan användas både för unicast och [[Cisco_Multicast|multicast]]. 

Se även [[Cisco_Security|Cisco Security]], [[Cisco_DMVPN|Cisco DMVPN]] och [[Cisco_ASA_VPN|ASA VPN]].

'''MTU''' &lt;br/&gt;
IPsec påverkar MTU, detta bör man ta med i beräkningarna. Notera att packet size inte är linjärt i förhållande till storleken på de enkapsulerade paketen eftersom ESP jobbar med block. Detta i kombination med att det finns väldigt många IPsec-algoritmer gör att det inte alltid är solklart exakt hur det blir men det finns verktyg som hjälper till att räkna på det. Med hjälp av detta kan man sätta en lämplig IP MTU på tunnel interface och sedan justera TCP MSS till 40 bytes lägre än det.
 https://cway.cisco.com/tools/ipsec-overhead-calc/

=Konfiguration=
Dead Peer Detection (DPD) &amp; NAT Keepalives
 crypto isakmp keepalive 30 
 crypto isakmp nat keepalive 30

Capabilities, Encryption Layer Interface
 show crypto eli

Errors and Invalid SPI Recovery Feature 
 crypto isakmp invalid-spi-recovery 

===Legacy===
IPsec VPN med crypto maps och IKEv1 är den äldsta och minst skalbara varianten av IPsec VPN.
 crypto isakmp policy 10
  encryption aes 256
  authentication pre-share
  group 20
  lifetime 86400
 
 show crypto isakmp policy

PSK Authentication
 crypto isakmp key S3cr3ts address 3.3.3.3
 
 show crypto isakmp key

'''Fas 2'''
 crypto ipsec transform-set PHASE2 esp-aes esp-sha-hmac
  mode tunnel
 ip access-list extended CRYPTO
  permit ip 192.168.1.0 0.0.0.255 192.168.2.0 0.0.0.255
 
 crypto map VPNMAP 10 ipsec-isakmp
  set peer 3.3.3.3
  set transform-set PHASE2
  match address CRYPTO

Interfaces
 interface GigabitEthernet0/1
  description Internet
  ip address 2.2.2.2 255.255.255.0
  crypto map VPNMAP
 
 interface GigabitEthernet0/2
  description Inside
  ip address 192.168.1.1 255.255.255.0

Verify Fas 1 och 2. Inget förhandlas förens det skickas trafik som triggar tunneln.
 show crypto isakmp sa
 show crypto ipsec sa
 show crypto session

Loopback
 crypto map VPNMAP local-address Loopback0
Reverse Route Injection
 crypto map VPNMAP 10 ipsec-isakmp
  set reverse-route distance 10
 
 show crypto route

==GRE over IPsec with Profile==
En fördel med att tunnla trafiken med [[Cisco_GRE|GRE]] är att routingprotokoll kan användas över tunneln. Trafiken krypteras efter att det har enkapsulerats med GRE. Man bör manuellt ange '''ip mtu''' på tunnel-interfacet för det tar ej hänsyn till ESP-enkapsuleringen som lägger till overhead.
 crypto isakmp policy 10
  encryption aes 256
  authentication pre-share
  group 20
  lifetime 86400
 
 crypto isakmp key S3cr3ts address 3.3.3.3    
 
 crypto ipsec transform-set PHASE2 esp-aes esp-sha-hmac 
  mode transport  #''Spara overhead genom att köra i transport mode''
 
 crypto ipsec profile GRE_OVER_IPSEC
  set transform-set PHASE2 
 
 interface Tunnel0
  ip address 1.1.1.1 255.255.255.0
  ip mtu 1400
  ip tcp adjust-mss 1360
  tunnel source Loopback0
  tunnel destination 3.3.3.3
  tunnel protection ipsec profile GRE_OVER_IPSEC
Verify
 show crypto ipsec profile
 show crypto session
Local och remote i IPsec SA kommer att förhandlas som ''tunnel-endpoint''/32 &lt;-&gt; ''tunnel-endpoint''/32 protokoll GRE vilket gör att det aldrig behövs mer än en entry per tunnel.

====FVRF====
Om interfacet som terminerar tunneln ligger i en vrf måste man använda en keyring som man lägger i en isakmp-profil.
 crypto keyring VPN_PEERS vrf Outside
  pre-shared-key address 3.3.3.3 key SecretKey
 
 crypto isakmp profile VPN_PROFILE
   keyring VPN_PEERS
   match identity address 3.3.3.3 255.255.255.255
   keepalive 10 retry 5

==VTI==
Med VPN som byggs med Virtual Tunnel Interface kan man både använda dynamic routing och multicast. Det fungerar likadant som GRE över IPsec men annan enkapsulering används. Payloaden enkapsuleras direkt i IPsec som är en IP-enkapsulering därför stöds inget annat än IP (så t.ex. IS-IS fungerar ej). Detta gör att tunnel-interfacet vet sin korrekta mtu. VTI konfigureras likadant som GRE över IPsec med profil men med en skillnad, här följer därför endast skillnaden samt att transform set alltid måste köras i tunnel mode.
 crypto ipsec transform-set PHASE2 esp-aes esp-sha-hmac 
  mode tunnel
 
 interface Tunnel0
  '''tunnel mode ipsec ipv4'''

Verify
 show crypto ipsec sa
 show crypto route
 show crypto session
Local och remote kommer alltid att förhandlas som '''0.0.0.0/0 &lt;-&gt; 0.0.0.0/0''' vilket gör att det aldrig behövs mer än en entry per tunnel.

===Dynamic VTI===
Man kan även låta VTI:s skapas dynamiskt.
 interface Virtual-Template1 type tunnel  
  ip unnumbered Loopback0 
  tunnel mode ipsec ipv4 
  tunnel protection ipsec profile VTI_PROFILE
 
 crypto isakmp profile VTI_ISAKMP_PROFILE
  keyring default  
  match identity address 0.0.0.0    
  virtual-template 1

Verify
 show interfaces virtual-template 1
  ...
  Tunnel linestate evaluation down - no IPv4 tunnel destination address
  Tunnel source UNKNOWN
  ...
 
 show interfaces virtual-access 1
  ...
  Tunnel vaccess, cloned from Virtual-Template1
  Tunnel linestate evaluation up
  Tunnel source 10.0.0.1, destination 10.0.0.2
  ...

Andra sidan konfigureras som en vanlig point-to-point IPsec tunnel.
 interface Tunnel10
  ip address 10.0.0.2 255.255.255.0
  tunnel source Loopback0  
  tunnel mode ipsec ipv4  
  tunnel destination 1.1.1.1
  tunnel protection ipsec profile IPSEC

==NAT-T==
IOS märker med hjälp av NAT-Discovery (RFC 3947) om paketen till och från remote peer natas och byter då till UDP 4500. Detta är på default men kan stängas av. Båda sidor måste ha stöd NAT-T för att det ska funka.
 no crypto ipsec nat-transparency udp-encapsulation

==IKEv2==
IKEv2 har inbyggt stöd för NAT traversal och ID är alltid skyddat till skillnad från IKEv1 aggressive mode.

Key ring
 crypto ikev2 keyring IKEv2_KEYRING
  peer SITE2
   address 3.3.3.3
   pre-shared-key local PSK01
   pre-shared-key remote PSK02

Proposal
 crypto ikev2 proposal IKEv2_PROPOSAL
  encryption aes-cbc-256
  integrity sha512
  group 20
 
 show crypto ikev2 proposal
''Används aes-gcm måste prf köras på båda sidor.''

Profile
 crypto ikev2 profile IKEv2_PROFILE
  match identity remote address 3.3.3.3 255.255.255.255
  identity local address 2.2.2.2
  authentication remote pre-share
  authentication local pre-share
  keyring local IKEv2_KEYRING
 
 show crypto ikev2 profile

Policy
 crypto ikev2 policy IKEv2_POLICY
  proposal IKEv2_PROPOSAL
 
 show crypto ikev2 policy

Transform set
 crypto ipsec transform-set SITE2 esp-aes 256 esp-sha-hmac
  mode tunnel
 
 show crypto ipsec transform-set

Crypto map
 crypto map IKEv2_MAP 1000 ipsec-isakmp
  set peer 3.3.3.3
  set transform-set SITE2
  match address CRYPTO
 interface gi2
  crypto map IKEv2_MAP
 show crypto map

Verify
 show crypto ikev2 sa

==High Availability==
För att få till HA kan man sätta upp det på olika sätt. Man kan t.ex. ha loopbacks som tunnel endpoints och sedan sköta konvergering med routingprotokoll. Man kan även bygga redundans genom att ha flera peer-adresser i sin crypto-map.
 crypto map VPNMAP 10 ipsec-isakmp
  set peer 2.2.2.2 default
  set peer 3.3.3.3

'''Stateless IPsec redundancy''' &lt;br/&gt;
Det finns inget samspel mellan IPSec och [[Cisco_HSRP|HSRP]], dvs HSRP kan inte hålla koll på IPSec's SA state och IPSec vet inte när HSRP gör en failover. Men det går att konfigurera crypto-mapen att sourcea IKE fas 1 och 2 från HSRP VIP och HSRP group names bör matcha på båda enheterna. Även om HSRP konvergerar snabbt kan det ta en stund innan IPsec-tunnlar är uppsatta på nytt efter en failover pga renegotiation. Därför är denna metod inte optimal utan det man t.ex. kan göra istället är att ha uppe två tunnlar parallellt och sedan styra routingen med [[Cisco_Routing#IP_SLA|IP SLA]].

 crypto dynamic-map VPNMAP 10
  set transform-set PHASE2
  match address ACL
  reverse-route
 
 crypto map CRYPTO 10 ipsec-isakmp dynamic VPNMAP
 
 interface GigabitEthernet0/1
  standby 1 name IPSEC
  crypto map CRYPTO redundancy IPSEC

'''Stateful IPsec redundancy''' &lt;br/&gt;
Det går även att synka SA-states mellan IOS-routrar vilket möjliggör snabbare överslag. Phase1/Phase2 session states synkroniseras mellan ACTIVE och STANDBY så inget behöver förhandlas om vid failover. Detta sköts automatiskt med hjälp av SCTP, men ingen konfiguration synkas utan det måste sättas upp symmetriskt. Utöver ovanstående HSRP/IPsec-konfiguration behövs synkronisering sättas upp.
 ipc zone default
  association 1
   protocol sctp
    local-port 5000
    local-ip 10.0.0.1
    remote-port 5000
    remote-ip 10.0.0.2
 
 redundancy inter-device
  scheme standby IPSEC
Verify
 show redundancy inter-device
 show crypto ha

==QoS==
Eftersom trafiken är enkapsulerad och krypterad måste QoS-markeringar/beslut fattas innan, man kan använda QoS pre-classify på crypto map. Se även [[Cisco_QoS|Cisco QoS]].
 crypto map VPNMAP 10 ipsec-isakmp 
  qos pre-classify

=GET VPN=
Group Encrypted Transport VPN är en Cisco proprietary VPN-teknik som inte använder point-to-point-tunnlar utan istället tillhandahåller any-to-any kryptering genom att alla inblandade enheter kör med samma IPsec-nycklar. Group Domain Of Interpretation (RFC 3547) är ett group key management protocol som används för att distribuera dessa nycklar till alla Group Members (IOS devices) som vill ha det. GDOI körs mellan GM och Key Server. KS är en IOS-enhet som är ansvarig för att skapa och hålla koll på GET VPN control plane. All policy konfigureras på den som t.ex. krypteringsalgoritmer, timers och vilken trafik som ska krypteras. Detta laddas sedan ner av GMs under registreringen. Även om inte all policy är intressant för alla kommer det fortfarande att hämtas från KS. GET VPN har stöd för multipla KS för HA och GMs kan konfigureras att registrera med flera. Den KS med högst prio blir primary KS och övriga blir secondary. Vid lika används högst IP som tiebreaker. Nycklarna refreshas med jämna mellanrum (default 24h) genom en rekey-process. Detta görs med UDP 848 antingen med unicast eller multicast. Använder man unicast kommer varje GM att skicka ACK message som svar på den nya nyckeln. Det är endast primary KS som skickar rekey messages. Normalt sett får GMs skicka trafik utan kryptering innan man har registrerat sig med KS, detta kallas Fail-Open.

GET VPN använder Tunnel mode IPSec men istället för att använda tunnel endpoints i den nya IP-headern återanvänds orginal-IP. Detta gör att GET VPN inte passar bra att köra över internet eftersom där kan inte privata adresser routas. Därför är GET VPN bäst lämpat för privata nät, t.ex. som gör över MPLS VPN eller VPLS. Vill man däremot köra det över internet kan man kombinera det med [[Cisco_DMVPN|DMVPN]].

GDOI Payloads
* GDOI SA
* SA KEK: används för att säkra GET VPN control plane
* SA TEK: används för att säkra data plane
* Key Download (KD)
* Sequence Number (SEQ)
* Proof of Possession (POP)

===Konfiguration===
'''Key Server''' &lt;br/&gt;
Generera RSA-nycklar
 crypto key generate rsa general-keys label GDOI_KEYS modulus 2048 exportable

KS har all IPsec-konfiguration som sedan laddas ner av gruppmedlemmarna
 crypto isakmp policy 10
  authentication pre-share
 
 crypto isakmp key 0 SECRET address 2.2.2.2   #GM-1
 crypto isakmp key 0 SECRET address 3.3.3.3   #GM-2 
 crypto isakmp key 0 SECRET address 4.4.4.4   #GM-3 
 
 crypto ipsec transform-set PHASE2 esp-aes esp-sha-hmac
 
 crypto ipsec profile GDOI_PROFILE
  set transform-set PHASE2
 
 ip access-list extended SYMMETRIC_ACL
  permit ip 172.16.0.0 0.0.255.255 172.16.0.0 0.0.255.255 
 
 crypto gdoi group GDOI_GROUP
  identity number 123
  server local
   rekey transport unicast
   rekey authentication mypubkey rsa GDOI_KEYS
   rekey retransmit 60 number 2
   sa ipsec 1
    profile GDOI_PROFILE
    match address ipv4 SYMMETRIC_ACL
    replay time window-size 5
   address ipv4 1.1.1.1 

'''Group Member'''
 crypto isakmp policy 10
  authentication pre-share
 
 crypto isakmp key 0 SECRET address 1.1.1.1   #KS
 
 crypto gdoi group GDOI_GROUP
  identity number 123
  server address ipv4 1.1.1.1 
 
 crypto map GETVPN local-address Loopback 0
 crypto map GETVPN 10 gdoi
  set group GDOI_GROUP
 
 interface Gi2
  description To KS
  crypto map GETVPN

'''Verify'''
 show crypto gdoi
 show crypto gdoi ks
 show crypto gdoi gm

'''COOP KS''' &lt;br/&gt;
För redundans och lastdelning kan man ha flera KS som då konfigureras likadant. Generera RSA-nycklar på primary KS och exportera både public och private till alla COOP KS. Notera att på vissa IOS-versioner går det att köra KS och GM på samma enhet men det är inte officially supported.
 crypto key export rsa GDOI_KEYS pem terminal 3des CISCO123 
 crypto key import rsa GDOI_KEYS pem exportable terminal CISCO123

'''Suite B''' &lt;br/&gt;
GET VPN har stöd för Suite B men måste sättas upp för det genom att på KS konfigurera de säkra algoritmer som ska användas.
 show crypto gdoi feature suite-b 

[[Category:Cisco]]</text>
      <sha1>17v8q5mkdrcobb588p2isj33fykx8q1</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco IS-IS</title>
    <ns>0</ns>
    <id>181</id>
    <revision>
      <id>3080</id>
      <parentid>3009</parentid>
      <timestamp>2019-12-07T17:40:00Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="24878">Intermediate System-to-Intermediate System är ett link-state routing protokoll. Det använder Network Service Access Point (NSAP) adressering för att identifiera routrar, area-tillhörighet och deras grannskap. IS-IS använder inte något L3-protokoll alls utan det enkapsuleras direkt i L2 multicast frames, för L1 används 01:80:C2:00:00:14 och för L2 01:80:C2:00:00:15, detta gör det helt L3-protokolloberonde. Grannskap och adressinformation skrivs med Type-Length-Value (TLV) records, detta gör det väldigt flexibelt. T.ex. om en ny adressfamilj eller ett nytt protokoll ska läggas till så handlar det om att definiera nya TLVer som innehåller adress- och topologiinformation. För lista med TLVer som IS-IS kan använda se IANAs [http://www.iana.org/assignments/isis-tlv-codepoints/isis-tlv-codepoints.xhtml TLV Codepoints].

IS-IS är ett av de tre protokollen i standarden Connectionless Network Services ([https://en.wikipedia.org/wiki/Connectionless-mode_Network_Service CLNS]), de andra två är CLNP och ES-IS. Numera används det vanligare för IP IGP och är bl.a. en del i klassisk [[Cisco_MPLS#Traffic_Engineering|MPLS Traffic Engineering]]. Level 3 routing är routing mellan domäner (AS) och det var tänkt att göras med protokollet IDRP men numera görs det fördelaktigt med [[Cisco_BGP|BGP]], som kan bära NSAP-adresser.

'''Type:''' Link State

'''Algorithm:''' Dijkstra

'''AD:''' 115

'''Protocols:''' IP, CLNS

'''Packets:''' 4

===Terminologi===
* End system: host
* Intermediate system: router
* Circuit: interface
* Domain: autonomous system
* SNPA: layer 2 address

==Packets==
'''Hello/IIH:''' IS-IS Hello används för att upptäcka grannar och kontrollera att de lever. De skickas default var 10:e sekund och innehåller en lista på alla grannar man har på segmentet om det är ett broadcastnäverk. De används också för att välja DIS (Designated IS) där det behövs. DIS skickar Hellos mer frekvent, hello time delat på 3 så var 3.33 sekund default. Hold time är Hello-interval x Hello-multiplier. Varken Hello eller Hold behöver matcha för grannskap. På broadcast segment används separata Hellos för L1 och L2 medans på point-to-point interface används gemensamma L1L2 Hellos pga effektivitet. Hello padding görs default för att ta reda på hur stora frames som kan skickas. 

&lt;div class="mw-collapsible mw-collapsed" style="width:450px"&gt;
L1 Hello:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_ISIS_Hello_L1.png]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:450px"&gt;
L1L2 Hello:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_ISIS_Hello_L1L2.png]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:450px"&gt;
P2P Hello: (finns ingen prio utan istället finns Local Circuit ID)
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_ISIS_Hello_P2P.png]]
&lt;/div&gt;
&lt;/div&gt;

Timers ställs per interface. Default är 10 sekunder och multiplier är 3 för hold time.  
 isis hello-interval 10 [level]
 isis hello-multiplier 3 [level]


'''Link state PDU:''' 
LSPs används för att skicka routing-information till andra IS. Det finns inte olika LSP-typer som OSPF har olika LSA-typer utan adjacencies och prefixes skickas med en LSP som innehåller olika TLVer. En LSPs payload kan därmed variera i storlek. Varje LSP innehåller ett LSPID som gör det unikt. Det består av System ID (router that originated the LSP), Pseudonode ID (DIS) och LSP number (fragment number). För att skilja mellan olika versioner av samma LSP sätts även ett löpnummer. Det börjar på 1 och varje gång en ändring görs ökas det med 1. 

Om Attached Biten är satt i LSP-headern betyder det att den kommer ifrån en nod med ben i en annan area eller L2, det finns flera "Attached bits" men endast default metric används på Cisco IOS. För att en L1L2 ISIS router ska sätta ATT-biten på sina LSPer måste den vara ansluten till två olika areor. Den behöver inte själv vara directly attached till en annan area men arean måste finnas kopplad till L2. Varje LSP har även en remaining lifetime satt, det börjar på 1200 sekunder och tickar neråt. Var 900:e sekund så refreshar en IS-IS router sina self-originated LSPer och skickar ut dem pånytt. Går remaining lifetime ner till 0 på en LSP tas routing informationen bort från LSDB och routern kommer att flooda ut endast LSP:ns header med remaining lifetime satt till 0 för att signalera att man vill ha ny information och på så vis ta reda på om någon annan känner till mer aktuell information, detta kallas LSP Purge. LSP headern hålls kvar i LSDB så länge som ZeroAgeLifetime är satt till, 60 sekunder default men kan sparas 20 minuter på Cisco-routrar. 
 router isis
  max-lsp-lifetime 1200
  lsp-refresh-interval 900

Eftersom IS-IS paket enkapsuleras direkt i L2-frames måste IS-IS ha en egen fragmenteringsfunktion för LSPer som är större än MTU. Behöver man skicka en LSP vars header + TLVer är större än MTU så delar routern upp det i flera LSPer som innehåller några TLVer var. LSPerna har samma LSPID men LSP/fragment number ökas per LSP med start från 0. Fragmentering görs av den router som skapar LSPn, när den sedan har skickats ut får den inte modifieras eller fragmenteras om. Detta leder till att MTU på alla interface inom arean måste vara identiskt. Annars får man manuellt ställa lsp-storlek på alla enheter så det inte överstiger lägsta MTU.
 lsp-mtu 1400

&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_ISIS_LSP.png]]
&lt;/div&gt;
&lt;/div&gt;


'''Complete Sequence Numbers PDU:'''
CSNP används för att synkronisera LSDB mellan enheter (fungerar ungefär på samma sätt som DD i OSPF). CSNP innehåller en komplett lista med alla LSPer som routern har och mottagaren kan jämföra det mot sin egen LSDB. Finns det någon LSP som mottagaren ej har kan den requesta den och fattas det någon hos avsändaren floodas den tillbaka. Finns det fler LSPID:n än vad MTU klarar skickas det flera paket. Varje CSNP specificerar vilka LSPID:n den innehåller och det börjar på 0000.0000.0000.00-00 och räknar uppåt (stigande). 

På point-to-point-länkar utbyts CSNP vid adjacency buildup och på broadcast skickas det regelbundet av DIS. Eftersom ack sköts av PSNP på point-to-point-länkar skickas inga CSNP periodiskt, detta kan man slå på manuellt med interface-kommandot '''isis csnp-interval &lt;nonzero value&gt;'''

&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_ISIS_CSNP.png]]
&lt;/div&gt;
&lt;/div&gt;


'''Partial Sequence Numbers PDU:'''
PSNP skickas för att requesta eller acka en LSP (fungerar både som OSPF LSR och LSAck). En PSNP kan requesta eller acka flera LSPer. På broadcast används dock PSNP endast för Request eftersom Ack görs av CSNP från DIS.

&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_ISIS_PSNP.png]]
&lt;/div&gt;
&lt;/div&gt;

==Levels==
En IS-IS router konfigureras med nivå som anger systemtyp - antingen Level 1, Level 2 eller Level 1-2. Se en Level 2 router som motsvarande area 0 (backbone area) i [[Cisco_OSPF|OSPF]] och Level 1 som en area som är ”NSSA Totally Stubby ”, d.v.s. det enda som injiceras i arean är en default route samt att redistribution från andra routingprotokoll är tillåtet, och en Level 1-2 som en ABR.

IS-IS routrar på level 1 agerar oberoende av level 2 och vice versa. De upprättar separata grannskap på varje level. T.ex. om det finns två stycken IS-IS routrar som båda kör L1 och L2 så kommer de att ha två grannskap med varandra. Det blir bara grannskap om båda är på samma level, t.ex. L2 + L1L2 = L2-grannskap. De kommer även hålla separata LSDBer för varje level. Så Link State PDUer som skickas görs det antingen på L1 eller L2. L1-LSPer beskriver grannskap i L1 och samma gäller för L2. Det går nästan likna vid separata routing-processer. Att ändra mellan L1, L2 och L1L2 görs per router.
 router isis 1
  is-type level-1-2  #Default
Men det går att ändra per interface för att sluta skicka Hellos för en specifik level. T.ex. om man själv är L1L2 och vet man att andra sidan är en L1 only är det onödigt att skicka L2 Hellos.
 interface gi2
  isis circuit-type {level-1 | level-2 | level-1-2}

Show
 show isis protocol | i IS-Type

'''Backdoor''' &lt;br/&gt;
Default använder L1-routrar den närmaste L1L2-routern som gateway of last resort. Det är inte alltid man vill ha det så, då kan man stänga av att L1L2-routern sätter attached bit i sina Hellos och övriga routrar kommer inte att installera en default route till den. 
 is-type level-1-2 backdoor 

===NET===
Network Entity Title kallas den adress som IS-IS-processer (och därmed noder) använder, längden kan variera mellan 64 och 160 bitar men det måste vara jämt antal bytes. Formatet är AFI.DSP.SystemID.NSEL:
* AFI = 49
* DSP(Area ID) = 0001
* SystemID = Räknas fram baserat på Loopback adressen
* NSEL = 00

===Areas===
Eftersom en nod endast har en NSAP-adress tillhör en nod och alla dens interface samma area (det går att konfigurera upp till 3 NSAP-adresser men det är endast användbart under splitting/joining/renumbering areor och det skapas bara en mergead LSDB och SystemID måste vara samma). Två L1-noder med olika areor upprättar inte grannskap medans L2 inte bryr sig om area-ID. Både L1 och L2 annonserar sina directly connected IP networks till sina grannar. Är en nod L1L2 redistribueras alla routes från L1 till L2 medans åt andra hållet går endast en default route default. Detta leder till att backbone känner till alla routes. 

===Nätverkstyp===
Till skillnad från OSPF finns det endast två nätverkstyper, broadcast och point-to-point. På broadcast-segment har man en pseudonod som alla formar grannskap med, denna kallas Designated IS och är motsvarigheten till DR i OSPF. Man låter en enhet stå för LSP för segmentet annars blir LSDB större och rörigare. Dock är det skillnad på hur flooding fungerar. Alla uppdaterar alla vilket leder till att det inte behövs någon "Backup" DIS. DIS floodar periodvis sin databas och finns det då med någon LSP som en IS inte har fått märker den det och begär att få den av DIS. Detta leder också till att DIS kan ersättas preemptively vilket inte OSPF DR kan. 

Den som väljs till DIS är den med högst prio (default 64), vid lika är högsta MAC-adress tie breaker. 
 interface gi2
  isis priority 100
 show clns interface | i DR

==Metrics==
IS-IS använder bandwidth som metric precis som OSPF. Från början fanns det 4 olika metric-typer men i princip är det endast default (bandwidth) som används idag. Default så får alla interface en cost av 10 oavsett bandbredd. Med andra ord så räknar inte routern ut cost på en länk så som andra routing protokoll gör utan det är upp till administratören att manuellt ställa metric per interface om man vill. Likt OSPF är det inte metric som i första hand jämförs vid path selection utan det är typ av route där L1 &gt; L2 &gt; external. Nedan visas det som kallas ''narrow metrics'', det är legacy och är inte default på Cisco-routrar.
 isis metric 1-63
'''Wide metrics''' togs fram för att man hade behov av större metrics och det har 24-bitars längd. Detta är alltid rekommenderat men alla enheter inom arean måste stödja det. T.ex. krävs det för MPLS traffic engineering över IS-IS. 
 router isis
  metric-style wide
Det går även att acceptera båda typerna av metric.
 metric-style transition
Verify
 R1# show isis protocol | i metrics
  Generate narrow metrics: none
  Accept narrow metrics:   none
  Generate wide metrics:   level-1-2
  Accept wide metrics:     level-1-2

=Konfiguration=
Om man ska köra med flera areor på en enhet måste man ange tag för varje IS-IS-process. Den första IS-IS instansen som konfigureras blir default L1L2 och därefter blir instanser L1. Det finns även RFC för defaultvärden för att underlätta interoperability (RFC 8196).
 router isis [tag]
  is-type level-1-2
  log-adjacency-changes
  net 49.0001.0001.0001.0001.0001.00
 
  address-family ipv4 unicast
  exit
  address-family ipv6 unicast
  exit

Passive interfaces, med passive interface default annonseras allt som är directly connected i isis men inga grannskap byggs förrens man tar bort passive på något interface. Det är även med passive interfaces man gör prefix suppression. 
  passive-interface default
  no passive-interface te0/1/1
 
  passive-interface lo0
  advertise passive-only

För att skicka en default route i level 2
 default-information originate

Verify
 show isis
 show isis database

'''Default konfiguration''' när man drar igång IS-IS (kan skilja mellan IOS-versioner).
 router isis
  no protocol shutdown
  max-area-addresses 3
  no fast-flood
  adjacency-check
  no use external-metrics
  metric 10 level-1
  metric 10 level-2
  hello padding
  no nsf cisco
  no nsf ietf
  maximum-paths 4  #Max är 32
  distance 115 ip
  no bfd all-interface
  no bfd check-ctrl-plane-failure

Vänta med att använda en granne som nyss har bootat.
 set-overload-bit on-startup 180

'''MPLS''' &lt;br/&gt;
[[Cisco_MPLS|MPLS]] LDP kan autokonfigureras med hjälp av IS-IS. Man kan även synka IS-IS mot LDP, dvs låta LDP bli klar innan länken får en normal (låg) IGP-metric och därmed börjar användas. 
 mpls ldp autoconfig
 mpls ldp sync
 
 show isis mpls ldp
IS-IS kan även användas för [[Cisco_SR|Segment Routing]] med MPLS.

==Adjacency==
Enablea IS-IS på interface. Interface MTU måste matcha för grannskap. Grannar måste även vara i samma IP subnet för att adjacency ska gå upp, detta behövdes inte förr men nu är checken på default. Går inte grannskap upp kan det också bero på duplicate system ID men det säger loggen tydligt.
 interface te0/1/1
  ip router isis 1
  no isis hello padding
  isis network point-to-point  #effektivisera LSP-hantering
  no shut

'''Verify'''
 show isis hostname
 show isis neighbors/adjacency
 show isis topology
 show clns neighbor

===Authentication===
IS-IS authentication skiljer sig ganska mycket från authentication med övriga IGP:er. Authentication för Hellos görs fristående från övriga pakettyper. Authentication görs med en TLV och en LSP får ej modifieras av någon annan än originator, detta medför att alla inom arean måste ha samma authentication på sina LSP/CSNP/PSNP men det blir inget krav på Hellos. Sålänge Hello-paket autentiseras korrekt kommer grannskap att bli Up men det behöver inte betyda att LSP:er kan utbytas utan då måste som sagt area/domain password matcha. Authentication kan göras med clear text eller md5. Använder man en key chain så skickas heller inte key id med.

Hello-paket görs per interface oavsett level.
 interface gi2
  isis authentication mode md5
  isis authentication key-chain &lt;key-chain-name&gt;
LSP authentication
 router isis 1
  authentication mode md5
  authentication key-chain &lt;key-chain-name&gt;

==Redistribution==
Routes som redistribueras in i IS-IS får default metric 0. En viktig faktor för route leaking i ISIS är U/D-biten i TLV:n för routen. Den fyller samma funktion som Down-biten i OSPF, den används för att förhindra loopar. En L1L2-router som via L1 får in routes med U/D-biten satt kommer inte att skicka in den till L2.

Redistribution into level 2. Redistribution into level 1
 redistribute static ip
 redistribute static ip level-1
 
 show isis ip rib redistribution

Man kan läcka L2 routes till L1 med hjälp av redistribution.
 redistribute isis 1 ip level-2 into level-1 distribute-list ''ACL''

===Summary===
När routes går mellan areor eller redistribueras kan man summera (likt OSPF). 
 summary-address 10.1.0.0 255.255.0.0 [level]
* level-1: endast routes redistribuerade in i Level 1 summeras.
* level-1-2: routes redistribuerade in i Level 1 summeras och routes från Level 1 routing eller redistribution summeras in i Level 2 backbone.
* level-2: routes från Level 1 routing eller redistribution summeras in i Level 2 backbone.

==IPv6==
IS-IS är oberoende av L3-protokoll för grannskap och kan bära information om destinationer för olika adressfamiljer. IPv6 prefix kan skickas med samma IS-IS-process, i samma LSP:er över samma grannskap som IPv4 och samma L1/L2-förhållanden gäller då för IPv6. Det man däremot bör ha koll på är om IPv4 och IPv6 ska använda samma topologi eller ej, ska man köra single topology krävs en 1:1-korrelation mellan IPv4 och IPv6 interface (dvs dual stack överallt) och då kommer det endast göras en SPF-beräkning. Adjacency checken som är på default rejectar Hellos från grannar som inte kör IPv6. Ska man köra multi topology behöver man inte ha dual stack överallt, SPF beräknas fristående per protokoll och man måste använda wide metrics. Det konfigureras under adressfamiljen. Man kan även köra multi-topology under en transitionsperiod, då accepterar och genererar man både IS-IS IPv6 och Multi-topology IPv6 TLVs.

Den mesta av konfigurationen görs under adressfamiljen, till skillnad från IPv4. IS-IS kommer att skicka vidare IPv6-information men ej börja använda det förens man lagt in ''address-family ipv6''.
 router isis 1
  address-family ipv6 unicast
   multi-topology [transition]
   maximum-paths 16
  exit
Verify
 show ipv6 route isis
 show isis ipv6 topology  #Multi topology
 show isis ipv6 rib

==Convergence==
Timers
 lsp-gen-interval 5 50 50
 prc-interval 5 50 50
 spf-interval 5 50 50

'''Nonstop Forwarding''' &lt;br/&gt;
När en router gör en RP switchover måste den nya snabbt få all info om adjacencies och en synkad LSDB. IS-IS NSF kan möjligöras på två sätt.

* IETF (RFC 3847): NSF-kapabla enheter skickar IS-IS NSF restart requests till grannarna som är NSF-aware. Då förstår de att de inte ska starta om grannskapet utan istället initiera en LSDB-synkronisering. Grannarna måste ha stöd för NSF IETF.
* Cisco: Skickar både protocol adjacency och link-state information från aktiv RP till standby. Detta är inte beroende av att grannarna är NSF-aware.

'''BFD''' &lt;br/&gt;
När IS-IS konfigureras med [[Cisco_BFD|BFD]] blir det ett registrerat protokoll till BFD och kan dra nytta av de forwarding path detection failure messages som BFD tillhandahåller. Det kan antingen konfigureras under adressfamiljen eller per interface. 
 int te0/1/1
  bfd interval 50 min_rx 50 multiplier 5
  isis bfd
IS-IS-klienten kan även utnyttja BFD C-biten för att veta om det är ett äkta data plane failure eller om det är resultatet av ett control plane failure t.ex. pga reboot, detta är på default. 
 router isis 
  bfd check-control-plane-failure 

'''iSPF''' &lt;br/&gt;
SPF-algoritmen behöver inte köras för alla länkar varje gång det sker en topologi-förändring. Med incremental SPF körs endast algoritmen för de delar som har påverkats av förändringen för att spara CPU-cykler. Detta går att styra individuellt på enheterna med ispf-kommandot. Det kan vara svårt att veta exakt hur mycket skillnad detta gör men generellt ju större topologi ju större skillnad. OBS iSPF är inte längre supporterat i IOS.
 router isis 1
  ispf level-1-2 10
 show isis protocol | i Incremental

'''Fast flood''' &lt;br/&gt;
Man kan välja att LSP:er ska floodas innan SPF-beräkningen påbörjas för att få snabbare konvergenstid. Detta är ej påslaget default. 
 router isis 1
  fast-flood

===Loop-Free Alternate Fast Reroute===
Med IP LFA FRR kommer IS-IS beräkna loop-fria next-hop routes till forwarding plane som kan användas om primary path går ner. Detta beräknas per prefix. LFA är en next-hop route som skickar paketet till destination utan att loopa tillbaka det. LFA gör ingen signaling utan lokal router räknar själv. 

* '''P:''' de noder man kan nå utan att gå igenom länken man vill skydda
* '''Q:''' de noder som kan nå destination utan att gå igenom länken man vill skydda
Finns det inga PQ får man extenda P space genom att kolla P noder utifrån dina grannar.

'''Remote LFA''' &lt;br/&gt;
Med IS-IS remote LFA FRR kan man skapa backup paths som är flera hop bort, dvs man man tunnlar det till en drop off point som sedan skickar till slutdestination. Det man gör i praktiken är att tunnla till närmasta PQ. Detta är t.ex. användbart i ringtopologier. IS-IS stödjer detta endast när också targeted LDP stöds. LFA-beräkningar är begränsade till interface/länkar som tillhör samma area och level. Finns det multipla LFAs för en primary path så kommer IS-IS att använda en tiebreaking rule för att välja en LFA och finns det multipla LFA paths så kommer prefixen att distribueras jämt mellan dem. Eftersom IS-IS kollar på prefixen efter att SPF har körts kan best repair path hållas efter att grannen har kört SPF. När man slår på remote LFA enableas microloop avoidance med delay 5000 ms. Alla IS-IS interface måste vara point-to-point.

 router isis 1
  fast-reroute remote-lfa level-2 mpls-ldp
 
 show isis fast-reroute remote-lfa tunnels

'''TI-LFA''' &lt;br/&gt;
Med Topology Independent LFA får man alltid post-konvergens routen och den är garanterat loopfri med 100% coverage. Syftet med TI-LFA är att garantera link protection i symmetric metric networks (t.ex. ringnät), skydda IP och MPLS-trafik samt undvika congestion och suboptimal routing genom att undvika high metric links. TI-LFA använder inte targeted LDP utan det bygger på Segment Routing.
 router isis 1
  segment-routing mpls
  ip route priority high tag 1000
  fast-reroute per-prefix level-2 all
  fast-reroute ti-lfa level-2
Verify
 show isis fast-reroute summary
 show isis fast-reroute interfaces
 show isis fast-reroute ti-lfa tunnel
 show ip route repair-paths

=NX-OS=
Grundkonfiguration
 feature isis
 
 router isis IS
  net 49.0001.0001.0001.0001.0002.00
  is-type level-1
  passive-interface default level-1
  log-adjacency-changes
 
  address-family ipv4 unicast
  exit
NX-OS, några defaults
 router isis IS
  graceful-restart
  maximum-paths 8
  max-lsp-lifetime 1200
  lsp-mtu 1492
  reference-bandwidth 40 Gbps

Fast convergence
 spf-interval level-2 5000 50 50
 lsp-gen-interval level-2 5000 50 50
Authentication
 authentication-type md5 level-2
 authentication key-chain &lt;key-chain-name&gt; level-2
Vänta med att använda en granne som nyss har bootat.
 set-overload-bit on-startup 180

Interface
 int lo0
  ip router isis IS
 
 interface e1/1
  no switchport
  ip router isis IS
  no isis passive-interface level-2
  no isis hello-padding
  isis network point-to-point
  isis authentication-type md5 level-2
  isis authentication key-chain &lt;key-chain-name&gt; level-2
Genom att använda network type p2p effektiviserar man LSP-hanteringen. Det går även att använda kommandot "medium p2p" för att uppnå detta.

[[Cisco_BFD#NX-OS|BFD]]
 feature bfd
 interface e1/1
  bfd interval 50 min_rx 50 multiplier 3
  no bfd echo
  isis bfd

=IOS-XR=
IOS-XR IS-IS kör default i Multi Topology mode.

 router isis 1
  set-overload-bit on-startup 180
  is-type level-2-only
  net 49.0000.0000.0011.00
  nsr
  nsf cisco
  log adjacency changes
  lsp-refresh-interval 65000
  max-lsp-lifetime 65535
  lsp-password keychain ISIS-KEY
  address-family ipv4 unicast
   metric-style wide
   advertise passive-only
  !
  address-family ipv6 unicast
   metric-style wide
   advertise passive-only
  !
  interface Loopback0
   passive
   address-family ipv4 unicast
   !
   address-family ipv6 unicast
  !
  interface TenGigE0/0/0/10
   point-to-point
   hello-password keychain ISIS-KEY
   address-family ipv4 unicast
    fast-reroute per-prefix
    fast-reroute per-prefix ti-lfa
    metric 100

'''LFA'''&lt;br/&gt;
 router isis 1
  interface GigabitEthernet0/0/0/0
   address-family ipv4 unicast
    fast-reroute per-prefix
    fast-reroute per-prefix ti-lfa
   address-family ipv6 unicast
    fast-reroute per-prefix
    fast-reroute per-prefix ti-lfa
IOS-XR har även per-link LFA men det finns egentligen inget use case för det längre. Default märker ISIS /32-prefix som Medium priority och allt annat som Low priority.
 show isis fast-reroute summary
 show cef fast-reroute

'''Prefix Prioritization'''
 router isis 1
  address-family ipv4 unicast
   spf prefix-priority level 2 high tag 100
  !
  interface Loopback0
   address-family ipv4 unicast
    tag 100
När man konfigurerar några prefix med high priority så får alla andra prefix (inklusive /32) low priority. 

'''SRLG'''
 srlg
  interface GigabitEthernet0/0/0/1
   8 value 10
  ! 
  interface GigabitEthernet0/0/0/2
   8 value 10
 !
 router isis 1
  address-family ipv4 unicast
   fast-reroute per-prefix tiebreaker srlg-disjoint index 40
   fast-reroute per-prefix tiebreaker lowest-backup-metric index 50

[[Category:Cisco]]</text>
      <sha1>f1ef8n38h8tni37f7wo3ylzn83zknnb</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco L2VPN</title>
    <ns>0</ns>
    <id>264</id>
    <revision>
      <id>3097</id>
      <parentid>3070</parentid>
      <timestamp>2020-05-18T08:13:09Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10512">Provider-provisioned Layer-2 Virtual Private Network. Att sträcka L2 är aldrig häftigt men man får göra så gott man kan med [[Cisco_STP|STP]] alternativt ha routrar direkt på andra sidan. Se även [[Cisco_MPLS|Cisco MPLS]].

===Ethernet Virtual Circuit===
Att binda en kund eller tjänst till en port eller VLAN var en begränsande faktor i access-lagret. Därför togs EVC framework fram för att komma förbi det. Det är en unified software infrastructure för att konfigurera Ethernet services. Tanken är att låta access circuits mappas till flera olika typer av Ethernet-tjänster så som L2 point-to-point local connects, L2 point-to-point xconnects, L2 multipoint-to-multipoint VPLS och andra tjänster. Man kan genom att välja encapsulation även vlan-tagga, dubbel-tagga eller skriva om vlan-tag.

 interface GigabitEthernet2
  no ip address
  service instance 10 ethernet
   encapsulation default
   xconnect 19.19.19.19 219 encapsulation mpls
Verification
 show ethernet service instance summary
 show ethernet service instance id 10 interface gig2 detail
 show l2vpn service all 

'''BFD'''&lt;br/&gt;
 bfd-template multi-hop MH
  interval min-tx 200 min-rx 200 multiplier 3 
 bfd map ipv4 1.1.1.0/24 1.1.1.1/32 MH
 
 pseudowire-class MPLS-BFD
  encapsulation mpls
  monitor peer bfd local interface Loopback0

=VPLS=
Virtual Private LAN Service (VPLS) är ett sätt att tillhandahålla Ethernet-baserad multipoint-to-multipoint-kommunikation över IP eller MPLS. Multipla siter kopplas ihop med hjälp av full mesh pseudowires. VPLS använder Virtual Forwarding Instance (VFI) för att hosta alla pseudowires för en tjänst. Den vanligaste bäraren är MPLS och för control plane (Auto-Discovery/Signaling) kan LDP eller [[Cisco_BGP|BGP]] användas. Det finns inbyggd loop prevention i form av att frames som kommer ifrån en VPLS aldrig får skickas vidare inom VPLS (split-horizon). En begränsande faktor för VPLS är minnesmängden på Edge devices eftersom de måste lära sig kundens MAC-adresser. All MAC Learning är data plane driven. Det fungerar som en vanlig bridge dvs det är dynamiskt och baserat på source MAC. By default så age:ar VFI:er ut inaktiva MAC-adresser efter 5 minuter.

Manual VPLS, legacy syntax. Bridge domain används för mac learning samt att binda ihop Ethernet UNI med LSP. Man kan ej blanda gammal och ny syntax pga att bridge-domain betyder olika beroende på config context.
 l2 vfi VPLS manual
  vpn id 100
  bridge-domain 1
  neighbor 10.0.0.2 encapsulation mpls
  neighbor 10.0.0.3 encapsulation mpls
 
 interface gi2
  service instance 10 ethernet
   encapsulation default
   bridge-domain 1

Bridge Domain Centric (preferred syntax). Full mesh scaling är ett administrativt problem oavsett syntax.
 l2vpn vfi context VPLS
  vpn id 100
  member 10.0.0.2 encapsulation mpls
  member 10.0.0.3 encapsulation mpls
  member 10.0.0.4 encapsulation mpls
 
 interface gi2
  service instance 10 ethernet
   encapsulation default
 
 bridge-domain 1
  mac limit maximum addresses 50
  member gi2 service-instance 10
  member vfi VPLS 

Verify
 show l2vpn vfi
 show bridge-domain
 show l2vpn service all 
 show mpls l2transport vc
 show mpls forwarding-table | i l2ckt

Man kan även koppla in L3-interface på sin bridge-domain.
 interface BDI1
  ip address 172.20.0.10 255.255.255.0

===BGP Autodiscovery===
'''LDP''' based VPLS med BGP Autodiscovery (RFC 4762). BGP används för att upptäcka VPLS-endpoints automatiskt för varje VPN och VC-grannar konfigureras ej maneullt. Varje VPLS får en egen rd och detta går att använda i kombination med route reflector.

 l2vpn vfi context VPLS
  vpn id 100
  autodiscovery bgp signaling ldp
   auto-route-target  #på default
 
 router bgp 100
  address-family l2vpn vpls
   neighbor 1.1.1.1 activate
   neighbor 1.1.1.1 send-comunity extended
Verify
 show bgp l2vpn vpls all summary

'''BGP''' based VPLS med BGP Autodiscovery (RFC 4761). BGP används för att upptäcka VPLS-endpoints men också för att signalera labels. Man måste suppress ldp signaling för att slå på bgp signaling.
 l2vpn vfi context VPLS
  vpn id 100
  autodiscovery bgp signaling bgp
   ve id 11  #unik per VPLS Edge device 
 
 router bgp 100
  address-family l2vpn vpls
   neighbor 1.1.1.1 suppress-signaling-protocol ldp

Verify
 show bgp l2vpn vpls all

===H-VPLS===
VPLS skalar inte superbra eftersom det kräver full-mesh, detta går att bygga ut med Hierarchical VPLS. Det man gör då är att koppla ihop flera VPLS och stänga av split horizon vid intersektionerna. Notera att Split-Horizon endast har effekt på Core Facing pseudowires (mesh pseudowires) och inte Spoke pseudowires. Trafik ifrån Spoke kan forwarderas till Core PW och vice versa. Spoke kan även skicka till annan spoke, dock går den trafiken alltid via core. Trafik tar alltså sällan den optimala vägen och alla PEs måste lära sig alla MAC-adresser. För att få redundans ifrån u-PE (spoke) till n-PE (core) kan man använda Pseudowire Redundancy.

===L2 Tunneling===
För CDP, LACP, STP frames etc krävs l2 tunneling protocol. Detta finns det inte stöd för på alla plattformar, ''l2protocol action not supported''.
 interface gi2
  service instance 100 ethernet
   l2protocol tunnel
 
 show ethernet service instance detail | i L2protocol

=EoMPLS/AToM=
Ethernet-over-MPLS eller Any Transport over MPLS (RFC 4448). Requires end-to-end MPLS LSP. Notera att MTU på Access Circuits måste matcha för att pseudowire ska gå upp. Det finns ingen MAC Learning med EoMPLS.

EoMPLS features
* Ethernet Port Mode
* VLAN Mode
* Inter-AS Mode
* QinQ Mode
* QinAny Mode
Port mode använder VC type 5 (Ethernet) och VLAN mode använder VC type 5 men med type 4 (Vlan) som fallback (''show mpls l2transport binding'').

PW logging
 xconnect logging pseudowire status 
PE1
 interface gi2
  xconnect 2.2.2.2 102 encapsulation mpls
PE2, VCID måste matcha på båda sidor
 interface gi2
  xconnect 1.1.1.1 102 encapsulation mpls

Verify
 show xconnect all
 show xconnect peer 2.2.2.2 vcid 102
 show l2vpn service all 
 show mpls l2transport vc 102 detail
 ping mpls pseudowire 10.0.0.10 102

Segment 1 är de interface som kunden sitter på, segment 2 är core.

'''Pseudowire Redundancy''' &lt;br/&gt;
Pseudowire redundancy innebär att man sätter upp en backup PW. 
 l2vpn xconnect context Redundancy
  member 1.1.1.1 10 encapsulation mpls group 1 priority 1
  member 2.2.2.2 10 encapsulation mpls group 1 priority 2

==EVPN-VPWS==
 l2vpn evpn
  replication-type ingress
  router-id Loopback0
  mpls label mode per-ce
 !
 l2vpn evpn instance 10 vlan-based
  route-distinguisher 1.1.1.1:10
  route-target both 10:10
  no auto-route-target
 ! 
 member evpn-instance 10
  member GigabitEthernet0/0/1 service-instance 10
 !
 interface GigabitEthernet0/0/1
  no ip address
  service instance 10 ethernet
   encapsulation dot1q 100
 ! 
 router bgp 1
  address-family l2vpn evpn 
   neighbor IBGP activate
   neighbor IBGP send-community both

Verify
 show l2vpn evpn evi detail 
 show l2vpn evpn mac 
 show l2vpn l2route evpn mac

==L2TPv3==
Layer 2 Tunneling Protocol (RFC 3931, RFC 4719) kräver [[Cisco_CEF|CEF]] och IP-konnektivitet end-to-end. Det är endast point-to-point. IP protocol: 115.
 pseudowire-class L2TP-PWCLASS
  encapsulation l2tpv3
  ip local interface Loopback0
 
 interface gi2
  xconnect 2.2.2.2 102 pw-class L2TP-PWCLASS
Verify
 show l2tp session all
 show l2tun tunnel all
Default kopieras inte DF bit som finns i paketen som kommer in ifrån CE när L2TPv3 IP header adderas. Man kan ändra det i pw-klassen.
 pseudowire-class L2TP-PWCLASS
  ip pmtu

==Inter-AS Option B==
PE
 mpls ldp discovery targeted-hello accept
 
 l2vpn
  pseudowire routing 
   terminating-pe tie-breaker
 
 l2vpn vfi context vfiA
  vpn id 111
  autodiscovery bgp signaling ldp
  vpls-id 111:111
  rd 111:111
  route-target 111:111

ASBR
 mpls ldp discovery targeted-hello accept
 
 l2vpn
  pseudowire routing
 
 router bgp 1
  no bgp default route-target filter
  address-family l2vpn vpls
   neighbor &lt;ibgp&gt; activate
   neighbor &lt;ibgp&gt; send-community extended
   neighbor &lt;ibgp&gt; next-hop-self
   neighbor &lt;ebgp&gt; activate
   neighbor &lt;ebgp&gt; send-community extended
 
 interface GigabitEthernet1
  description ASBR-to-ASBR
  mpls ip
  mpls ldp discovery transport-address interface

=IOS-XR=
IOS-XR implementerar ett strukturerat CLI för EFP och EVC konfiguration. 
* '''l2transport''': identifierar subinterface, fysisk port eller bundle som en EFP. 
* '''encapsulation''': används för att matcha på VLAN tag
* '''rewrite''': används för att specificera rewrite av VLAN tag. 

Exempel:
 interface Bundle-Ether1.20 l2transport
  encapsulation dot1q 20
  rewrite ingress tag pop 1 symmetric
  mtu 9022

'''Loggning'''
 l2vpn
  logging
   bridge-domain
   pseudowire
   vfi

'''Static VPLS'''
 l2vpn
  bridge group PROD
   bridge-domain 101
    mtu 9000
    interface Bundle-Ether1.101
    !
    vfi 101
     neighbor 10.0.10.15 pw-id 101
     neighbor 10.0.10.16 pw-id 101

Verify
 show l2vpn bridge-domain brief

'''Static P2P''' &lt;br/&gt;
EoMPLS tillhandahåller en tunnlingsmekanism för Ethernet-trafik över ett MPLS-enabled L3 core. Man enkapsulerar Ethernet PDUs i MPLS-paket. Notera att MTU på Access Circuits måste matcha för att pseudowire ska gå upp.

"VC Type 5" = Port Based 
 interface GigabitEthernet0/0/0/1
  l2transport
  no cdp
 !
 l2vpn
  !
  xconnect group GROUP1
   p2p TO_XR2
    interface GigabitEthernet0/0/0/1
    neighbor ipv4 2.2.2.2 pw-id 100

"VC-Type 4" = VLAN based pseudowire
 l2vpn
  pw-class VLAN
   encapsulation mpls
    no transport-mode
    transport-mode vlan

Verify
 show l2vpn forwarding neighbor 2.2.2.2 pw-id 100 detail location 0/0/CPU0

===Control Word===
Normalt sett kollar PE i packet header för att avgöra om det är ett IPv4- eller IPv6-paket och kollar sedan source/destination tuples för att avgöra eventuell load sharing. Med L2VPN så kommer headern att vara en Ethernet-header istället för IP-header. Om MAC-adressen händelsevis börjar på 0x4 eller 0x6 så kommer routern tro att det är ett IP-paket och fatta beslut på fel grunder. Genom att lägga till ett kontrollord så kan routern titta på det för att avgöra om det är ett IP-paket eller ej och därmed finns det ingen risk att load sharing blir fel. Control-Word spelar en viktig roll för ECMP och det är rekommenderat att man slår på det. 
 l2vpn
  pw-class CONTROL
   encapsulation mpls
    control-word

[[Category:Cisco]]</text>
      <sha1>g9xmyp579n5e1qe5x5m477rd2o5nm6a</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco L2 Security</title>
    <ns>0</ns>
    <id>299</id>
    <revision>
      <id>3157</id>
      <parentid>3096</parentid>
      <timestamp>2022-05-10T08:10:43Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9594">Huvudartikel: [[Cisco_Security|Cisco Security]].

Se även [[Cisco_VLAN#Private_VLAN|Private VLANs]], [[Cisco_DHCP#Snooping|DHCP Snooping]] och [[Cisco_L3_Security|Cisco L3 Security]].

===Frame Block===
Ändra beteende på en switch så att unknown unicast droppas. Fungerar som säkerhetsmekansim om CAM går fullt för då floodas inte alla frames.
 switchport block unicast
 switchport block multicast

==Port Security==
När man slår på port-security på en port så är default MAC learning method "dynamic". Det betyder att switchen säkrar MAC-adresser ingress när de passerar interfacet. Om en ny MAC-adress kommer in och max antal tillåtna MAC-adresser inte har uppnåtts så kommer switchen lagra MAC-adressen i minne och tillåta trafiken. Man kan även köra något som kallas "sticky method", då säkrar switchen MAC-adresser på samma sätt som med dynamic men de sparas i NVRAM istället. Detta gör att de finns kvar genom reboots. Notera att sticky-adresser ej syns i running config. Utöver detta kan man ange MAC-adresser statiskt, detta gör man i running config under interfacet, vilket gör att man även kan spara det i startup config. En till grej som port-security gör är att kolla att MAC-adresser som är säkrade inte kommer in på någon annan port i VLANet än där de är säkrade (oavsett learning method). Port-security fungerar endast på portar som är statiskt konfigurerade som access eller trunk. Ska port security kombineras med [[Cisco_HSRP|HSRP]] bör BIA MAC användas.
 interface [interface]
  switchport mode access
  switchport port-security
  switchport port-security maximum 1
  switchport port-security mac-address sticky
  switchport port-security violation shutdown
Verify
 show port-security interface

 errdisable recovery cause psecure-violation

==ACL==
===PACL===
Port ACLs används ingress på Layer 2 interfaces på switchar.
 interface gi0/2
  ip access-group PACL in
  mac access-group PACL in
Verify
 show mac access-group

===VACL===
VLAN ACL är ingress, kollar både lokal och transit-trafik och funkar även med non-IP traffic.
 access-list 100 permit ip any host 10.0.0.10
 
 vlan access-map BLOCK-TO-SERVER 10
  match ip address 100
  action drop
 vlan access-map BLOCK-TO-SERVER 20
  action forward
Apply to vlan
 vlan filter BLOCK-TO-SERVER vlan-list 10

Logging
 vlan access-log maxflow 500
 vlan access-log threshold 0

==Storm Control==
Storm control är teknik för att låta administratörer dämpa unicast-, multicast- eller broadcast-trafik på L2-interface. Det kan användas för att reducera skadan vid broadcast-stormar. Olika switchmodeller fungerar olika när det gäller [[Cisco_EtherChannel|EtherChannels]] kontra fysiska interface för Storm control. För att konfigurera Storm control måste man ange gränsvärde (rising) men falling är optional. 
 interface gi0/7
  storm-control unicast level bps 1m 500k
  storm-control multicast level pps 500
  storm-control broadcast level 10

Ange vad som ska hända när tröskelvärde överskrids, t.ex. droppa frames eller skicka snmp-trap.
  storm-control action trap
Verify
 show storm-control

==802.1x==
802.1x är ett säkerhetsprotokoll som låter klienter (end devices) autentisera sig genom att prata EAP (RFC 3748) innan de får tillgång till tråd/trådlösa nätverk. Switcharna kan prata radius med authentication server som t.ex. kan vara en Windows-server eller en Cisco ISE. Authentication port-control används för att ställa en port i ett av tre operational modes: auto, force-authorized och force-unauthorized.

 aaa authentication dot1x default group radius
 dot1x system-auth-control
 
 interface gi0/5
  switchport mode access
  dot1x port-control auto
Har man flera hostar på samma port så kan man låta varje mac-adress autentisera sig.
 interface gi0/5
  authentication host-mode multi-host
Om man vill testköra (dry-run) sin autentiseringslösning kan man använda öppen auth, då skickas authentication data till Radius-servern men porten agerar vanlig port (alltså tillåter trafik på access vlan).
 interface gi0/5
  authentication open
Man kan slå på att alla andra får prata ut genom porten men inkommande frames accepteras endast om auth går igenom. Detta är t.ex. användbart för [[PXE-Deploy|PXE]].
 interface gi0/5
  authentication control-direction in 

Verify
 show dot1x

==DAI==
För att skydda sitt L2-nätverk mot MITM-attacker som använder G-ARP kan man använda Dynamic ARP inspection. DAI kräver [[Cisco_DHCP#Snooping|DHCP Snooping]] eftersom inkomna ARP-meddelanden valideras mot snooping-databasen. Om inte ARP:en stämmer överens mot det som står i databasen kommer frames att droppas, ''SW_DAI-4-DHCP_SNOOPING_DENY''. Man slår på DAI per VLAN man vill skydda. 
 ip arp inspection vlan 10
 show ip arp inspection vlan 10

Man kan även kontrollera IP-avsändare och mottagare i paketen utifrån ARP-information. Detta kollar även ARP bodies efter invalid eller oväntade IP-adresser som 0.0.0.0, 255.255.255.255 och alla multicast-adresser.
 ip arp inspection validate ip

Konfigurera interface som trusted för ARP. På dessa inspekteras ej ARP-meddelanden.
 interface gi0/7
  ip arp inspection trust

Static entries behövs för hostar som inte använder DHCP.
 arp access-list ARP_ACL
  permit ip host 10.0.0.30 mac host 0011.2233.4455
 
 ip arp inspection filter ARP_ACL vlan 10

Eftersom DAI gör att switchen jobbar mer kan man överlasta den genom att skicka ett stort antal ARP-meddelanden. DAI har därför default en limit på 15 ARP-meddelanden per port per sekund. 
 interface gi0/7
  ip arp inspection limit 15 

Logging
 ip arp inspection vlan 10 logging acl-match
 
 ip arp inspection log-buffer entries 32
 ip arp inspection log-buffer logs 5 interval 1

Verify
 show ip arp inspection

==MACsec==
En del Nexus-switchar har line rate encryption capabilities. MACsec Layer 2 security krypterar paketen hop-by-hop. Detta skyddar mot wiretapping och MITM samtidigt som det gör att man kan inspektera, monitorera, QoS-tagga och forwardera frames som vanligt fast trots att det är krypterat on the wire. För att upptäcka MACsec peers och förhandla nycklar mellan MACsec-deltagare används MACsec Key Agreement (MKA) protocol. Sedan används Secure Association Key (SAK) för att kryptera och avkryptera på data plane. En MACsec keychain kan ha multipla PSKs, var och en med egen key ID och valfri lifetime. En MACsec-session kan t.ex. faila pga key/key name (CKN) mismatch eller att key duration har gått ut. Om den failar så kan man ha en fallback session som tar över, då måste man ha en fallback key konfad. En fallback session gör att man slipper nertid när primary session går ner och man får lite tid på sig att fixa problemet. 

'''Overview''' &lt;br/&gt;
[[File:Cisco-MACsec.PNG]]

MACsec funkar på:
* Layer 2 switchports (access and trunk)
* Layer 3 routed interfaces (no subinterfaces)
* Layer 2 and Layer 3 port channels

'''Konfiguration'''
 feature macsec
 
 key-chain macsec-psk no-show
 
 key chain KC1 macsec
  key 100
   key-octet-string abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789 cryptographic-algorithm AES_256_CMAC
   send-lifetime 00:00:00 Oct 04 2018 duration 100000
Om man inte anger någon key lifetime så defaultar det till unlimited. 

Policy
 macsec policy MACsec01
  cipher-suite GCM-AES-256
  security-policy '''should-secure'''
Här kan man även välja "'''must-secure'''" = packets not carrying MACsec headers will be dropped.

Apply
 interface e1/15
  macsec keychain KC1 policy MACsec01 fallback-keychain KC-fallback
Notera att man inte kan ändra en policy utan man får skapa en ny och attacha på interfacet.

Verify
 show macsec policy
 show macsec mka session/summary
 show interface capabilities | i "Ethernet|MACSEC

===XPN===
MACsec Extended Packet Numbering (XPN). Varje MACsec frame innehåller ett 32-bitars packetnummer som är unikt för varje given SAK. Om dessa tar slut så blir det SAK rekey för data plane keys. För högkapacitetslänkar så tar dessa slut rätt snabbt och kontrollplan måste göra SAK rekey. Med XPN så används ett 64-bitars nummer istället och därmed elimineras behovet av frekvent SAK rekey. 

 mka policy MACSEC
  macsec-cipher-suite gcm-aes-xpn-256
 !
 key chain MACSEC macsec
  key 1000
   cryptographic-algorithm aes-256-cmac
   key-string 7 075E701D1F58485446435A5D557B7A757962647342
 !
 interface HundredGigE1/0/1
  macsec network-link
  mka policy MACSEC
  mka pre-shared-key key-chain MACSEC

===Certificate Based MACsec===
Cisco IOS-XE har stöd för Certificate Based MACsec med Local Authentication. Då används EAP-TLS för authentication. MKA och MACsec implementeras efter lyckad authentication med certificate-based MACsec.

 show mka session interface g1/0/1 details

==IPv6==
'''RA guard''' &lt;br/&gt;
RA guard blockerar unwanted eller rogue router advertisement. Denna feature körs i ingress direction.
 interface GigabitEthernet0/1
  ipv6 nd raguard
Verify
 show ipv6 snooping features
 show ipv6 nd raguard

'''DHCPv6 Guard''' &lt;br/&gt;
DHCPv6 Guard blockerar reply och advertisments som kommer från unauthorized DHCP servers.

 show ipv6 dhcp guard

'''Binding table'''
 show ipv6 neighbor binding

'''Device tracking'''
 show ipv6 neighbor tracking

'''ND inspection/snooping'''
 show ipv6 nd inspection

'''SeND''' &lt;br/&gt;
Secure Neighbor Discovery is a protocol that enhances NDP with three additional capabilities: Address ownership proof, Message protection, Router authorization.

==MAC access control list==
Work in progress

[[Category:Cisco]]</text>
      <sha1>9ypwi77mid3d39iu6meeozjiy9fybqb</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco L3 Security</title>
    <ns>0</ns>
    <id>300</id>
    <revision>
      <id>3073</id>
      <parentid>2848</parentid>
      <timestamp>2019-11-24T16:51:41Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7584">Huvudartikel: [[Cisco_Security|Cisco Security]]

Se även [[Cisco_L2_Security|Cisco L2 Security]].

===Routing===
Tillåt ej IP options och source routing är bra praktik!
 ip options drop
 no ip source-route
Notera att "ip options drop" kan störa ut IGMP.

==ACL==
Accesslistor finns i flera olika varianter förutom standard och extended.

'''Logging''' &lt;br/&gt;
Access list logging interval (milliseconds) &amp; log-update threshold (number of hits)
 ip access-list logging interval 1000
 ip access-list log-update threshold 10

'''Reflexive ACL''' &lt;br/&gt;
För att använda reflexive ACL behövs det en ACL för inbound traffic, en för outbound och en reflexive för att hålla koll på dynamic entries. Några begränsningar är att trafik endast kan initieras från ena sidan och det går inte ge olika trafikklasser olika access. Trafik initierad lokalt i routern behandlas ej heller. Det funkar inte heller med applikationer som jobbar med olika portnummer, t.ex. FTP. 
 ip access-list extended Egress
  permit ip any any reflect Mirror
 ip access-list extended Ingress
  evaluate Mirror
  deny ip any any
 
 interface gi0/1
  description Outside
  ip access-group out Egress
  ip access-group in Ingress
Timeout
 ip reflexive-list timeout 30
Verify
 show ip access-lists Mirror
 show ip access-lists

'''IPv6''' &lt;br/&gt;
För IPv6 finns det endast extended named ACL:er. Wildcard mask används inte heller utan det är CIDR notation som gäller.
 ipv6 access-list Deny_ABC
  deny ipv6 2001:A:B:C::/64 any
  permit ipv6 any any
 
 interface Gi0/1
  ipv6 traffic-filter Deny_ABC out

 show ipv6 access-list

'''Lock and Key''' (Dynamic ACLs) &lt;br/&gt;
Lock and key configuration starts with the application of an extended ACL to block traffic through the router. Users that want to traverse the router are blocked by the extended ACL until they Telnet to the router and are authenticated. The Telnet connection then drops and a single-entry dynamic ACL is added to the extended ACL that exists. This permits traffic for a particular time period; idle and absolute timeouts are possible.

 username DYN autocommand access-enable timeout 5
 
 ip access-list extended 100 
  permit tcp 10.0.0.0 0.0.0.255 host 10.0.0.1 eq telnet
  dynamic DYN timeout 5 permit ip 10.0.0.0 0.0.0.255 any

'''Turbo ACL''' &lt;br/&gt;
The turbo ACL feature is designed in order to process ACLs more efficiently in order to improve router performance. Found only on high-end platforms.
 show access-list compiled

==CBAC==
Context-Based Access Control tillhandahåller stateful packet inspection på IOS-enheter. Man väljer vilka protokoll som ska inspekteras, det finns många protokoll default. Detta är ett konfigurationsexempel för ett interface som endast ska släppa in webbtrafik initierad från insidan.
 ip access-list extended DENY_ALL
  deny ip any any
 ip inspect name Web http
 ip inspect name Web https
 
 interface gi0/0
  description Outside
  ip access-group DENY_ALL in
  ip inspect Web out

Verify
 show ip inspect all
 show ip inspect sessions

Vill man att CBAC ska inspektera protokoll som inte använder standardportar kan lägga till dessa med port-map-kommandot.
 ip port-map http port tcp 8081
 ip port-map smtp port tcp 2500
 
 show ip port-map

==ZFW==
Zone-based policy firewall är stateful packet inspection som är en vidareutveckling av CBAC. Det är [[Cisco_Routing#VRF|VRF]]-aware och man skapar zoner som man binder ett eller flera interface till. Default skapas det en "self"-zon som allt till och från tillåts samt att trafik mellan interface i samma zon tillåts. Konfigurationssyntaxen som används kallas Cisco Policy Language. ZFW kan inte inspektera [[Cisco_Multicast|multicast]] eller [[Cisco_MPLS|MPLS]]-trafik men det går att att köra ZFW i transparent mode samt att man kan policea trafiken.
 zone security INTERNET
 zone security INSIDE
 interface Gi1
  zone-member security INTERNET
 interface Gi2
  zone-member security INSIDE
Bind ihop zonerna och ange source zon.
 zone-pair security ZONE-PAIR source INSIDE destination INTERNET
  service-policy type inspect INSIDE-TO-INTERNET

För att tillåta trafik mellan zoner måste en policy skapas. ZFW inspect class-map kan matcha: access-groups, class-maps, group-objects och protokoll. 
 class-map type inspect match-any ALLOW-TRAFFIC
  match protocol icmp
  match protocol dns
  match protocol http
 
 policy-map type inspect INSIDE-TO-INTERNET
  class type inspect ALLOW-TRAFFIC
   inspect
  class class-default
   drop

Verify
 show zone-pair security
 show policy-map type inspect zone-pair
 show policy-firewall config 
 show policy-firewall session zone-pair ZONE-PAIR

'''High Availability''' &lt;br/&gt;
ZFW stödjer HA och session state replikeras för inspect actions mellan ACTIVE och STANDBY. Dock görs det endast för L4 protokoll TCP/UDP så ingen ICMP eller L7 inspections. Enheten med högst prio blir ACTIVE, vid lika avgör högsta IP på control link.

 interface GigabitEthernet0/1
  description Control link
  ip address 10.1.1.2 255.255.255.0
 
 parameter-map type inspect global
  redundancy
 
 redundancy
  application redundancy
   group 1
    name ZFW
    preempt
    priority 100
    control GigabitEthernet0/1 protocol 1
    data GigabitEthernet0/1
Verify
 show redundancy application group 1

==uRPF==
Unicast Reverse Path Forwarding är en mekanism som förhindrar spoofing attacks. Source-adressen på paket som kommer in kollas och jämförs mot den egna FIB:en för att säkerställa att paketen kommer in på det interface som routern själv hade använt för att nå den adressen. [[Cisco_CEF|CEF]] är därför ett prereq för uRPF. uRPF finns i två modes och tar hänsyn till equal och unequal cost load sharing. Om default-routen också ska användas vid kontrollen måste '''allow-default''' sättas efter interface-kommandot.

'''Strict mode''', fungerar såklart inte med asymmetric routing.
 ip verify unicast source reachable-via rx

Med '''Loose mode''' räcker det att sourcen är reachable via något interface.
 ip verify unicast source reachable-via any

uRPF exemptions, vill man inte kontrollera all trafik kan man matcha RPF-checken mot en ACL, dvs permita det som RPF inte ska bry sig om att droppa om det inte klarar checken.
 ip verify unicast source reachable-via rx &lt;ACL&gt; 
Verify
 show ip traffic
 show ip verify source

Trick för att logga all packets med spoofed sources.
 access-list 100 deny ip any any log
 interface GigabitEthernet0/1
  ip verify unicast source reachable-via any 100

==IPSG==
IP Source Guard hjälper till att skydda mot IP spoofing. Det konfigureras på access-lagret och använder sig av [[Cisco_DHCP#Snooping|DHCP Snooping]]-databasen för att dynamiskt skapa IP/MAC ACL:er per switchport och allt som inte träffar ACL:en droppas silently. Det enda som tillåts är paket med den source som matchar den DHCP snooping binding som finns för porten. Man kan också sätta upp statiska IP binding entries för hostar som inte använder DHCP. IPSG kan kontrollera IP-adresser eller både IP-adresser och MAC-adresser. Det bör konfigureras konsekvent på alla accessportar på network edge. 

Prereq, DHCP Snooping måste faktiskt vara påslaget även om man bara använder manuella bindings.
 ip dhcp snooping
 ip dhcp snooping vlan 10

'''L3 check'''
 interface gi0/7
  ip verify source

'''L3+L2 check'''
 interface gi0/7
  switchport port-security
  ip verify source port-security

Static binding
 ip source binding 0011.2233.4455 vlan 10 172.20.0.10 int gi0/7

Verify
 show ip verify source
 show ip source binding

[[Category:Cisco]]</text>
      <sha1>jjofb24u8pm479ladaevossrnddatx9</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco LISP</title>
    <ns>0</ns>
    <id>306</id>
    <revision>
      <id>2220</id>
      <parentid>2219</parentid>
      <timestamp>2017-01-08T14:02:31Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>/* Konfiguration */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3689">Locator/Identifier Separation Protocol (RFC 6830) är en routing och adresseringsarkitektur utvecklat av Cisco men är en öppen standard. Vanligtvis används en IP-adress för att representera både identitet och lokation men med LISP separeras dessa som RLOC och EID (som går att mixa mellan IPv4 och IPv6). Att separera identitet och lokation är möjligt eftersom LISP tunnlar trafik med UDP, dvs det är overlay. Med hjälp av en registreringsprocess skapas det en mapping database på en ciscorouter som agerar Map Server och Map Resolver. Denna databas håller alla EID &lt;-&gt; RLOC mappings och det är den man frågar för att få veta var trafiken för olika IP-adresser ska tunnlas. LISP control plane använder udp 4342 och data plane trafik skickas till udp 4341.

===Terminology===
* Routing Locator (RLOC)
* Endpoint ID (EID)
* Egress Tunnel Router (ETR)
* Ingress Tunnel Router (ITR)
* Egress/Ingress Tunnel Router (xTR)
* Proxy Ingress Tunnel Router (P-ITR)

[[File:Cisco_LISP.png]]

==Konfiguration==
'''Map Server/Resolver''' &lt;br/&gt;
På MS/MR konfar man vilka sites som får registrera sig, med sites menas de prefix/adresser som ska LISP:as. Dvs det är inte en vitlista på RLOCs som får registrera sig däremot måste MS/MR kunna nå alla RLOC-adresser. Det går att ha dessa roller på olika enheter men det finns ingen större vinning med det eftersom MS/MR inte behöver finnas i data plane. För att göra MS/MR-funktionen redundant kan man bygga IP anycast.
 router lisp
  ipv4 map-server
  ipv4 map-resolver
 
  site SITE_A
   authentication-key SITE_A_KEY
   eid-prefix 192.168.1.0/24
''alla lokala ip-adresser på MS/MR används default av LISP''

'''Branch Site''' &lt;br/&gt;
MS/MR ska vara nåbar med unicast i default-vrfen. Man kan ha flera RLOCs på samma site för redundans och lastdelning, då ska alla konfas likadant vad gäller RLOC-adresser. Med priority kan man styra vilken RLOC som ska användas. Har två stycken samma prio kan man styra lastdelning med weight. RLOC:ar inom samma site kommer automatiskt proba varandra för att kolla att de lever.
 router lisp
  ipv4 itr map-resolver 10.0.0.10
  ipv4 itr
  ipv4 etr map-server 10.0.0.10 key SITE_A_KEY
  ipv4 etr
 
  database-mapping 192.168.1.0/24 IPv4-interface GigabitEthernet2 priority 1 weight 1

Verify
 show lisp
 show lisp site
 show ip lisp map-cache 
 show ip lisp database
 
 clear ip lisp map-cache *
''map cache default TTL: 24h''

===Data Center===
Genom att tillåta registrering av mer specifika routes (/32-routes) kan man lösa VM mobility mellan datacenter. IP-adressen på roaming device måste vara inom EID-prefixet. En LISP xTR konfigurerad för LISP VM mobility och dynamiska EIDs är en LISP-VM router. Den avgör dynamiskt om en VM finns i det direktanslutna subnätet eller någon annanstans. LISP-VM routers är RLOCs som används för enkapsulering till EID. 
 router lisp
  site DATA_CENTER
   authentication-key DC_KEY
   eid-prefix 10.8.0.0/16 accept-more-specifics

===PxTR===
Proxy xTR kan användas för att lisp-siter ska kunna nå non-lisp-aware sites. Då skickas paketen native ip ut ur nätverket och sedan lisp-enkapsulerat på vägen tillbaka till siten.
 router lisp
  ipv4 proxy-etr
  ipv4 proxy-itr 2.2.2.2  #local ip
  ipv4 itr map-resolver 8.8.8.8
  map-cache ''EID-prefix'' map-request

'''MTU''' &lt;br/&gt;
PMTUD är på default.
 router lisp
  ipv4 path-mtu-discovery min 576 max 65535
  ipv6 path-mtu-discovery min 1280 max 65535

===VRF===
EIDs och RLOCs kan separeras i olika VRF:er.
 router lisp
  locator-table vrf UNDERLAY
 
  eid-table vrf Cust_A instance-id 101
   database-mapping 192.168.1.0/24 10.0.0.10 priority 1 weight 1

[[Category:Cisco]]</text>
      <sha1>kbts17d9bfrhnuczwczsmorqw5mq41z</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco Logging</title>
    <ns>0</ns>
    <id>240</id>
    <revision>
      <id>2899</id>
      <parentid>2636</parentid>
      <timestamp>2018-11-28T07:24:20Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3234">Ciscoenheter kan logga meddelanden lokalt och/eller remote. Se även [[Cisco_IOS|Cisco IOS]].

===Format===
Man kan använda lite olika format på sina loggmeddelanden, detta går även ändra på debugmeddelanden. Vill man att tidsstämplarna ska utgå ifrån den tidszon enheten är konfad med kan man lägga till '''localtime''' efter datetime-kommandona.
 (Utan tidsstämpel)
 %LINK-3-UPDOWN: Interface Port-channel1, changed state to up
 
 '''service timestamps log uptime'''
 00:00:46: %LINK-3-UPDOWN: Interface Port-channel1, changed state to up
 
 '''service timestamps log datetime'''
 *Feb  8 18:24:02: %LINK-3-UPDOWN: Interface Port-channel1, changed state to up
 
 '''service timestamps log datetime msec'''
 *Feb  8 18:24:02:355 %LINK-3-UPDOWN: Interface Port-channel1, changed state to up
[[Cisco_Nexus|NX-OS]] har lite annan struktur på syslog
 2016 Feb  8 18:41:55.911853  DC01-SW02  %BGP-3-UNEXPECT:  the-message...

===Diverse===
Default har de flesta IOS-enheter en rätt liten logg-buffer men det går att ställa upp.
 logging buffered 131072

Count every log message and timestamp last occurance
 logging count
 show logging count
Persistent, no buffering
 logging persistent immediate
Rate limit
 logging rate-limit console all 1
Numrera loggrader, gör det svårare att manipulera lagrade loggar i efterhand.
 service sequence-numbers

'''Message Discriminator''' &lt;br/&gt;
Innan ett loggmeddelande levereras kan man ha det checkat mot en manuellt definierad kriterielista. På så sätt kan man t.ex. specificera om några speciella loggmeddelanden ska droppas. 
 logging discriminator BLOCK msg-body drops Interface Port-channel1
 
 logging monitor discriminator BLOCK
 logging host 1.1.1.1 discriminator BLOCK

=Local Storage=
Man kan lagra loggar lokalt på flash.
 mkdir flash:/logs
 logging persistent url flash:/logs
 logging on
Verify
 show logging

=Syslog=
Syslog är en standard för message logging, även om inte strukturen på meddelandena är standardiserad. Syslog använder default UDP port 514. Syslog-meddelanden går även att skicka med [[Cisco_SNMP|SNMP]]-traps, först skickas det lokalt till en speciell history buffer och sedan replikerar SNMP agenten det till traps.

 logging on
Set syslog server logging level, 0-7.
 logging trap ?
Source
 logging origin-id HOSTNAME
 logging source-interface Loopback 0
Bytt protokoll och port
 logging host 1.1.1.1 transport tcp port 5514

=Kommandologgning=
 archive
  log config
   logging enable
   notify syslog
   hidekeys

Verify
 show archive log config all

=ACL=
Förutom att öka hit count generera ett loggmeddelande när en ACL-regel träffas.
 ip access-list extended Block_HTTP
  10 deny tcp any any eq 80 '''log'''
  20 permit ip any any
För L2-info också använd ''log-input'' istället för log.

Access list logging interval (milliseconds) &amp; log-update threshold (number of hits)
 ip access-list logging interval 1000
 ip access-list log-update threshold 10
IOS kan generera och lägga på en MD5 hash på varje access-list entry. Denna hash kan användas för att enklare söka och filtrera på loggmeddelanden utifrån en viss regel. Hashen ligger kvar efter reboot. 
 ip access-list logging hash-generation 

[[Category:Cisco]]</text>
      <sha1>e9dgp0rb0lltx9ty5ivaglep8qtbuwi</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco MPLS</title>
    <ns>0</ns>
    <id>179</id>
    <revision>
      <id>3053</id>
      <parentid>3026</parentid>
      <timestamp>2019-11-12T10:09:39Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19356">Multiprotocol Label Switching (RFC 3031) är protokoll som routrar kan använda för att forwardera paket baserat på labels istället för destination IP address. Routrarna kallas då LSR, Label Switch Router. Genom att separera forwarding decision från destination IP address kan besluten baseras på andra faktorer såsom [[Cisco_QoS|QoS]] eller Traffic Engineering. Det kan användas för vanlig unicast IP forwarding men också annat som t.ex. VPN-tjänster. En grupp av paket som skall till ett visst destinationsnät kommer vanligtvis att skickas samma väg genom nätverket. I MPLS grupperas dessa paket i klasser som kallas Forwarding Equivalence Class, FEC. Alla paket som tillhör samma FEC skickas med samma label. En MPLS-header är 4 bytes och innehåller bl.a. ett 20-bitars fält som är den unika labeln. Bottom-of-stack bit, QoS marking och TTL finns också i headern. Olika protokoll kan användas för control plane, t.ex. LDP, [[Cisco_BGP#Multiprotocol_BGP|MP-BGP]] eller [[Cisco_SR|Segment Routing]]. MPLS på Cisco-enheter använder sig av [[Cisco_CEF|CEF]]. MPLS går även att tunnla över IP (RFC 4023), se [[Cisco_GRE|Cisco GRE]]. 

Se även [[Cisco_MPLS-TE|MPLS-TE]].

==Tables==
För varje [[Cisco_Routing#VRF|VRF]] skapas det nya tabeller, '''show cef table | begin active'''

RIB
 show ip route
 show ip route vrf NAME
LIB, innehåller all labels known to LSR
 show mpls ldp bindings
 show mpls ldp binding summary
 show mpls ldp bindings vrf NAME
FIB, används för paket utan label
 show ip cef
 show ip cef vrf NAME
LFIB, används för paket med label
 show mpls forwarding-table
 show mpls forwarding-table vrf NAME

=LDP=
För att veta vilka labels en LSR ska sätta på paketen som ska skickas iväg används Label Distribution Protocol (TDP är legacy). Routrar bygger LDP-grannskap och utbyter sedan dynamiskt labels med varandra för att kunna bygga korrekta forwarding tables. Det fungerar ungefär som ett routingprotokoll. För unicast IP routing så utbyts en label per prefix i routingtabellen, Cisco IOS använder independent label distribution control. Dyker det upp något nytt i routingtabellen skapas en ny lokal label i LIB och sedan annonseras det till alla LDP-grannarna. På så sätt kan en label-switched path (LSP) byggas. Dessa är enkelriktade och en enskild LSR känner inte till hela pathen för det behövs inte. En label går aldrig längre än till grannen utan där poppas eller byts den mot nästa routers label. MPLS låter routingtabellen och IGP stå för path selection och därmed loop-prevention och convergence. 

LDP använder sig utav två sorts paket för att kommunicera. För neighbor discovery skickas Hello-paket till 224.0.0.2 UDP 646 var 5:e sekund. När grannskap är bildat görs all informationsöverföring (updates) med unicast som skickas på TCP 646. 
&lt;div class="mw-collapsible mw-collapsed" style="width:240px"&gt;
'''LDP Hello:'''
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_MPLS_LDP_Hello.PNG]]
&lt;/div&gt;
&lt;/div&gt;

MPLS-nätet måste använda något routingprotokoll för att lära sig routes och dra nytta av label-annonsering, vanligtvis används ett IGP för detta. När en ny lokal label skapas, pga nylärd route från IGP, annonseras det till alla LDP-grannarna (även den man fick route-uppdateringen ifrån, frame-mode MPLS har inte hört talas om split horizon :). Detta händer för alla routes på alla LSR. Router-ID väljs på exakt samma sätt som för [[Cisco_OSPF#Konfiguration|OSPF]]. Om man har en LSR med LDP-grannskap till säg 5 andra enheter så kommer alla grannskap gå ner om man stänger ett av sina 5 interface eftersom LDP skapar sitt ID utifrån tillgängliga IGP interface. Det ändras om ett interface försvinner vilket det gör om man t.ex. shutar ett av dem. Hold time ska kommas överens om och är default 15 sekunder (3x Hello). Om två LSR inte kommer överens om timers, label distribution method etc kan man öka intevallet mellan försöken med ''mpls ldp backoff''-kommandot. T.ex. från 5 sekunder till att börja med till 120 sekunder mellan varje försök.

Global
 mpls label protocol ldp  #Default
 mpls ldp router-id loopback0 [force]
 show mpls ldp parameters 

Man kan per interface slå på MPLS, höja MTU för att stödja MPLS-headers och ändra vilken adress som ldp ska bygga grannskap med. Om man har flera länkar till samma LSR och ska sätta upp flera parallella LDP-sessioner måste man använda samma transport address på alla interface. LDP RID används default som transport address.
 interface gi1/1
  mpls ip
  mpls mtu 1508
  mpls ldp discovery transport-address interface

'''Verify'''
 show mpls interfaces [vrf NAME]
 show mpls ldp neighbor
 show mpls ldp discovery

Graceful restart
 mpls ldp graceful-restart
 show mpls ldp graceful-restart
Allow MPLS forwarding for ip default route
 mpls ip default-route 

===Labels===
Special-Purpose Label Values
* 0 – IPv4 Explicit null – Instead of popping label at PHP, the second last router sets top label to zero, this means EXP bits are preserved.
* 1 – Router alert – Alerts LSR that packet needs a closer look. Can’t be forwarded in hardware, software needed.
* 2 – IPv6 Explicit null
* 3 – Implicit null – Pop label

Label range, default på IOS är 16-1048575 (label range kan skilja beroende på modell). Att byta label range tar effekt när MPLS startas om, det görs snabbast med de globala kommadona ''no mpls ip'' -&gt; ''mpls ip''.
 mpls label range 200-299
 show mpls label range

'''Advertisments''' &lt;br/&gt;
Default på Cisco IOS allokeras och annonseras labels för allt, detta går att ändra.
 no mpls ldp advertise-label
 mpls ldp advertise-lable for &lt;dest prefix&gt; to &lt;ldp peer&gt;
För att slippa hålla koll på prefix-listor kan man konfigurera att det endast ska allokeras (och därmed annonseras) labels för /32-routes i RIB:en.
 mpls ldp label
  allocate global host-routes

Label space
 show mpls ldp discovery
 10.0.0.10:'''0'''
 0 betyder platform wide label space
 1 betyder interface label space

Disable PHP
 mpls ldp explicit-null

===TTL===
När en ingress E-LSR får in ett IP-paket sänker den IP TTL med ett och sedan pushar den en label och kopierar TTLen till MPLS-headern. När sedan paketet traverserar en LSR sänks endast MPLS-TTLen men vid egress E-LSR kopieras MPLS-TTLen till IP TTL och skickas vidare. Detta går att ändra på så att IP-TTL inte kopieras utan MPLS-TTL sätts till 255 av ingress E-LSR för att hela MPLS-nätet verkligen ska vara som ett router hop. Detta behöver endast konfigureras på PE.
 no mpls ip propagate-ttl

===Session Protection===
Om två directly connected LDP-grannar tappar kontakten flushas alla bindings från LIB. Men det behöver inte betyda att det inte fortfarande finns IP-reachability mellan dem en annan väg. Session Protection är en optimerings-feature som gör att LIB inte flushas sålänge det finns en annan väg till LDP-peer, targeted LDP sätts då upp för att hålla LIB synkat. Dvs om det slutar att komma in multicast hellos så skickas det unicast UDP-paket till grannes LDP transport address för att förhindra timeout. När sedan directly connected grannskapet kommer tillbaka behöver inte allt synkas om. Detta är en global inställning och måste konfigureras på båda sidor annars kommer inte andra sidan acceptera targeted hellos. Max hops är 255 och för Hello och Hold time gäller 10 sekunder respektive 90 sekunder default.
 mpls ldp session protection
 mpls ldp discovery targeted-hello accept
 mpls ldp discovery targeted-hello holdtime 30
 
 show mpls ldp neighbor detail | i Targeted|Session 

Både session protection och accept unicast hellos kan begränsas med ACL. Med show mpls ldp neighbor kommandot ser man att det finns en lista på Addresses bound to peer LDP Identity, det är så de fattar vilka andra IP-adresser som kan användas för LDP-kommunikation. LDP session holdtime rekommenderas enligt följande formel: Session Holdtime &lt;= (Hello holdtime - Hello interval) * 3

===Security===
Med tcp-autentisering kan man säkra LDP-kommunikationen. ACL ska träffa LDP ID som andra sidan har och måste vara standard.
 ip access-list standard LDP-PEERS
  permit host 10.0.0.5
  permit host 10.0.0.6
 mpls ldp password required for LDP-PEERS
 mpls ldp neighbor 10.0.0.5 password SECRET
Kräv lösenord för alla LDP-grannskap. Om man inte har angett något lösenord för en specifik granne kommer fallback att användas om det finns konfigurerat.
 mpls ldp password required
 mpls ldp password fallback SECRET

Verify
 show mpls ldp discovery detail | i Ethernet|Password

===IGP===
LDP går att autokonfa tillsammans med [[Cisco_IS-IS|IS-IS]] och [[Cisco_OSPF|OSPF]], dvs slå på LDP på de interface som är aktiva i IGPn, detta kan antingen göras per interface eller under routingprocessen. Man kan även använda ''prefix suppression'' så kommer det inte att genereras lika många labels för ens core-nätverk.
 router ospf/isis 1
  mpls ldp autoconfig

'''Synchronization''' &lt;br/&gt;
Länkkostnaden för nyetablerade grannskap sätts till max tills LDP är klar med labelutbyte och berättar för link-state IGP att det är okej att använda länken. 

LDP deklarerar LDP sync up så fort alla dessa nödvändiga villkor är uppfyllda.
* LDP session är up
* LDP har skickat alla sina label bindings till åtminstone en peer
* LDP har tagit emot åtminstone en label binding ifrån en peer

Slå på det under IGP-processen. 
 router ospf/isis 1
  mpls ldp sync
Alternativt per interface.
 interface gi2
  mpls ldp igp sync
På IOS-XE är det rekommenderat att sätta IGP sync holddown timer till något non-infinite för att undvika device isolation som kan uppstå vid vissa felscenarion.
 mpls ldp igp sync holddown 120000

Verify
 show mpls ldp igp sync
 show mpls interface detail | i Interface|IGP

=VPN=
MPLS VPN (RFC 4364) är en populär MPLS-applikation och det räknas som trusted VPN. PHP för transport label används default för att slippa en lookup. För PE-PE label utbyten används [[Cisco_BGP#Multiprotocol_BGP|MP-BGP]], det kan dock gå via route reflector precis som vanligt för ökad skalbarhet. För att VPN-trafik ska fungera måste PE ha en route till next-hop PE, det går ej med en default route. Control plane kommer att fungera men ej data plane eftersom forwardering med labels lärda från BGP endast fungerar om det finns en /32-route i RIB. För L2 VPN se [[Cisco_VPLS|Cisco VPLS]] och för multicast se [[Cisco_MLDP|Cisco MLDP]]. Det går även att integrera [[Cisco_NAT#MPLS_VPN|NAT]] med MPLS VPN.

 ip bgp-community new-format
 show ip bgp community ?  #''Så står det antingen aa:nn eller 1-4294967295''

'''Route Distinguisher:''' är ett 64-bitars nummer som skickas med BGP-uppdateringarna och används för att göra routes unika mellan VRFer. Det används med adressfamiljerna vpnv4 och vpnv6. 

'''Route Target:''' skickas med BGP-uppdateringarna som ett Extended Community PA. Det används för att bestämma vilken/vilka VRFer routsen ska in i. 

Import och export bestämmer vad som ska redistribueras mellan VRF och BGP.

Add IBGP neighbor. Man konfar inte next-hop-self eftersom VPNv4 sätter det default.
 router bgp 100
  neighbor 10.0.0.10 remote-as 100
  address-family vpnv4 unicast
   send-community extended

Default är att droppa VPNv4 updates för RTs som det inte finns någon lokal vrf för. Detta kan man ändra på.
 router bgp 100
  no bgp default route-target filter

Man kan dölja MPLS-nätet endast för VPN-kunder.
 no mpls ip propagate-ttl forwarded 

Label Mode avgör hur det ska allokeras labels. Har man VPN-kunder med många routes kan man av effektivitetsskäl byta till per-vrf mode och då kommer varje kund få en label per PE oavsett hur stor routingtabellen är i den VRF:en och därmed sparas det minne. Däremot måste en routing lookup göras när paketet kommer fram eftersom alla paket har samma label oavsett var de ska. Det finns därför en mellanvariant som kallas per-ce där det allokeras en label per next-hop per vrf och man sparar minne samtidigt som man slipper routing lookup.
 mpls label mode all-vrfs protocol all-afs per-prefix  #Default
 mpls label mode all-vrfs protocol bgp-vpnv6 per-vrf
 mpls label mode vrf INTERNET protocol bgp-vpnv4 per-ce

Man kan partitionera upp nätverket genom att skapa RR-grupper som filtrerar på route-targets.
 address-family vpnv4
  bgp rr-group EXTCOM-LIST

===6VPE===
6VPE (RFC 4659) är en teknik för att köra IPv6 över IPv4 MPLS-nät. Adressfamilj VPNv6 måste aktiveras på IPv4 iBGP-grannskapen mellan PEs/RRs. VPNv6 prefixen har en IPv4-mappad IPv6-adress som next-hop genom MPLS-nätet och en IPv4 LSP finns mellan PEs. Next-hop-adressen måste finns i IPv4-routingtabellen och en LSP måste existera för destinationen. 

 router bgp 100
  address-family vpnv6
   neighbor 10.0.0.10 activate
   neighbor 10.0.0.10 send-community extended

==Inter-AS MPLS VPN==
'''Back to Back VRFs''' ''Option 10A'' &lt;br/&gt;
PE använder iBGP för att distribuera labeled VPN-routes inom sitt AS som vanligt. PE kommunicerar med andra sidan PE med ett sub-interface, länknät och eBGP-grannskap per VRF. Det krävs ingen MPLS mellan PE utan det är unlabeled IP-adresser som annonseras. Detta är dock inte den mest skalbara lösningen.

'''VPNv4 eBGP''' ''Option 10B'' &lt;br/&gt;
PE använder iBGP för att distribuera labeled VPN-routes inom sitt AS som vanligt. PE använder sedan eBGP för att distribuera labeled VPN-routes till PE i ett annat AS, som i sin tur distribuerar dem till PE routrar i sitt AS. Det kan finnas flera vägar mellan de olika AS för redundans och ökad kapacitet. Service Providers måste komma överens om detta. Detta är mer skalbart eftersom det räcker med ett BGP-grannskap per koppling mellan AS. Följande fetmarkerade kommando slår på att /32-routes för eBGP-grannar autoläggs in i RIB och därmed möjliggör label forwarding, så fungerar ej IOS XR utan där måste man lägga till statiska routes manuellt.
 interface GigabitEthernet1/0
  description Connection to other AS
  '''mpls bgp forwarding'''
 
 router bgp 100
  no bgp default route-target filter
  neighbor 2.2.2.2 remote-as 200
  neighbor 10.0.0.10 description iBGP
  address-family vpnv4
   neighbor 2.2.2.2 activate
   neighbor 10.0.0.10 activate
   neighbor 10.0.0.10 next-hop-self
 
 show bgp vpnv4 unicast all labels

'''VPNv4 between RRs''' ''Option 10C'' &lt;br/&gt;
(eller PEs using multihop eBGP)

Istället för att använda PEs för att hålla koll och distribuera VPN-routes bygger man grannskap mellan RRs i varje AS. Dock måste PE hålla koll på labeled routes till alla andra PE/RR i sitt AS och skicka med eBGP till andra sidan AS så deras PE/RR hittar till PE/RR i det egna AS. Då kan PE/RR i olika AS bygga eBGP multi-hop grannskap (det måste finnas LSP mellan dessa) och utbyta labeled VPN-routes. Om P routrar får känna till PE i andra AS fungerar det som vanligt med dubbla labels. Men om det däremot inte är uppsatt så måste det trippel labelas. En för kundens IP till egress PE, en satt av ASBR för egress PE och en för IGP next-hop. Använder man RR är detta ett väldigt skalbart alternativ. 
 router bgp 100
  neighbor 10.0.0.10 description eBGP
  address-family vpnv4
   neighbor 10.0.0.10 next-hop-unchanged

'''Option AB''' &lt;br/&gt;
Control plane: BGP VPNv4 &lt;br/&gt;
Data plane: subinterfaces / back-to-back VRF &lt;br/&gt;
Notera att option AB ej är supporterat på IOS-XR.
 vrf definition VRF1
  address-family ipv4
   inter-as-hybrid next-hop 10.0.0.2
 !
 router bgp 100
  no bgp default route-target filter
  neighbor 2.2.2.2 remote-as 200
  address-family vpnv4
   neighbor 2.2.2.2 activate
   neighbor 2.2.2.2 inter-as-hybrid

==BGP-LU==
BGP Labeled Unicast (RFC 3107) tillhandahåller MPLS-transport mellan IGP-domäner. Genom att annonsera loopbacks och label bindings går det att kommunicera med routrar över IGP-gränser. BGP-LU annonseras mellan edge routrar och transport-routrarna i mitten märker inget. De vanligaste use casen för BGP-LU är Inter-AS MPLS VPN Option C, Seamless/Unified MPLS, CSC VPN och IGP free data center. 

 router bgp 100
  address-family ipv4
   neighbor 10.0.0.10 send-community both
   neighbor 10.0.0.10 next-hop-self
   neighbor 10.0.0.10 send-label 
Show
 show bgp ipv4 unicast labels
Notera att man på IOS måste ha med '''set mpls-label''' i sina route-map entries om ska använda route-maps för policy med BGP-LU.

=ICMP=
MPLS Echo skickas unicast till LDP-grannen med L3 destination address 127.0.0.1 på UDP 3503.

&lt;div class="mw-collapsible mw-collapsed" style="width:240px"&gt;
'''Echo Request:'''
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_MPLS_Echo_Request.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:240px"&gt;
'''Echo Reply:'''
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_MPLS_Echo_Reply.png]]
&lt;/div&gt;
&lt;/div&gt;

Man kan med MPLS-ping testa konnektivitet till en FEC, så detta funkar endast ifrån en LSR samt inga VPN-prefix fungerar heller utan endast det man lärt sig med LDP.
 ping mpls ipv4 10.1.1.1/32 
Med MPLS-traceroute kan man få ut mer information jämfört med vanlig traceroute eftersom det skickas mer data i payloaden. 
 traceroute mpls ipv4 10.1.1.1/32

=6PE=
IPv6 Provider Edge (RFC 4798) är en teknik för att köra IPv6 över ett IPv4+MPLS-nät. IPv6 prefix med tillhörande label utbyts genom att skicka det med IPv4 iBGP mellan PEs (eller via route reflector). Alla IPv6-prefix finns i den globala routingtabellen till skillnad från 6VPE. IPv6 prefixen har en IPv4-mappad IPv6-adress som next-hop inom MPLS-nätet och IPv4 LSP:er används mellan 6PEs. Detta gör att man inte behöver konfigurera next-hop-self. Däremot om IPv4-adressen inte finns i routingtabellen eller om det inte finns någon LSP kommer IPv6-prefixet att stå som inaccessible.

 router bgp 100
  address-family ipv6
   neighbor 10.0.0.10 activate
   neighbor 10.0.0.10 send-label
 
 show bgp ipv6 unicast labels

=IOS-XR=
 mpls ldp
  log
   hello-adjacency
   neighbor
   graceful-restart
   session-protection
  !
  graceful-restart
  discovery
   targeted-hello holdtime 30
   targeted-hello interval 10
  !
  router-id 10.10.0.101
  neighbor
   password encrypted 10422A2A0D33371D030A796571
  !
  session protection
  address-family ipv4
   discovery targeted-hello accept
   label
    local
     allocate for host-routes
     advertise
      explicit-null
 
 router isis 1
  address-family ipv4 unicast
   mpls ldp auto-config

Verify
 show mpls interfaces
 show isis mpls ldp

'''Unified MPLS''' &lt;br/&gt;
ABR/RR, för att next-hop-self ska funka. 
 router bgp 100
  ibgp policy out enforce-modifications
RR (som måste finnas i data path) kan stå för att stoppa in alla PE-prefix (/32) i bgp-tabellen.

=NX-OS=
Förutsättningar
 install feature-set mpls
 feature-set mpls
 feature mpls l3vpn
 feature mpls ldp
 
 interface loopback 1
  ip address 10.0.0.1/24
 
 mpls ldp configuration
  session protection
  router-id loopback 1
Aktivera på interface
 interface e1/1
  mpls ip
Synk med routing protokoll
 router isis P1
  mpls ldp sync
Authentication
 ip prefix-list &lt;namn&gt; permit &lt;granne1&gt;/32
 mpls ldp configuration
  password required for &lt;prefix-list&gt;
  password option 1 for &lt;prefix-list&gt; key-chain &lt;key-chain-name&gt;

[[Category:Cisco]]</text>
      <sha1>f4etombfj2utveu3cl44ep7p5gajtun</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco MPLS-TE</title>
    <ns>0</ns>
    <id>301</id>
    <revision>
      <id>3081</id>
      <parentid>3072</parentid>
      <timestamp>2020-01-03T09:45:17Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9427">Det finns olika tekniker för att göra TE i ett MPLS-nät. Det mest flexibla och skalbara är Segment Routing, se [[Cisco_SR|egen artikel]].

==RSVP==
Resource Reservation Protocol (RFC 2205) är ett kontrollplansprotokoll (IP protokoll #46) designat för att reservera resurser genom ett nätverk. Hostar/routrar kan begära att få vissa QoS-nivåer av nätverket. RSVP reserverar resurser men det är upp till varje enhet att ha en QoS-teknik för att leverera bandbredden. Till skillnad från vanlig QoS som är per frame/paket är detta per flöde, se även [[Cisco_QoS|Cisco QoS]]. 

Resource Reservation Protocol - Traffic Engineering (RFC 3209) är en extension till [[Cisco_RSVP|RSVP]] som används för Traffic Engineering i MPLS-nät. Det fungerar både som MPLS label distribution protocol och MPLS signaling protocol. En ingress LSR kan använda RSVP-TE för att notifiera alla LSR:er längs pathen till egress att den vill sätta upp en LSP. Bandbredd kan då allokeras genom hela MPLS-nätverket. RSVP är unidirectional och det sätts upp en LSP per riktning. Det fungerar både med IPv4 och IPv6. Default kommer MPLS-TE tunnlar att föredra TE metric value över IGP metric för deras dynamiska path selection. Dock är TE metrics tagna ifrån IGP metric default. 

Paket
* Path messages: används av ingress LSR för att begära LSP setup hop-by-hop längs hela pathen.
* Resv messages: används av egress LSR för att svara på Path message från ingress.
För att hålla LSP aktuell skickas periodvis PATH refresh och RESV refresh meddelanden. Om det inte finns tillräckliga resurser att tillgå någonstans längs vägen kommer den LSR:en att besvara ingress LSR som då får hitta en annan väg eller misslyckas med LSP-uppsättningen. 

===Konfiguration===
RSVP konfigureras på alla enheter genom nätverket och enableas på alla interface flödena ska traversera. Det behöver inte köras på alla enheter för att det ska funka men då kan man inte reservera bandbredd på dem heller.

 interface Gi2
  ip rsvp bandwidth 1000 100  #kbps
Om man inte specificerar total bandbredd och per-flow bandbredd kommer 75% av interfacets bandbredd kunna reserveras av ett enskilt flöde.

Verify
 show ip rsvp
 show ip rsvp interface
 show ip rsvp reservation

Om man kör LLQ/CBWFQ bör man stänga av RSVPs WFQ och klassificering.
 ip rsvp resource-provider none
 ip rsvp data-packet classification none

==Traffic Engineering==
MPLS TE är unidirectional tunnels från source (head-end) till destination (tail-end) i form av LSP:er som används för att forwardera trafik. RSVP-TE Explicit Route Object (ERO) är pathen för MPLS LSP som inkluderar en sekvenserad lista av LSR:er som LSP:n måste passera igenom mellan ingress och egress LSR. RSVP-TE använder pathen som beskrivs i ERO för att signalera och sätta upp LSP:n. Pathen kan vara admin specified eller automatiskt uträknad på headend utifrån en algoritm som constrained shortest path first (CSPF). Det finns strict path och loose path. Ingen LDP behövs. 

Traffic Parameter Attributes: &lt;br/&gt;
TE metric, Maximum bandwidth, Maximum reservable bandwidth, Unreserved bandwidth, Administrative group.

En sak som är bra att känna till med RSVP-TE är att om den primära vägen går ner (oavsett om det finns FRR eller inte) så kommer inte trafiken att skifta tillbaka till den ursprungliga vägen direkt efter att felet är åtgärdat. Det krävs att head-end signalerar berörd LSP igen (kollar om det finns en mer optimal väg). På både IOS och IOS XR sker detta periodiskt varje timme som standard. Det går även att signalera om en LSP manuellt. Om det finns en bättre väg kommer trafiken att skiftas över till den med MBB (make before break).

'''Konfiguration'''
 mpls traffic-eng tunnels

Per interface, detta måste konfas på alla core-interface.
 interface gi2
  mpls traffic-eng tunnels
  ip rsvp bandwidth

IGP, OSPF använder opaque LSA:er och IS-IS använder nya TLV:er för att skicka TE attribut.
 router ospf 1
  mpls traffic-eng router-id Loopback0
  mpls traffic-eng area 0
 
 router isis 1
  mpls traffic-eng router-id Loopback0
  mpls traffic-eng level-2

Tunnel. För att tunneln ska användas måste man routa över den, detta kan t.ex. göras med statisk routing eller autoroute. Eftersom det inte är en vanlig GRE-tunnel uppstår ingen recursive routing. Record route används för loop detection.
 interface Tunnel0
  ip unnumbered Loopback0
  tunnel mode mpls traffic-eng
  tunnel destination x.x.x.x
  tunnel mpls traffic-eng path-option 1 dynamic
  tunnel mpls traffic-eng autoroute destination
  tunnel mpls traffic-eng record-route

Verify
 show mpls traffic-eng tunnel
 show ip rsvp interface
 show ip route
 show ip rsvp reservation detail
 
 traceroute mpls traffic-eng tunnel 0

Dry run
 show mpls traffic-eng topology path destination 10.10.10.10 bandwidth 50000 
 show mpls traffic-eng link-management admission-control 

Logging, detta är för att skicka traps.
 mpls traffic-eng logging lsp
 mpls traffic-eng logging tunnel

'''Auto-Bandwidth'''&lt;br/&gt;
Med auto-bw mäter routern själv trafikmängden på tunneln periodiskt. Sedan kan olika bw-reservationer signaleras allt eftersom utifrån tunnels behov. Med statistics interval kan man t.ex. mäta LSP:n i 60 sekunder och sedan fatta ett beslut. Man bör känna till att auto-bw inte funkar klockrent med burstig trafik eftersom det inte alltid är så snabbt i förändring. Underflow och Overflow är tröskelvärden för event-baserad statistikinsamling. Detta är inte heller alltid supersnabbt vid förändring. Det är rekommenderat att köra: tunnel load-interval &lt; global sampling frequency &lt; tunnel adjust frequency.
 int tun0
  tunnel mpls traffic-eng auto-bw
Notera att senaste requested/signaled bandwidth sparas i running config.

'''TE - inter-area/multi-level'''&lt;br/&gt;
IOS implementerar Inter-Area MPLS TE genom att definiera ett Explicit Route Object (ERO), dvs en explicit-path som innehåller adresser till ABR eller L1/L2-router som ett loose hop i path:en. Detta resulterar i en pseudo-dynamic path calculation där Head End dynamiskt kalkylerar cSPF till sin exit ABR. Den kommer sedan dynamiskt kalkylera exit path till nästa ABR och så vidare tills man har nått tail end. Detta uppnås genom en loose hop expanderas i den fullt definierade explicita path:en, dvs Head End och ABRs definierar de hop som finns i den egna lokala flooding domain.

 ip explicit-path name INTER_AREA_TE enable
  next-address loose &lt;ABR1&gt;
  next-address loose &lt;ABR2&gt;

===Autotunnel - Fast Reroute===
RSVP-TE kan använda sig av backup LSPer för snabbare konvergens. Med hjälp av autotunnel backup kan dessa autoskapas efter behov och man behöver därmed inte assigna något till protected interfaces. Dynamiska backup NHOP/NNHOP tunnels skapas när en LSP requestar FRR protection, dvs tunnel signaleras när det finns något aktivt flöde som ska skyddas och det finns alternativa vägar. FRR föredrar NNHOP över NHOP backup tunnels om båda finns tillgängliga. För NNHOP FRR måste man ha record route. 

PLR
 mpls traffic-eng auto-tunnel backup

Head-end
 interface Tunnel0
  tunnel mpls traffic-eng fast-reroute

'''SRLG'''&lt;br/&gt;
SRLG-information distribueras med IGP och funkar endast för backup tunnels som är skapade av Autotunnel backup. 
 interface Gi0/1
  mpls traffic-eng srlg 1
  mpls traffic-eng srlg 2
 !
 interface Gi0/2
  mpls traffic-eng srlg 2
  mpls traffic-eng srlg 3
 !
 mpls traffic-eng auto-tunnel backup
 mpls traffic-eng auto-tunnel backup srlg exclude force 

===Autotunnel - Mesh===
Autoskapa tunnlar till alla PE:s som finns med i en acl.
 mpls traffic-eng auto-tunnel mesh
 
 interface Auto-Template1
  ip unnumbered Loopback0
  tunnel mode mpls traffic-eng
  tunnel destination access-list 1
 
 access-list 1 permit 1.1.1.1
 access-list 1 permit 1.1.1.2

Primary, configure tunnels to directly connected neighbors.
 mpls traffic-eng auto-tunnel primary onehop

===Inter-AS TE===
Med ASBR Forced Link Flooding kan man låta länkar som inte är med i IGP att installeras i TE database som point-to-point. Man konfigurerar länken som passiv för MPLS TE och anger neighbor TE-ID och ip-adress.
 mpls traffic-eng passive-interface nbr-te-id 1.1.1.2 nbr-if-addr 10.0.0.2 nbr-igp-id isis 49.0000.0000.0002.00

===Multicast===
Om man routar multicast i sitt core samtidigt som man kör MPLE-TE med autoroute announce kommer RPF att titta på fel best path. Workaround är att slå på att IGP håller två set med best paths under SPF calculation, en för unicast (TE tunnels och physical interfaces) och en för multicast (endast physical interfaces). 
 router ospf 1
  mpls traffic-eng multicast-intact

=IOS-XR=
===Auto-Tunnel Backup===
 ipv4 unnumbered mpls traffic-eng lo0
 mpls traffic-eng
  auto-tunnel backup
   tunnel-id min 6000 max 6500
  !
  interface GigabitEthernet0/0/0/0
   auto-tunnel backup

Verify
 show mpls traffic-eng auto-tunnel backup summary

===Mesh===
 ipv4 unnumbered mpls traffic-eng Loopback0
 ipv4 prefix-list PE
  10 permit 10.0.0.1/32
  20 permit 10.0.0.2/32
 !
 mpls traffic-eng
  auto-tunnel mesh
   group 1
    attribute-set PE
    destination-list PE
   !
   tunnel-id min 1000 max 1499
  !
  attribute-set auto-mesh PE
   logging events lsp-status state
   signalled-bandwidth 100 class-type 0
   autoroute announce
   fast-reroute
   record-route

[[Category:Cisco]]</text>
      <sha1>asj206q2eswmqcdiolbuja1e1hc9suq</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco MST</title>
    <ns>0</ns>
    <id>152</id>
    <revision>
      <id>2827</id>
      <parentid>2258</parentid>
      <timestamp>2018-08-22T12:26:48Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10541">Multiple Spanning Tree Protocol, IEEE 802.1s, använder algoritm Rapid ST och konvergerar snabbt. Man kan konfigurera så många topologier som man vill ha. Alla VLAN som inte specificeras i någon instans hamnar i instans 0 som default. Pathcost method behöver inte konfigureras utan operational value är alltid long till skillnad från andra STP-varianter. Se [[Cisco_STP|Cisco STP]]. MST-konfiguration går även att distribuera med hjälp av [[Cisco_VTP#VTPv3|VTPv3]].

===MST BPDU===
MST använder en BPDU för att skicka information om alla instanser. 
&lt;div class="mw-collapsible mw-collapsed" style="width:190px"&gt;
Exempel
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_MST_BPDU.png]]
&lt;/div&gt;
&lt;/div&gt;

'''Topology change''' &lt;br/&gt;
Den enda gång en topologiändring anses hända är när en non-edge port går från non-forwarding till forwarding. Den nya portan kan ha en bättre väg för MAC-adresserna och CAM-tabellen måste uppdateras. Går en port från forwarding till non-forwarding spelar det ingen roll för då är de MAC-adresserna unreachable, dyker de upp någon annanstans är det för att någon annan port har gått från non-forwarding till forwarding och då är det en topologiändring iallafall. Med MST floodas BPDUer med TC-biten satt till alla non-edge designated ports och root port förutom porten där ändringen kom in på. Även så flushas alla MAC-adresser på den porten. För att MST ska kunna tillhandahålla snabb konvergens måste alla inter-switchlänkar måste vara p2p och alla portar mot end systems måste vara edge ports annars kommer prestandan att degraderas.

==Region Interoperability==
MST instance 0 kallas Internal Spanning Tree (IST) och det är den som används för att interagera med andra MST-regioner och STP-protokoll. Det gör att MST-regionen ser ut som en enda stor switch för utsidan. STP-domäner kan kopplas ihop på flera ställen vilket kan leda till loopar därför skapar MST en Common Spanning Tree (CST) som innehåller alla inter region links. Andra STP-protokoll vet ej att de deltar i en CST. Detta kan sedan kopplas ihop med varje IST för att skapa Common and Internal Spanning Tree (CIST) som omfattar hela topologin som därmed hållas loopfri. Eftersom varje region har en egen rotbrygga kan det finnas flera CIST Regional Root Switches men det kan endast finnas en CIST Root. Den med bäst Bridge ID av alla switchar i alla regioner blir CIST. Alla andra regionala root väljs utifrån lägst cost till CIST och inte BID.

[[File:Cisco_MST_Regions.jpg|650px]]

=Konfiguration=
Följande element måste vara identiska på alla switchar inom samma MST region:
* region name
* revision number
* instances

 spanning-tree extend system-id
 spanning-tree mode mst
 spanning-tree mst configuration
  name Site1
  revision 1
  instance 1 vlan 1-2000
  instance 2 vlan 2001-4094
  show current

Root, priority 0 är det absolut lägsta medans root primary sätter prio till 24k förutsatt att det ger root-rollen, detta ändras inte dynamiskt.
 spanning-tree mst 1 root primary
 spanning-tree mst 2 priority 0
 spanning-tree mst 0 root primary diameter 7 hello-time 2

Port Cost &amp; Priority
 interface Gi0/1
  spanning-tree mst 1 cost 50
  spanning-tree mst 1 port-priority 128

'''Verify'''
 show spanning-tree mst
 show spanning-tree mst interface
 
 spanning-tree logging 
 test spanning-tree diameter 3
 test spanning-tree get configuration mst

Mappa alla secondary vlan till samma MST-instans som deras primary VLAN befinner sig i, se även [[Cisco_VLAN#Private_VLAN|Private VLAN]].
 spanning-tree mst configuration
  private-vlan synchronize

MST började implementeras av tillverkarna innan standarden var helt spikad vilket man bör tänka på om man kör gamla enheter. Dock säger standarden att pre-standard MST-grannar måste kunna upptäckas automatiskt av kompabilitetsskäl. I normalfallet märker man ingenting men om grannen är tyst, t.ex. en root port, kan man slå på det per interface.

 interface gi0/7
  spanning-tree mst pre-standard

 show spanning-tree mst configuration digest

==Nexus==
Grundkonf för [[Cisco_Nexus|NX-OS]].
 spanning-tree mode mst
 spanning-tree mst configuration
  name DC1
  revision 1
  exit
 
 spanning-tree mst 0 priority 32768
 spanning-tree pathcost method long
 spanning-tree port type edge default
 spanning-tree port type edge bpduguard default
 spanning-tree port type edge bpdufilter default
 spanning-tree loopguard default

=Extensions=
Det finns många tillägg till spanning-tree som kan öka stabilitet och säkerhet. Dessa agerar fristående från varandra förutom att de går att konfigurera ihop. Detta är tillägg för protokoll som kör Rapid ST.
 show spanning-tree summary

===PortFast===
När en vanlig port aktiveras så initierar RSTP sin synk-process för snabb konvergens. Om andra sidan t.ex. är en server så kommer den inte att köra STP och inget sync response kommer att skickas tillbaka. Detta gör att RSTP måste falla tillbaka till legacy STP-regler och vänta på att forward delay ska gå ut innan länken blir i forwarding state. Med PortFast definierar man edge ports, dessa går direkt till forwarding när de kommer upp och inget topology change event genereras. En edge port skickar ut BDPUer men förväntar sig inga tillbaks. Om det kommer in en BPDU slutar porten vara edge port och återgår till normal tills interfacet går down/up. Används för anslutningar ut till servrar och andra end hosts. Ibland är PortFast ett måste pga att [[Cisco_DHCP|DHCP]] hinner timea ut innan porten blivit forwarding. 

Globalt, aktiveras på alla portar i operational state: access
 spanning-tree portfast default
Per interface, on/off
 spanning-tree portfast
 spanning-tree portfast disable
Verify
 show spanning-tree interface gi0/10 portfast
Vill man ha portfast på en trunk måste man ställa det per interface
 spanning-tree portfast trunk
Kör aldrig portfast mot andra switchar! MST och RSTP har tekniker för att vara snabba ändå.

===BPDU Guard===
BPDU Guard är en säkerhetsmekanism som sätter interface i error disable om det kommer en BPDU. ''%PM-4-ERR_DISABLE: bpduguard error detected on Po2, putting Gi0/8 in err-disable state''

Globalt, skyddar alla PortFast-portar
 spanning-tree bpduguard default
Per interface, on/off
 spanning-tree bpduguard enable
 spanning-tree bpduguard disable
Auto recovery
 errdisable recovery cause bpduguard 

===Root Guard===
Skydda så att ingen annan än den enhet man själv har konfigurerat kan bli root genom att ignorera superior BPDUer som kommer in på portar med Root Guard påslaget. Om det kommer in en superior BPDU så hamnar porten i root-inconsistent blocking state och frames varken forwardas eller tas emot. Porten går automatiskt tillbaka när dessa BPDUer slutar att komma in. ''%SPANTREE-2-ROOTGUARD_BLOCK: Root guard blocking port GigabitEthernet0/8 on VLAN0002.''

Per interface
 spanning-tree guard root

===BPDU Filter===
En edge port skickar BPDUer som vanligt enligt Hello-interval men om det inte finns något som talar STP på andra sidan är detta onödigt. Med BPDU filter påslaget slutar switchen att skicka BPDUer efter 10 obesvarade (det skickas även en BDPU direkt vid link up så 11 totalt). Porten är dock beredd på att behandla BPDUer och BDPU-filter inaktiveras ifall det kommer in en BPDU vilket gör att detta är ett någorlunda mindre osäkert sätt att terminera sin STP-domän på.

Globalt, gäller alla PortFast-portar
 spanning-tree portfast bpdufilter default

Man kan också hårdställa BPDU-filter per interface om man t.ex. ska splita ett nätverk i olika STP-domäner. Inga BPDUer kommer att skickas eller behandlas. 

Per interface, hard on/off
 spanning-tree bpdufilter enable
 spanning-tree bpdufilter disable

===Loop Guard===
Unidirectional links kan ställa till det för en L2-domän. Med Loop Guard stoppar man den vanliga STP-konvergeringen för root och alternate portar. Eftersom det ska komma in BPDUer på vissa portar är det inte normalt att det plötsligt inte gör det längre utan att länken har gått ner. Loop Guard förhindrar dessa portar från att bli designated utan de hamnar istället i loop-inconsistent blocking state. När det kommer BPDUer igen återgår portarna till normalt tillstånd. Loop Guard fungerar endast på point-to-point länkar. ''%SPANTREE-2-LOOPGUARD_BLOCK: Loop guard blocking port GigabitEthernet0/8 on VLAN0002.''

Globalt, skyddar alla root- och alternate-portar
 spanning-tree loopguard default
Per interface
 spanning-tree guard loop

===Bridge Assurance===
Bridge Assurance är en utökning till Loop Guard och det fungerar med RSTP och MST. Slår man på det så skickar båda sidor alltid BPDUer oavsett port state och BPDUerna används som en Hello-mekanism för att se om grannen lever. BPDU agerar alltså keepalive message och skickas per-vlan eller per-instans beroende på STP mode. Kommer det inte in någon BPDU hamnar porten i BA-inconsistent blocking state tills BPDU åter mottages. Båda sidor av länken måste alltså slå igång Bridge Assurance. Detta skyddar mot unidirectional links eftersom de error disableas men även vid loopar orsakade av switchar som slutat prata STP men ändå forwarderar frames. BA prunear också onödiga VLAN på trunklänkar. Detta är en [[Cisco_Nexus|Nexus]]-feature men finns även i nyare versioner av IOS. 

Global
 spanning-tree bridge assurance
Per interface
 spanning-tree portfast network 

===PVST Simulation===
MST kan samköras med Rapid PVST+ utan någon speciell konfiguration. Detta är en feature på [[Cisco_Nexus|Nexus]]-switchar och nyare IOS och det slåss på när man konfigurerar MST. Man kan stänga av PVST simulation globalt eller per port, det som händer då är att en port som får in en Rapid PVST+ BPDU hamnar i blocking state tills det slutar komma BPDUer. Rotbryggan för alla VLAN måste finnas på samma sida, antingen i MST eller i PVST+. Om man inte uppfyller detta kommer porten att hamna i PVST simulation-inconsistent state dvs forwarding stängs av. 
 interface Gi0/2
  spanning-tree mst simulate pvst

===Others===
Dispute mechanism innebär att role och state hos porten som skickar en BPDU skickas med i BPDUn så andra sidan vet att den inte pratat med en designated port på en designated port. Då hamnar porten i discarding state. Detta är påslaget default och behöver inte konfigureras. Fungerar dock inte med de äldsta varianterna av STP.

'''UDLD''' &lt;br/&gt;
Se [[Cisco_UDLD|Cisco UDLD]]

[[Category:Cisco]]</text>
      <sha1>7m2843u7bnpclilojcdg2pthccxg3im</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco MVPN</title>
    <ns>0</ns>
    <id>555</id>
    <revision>
      <id>3055</id>
      <timestamp>2019-11-14T19:52:12Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Multicast VPN (MVPN) möjliggör multicast över [[Cisco_MPLS#VPN|L3VPN]]. En viktig komponent för MVPN är BGP, safi MVPN kan göra två saker: Auto-Discovery routes och C-m..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3165">Multicast VPN (MVPN) möjliggör multicast över [[Cisco_MPLS#VPN|L3VPN]]. En viktig komponent för MVPN är BGP, safi MVPN kan göra två saker: Auto-Discovery routes och C-mcast signaling. PE-CE är alltid PIM men underlay i core kan göras på en mängd olika sätt och stäm därför alltid av med Ciscos dokumentation över MVPN-profilerna. 

* '''IOS:''' https://www.cisco.com/c/en/us/support/docs/ip/multicast/118985-configure-mcast-00.html
* '''IOS-XR:''' https://www.cisco.com/c/en/us/support/docs/ip/multicast/200512-Configure-mVPN-Profiles-within-Cisco-IOS.html

[[Cisco_MVPN.PNG]]

=MLDP=
Multicast Label Distribution Protocol (MLDP) är en extension till LDP som används för att sätta upp P2MP och MP2MP LSP:er i MPLS-nätverk. I overlay (allt som har med vpn/vrf context att göra) kan man använda PIM och/eller BGP för control plane. Det finns även in-band signaling med MLDP, det man gör i praktiken är att stitcha ihop customer pim tree med MLDP LSP:er i core. Detta är inte superskalbart eftersom P-noder måste hålla state för kunders multicast-träd. I varje MLDP-träd finns en root, för att lösa root node redundancy kan man antingen köra med en phantom root (olika masklängd på loopbacks) eller med två parallella root-noder. Det senare kräver mer state men har snabbare konvergens eftersom all signalering redan är gjord. Eftersom alla är med i båda träd kan man skicka multicastströmmar i valfritt träd. Med MLDP swapas label per hop men det finns ingen PHP. Det finns stöd för FRR.

MLDP utbyts som en capability, alla plattformar har inte stöd för MLDP.
 show mpls ldp capabilities
 show mpls mldp neighbors

Core tree types. Ciscos namn kontra RFC:
* Default MDT = Multi-directional inclusive PMSI
* Data MDT = Selective PMSI
* Partitioned MDT = Multi-directional selective PMSI

[[Cisco_mLDP.PNG]]

[[Cisco_MVPN_in-band.PNG]]

==IOS==
Konfiguration
 ip multicast mpls mldp
 mpls mldp logging notifications
Exempel
 ip multicast-routing vrf VPN_A distributed
 !
 vrf definition VPN_A
  vpn id 100:100
  address-family ipv4
  mdt default mpls mldp 11.11.11.11
  mdt data mpls mldp 110
  mdt data threshold 30

Verify
 show ip multicast mpls vif
 show mpls mldp database brief
 show mpls mldp root
 ping mpls mldp mp2mp &lt;root&gt; mdt &lt;vpn-id&gt; 0

Det finns ingen MBB by default.
 mpls mldp make-before-break delay 5000

==IOS-XR==
Konfiguration
 multicast-routing
  address-family ipv4
   interface Loopback0
    enable
 !
 mpls ldp
  mldp
   logging notifications

Verify
 show mpls forwarding p2mp
 show mpls mldp forwarding
 show mrib mpls forwarding

Om man kör t.ex. Segment Routing har man inget behov av LDP, då kan man köra MLDP only.
 mpls ldp
  capabilities sac mldp-only

'''MoFRR'''&lt;br/&gt;
MoFRR bygger två träd, egress PE måste ha IGP ecmp till ingress PE.
 mpls ldp
  mldp
   address-family ipv4
    mofrr

==Unified MPLS==
MVPN över unified MPLS eller Inter-AS MPLS option C funkar faktiskt men det är en växel man måste slå på i egress PE. 

IOS-XE
 mpls mldp forwarding recursive-fec
IOS-XR
 mpls ldp mldp address-family ipv4 recursive-fec

[[Cisco_MPLS_Seamless.PNG]]

[[Category:Cisco]]</text>
      <sha1>a3tpkl7hut17u5lvvxmsffov5s4nqv1</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco Multicast</title>
    <ns>0</ns>
    <id>289</id>
    <revision>
      <id>3018</id>
      <parentid>2591</parentid>
      <timestamp>2019-09-17T12:15:11Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7311">IP Multicast är att skicka ett meddelande från en source till multipla destinationer i en ström över ett IP-nät, vilket kan spara väldigt mycket bandbredd. En multicast-IP är en destinationsadress och alla som ska ta del av trafiken måste gå med i samma multicastgrupp, dvs lyssna på den IPn och meddela det till intermediate systems. End systems och routrar pratar IGMP med varandra för att ta reda på vem som är med i vilken multicastgrupp. För att routrar ska kunna veta vilka nät som har intressenter av multicastströmmar används något routing eller signaleringsprotokoll (control plane), DVMRP, MOSPF eller PIM. För loop prevention används RPF, inga paket forwarderas utan att klara denna check. IP Multicast fungerar för protokoll som är connectionless.

För konfiguration se [[Cisco_PIM|Cisco PIM]], [[Cisco_IGMP|Cisco IGMP]] och [[Cisco_MLDP|Cisco MLDP]]. Även om framtiden kanske stavas Bit Indexed Explicit Replication.


[[File:Cisco_Multicast.png]]

==Multicast Addressing==
Multicast har egna address spaces, för IPv4 används 224.0.0.0/4 (class D) och för IPv6 FF00::/8. I dessa finns det olika ranges, GLOP (RFC 2770) innebär att varje 16-bitars AS har en egen unik multicast-range på internet, 233.&lt;ASN&gt;.0/24. Administratively scoped (RFC 2365) är motsvarigheten till unicasts RFC 1918.

* Local-link (TTL 1): 224.0.0.0/24
* Globally scoped: 224.0.1.0 - 238.255.255.255
* GLOP addresses: 233.0.0.0/8
* Administratively scoped: 239.0.0.0/8
Complete IANA list: [http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml IPv4], [http://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml IPv6]

Utifrån IP-adress räknas multicast mac-adress fram så att enheterna vet vad de ska skicka till och ta emot frames för utöver BIA och broadcast. En multicast-adress för IPv4 mappas till MAC address 01:00:5E:&lt;low-order 23 bits&gt; och IPv6 mappas till MAC 33:33:&lt;low-order 32 bits&gt;.

===Distribution Trees===
Multicastroutrar skapar distributions-träd för att styra vilken väg multicasttrafiken tar genom nätverket. Det finns två typer av trädtopologier, source trees och shared trees. Source trees kallas också shortest-path tree och det skapas ett spanning tree från root/source till alla leaves. Ett source tree består av source och destination och betecknas S,G, t.ex. (172.20.0.40, 225.0.10.10). Till skillnad från source trees har shared trees en gemensam rot oavsett source, denna punkt kallas rendezvous point. Ett shared tree betecknas *,G vilket betyder any source. Trafik tunnlas från routern närmast källan till RP för att sedan distribueras ut i det delade trädet. 

===Source Specific Multicast===
Med SSM kan hostarna själva välja source för trafikströmmen ifall det finns flera. Det kan även skydda mot dos-attacker eftersom mottagare berättar för nätverket vilka källor de vill få trafik ifrån och inte vem som helst. Det ger också fördelar med att överlappande grupp-adresser kommer att fungera eftersom olika källor gör strömmarna unika. Det finns inga shared trees med SSM utan allt hanteras som source trees. SSM har 232.0.0.0/8 IANA-reserverat. Se [[Cisco_PIM#Source_Specific_Multicast|SSM-konfiguration]].

==Multicast Routes==
Static mroutes kan användas i situationer när man behöver konstruera multicast-strömmar att gå över en länk som inte kör IGP, t.ex. tunnlar, eller fixa RPF failures som man får när multicast routing inte körs på alla länkar. Genom att lägga till en static mroute så kommer RPF att titta på den i första hand eftersom den har en bättre administrative distance (AD = 0) än det som finns i unicast RIB:en. Finns det flera equal cost paths till sender kommer endast interface med aktiva PIM-grannskap att användas. Och efter det kommer den med högst PIM neighbor IP att vinna, detta gör att RPF är deterministiskt. I nyare versioner av IOS används alltid longest match av RPF vilket inte var fallet förr. 

 ip mroute 10.0.0.0 255.255.255.0 gi2
 ipv6 route 1000::/64 gi2 multicast

Verify. Notera att endast routes med next-hop över interface där det finns PIM neighbors genererar RPF entries och därmed syns med dessa kommandon.
 show ip rpf &lt;mcast-source&gt;
 show ipv6 rpf &lt;mcast-source&gt;

'''CEF''' &lt;br/&gt;
Såhär fungerar CEF default
 224.0.0.0/4          drop
 224.0.0.0/24         receive

==Troubleshooting==
Active IP Multicast Sources sending &gt;= 4 kbps.
 show ip mroute active

'''mtrace''' &lt;br/&gt;
Show the multicast path from the source to the receiver. Detta är en IGMP-baserad trace.
 mtrace 10.0.0.10 20.0.0.20 224.1.4.4

'''mstat''' &lt;br/&gt;
Show the multicast path, användbart för att upptäcka congestion.
 mstat 10.0.0.10 20.0.0.20 224.1.4.4

'''mrinfo''' &lt;br/&gt;
Show multicast neighbor router information (legacy-kommando).
 mrinfo

'''Packet Debugging'''
 interface gi2
  no ip mfib cef input
  no ip mfib cef output
 
 debug ip mfib pak 239.1.1.10

==Multicast Helper==
Syftet med denna funktion är att tillåta broadcasts över ett multicast capable network. Det fungerar precis som det mer vanliga '''ip helper-address''' men då konverteras broadcast till unicast. IP multicast helper-map konverterar broadcast till en utvald multicast-adress. Man måste ha ett fungerande multicast-nät för kunna nyttja detta samt en extended ACL som pekar ut vilken trafik som får göras om till multicast.

Ingress router
 ip forward-protocol udp &lt;port-number&gt;
 
 interface gi2
  ip multicast helper-map broadcast &lt;mcast-address&gt; &lt;acl&gt;

Egress router
 ip forward-protocol udp &lt;port-number&gt;
 
 interface gi2
  ip multicast helper-map &lt;mcast-group&gt; &lt;directed-broadcast-IP&gt; &lt;acl&gt;
Default så skickas broadcasten ut till 255.255.255.255 oavsett vad man satt ''directed-broadcast-IP'' till, vill man ha det till något annat måste man använda '''ip broadcast-address &lt;IP&gt;''' på interfacet.

==IGMP Static Group==
Man kan skicka ut multicastpaket på ett interface även fast det inte finns någon enhet som pratar PIM eller IGMP, detta kallas Static Group. Routern som konfas med detta kommer att skicka PIM Join request upstream för att ta del av strömmen och sedan forwardera ut det på de interface med den statiska gruppen. 
 interface gi2
  ip pim sparse-mode
  ip igmp static-group 232.1.1.1 source 10.1.1.3

==BGP==
Man kan skicka information om multicast-strömmar mellan domäner med hjälp av MP-BGP extensions. När man lär sig ett prefix med multicast BGP så kommer RPF att kollas mot den IP som står som next-hop i uppdateringen. Dvs BGP handlar inte om hur man hittar till en destination eftersom en multicast-adress alltid kommer vara destination utan man berättar vilka sources man har från en viss next-hop och då kan man klara rpf-checken. Så man måste se till att populera även denna BGP-tabell, det kan t.ex. göras med redistribution från ett unicast-protokoll. Man måste köra PIM mellan domänerna för att shared och shortest-path trees ska kunna signaleras. Man måste även utbyta unicast routes för multicast-källorna för att alla multicast routrarna ska kunna använda RPF. Se även [[Cisco_BGP#Multiprotocol_BGP|Cisco MP-BGP]].

 router bgp 100
  address-family ipv4 multicast
   neighbor 10.0.0.20 activate
Verify
 show bgp ipv4 multicast summary

[[Category:Cisco]]</text>
      <sha1>npjh4oewht4u425meppdb5kqmnx5itj</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco NAT</title>
    <ns>0</ns>
    <id>254</id>
    <revision>
      <id>3028</id>
      <parentid>2967</parentid>
      <timestamp>2019-10-01T10:40:06Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8443">Network Address Translation används för att skriva om adresser i IP-paket. Det är inte säkert att NAT fungerar tillsammans med ACL:er som använder '''log''' så det bör man ha i åtanke. För att accelerera NAT-processen finns '''ip nat create flow-entries''' som är påslaget default i [[Cisco_IOS|IOS]]-routrar. 

Generell metod för att testa om NAT fungerar.
 debug ip nat
 telnet 1.1.1.1 
 who

==Dynamic NAT==
===NAT Overload===
Alla adresser göms bakom en IP-adress, kallas även PAT.
 access-list 10 permit [ip-address] [wildcard-mask]
 ip nat inside source list 10 interface [outside-interface] overload
Man kan även skapa en pool med endast en ip adress och köra overload på den.

Verify
 show ip nat translations
 show ip nat statistics

===Default Interface===
NAT Default interface innebär att all trafik som initieras utifrån och natas in går till en och samma IP men däremot kan trafik som initieras inifrån hide natas till interface IP (nat overload). 

 ip access-list standard ALL
  permit any
 ip nat inside source list ALL interface Gi2 overload
 ip nat inside source static 172.16.0.20 interface Gi2

===NAT Pool===
 interface Gi0/1
  ip address 100.10.10.10 255.255.255.0
  ip nat outside
 interface Gi0/2
  ip address 192.168.0.1 255.255.255.0
  ip nat inside
 
 ip access-list standard CLIENT-LIST
  permit 192.168.0.0 0.0.0.15
 
 ip nat pool DYNAMIC 100.10.10.17 100.10.10.19 prefix-length 29
 ip nat inside source list CLIENT-LIST pool DYNAMIC
Interface IP ska ej ingå i NAT-poolen däremot bör netmask/prefix-length inrymma alla adresser i poolen. 

Verify
 show ip nat translations
 show ip nat pool name DYNAMIC
 show ip nat translations filter range inside global 100.10.10.17 100.10.10.19 total

===TCP Load Distribution===
Man kan gömma flera servrar bakom en ip-adress för att tillhandahålla lastdelning. Det görs med en rotary address pool samt en acl som anger den IP som man ska gå emot från outside. Både standard och extended acl fungerar. När paket/sessioner på ett NAT outside interface träffar acl:en så översätts det till en av adresserna från poolen enligt round-robin.

 ip nat pool ROTARY prefix-length 24 type rotary
  address 10.0.0.10 10.0.0.10
  address 10.0.0.11 10.0.0.11
  address 10.0.0.12 10.0.0.12
 
 ip access-list extended DISTRIBUTE_LOAD
  permit tcp any host 100.10.10.15 eq www
 
 ip nat inside destination list DISTRIBUTE_LOAD pool ROTARY

==Static NAT==
1:1 NAT
 interface Gi0/1
  ip address 100.10.10.10 255.255.255.0
  ip nat outside
 interface Gi0/2
  ip address 192.168.0.1 255.255.255.0
  ip nat inside
NAT
 ip nat inside source static 192.168.0.20 100.10.10.20 [no-alias]
''Med no-alias besvaras inte ARP-förfrågningar för den IP-adressen på utsidan.''

Verify
 show ip nat translations
 show ip nat statistics
 show ip alias
''DYNAMIC är IP-adresser som används för NAT.''

===Static PAT===
 interface Gi0/1
  ip address 100.10.10.10 255.255.255.0
  ip nat outside
 interface Gi0/2
  ip address 192.168.0.1 255.255.255.0
  ip nat inside
PAT / port forward. 
 ip nat inside source static tcp 192.168.0.55 80 100.10.10.10 80
Verify
 show ip nat translations
 show ip aliases

===Static Extendable NAT===
Om man vill ha flera ip-adresser som ska natas till samma inside IP. 
 ip nat inside source static 10.1.1.1 20.0.0.20 extendable
 ip nat inside source static 10.1.1.1 20.0.0.30 extendable

===Static Policy NAT===
Policy NAT använder route-maps. Med set interface kan man bestämma vilket interface paketen ska skickas ut på och därmed natas.
 interface Gi0/0
  ip nat outside
 
 ip access-list extended TO_OUTSIDE
  permit ip 192.168.0.0 0.0.0.255 any
 
 route-map TO_ISP1 permit 10
  match ip address TO_OUTSIDE
  set interface Gi0/0
 
 ip nat inside source route-map TO_ISP1 interface Gi0/0 overload

Man kan också låta routingtabellen styra och sedan NATa utifrån vilket interface som är egress.
 route-map TO_ISP1 permit 10
  match interface Gi0/0
 
 route-map TO_ISP2 permit 10
  match interface Gi0/1
 
 ip nat inside source static 192.168.0.10 100.10.10.10 route-map TO_ISP1
 ip nat inside source static 192.168.0.10 100.20.20.20 route-map TO_ISP2

==Reversible NAT==
Man kan konfigurera nat som endast funkar efter att ha blivit initierad från andra hållet.
 ip nat pool POOL 100.10.10.15 100.10.10.19 netmask 255.255.255.0
 ip nat inside source route-map ROUTE-MAP pool POOL '''reversible''' 

==Dubbel-NAT==
Har man överlappande subnät får man antingen NATa på båda sidorna eller bara ena. I detta exemplet kommunicerar 172.20.0.10 (server1) mot ip 172.20.0.50 som natas till 30.0.0.5 (server2) medans server2 ser server1 från 30.0.0.50.
 ip nat inside source static 172.20.0.10 30.0.0.50
 ip nat outside source static 30.0.0.5 172.20.0.50 add-route
Utan add-route måste en statisk route användas för att peka 172.20.0.50 till outside interface.
 show ip nat translations

==Stateful NAT==
Stateful NAT with [[Cisco_HSRP|HSRP]]. During failovers, NAT translated IP addresses on devices may be different from the IP address before the failover, because no state information is exchanged between active and standby devices. HSRP Virtual IP Address (VIP) cannot be used by NAT pools.

 interface gi2
  standby 100 name SNAT
 ip nat stateful id 1 redundancy SNAT mapping-id 10
 ip nat pool SNATPOOL 10.1.1.1 10.1.1.9 prefix-length 24
 ip nat inside source route-map ROUTE-MAP pool SNATPOOL mapping-id 10 overload

Primary
 ip nat stateful id 1 primary 10.10.10.10 peer 10.22.22.22 mapping-id 10
Backup
 ip nat stateful id 1 backup 10.2.2.2 peer 10.10.10.10 mapping-id 10

Verify
 show ip snat distributed verbose

==NVI==
Med Nat Virtual Interface kan man adressöversätta mellan VRF:er och man använder inte ''inside'' och ''outside'' med denna metod. NAT Virtual Interfaces are not supported in the Cisco IOS XE software.
 interface Gi0/1
  ip nat enable
 interface Gi0/2
  ip nat enable
 
 ip nat source static 192.168.0.1 100.10.10.10
Show
 show ip nat nvi translations
 show ip nat translations verbose

==IPv6==
NAT – Protocol Translation kan användas vid IPv4 till IPv6 migreringar och ger bi-directional connectivity mellan domänerna.
 interface gi 0/0
  ipv6 nat
 interface gi 0/1
  ipv6 nat
 ipv6 nat v6v4 source 3001:11:0:1::1 150.11.3.1
 ipv6 nat v4v6 source static 150.11.2.2 2000::960b:0202
 ipv6 nat prefix 2000::/96
NAT-PT kräver ett /96 prefix

Verify
 show ipv6 nat translations

'''NPTv6''' &lt;br/&gt;
IPv6-to-IPv6 Network Prefix Translation är NAT från IPv6 till IPv6. Eftersom det finns en 1:1-relation mellan inside och outside prefix behöver inte routern hålla något state i data plane för NAT:en. Detta underlättar multihoming.
 nat66 prefix 2002:ABC1::/64 Outside 2002:ABC2::/64
 
 interface GigabitEthernet0
  nat66 inside
 interface GigabitEthernet1
  nat66 outside

Verify
 show nat66 prefix
 show nat66 statistics

==CGNAT==
Carrier-grade NAT är large-scale NAT (LSN), det kan vara NAT44, NAT64 och/eller NAT66. Nyckeln till att kunna hantera fler NAT-sessioner än vanligt är att ingen information om destination lagras. CGNAT enableas globalt, dvs man kan inte köra annan NAT samtidigt. 
 ip nat settings mode cgn

Dynamic Port Address CGNAT
 ip nat settings pap
 ip nat pool PUBLIC-POOL 1.1.1.10 1.1.1.20 prefix-length 24
 ip nat inside source list NAT-ACL pool PUBLIC-POOL overload
 ip access-list extended NAT-ACL
  permit ip 10.0.0.0 0.255.255.255 any

==MPLS VPN==
NAT-integration med MPLS VPN tillåter flera MPLS VPN att konfigureras att fungera tillsammans på samma enhet. NAT kan skilja på vilken VPN den får in trafik på även om alla använder samma IP-adresser. Detta låter flera kunder använda samma services men ändå vara skiljda logiskt. Se även [[Cisco_MPLS|Cisco MPLS]].

 interface Gi0/1
  ip address 100.10.10.10 255.255.255.0
  ip nat outside
 interface Gi0/2
  vrf forwarding VPN1
  ip address 192.168.0.1 255.255.255.0
  ip nat inside
 interface Gi0/3
  vrf forwarding VPN2
  ip address 192.168.0.1 255.255.255.0
  ip nat inside
 
 access-list 1 permit 192.168.0.0 0.0.255.255
 ip nat pool SHARED 100.10.10.20 100.10.10.40 netmask 255.255.255.0
 
 ip nat inside source list 1 pool SHARED vrf VPN1 overload
 ip nat inside source list 1 pool SHARED vrf VPN2 overload
 
 ip route vrf VPN1 0.0.0.0 0.0.0.0 Gi0/1 100.10.10.1
 ip route vrf VPN2 0.0.0.0 0.0.0.0 Gi0/1 100.10.10.1

Verify
 show ip nat translations vrf VPN1

[[Category:Cisco]]</text>
      <sha1>0zk82lf9dpwn5s165tn1suvo3ramwmq</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco NetFlow</title>
    <ns>0</ns>
    <id>226</id>
    <revision>
      <id>2911</id>
      <parentid>2212</parentid>
      <timestamp>2018-12-19T13:18:55Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4260">Netflow är ett Cisco-properitärt protokoll som används för att kunna exportera data om vilka adresser och protokoll som används i ett nätverk och hur mycket trafik de genererar. De vanligaste versioner som används är 5 och 9. Den stora skillnaden är att v5 inte har stöd för IPv6 eller MPLS. Samt att v5-paket har ett fixerat paketformat. Paket för version 9 kan se olika ut och man kan ändra det med templates. Det finns även IETF-standard, [https://en.wikipedia.org/wiki/IP_Flow_Information_Export IPFIX]. Se även [[Cisco_SPAN|Cisco SPAN]].

Komponenter:
* Flow exporter, t.ex. en router
* Flow collector, t.ex. [[Pmacct]]
* Analysis application, t.ex. [[Ntopng]], [[FastNetMon]]

===Paket===
Ett NetFlow-paket skickas med UDP och kan innehålla metadata om flera trafikflöden. 

&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
* NetFlow v9:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_Netflow_v9.png]]
&lt;/div&gt;
&lt;/div&gt;

Om man använder version 9 så skickar Cisco-enheter en NetFlow-template var 20:e paket så mottagare vet vilken information NetFlow-paketen innehåller. 
&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
* NetFlow template:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_NetFlow_Template.png]]
&lt;/div&gt;
&lt;/div&gt;

=Konfiguration=
Legacy IOS syntax
 int gi0/0
  ip flow ingress
  ip flow egress

Top-talkers
 ip flow-top-talkers
  sort-by bytes
  top 5

Show
 show ip flow top-talkers 
 show ip cache flow 

===ASR===
IOS-XE använder den modernare syntaxen som kallas Flexible NetFlow. Man kan även definiera och använda egna flow records, dvs vilken information som ska exporteras. &lt;br/&gt;
OBS en ASR 1000 kan inte använda sitt management-interface som source för NetFlow-exporten.
 flow exporter COLLECTOR
  destination 10.0.0.10
  transport udp 2055
  source gi0/1
  export-protocol netflow-v9
 
 flow monitor FLOW-MONITOR
  record netflow ipv4 original-input 
  exporter COLLECTOR
  cache timeout active 60
 
 interface gi0/3
  ip flow monitor FLOW-MONITOR input
"Random Sampled NetFlow is more statistically accurate than Sampled NetFlow." - Cisco
 sampler SAMPLER-1
  mode random 1 out-of 1000
 interface gi0/3
  ip flow monitor FLOW-MONITOR sampler SAMPLER-1 input

Verify
 show flow exporter
 show flow interface
 show flow monitor
 show flow exporter statistics
 show flow record
 show sampler

'''MPLS-aware NetFlow'''
 interface gi2
  mpls netflow egress

===EzPM===
Med Easy Performance Monitoring så autokonfas allt man behöver utifrån en färdig profil, man kan välja mellan prestanda, upplevelse och statistik. Man får tillgång till alla Application, Visibility and Control (AVC) features.

 performance monitor context EzPM profile application-experience
  exporter destination 10.0.0.10 source loopback0 transport udp port 2055 [vrf]
  traffic-monitor all
 
 interface Gi0/1
  performance monitor context EzPM

Verify
 show performance monitor context EzPM

===Nexus===
 feature netflow
 
 flow exporter COLLECTOR
  destination 10.0.0.10 use-vrf management
  version 9
  transport udp 2055
  source mgmt 0
 
 flow monitor FLOW-MONITOR
  exporter COLLECTOR
  record netflow-original

Ska man samla in netflow på ett interface i ett F3-kort måste sampler användas.
 sampler SAMPLER-1
  mode 1 out-of 5
Interface
 interface Ethernet1/1
  ip flow monitor FLOW-MONITOR input sampler SAMPLER-1

Verify
 show flow record netflow-original
 show flow exporter
 show flow monitor 
 show flow interface

'''Layer 2''' &lt;br/&gt;
Man kan även exportera metadata för L2-trafik med netflow. Notera att flow monitor måste ha flow records för L2, dvs Vlan, MAC och ethertype.
 interface e1/1
  switchport
  layer2-switched flow monitor FLOW-MONITOR input

=IP Accounting=
IP Accounting är en annan feature i IOS som också kan användas för att kolla trafik lokalt, dock mindre populär än NetFlow.
 ip accounting-threshold 1200
 ip accounting-list 10.0.10.0 0.0.0.255
 int g2/0
  ip accounting output-packets

 show ip accounting
 clear ip accounting
Stores the old accounting database into a checkpoint
 show ip accounting checkpoint

Det går även att kolla MAC-adresser.
 interface gi2
  ip accounting mac-address input
 show interface gi2 mac-accounting

[[Category:Cisco]]</text>
      <sha1>pzfsy22nrsdeaenksim1u48h7gz58pu</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco Nexus</title>
    <ns>0</ns>
    <id>170</id>
    <revision>
      <id>3163</id>
      <parentid>3118</parentid>
      <timestamp>2022-12-12T12:50:58Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13822">Cisco Nexus switchar är designade för datacenter. De kör NX-OS som bygger på en nedbantad variant av Linux kernel. De har stöd för tekniker som [[Nexus_FabricPath|FabricPath]] och [[Nexus_vPC|vPC]] och går att konfigurera med CLI (SSH/console) eller XML baserat på NETCONF. För virtuell instans se [[Nexus_VDC|Nexus VDC]] och för virtuell switch se [[Nexus_1000V|Nexus 1000V]] och Nexus 9000v (nedan). 

===Nexus 9000 Taxonomy===
[[File:CiscoNexusTaxonomy.jpg|790px]]

==Konfiguration==
 hostname Nexus-01
 service password-encryption
 no ip domain-lookup
 user admin password bigdog role vdc-admin

Management
 interface mgmt0
  ip address 10.0.0.10/24
 
 vrf context management
  ip route 0.0.0.0/0 10.0.0.1 

Slå på loggmeddelanden och färgkodning i SSH terminal.
 terminal monitor
 terminal color persist

Slå på features görs efter behov.
 feature ssh
 feature fex
 feature lacp
 feature vpc

Global
 system default switchport shutdown
 port-channel load-balance ethernet source-dest-port
 clock timezone CET 1 0 
 clock summer-time CEST 5 Sunday March 02:00 5 Sunday October 02:00 60

Show
 show module
 show system resources
 show cli history unformatted
 show cli history config-mode 

Alias, exempel
 cli alias name wr copy running-config startup-config
 cli alias name diff show running diff
 cli alias name changeto switchto vdc

'''Jumbo frames Nexus 5K''' &lt;br/&gt;
Detta gäller för L2 interface. Vill man vara någorlunda granulär kan man köra jumbo frames per vlan. Show interface visar inte rätt eftersom Nexus 5k inte har stöd för per interface MTU utan man får använda show queuing. Se även [[Cisco_QoS#NX-OS|QoS]] för NX-OS för mer info. 
 policy-map type network-qos JUMBO-MTU
  class type network-qos class-default
   mtu 9216
 system qos
  service-policy type network-qos JUMBO-MTU
 
 show queuing interface e1/1

Nexus 7K, denna globala inställning säger vad man max får konfa under interfacen.
 system jumbomtu 9216

'''API''' &lt;br/&gt;
NX-OS har stöd för flera olika API:er.
 feature netconf
 feature restconf
 feature grpc

'''Troubleshooting''' &lt;br/&gt;
NX-OS har en on-device log file med de exec level configuration commands som körts.
 show accounting log

Visa historical event log för Layer 2 MAC-databasen.
 show system internal l2fm l2dbg macdb address 0011.2233.4455 vlan 100

Routing and forwarding&lt;br/&gt;
 show forwarding ip route &lt;IP&gt;
 show forwarding adjacency &lt;IP&gt;
 show hardware mac address-table 1
Verify ECMP
 show routing hash &lt;src-ip&gt; &lt;dst-ip&gt;

Nexus 9K, för att smidigt se om t.ex. en counter räknar upp eller ej.
 watch differences interval 1 show interface e1/1
 watch show interface counters table
Alternativt
 show int eth1/10 | diff
 show int eth1/10 | diff

VLAN &lt;br/&gt;
Man kan kolla vilka VLAN som är reserverade och används internt.
 show vlan internal usage

Sätt switchen i maintenance mode.
 system mode maintenance [dont-generate-profile] 
 show system mode
 show config-profile

Software Reload&lt;br/&gt;
Endast mjukvaran startar om. Data plane påverkas inte men control plane är nere några minuter. OBS om detta failar av någon anledning så bootar switchen om som vanligt.
 soft-reload

Licens
 license grace-period
 
 show license brief
 show license usage
 show license host-id

'''Shell''' &lt;br/&gt;
Bash Access, här blir man root.
 feature bash-shell
 run bash
Secure Guest Shell är en kombination av bash och en secure Linux environment med ett modifierbart root system. Detta körs i en Linux Container. Man kan ändra resurstilldelning för en guestshell-contatiner med ''guestshell resize''.
 guestshell
 show virtual-service list

'''Python'''
 switch# python
 from cli import *
 import yaml
 cli('configure terminal ; interface loopback 5 ; no shut')
 intflist = yaml.safe_load(clid('show interface brief'))

'''Scheduler''' &lt;br/&gt;
NX-OS har en inbyggd schemaläggare som kan användas för att köra kommandon vid valda tidpunkter.
 feature scheduler
 
 scheduler job name CLEAR-STATISTICS
  clear counters interface all
  exit
 
 scheduler schedule name EVERYDAY
  job name CLEAR-STATISTICS
  time daily 23:30
  exit
 
 show scheduler schedule

CoPP
 control-plane 
  service-policy input copp-system-policy-scaled-l2

FIPS
 fips mode enable
 show fips status

'''Git repo backup'''
 event manager applet gitpush 
  event cli match "copy running-config startup-config" 
  action 1 cli copy running bootflash:running.latest 
  action 2 cli run guestshell python /home/admin/upload_git.py
  action 3 event-default 

'''Adjacency Manager''' &lt;br/&gt;
Nexus adjacency manager finns på den aktiva supervisorn och håller adjacency information för olika protokoll inklusive ARP, NDP och static mappings. Adjacency Manager populerar t.ex. IPv4 RIB:en med routes lärda från ARP. Dessa är host-routes och har Administrative Distance 250, detta går dock att ställa om.
 ip adjacency route distance 250
 ipv6 adjacency route distance 250

'''iCAM''' &lt;br/&gt;
Nexus 9000 har stöd för Intelligent CAM Analytics and Machine-learning feature. Man kan se traffic analytics per feature samt TCAM resources och entries.
 feature icam
 show icam scale

'''CLI variables''' &lt;br/&gt;
 cli var name MYINF interface e1/10
 show cli variables 
 tac-pac bootflash:$(SWITCHNAME)-$(TIMESTAMP)-show-tech-all.gz

===PTP===
PTP är ett time synchronization protocol för noder i ett nätverk. Hardware timestamps används för att ge bättre noggrannhet än andra protokoll som t.ex. [[Cisco_Services#NTP|NTP]]. PTP är ett distribuerat protokoll och ett PTP-system kan bestå av en kombination av PTP och icke-PTP devices. Ordinary clocks organiseras i en master-slave synchronization hierarki med en grandmaster clock på toppen som bestämmer referenstiden för hela systemet. PTP-processen består av två faser: etablera master-slave hierarkin och synka klockorna. PTP transporteras med UDP över multicast. För att hantera sin egen interna queuing eller snarare delays in queues kan en switch agera enligt transparent clock model eller boundary clock model. PTP är inte supporterat på FEX interface.

&lt;div class="mw-collapsible mw-collapsed" style="width:300px"&gt;
Sync message:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco-PTP-Sync.PNG]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:300px"&gt;
Announce message:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco-PTP-Announce.PNG]]
&lt;/div&gt;
&lt;/div&gt;

 feature ptp
 ptp source &lt;ip-address&gt;
 ptp domain 0    #Default
 
 interface ethernet1/1
  switchport
  ptp

Verify
 show ptp brief
 show ptp clock
 show ptp port interface ethernet 1/2

==Fabric Extender==
FEXar är remote linjekort man sprider ut i sitt DC för att få fördelar från både ToR-kabeldragning och EoR-management. Man kopplar in FEXar till Nexus-switchar eller UCS FI:s och sedan strömsätter man dem och associering görs automatiskt. För att upptäcka varandra använder FEX och parent switch Satellite Discovery Protocol (SDP). Får en FEX svar så startar den Satellite Registration Protocol (SRP). Därefter är FEXen registrerad med parent. Med hjälp av control VLAN 4042 och interna IP-adress 127.15.1.100 används Virtual Interface Configuration protocol för att konfa FEXens portar. SDP skickas periodvis och fungerar även som en keepalive mekanism. Om alla upplänkar går ner kommer FEXen att stänga alla sina interface, detta gör att dual homed servrar kan faila över till den andra FEXen.

Upplänkar på FEX kallas Fabric Interface. Server facing interfaces kallas Host Interface. Varje HIF har ett Virtual Interface inuti FEXen, detta får sin konfig ifrån parent switch. Varje VIF binds till ett Logical Interface i parent switch, detta har VLAN membership, ACL:er, etc. Mappningen mellan VIF och LIF görs med hjälp av en speciell tag i Ethernet framesen som går mellan FEX och parent. Denna logiska länk kallas VN-Link och taggen heter VNTag. Cisco VNTag har en egen ethertype och innehåller bl.a. Direction bit, Pointer bit, Looped bit, Version och Source och Destination Virtual Interface. Paket som kommer in på ett Host Interface skickas alltid till parent även om t.ex. destination är en annan port på samma FEX. 

FEXar har INTE stöd för:
* [[Cisco_STP|STP]], (BPDUGuard enabled by default)
* [[Cisco_VTP|VTP]]
* QinQ
* CDP, (Upplänkar undantag)

'''Supported Topologies''' &lt;br/&gt;
Man kan koppla in FEXar single homed eller dual homed beroende på om det som ska ansluta till FEXarna ska vara single eller dual homed. 

[[File:Cisco_Nexus_FEX.PNG|600px]]


'''Konfiguration''' &lt;br/&gt;
Notera att dual-homed FEXes måste ha identisk konfiguration, dvs Nexus-switcharna ska ha matchande FEX-relaterad konfig. Detta kan antingen göras manuellt eller med en configuration synchronization service som finns inbyggd i NX-OS. Config sync kan dock ställa till med konstiga fel så fördelaktigt görs detta med något externt automationsverktyg. När man konfar en port-channel till FEXen (vilket man bör) måste '''pinning max-links 1''' vara satt samt att ''mode on'' måste köras eftersom FEX ej har stöd för LACP. MTU på FEXar styrs av network QoS policy så för att ändra MTU på FEX-portar måste även MTU på fabric portar ändras. Notera att FEXar kräver minst 1058 bytes annars misslyckas registreringen med parent switch. Man kan konfa FEX innan den är online med hjälp av pre-provision, se nedan. Man måste göra modelval för att parent ska veta hur många och vilka sorts interface som finns på FEXen. Giltiga FEX-nummer är 101-199.

Do not power on the FEX until all cabling and uplink port provisioning on the uplinked Nexus has been completed.

Single homed FEX
 fex 101
  pinning max-links 1
  description "FEX101"
 
 interface port-channel101
  description FEX101
  switchport mode fex-fabric
  fex associate 101
 
 interface Ethernet1/1
  description FEX101, Uplink 1
  switchport mode fex-fabric
  fex associate 101
  channel-group 101
  no shutdown
 
 interface Ethernet1/2
  description FEX101, Uplink 2
  switchport mode fex-fabric
  fex associate 101
  channel-group 101
  no shutdown

Dual homed FEX
 fex 111
  pinning max-links 1
  description "FEX111"
 
 slot 111
  provision model N2K-C2248TP-E-1GE
 
 interface port-channel111
  description FEX111 
  switchport mode fex-fabric
  fex associate 111
  vpc 111
 
 interface Ethernet1/1
  description FEX111, Uplink 1
  switchport mode fex-fabric
  fex associate 111
  channel-group 111
  no shutdown
 
 interface Ethernet1/2
  description FEX111, Uplink 3
  switchport mode fex-fabric
  fex associate 111
  channel-group 111
  no shutdown

Verify 
 show fex detail
 show module fex
 show interface fex-fabric
Om serienummer är satt i konfigen måste det stämma annars blir det "Identity-Mismatch". Står det inget i konfigen accepteras vad som blir connected.

==Port Profiles==
En port profile används för att skapa en mall med fördefinierad konfiguration för portar. Istället för att manuellt kopiera befintlig portkonfiguration till en ny port kan istället profilen appliceras på porten för en färdig och enhetlig konfiguration.

Skapa port-profile
 port-profile ACCESS
  switchport
  switchport mode access
  switchport access vlan 10
  spanning-tree port type edge
  spanning-tree bpdufilter enable
  spanning-tree bpduguard enable
  no shutdown
  state enabled

Applicera port-profile, kan t.ex. appliceras under port-channel eller ethernet-interface.
 interface ethernet 1/1
  inherit port-profile ACCESS
Verifiering
 show run interface ethernet 1/1 expand-port-profile
 show port-profile

==Checkpoint==
Nexusswitchar har en inbyggd funktion för Configuration Roll Back. Checkpoint-featuren låter admins spara konfigurationssnapshots. Sedan kan man rollbacka när man behöver. Exempelvis när man tar bort en feature (''no feature xxx'') så skapar Feature Manager automatiskt en checkpoint.

Skapa checkpoint
 checkpoint
Show checkpoints
 show checkpoint summary
Diff
 show diff rollback-patch checkpoint user-checkpoint-1 running-config
Rollback
 rollback running-config checkpoint user-checkpoint-1
Delete
 clear checkpoint database

==Portmode==
På vissa nexus-modeller kan man ställa olika portmodes, t.ex. 93180LC och YC. I LC modellen så kan man sätta 18x100g isället för 4x100g+28x40g, man kan också köra 6x100g+24x40g.

För att ställa in 18x100g 
 hardware profile portmode 18x100g 
För 6x100g+24x40g 
 hardware profile portmode 6x100g+24x40g
För 4x100g+28x40g 
 hardware profile portmode 4x100g+28x40g
Man måste sedan spara configen och starta om switchen för att detta skall börja gälla.

==Nexus 9000v==
Nexus 9000v Switch är en virtuell maskin som man kan använda för att testa NX-OS features. Nexus 9000v funkar t.ex. i [[EVE-NG]]. Dock funkar inte alla features, t.ex. QoS, BFD, Storm-control, FCoE och MACsec.

Man måste lägga in i startup-config vilken image switchen ska boota ifrån. Här följer lite grundkonfig.
 hostname N9K01
 boot nxos bootflash:/nxos.7.0.3.I7.3.bin
 feature lldp
 terminal width 110
 spanning-tree mode mst
 line console
   exec-timeout 0
 
 policy-map type control-plane COPP
 control-plane
   service-policy input COPP

Detta kommando används istället för show mac address-table på Nexus 9000v.
 show system internal l2fwder mac

==Ansible==
 ansible-galaxy collection install cisco.nxos

nxos.yml
 ---
 ansible_connection: ansible.netcommon.httpapi
 ansible_httpapi_use_ssl: true
 ansible_httpapi_validate_certs: false
 ansible_network_os: cisco.nxos.nxos
 ansible_user: admin
 ansible_password: password

hosts.yml
 ---
 all: 
   hosts:
     switch1: 
       ansible_host: 10.0.0.40
     switch2:
       ansible_host: 10.0.0.41

ansible.cfg
 [defaults]
 collections_paths   = ./collections
 inventory           = ./inventory
 forks           = 15
 stdout_callback = yaml

[[Category:Cisco]]</text>
      <sha1>8y1gyg2r4a6kuhegphu0u4aq29ksdb5</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco OSPF</title>
    <ns>0</ns>
    <id>164</id>
    <revision>
      <id>3130</id>
      <parentid>3078</parentid>
      <timestamp>2021-11-09T09:28:32Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="33977">Open Shortest Path First (RFC 2328) är ett link-state routingprotokoll standardiserat av Internet Engineering Task Force (IETF). Link-state innebär att enheterna känner till alla länkar i topologin och deras ''operational states'' och lagrar detta i en LSDB. OSPF konvergerar snabbt och har bra skalbarhet. Det kommunicerar med multicast som har ttl satt till 1 alternativt unicast på vissa nätverkstyper. OSPF använder IP protokoll #89. Se även [[Cisco_OSPFv3|Cisco OSPFv3]] för IPv6-stöd.

'''Type:''' Link State

'''Algorithm:''' Dijkstra

'''AD:''' 110

'''Metric:''' Cost (Bandwidth)

'''Protocols:''' IP

'''Packets:''' 5

==Metric==
OSPF i IOS använder 100MBit/s som referensbandbredd för att räkna ut cost på varje länk. Man kan ändra detta till t.ex. 100G. 
 router ospf 1
  auto-cost reference-bandwidth 100000  #Mbits per second
 show ip ospf interface | i Cost
Om man stänger av auto-cost får alla länkar samma cost (10) oavsett bandbredd, så som [[Cisco_IS-IS|IS-IS]] fungerar.

'''Preferens''' &lt;br/&gt;
Det är viktigt att känna till att olika typer av routes har olika preferens och detta går före metric för path selection. I vissa fall går detta att ändra.
# intra-area
# inter-area
# external
# nssa-external

Routrar föredrar default N2 routes över E2 routes som injicerats av typ-7 till typ-5 translator men detta går att ändra.
 router ospf 1
  compatible rfc1587

==Packets==
Alla paket kan vara unicast eller multicast, det avgörs av nätverkstyp.
* '''Hello:''' Används för att upptäcka grannar. Innehåller mask, timers, flaggor (capabilities), DR/BDR (om det finns) och router-ID för grannar.
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
: Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_OSPF_Hello.PNG]]
&lt;/div&gt;
&lt;/div&gt;

* '''Database Description:''' Innehåller LSA headers under den initiala topologi-synken. Används först för att avgöra master/slave i grannskapet, högst router-id blir master. 
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
: Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_OSPF_DD.PNG]]
&lt;/div&gt;
&lt;/div&gt;

* '''Link-State Request:''' Innehåller vilka LSA:er som avsändaren vill ha alla detaljer om.
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
: Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_OSPF_Request.PNG]]
&lt;/div&gt;
&lt;/div&gt;

* '''Link-State Update:''' Innehåller alla typer och detaljer om LSA:er och skickas på förfrågan eller vid topologiändring
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
: Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_OSPF_Update.PNG]]
&lt;/div&gt;
&lt;/div&gt;

* '''Link-State Acknowledgment:''' LSU confirmation.
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
: Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_OSPF_Ack.PNG]]
&lt;/div&gt;
&lt;/div&gt;

==Grannskap==
OSPF-grannskap har bestämda tillstånd och neighbors måste komma överens om:
* Subnät/Mask
* Area
* Timers
* Olika router-ID
* Flaggor: Stub, NSSA
* MTU 
* Authentication type
* Kompatibla nätverkstyper, DR-election eller ej

'''Neighbor states''' &lt;br/&gt;
Kronologisk ordning
* Down: Initial state. Om det inte kommer in några OSPF-paket under Dead interval blir grannen down.
* Attempt: Gäller endast NBMA och point-to-multipoint nonbroadcast.
* Init: Ett hello (utan mottagarens router-ID) har tagits emot.
* 2-way: Ett hello med mottagarens router-ID har tagits emot.
* ExStart: Utbyta tomma DD för att bestämma master/slave.
* Exchange: Utbyta database description
* Loading: LSA:er tankas över
* Full: Allt klart

==LSA-typer==
LSUer innehåller link-state advertisements, dessa beskriver länkar och enheter i nätverket. Det är endast den router som en LSA härstammar ifrån som får modifiera eller ta bort LSA:n. Andra routrar måste processa och skicka den omodifierad vidare inom sitt flodding scope, de får ej droppa den innan maximum lifetime har gått ut. Detta säkerställer att alla routrar har identiska LSDB men det medför också att man blir begränsad i var man kan aggregera och filtrera routes. För att ta bort en LSA snabbt sätts age till 3600 sekunder (maximum lifetime) och den kommer då att tas bort direkt. En LSA header är vanligtvis 20 bytes.

De vanligaste LSAerna.
* '''Type 1, Router:''' &lt;br/&gt; Alla routrar skapar och floodar en LSA som representerar sig själv. Det finns information om vilka interface och grannar som finns i den arean. Floodas endast inom origin area. ABR sätter B-biten och ASBR sätter E-biten för att informera arean om sin roll.
 show ip ospf database router
 show ip ospf database router | i Link

* '''Type 2, Network:''' &lt;br/&gt; Dessa representerar transit subnät och skapas endast om det finns en DR på det subnätet, dvs multiaccess-segment. LSID sätts till DRs interface IP på subnätet men innehåller också information (RID) om alla grannar till DR på det subnätet. Floodas endast inom origin area.
 show ip ospf database network

Note: Typ 1 och 2 räcker för att alla routrar inom arean ska kunna känna till topologin och köra SPF för att bestämma bästa vägarna. 

* '''Type 3, Net Summary:''' &lt;br/&gt; Typ 1 och 2 går ej till andra areor utan istället skapar ABR (router med ben i 2 areor) typ 3 LSA:er (en ABR genererar aldrig summary LSA om den inte har ett ben i area 0). Det som annonseras är samma men den enda infon som skickas med är: subnät, mask och costen för ABR att nå dit. Typ 3 LSA:er korsar aldrig areor, istället har ABR en intern OSPF-routingtabell som innehåller allt som har kommit i backbone-arean och för varje intra- eller inter-area route skapas det nya typ 3 LSAer som floodas i nonbackbone-arean. OBS ABR accepterar endast typ 3 LSA:er från backbone area, detta för att förhindra routingloopar.
 show ip ospf border-routers
 show ip ospf database summary

* '''Type 4, ASBR Summary:''' &lt;br/&gt; När en ABR floodar vidare en typ 5 LSA in i sin area vet inte övriga routrar i arean hur långt det är till ASBR. Därför skapar den en LSA typ 4 som den också floodar. Den innehåller ASBRs RID och ABRs cost till ASBR. Typ 4 LSA:er behöver inte finnas i samma area som ASBR eftersom där berättar ASBR om sig själv med typ 1 LSA med E-biten satt utan dessa behövs i övriga areor. 
 show ip ospf database asbr-summary

* '''Type 5, AS External:''' &lt;br/&gt; När en ASBR skickar in en extern route skapar den en typ 5 LSA som innehåller metric och metric type. Det som är intressant för övriga routrar att veta är hur långt det är till ASBR och ifall det finns flera vägar som är lika används alla. Finns det flera ASBR används den som är närmast internt enligt SPF.
 show ip ospf border-routers
 show ip ospf database external

Det finns två typer av externa routes, E1 (increment metric) och E2 (do not increment metric). Detta avgörs beroende på vad ASBR sätter för flagga på LSAn. Default på Cisco är E2 för redistribution, dock är E1 prefered över E2. Externa routes måste även innehålla en '''Forwarding Address'''. Vanligtvis sätts 0.0.0.0, det innebär att det ska skickas till ASBR själv. Det finns dock situationer när man vill ha något annat (nonzero) för att undvika suboptimal routing. Denna adress måste kännas till intra- eller interarea annars installeras inte routen i routingtabellen.

* '''Type 7, NSSA External:'''
Floodas inom egna NSSA-arean, översätts till LSA typ 5 av ABR med högst RID för att lämna arean OM Propagate-biten är satt till 1. Annars stannar LSA:n inom arean, detta konfigureras vid redistributionen med nyckelordet '''nssa-only'''. Om man vill att trafiken alltid ska gå igenom translator kan man suppressa forward address, '''area 1 nssa translate type7 suppress-fa'''.
 show ip ospf database nssa-external

'''Show'''

Se alla LSA:er och RIB.
 show ip ospf database
 show ip ospf rib
 show ip ospf topology-info
Kolla vilka LSA:er en viss nod annonserar ut.
 show ip ospf database adv-router &lt;RID&gt;

* '''Others:''' Typ 6 (MOSPF) och 8 stöds inte på Cisco-routrar och 9-11 är Opaque. 

==Area types==
Att dela upp sitt nätverk i OSPF-areor är grunden för att göra OSPF mer skalbart eftersom det sparar på SPF-beräkningar. Med dagens CPU:er kan dock areor bli rätt stora innan det blir nödvändigt att dela upp det. Förutom vanliga areor finns det flera andra typer av areor.

'''Stub''' &lt;br/&gt;
Alla areor behöver inte känna till alla externa nätverk. Då kan man reducera overhead genom att ha areor där man endast skickar in LSA typ 3. Dvs det finns ingen ASBR och LSA typ 4 och 5 stoppas vid ABR. Skulle det komma en LSA 4/5 från någon så ignoreras den. För att hitta ut ur arean så skickar ABR:er in default route med en LSA typ 3.
 router ospf 1
  area 1 stub
''Stub bit is sent in hello packets''

'''Totally Stubby''' &lt;br/&gt;
Totally stubby är samma som stubby fast alla LSA typ 3 blockas också förutom default routen. Inga LSA typ 3,4,5 gör att LSDB reduceras ytterligare.&lt;br/&gt;
ABR
 area 1 stub no-summary
Others
 area 1 stub

'''NSSA''' &lt;br/&gt;
Om man vill effektivisera OSPF samtidigt som man behöver injicera in routes från något annat protokoll genom någon router i en stubby area så kommer det inte att funka eftersom LSA 4/5 ignoreras. Då kan man använda en not-so-stubby area. Då sätter routrarna N-biten i hellos och skapar ASBR typ 7 LSA:er istället. NSSA är en kompromiss som tillåter att externa routes kan laddas upp till backbone-arean medans all information från övriga areor ej behöver tas in i arean. I en NSSA kommer inte default routen att annonseras default som i övriga stubby areas. 
 router ospf 1
  area 1 nssa
  area 1 nssa default-information-originate

'''NSSA Totally Stubby''' &lt;br/&gt;
NSSA Totally Stubby är samma som NSSA fast alla LSA typ 3 blockas också förutom default routen, samt att default routen injiceras default. Inga LSA typ 3,4,5. Ett ben i area 0 krävs för detta kommando.
 area 1 nssa no-summary

'''Transit''' &lt;br/&gt;
Non-backbone areas kan användas för inter-area transit om det finns en kortare väg igenom dem. Transit är på default men går att stänga av.
 router ospf 1
  no capability transit
 show ip ospf | i transit

==Nätverkstyper==
Det finns olika typer av nätverk och pga hur OSPF fungerar måste man konfigurera det lite olika beroende på typ. T.ex. DR/BDR election hålls endast på broadcast och NBMA. Om frame relay används måste DR och BDR ha PVC till alla andra routrar annars får inte alla uppdateringar. På multiaccess och point-to-point (ethernet) används default nätverkstypen BROADCAST. Beroende på nätverkstyp behövs '''neighbor'''-kommandot användas eller ej, regel är non-broadcast needs neighbors. Point-to-multipoint interface annonseras som /32:or av effektivitetsskäl och lämpar sig väl om man kör OSPF över [[Cisco_L2VPN#VPLS]].
 show ip ospf interface | i protocol|Network Type

Ändra nätverkstyp på ett interface. Det behöver tekniskt sett inte vara samma på båda sidor sålänge det som behövs matchar, t.ex. timers.
 interface gi0/0
  ip ospf network ?
Loopback annonseras default som stub endpoint (/32), detta ändras med nätverkstyp point-to-point.
 interface lo0
  ip ospf network point-to-point

===Designated Router===
OSPF optimerar flooding-processen på multiaccess-länkar genom att använda ''designated routers'' och ''backup designated routers''. Annars hade varenda router på ett sådant segment behövt upprätta fulla grannskap med alla andra. Med en DR räcker det med att alla utbyter LSDB endast med den, detta resulterar i mindre trafik. Varje router har fullt grannskap med DR och BDR, 2-way med övriga. DR har två syften, det är också så att det är DRs som skapar typ 2 LSAn som representerar multiaccess-segmentet, annars hade det behövts för varje grannskap och det hade inte blivit någon vacker LSDB. 

Behöver en DR skicka ut en LSU gör den det till 224.0.0.5 som alla DROther lyssnar på. Behöver en DROther skicka en uppdatering gör den det till 224.0.0.6 som DR och BDR lyssnar på (det är av denna anledning det behövs en BDR). Alla enheter som får en LSU ackar den med en unicast LSAck till avsändaren, med undantag om LSUn kom från sig själv. I nätverkssegment utan DR används 224.0.0.5 för allt.

DR election görs mellan 2-way och ExStart i och med att Hellos innehåller DR/BDR om det finns. Om det kommer in en Hello med DR satt till 0.0.0.0 betyder det att det inte finns någon DR än, t.ex. efter ett outage. Då väntar routern en liten stund för att ge andra en chans att komma upp. Detta kallas OSPF wait time och är ställt till samma som Dead time på det interfacet. Under wait time lyssnar routern in RID och prioritet från sina grannar. Val av DR/BDR görs först efter wait time är över. Election görs lokalt på routern utifrån de värden som kommit in. Dock slutar det alltid med att alla har samma. 

Finns det en DR RID i ett Hello som kommer in så har någon annat gjort valet och man kan direkt hoppa till election, dvs skippa resten av wait time. Det som görs då är att man fyller den roll som ej är fylld, t.ex. BDR genom att ta den högsta prioriteten och högsta router id som man känner till. Detta gör att det inte finns någon preemption. Däremot kan det tillfälligt existera routrar som är klara med election och som har kommit fram till olika slutsatser. Då hålls election igen och man byter DR och BDR till de med högst prio/id när man upptäckte krocken. Om man kör samma prio på alla och stöter på att det inte högsta RID som är DR är det för att den med lägre RID har kommit upp först. Det finns som sagt ingen preemption.

Alla routrar med OSPF priority 1-255 är med i election, 1 är default och sätter man 0 ignoreras DR/BDR election på den enheten som därmed aldrig kan bli DR. Det är viktigt att DR kan nå alla andra vilket inte är fallet i en hub-and-spoke-topologi där en spoke är DR, se även [[Cisco_DMVPN|Cisco DMVPN]].
 interface gi0/0
  ip ospf priority 50

Även om det inte upptäcks några grannar på ett interface där DR election vanligtvis hålls så kommer OSPF ändå hålla valet med sig själv som vinnare, det väntas alltså inte på grannskap först. Om det däremot endast finns en OSPF-router på ett segment så kallas detta stub network och ingen LSA typ 2 kommer att genereras för det är onödigt utan då blir nätverksadressen och subnätmasken en LSA typ 1 som floodas.

=Konfiguration=
Routrar måste ha ett OSPF-id för att kunna skicka meddelanden, på Ciscoenheter väljs ID enligt följande ordning:
# router-id kommandot
# Högsta IP-adressen på ett no-shut loopback interface (som ej är assignat någon annan OSPF-process)
# Högsta IP-adressen på ett no-shut interface (som ej är assignat någon annan OSPF-process)
Interfacen behöver inte vara nåbara eller ha något med OSPF att göra utan alla interface jämförs. ID ändras endast när processen startas om.

router-id for this OSPF process (in IPv4 address format)
 router ospf 1
  router-id 1.1.1.1

'''Administrative Distance'''
 router ospf 1
  distance ospf intra-area 110 inter-area 110 external 110
 show ip protocols | i Distance

Advertise a maximum metric so that other routers do not prefer the router as an intermediate hop for 60 seconds.
 max-metric router-lsa on-startup 60

'''MTU mismatch'''
 ip ospf mtu-ignore

'''Allmänna rekommendationer'''
* Set your maximum LSA settings to keep from killing weak boxes ('''max-lsa''')
* Baseline your network so you know how many LSAs normally float around
* Configure LSA warnings to alert of problems
* Crash each type of box on your network in a lab environment so you know what it will do under stress.

'''MPLS''' &lt;br/&gt;
Om man kör OSPF kan man autoenablea LDP på alla OSPF-interface. Se även [[Cisco_MPLS|Cisco MPLS]] och [[Cisco_SR|Segment Routing]].
 router ospf 1
  mpls ldp autoconfig 
 show ip ospf mpls ldp interface

'''IP unnumbered''' &lt;br/&gt;
Man kan köra IP unnumbered med OSPF och det finns ett network statement som matchar IP-adressen på primär-interfacet så kommer båda interfacen att användas av OSPF i den valda arean. När man använder unnumbered kommer routern att ignorera source IP address i hello-paketen vilket annars fungerar som en check så att inte vilket paket som helst accepteras utan det ska komma från det subnät som det mottagande interfacet sitter i. Man kan ha loopback och fysiska interface i olika areor, dock kommer man att annonsera samma prefix i fler än en area.
 interface gi0/1
  ip unnumbered Loopback0
  ip ospf network point-to-point
  ip ospf 1 area 1

==Adjacency==
Logga ändringar i neighbor state, detta är på default. 
 router ospf 1
  log-adjacency-changes
 show ip ospf events

Styr grannskap/uppdateringar med passive-interface
 passive-interface default
 no passive-interface [interface]
 show ip ospf interface | i Ethernet|Passive

'''Unicast''' &lt;br/&gt;
Specificera granne manuellt, detta måste göras på NBMA och point-to-multipoint nonbroadcast. Det räcker att göra detta på ena sidan för att grannskap ska bildas men best practice är att köra detta på båda sidor.
 router ospf 1
  neighbor 10.0.0.2

Per neighbor cost/metric
 neighbor 10.0.0.5 cost 1000

Man kan sätta prioritet på sina grannar om man kör unicast. Default är detta 0 men om man har flera neighbor statements och någon har icke-noll så kommer routern att först skicka Hellos till denna. Endast när DR/BDR election är klart så börjar det skickas Hellos till de övriga grannarna. Detta är en mekanism som ökar chansen att DR och BDR blir de routrar man vill. OBS detta har inget med vinnare av DR/BDR att göra.
 router ospf 1
  neighbor 10.0.0.5 priority &lt;0-255&gt;

'''Verify'''
 show ip ospf neighbor
 show ip ospf interface brief
 show ip ospf neighbor detail | i interface
 ping 224.0.0.5

Clearing routing process
 clear ip ospf process
 debug ip ospf adj

'''GTSM''' &lt;br/&gt;
TTL Security Check kan konfigureras per process eller per interface och gäller både unicast och multicast. Dessa kommandon har ingen inverkan på virtual links eller sham links utan det görs med ''area virtual-link ttl-security'' och ''area sham-link ttl-security''.
 router ospf 1
  ttl-security all-interfaces
 interface gi2
  ip ospf ttl-security 

'''Graceful restart''' &lt;br/&gt;
En router kan starta om OSPF-grannskap och ändå fortsätta forwarda paket som vanligt med hjälp av Graceful OSPF Restart (RFC 3623). Cisco har även en egen variant av detta som kallas NSF (Non Stop Forwarding) men IOS har stöd för båda varianterna. Den som restartar skickar grace-LSA och hamnar i ''restart mode'' och directly connected grannar måste stödja ''helper mode'' för att detta ska lira. Helpers måste ignorera att det uteblir Hellos under antydd period och låtsas som att grannskapet är uppe och DR är densamme. Överskrids tidsgränsen rivs adjacency direkt. NSF-aware (helper support) finns på de flesta enheter och är på default, ''nsf ietf/cisco helper'' medans NSF-capable finns på high-end plattformar. GR/NSF utnyttjar att modernare enheter sköter data plane och control plane i olika hårdvara. 
 router ospf 1
  nsf ietf
  nsf cisco
 
 show ip ospf nsf

NSR är en intern mekanism som låter standby RP ta över etablerade sessioner vid en switchover.
  nsr
 show ip ospf nsr

'''Graceful shutdown''' &lt;br/&gt;
Droppa adjacencies, flusha LSA:er och skicka ut Hello med tom neighbor list för att trigga att grannens adjacency går direkt till Init state, kanske inte så graceful men det heter så ändå.
 router ospf 1
  shutdown
Per interface
 int gi2
  ip ospf shutdown

===Authentication===
Klassisk OSPF authentication är none/null, clear-text eller MD5. Default är none och man slår på det per interface eller per area. Man kan ha multipla nycklar per interface, då skickas det multipla OSPF paket parallellt vilket gör att grannskap ej går ner under key rotation. Detta pågår tills båda sidor har samma nyckel som senast konfigurerad, dvs key ID måste matcha men det spelar ingen roll för vilken som är att föredra utan det är youngest key. Det går även att köra authentication på virtual links, se det stycket.

Enable clear-text authentication on area 0
 router ospf 1
  area 0 authentication
 interface gi0/1
  ip ospf authentication-key [password]

Enable MD5 authentication on area 0. 
 router ospf 1
  area 0 authentication message-digest
 interface gi0/1
  ip ospf message-digest-key 10 md5 [password]

Enable MD5 authentication on an interface
 interface gi0/1
  ip ospf authentication message-digest
  ip ospf message-digest-key 10 md5 [password]

Verify
  show ip ospf interface | i Ethernet|authentication

'''Extended cryptographic authentication''' (RFC 5709) finns i modernare implementationer av OSPF och har stöd för key-chains och SHA-HMAC. Nyckel med högst id används ifall det finns flera nycklar som är aktiva. Cryptographic algorithm + key bildar SA.
 key chain HACKER
  key 1
   key-string SECRET
   cryptographic-algorithm hmac-sha-512
Per interface, det finns inget area-kommando som slår på key-chain auth på alla interface som vid klassisk konfiguration.
 int gi2
  ip ospf authentication key-chain HACKER

===Multiarea Adjacency===
Med OSPFv2 Multiarea Adjacency kan man konfigurera en länk för optimal routing i flera areor. Varje multiarea interface annonseras som en point-to-point unnumbered link och fungerar som en logisk konstruktion över det primära interfacet. Det upprättas grannskap med multiarea interface på andra sidan och detta är oberoende av neighbor state på det primära interfacet. Alla OSPF-parametrar (t.ex. autentisering) ärvs från det primära. Det går endast att konfigurera multiarea adjacency på interface som har två OSPF speakers, så på ethernet måste det konfigureras som network point-to-point. 

 interface gi2
  ip address 10.0.0.1 255.255.255.0
  ip ospf 1 area 0 
  ip ospf network point-to-point 
  ip ospf multi-area 2
 
 show ip ospf 2 multi-area

==Default Routing==
Kräver gateway of last resort.
 default-information originate
Om man inte har någon gateway of last resort kan man ändå annonsera ut en default route.
 default-information originate always

'''NSSA''' &lt;br/&gt;
En NSSA ABR genererar inte en default route by default (om den inte konfas som totally stubby) eftersom man inte vet om gateway of last resort ska vara i en annan area eller externt (type 7). En NSSA ASBR måste ha en default route i routingtabellen för att kunna skicka ut en default route. En NSSA ABR behöver inte det:
 area 1 nssa default-information-originate

'''Conditional''' &lt;br/&gt;
Med hjälp av en route map kan man annonsera en default route när ett visst kriterie är uppfyllt.
 default-information originate route-map TRACK_PREFIX

==Summarization==
OSPF-routrar inom samma area måste ha identiska LSDB efter att flooding är färdigt vilket gör att summering endast tillåts vid ABR eller ASBR. Med hjälp av '''not-advertise''' i slutet av kommandona kan man styra om summeringen ska fungera som filtrering, då varken de mer specifika prefixen eller aggregeringen annonseras. 

'''ABR'''
 router ospf 1
  area 10 range 10.10.0.0 255.255.252.0
Area 10 säger var summeringen kommer ifrån så denna aggregering skickas till alla andra areor. Cost för summeringen tas från den component route med lägst metric om man inte anger något specifikt.

'''ASBR'''
 router ospf 1
  summary-address 10.10.0.0 255.255.252.0
Konfigureras vid redistributionspunkt och summeringar ärver attribut från component routes.

'''Discard''' &lt;br/&gt;
Default installeras det en discard route när man summerar för att förhindra att det forwarderas trafik som man inte har någon specifik route för.
 no discard-route external|internal

==Convergence==
Tuning protocol parameters per interface.
 ip ospf hello-interval ''seconds''
 ip ospf dead-interval ''seconds''
 ip ospf retransmission-interval ''seconds''
 ip ospf transmit-delay ''seconds''

Fast Hellos, dead-interval minimal = 1 sek.
 ip ospf dead-interval minimal hello-multiplier 3

Timers: LSA &amp; SPF
 router ospf 1
  timers throttle spf 100 1000 10000
  timers pacing flood 50
  timers pacing retransmission 75
  timers throttle lsa all 10 4000 6000
  timers lsa arrival 2000
 show ip ospf | i msec
Med Group Pacing kan LSA:er "samåka" i refresh-paket.

'''SPF Prefix Priority''' &lt;br/&gt;
Man kan välja vilka prefix som SPF-algoritm ska köra först. Man skapar en route-map som matchar på route-type, prefix-list eller route-tag.

 route-map PREFIX-PRIORITY permit 10
  match tag 100
 
 router ospf 1
  prefix-priority high route-map PREFIX-PRIORITY

Verify
 show ip ospf rib detail

'''iSPF''' &lt;br/&gt;
SPF-algoritmen behöver inte köras för alla länkar varje gång det sker en topologi-förändring. Med incremental SPF körs endast algoritmen för de delar som har påverkats av förändringen för att spara CPU-cykler. Detta går att styra individuellt på enheterna med ''ispf''-kommandot. Det kan vara svårt att veta exakt hur mycket skillnad detta gör men generellt ju större topologi ju större skillnad. OBS iSPF är inte längre supporterat i IOS.
 router ospf 1
  ispf
 show ip ospf | i Incremental

'''BFD''' &lt;br/&gt;
Se även [[Cisco_BFD|BFD]].
 router ospf 1
  bfd all-interfaces
Disable per interface
 int gig2
  ip ospf bfd disable

===LSDB Optimization===
'''Prefix Suppression''' &lt;br/&gt;
För att få Loopback till Loopback-konnektivitet mellan alla routrar med minimal belastning på routingtabellen kan man skippa att ha med OSPF-länknäten i RIB. Alla noder bör stödja detta. 
 
Global
 router ospf 1
  prefix-suppression
Per interface
 interface gi2
  ip ospf prefix-suppression
Verify
 show ip ospf interface | i Ethernet|Prefix-suppression

'''Flooding Reduction''' &lt;br/&gt;
OSPF flood reduction stoppar det normala floodandet av LSAer genom att sätta DoNotAge (DNA) biten vilket gör att de inte behöver refreshas med jämna mellanrum.
 interface Gi2
  ip ospf flood-reduction

===LFA===
Eftersom OSPF-databasen är identisk på alla routrar i samma area har man modifierat SPF så att man lokalt kan köra SPF-algoritmen men med en granne som rot. Detta gör att man kan hitta alternativa loopfria vägar även i komplexa topologier. Man kan specificera flera kriterier för vilka alternate path som ska väljas, t.ex. använd ej de som använder samma interface, next-hop eller SRLG. Man måste använda [[Cisco_MPLS|MPLS]] för att kunna dra nytta av Loop-Free Alternate Fast Reroute och IOS supporterar endast per-link LFA. The high priority enables FRR for /32 prefixes only, the low priority enables FRR for all prefixes. The fast-reroute keep-all-paths option keeps all information in the table, including paths that were not chosen. When an area is specified, external routes are not a candidate for FRR. This is because they do not belong to an area.

Single Hop LFA / IP FRR.
 router ospf 1
  fast-reroute per-prefix enable prefix-priority low
  fast-reroute per-prefix enable area 0 prefix-priority high
  fast-reroute keep-all-paths
 
 show ip ospf fast-reroute
 show ip ospf fast-reroute prefix-summary
 show ip route repair-paths

Med hjälp av Remote LFA Tunnel kan man tunnla trafik loopfritt (i nästan alla topologier) till routrar flera hop bort utifrån lokala beräkningar. Detta stöds endast i default VRF:en och kräver MPLS.
 mpls ldp explicit-null
 mpls ldp discovery targeted-hello accept
 router ospf 1
  fast-reroute per-prefix remote-lfa tunnel mpls-ldp 
 
 show ip ospf fast-reroute remote-lfa tunnels

Interface options: &lt;br/&gt;
Om ett interface inte ska kunna användas för backup paths. 
 ip ospf fast-reroute per-prefix candidate disable

Primary routes som pekar på detta interface kommer inte att bli skyddade. 
 ip ospf fast-reroute per-prefix protection disable

==Filtering==
Non-local filtering för OSPF kan endast göras på ABR och ASBR.

'''Intra-area''' &lt;br/&gt;
Filtering påverkar inte LSDB eller flooding utan endast det som hamnar i RIB. Det går att göra med en distribute-list dock bör alla routrar vara konfade likadant annars kan det bli blackholing.
 access-list 1 deny 172.16.3.1
 access-list 1 permit any
 router ospf 1
  distribute-list 1 in
Alternativt
 summary-address 10.0.0.0 255.255.255.0 not-advertise

Administrative Distance, filtrering kan göras på Advertising Router.
 access-list 10 permit 10.0.0.0 0.0.0.255
 router ospf 1
  distance 255 &lt;RID&gt; 0.0.0.0 10

LSA Type-3 Filtering 
 area 1 range 10.0.0.0 255.255.255.0 not-advertise

'''Inter-area'''
 ip prefix-list PFXLIST seq 5 deny 10.10.0.0/24
 ip prefix-list PFXLIST seq 10 permit 0.0.0.0/0 le 32
 
 router ospf 1
  area 1 filter-list prefix PFXLIST out|in
out betyder att det som lämnar area 1 filtreras, in betyder filtrering av det som skickas in i area 1.

'''Database Filtering''' &lt;br/&gt;
Man kan stoppa OSPF-processen från att skicka LSA:er. Detta fungerar på network type point-to-multipoint och görs per interface alternativt neighbor. Det bör endast användas där all flooding är unnecessary, t.ex. NBMA subnets där det finns många routrar.
 interface gi2
  ip ospf database-filter all out

'''Route-Map''' &lt;br/&gt;
Med en route-map kan man matcha på interface, ip-adress, ip next-hop, ip route-source, metric, tagging och route-type. Eftersom det är en distribute-list påverkar detta endast lokala routingtabellen.
 access-list 1 permit &lt;prefix&gt;
 access-list 2 permit &lt;RID&gt;
 
 route-map DENY_R2 deny 10
  match ip address 1
  match ip next-hop 2
 
 route-map DENY_R2 permit 20
 
 router ospf 1
  distribute-list route-map DENY_R2 in

==Virtual Link==
OSPF kräver att alla areor är anslutna till area 0. I vissa scenarior kan det vara svårlöst och då kan man använda sig av virtual links för att tunnla OSPF-paket över en annan nonbackbone-area. ABR:n som ej har en direktanslutning till area 0 kan på så sätt få en full kopia av LSDB:n i area 0. Det har inget med data plane att göra utan endast OSPF control plane. En virtual link syns i LSDB som en unnumbered point-to-point länk och LSU:er som skickas har DoNotAge-biten satt. Arean som tunneln går över blir en transit area och den måste vara en vanlig area, dvs ingen stub eller nssa. Detta pga av att data plane går därigenom som vanlig routad trafik så den arean måste känna till allt, intra-, inter- och external routes. VL fungerar som en demand circuit därför bör man ta ner och upp interfacet vid konfigurationsändringar. Interface MTU skickas ej med i DBD-paket över en VL. Virtual link är rekommenderat som backup- eller temporär anslutning. Man kan även använda VL för att koppla ihop area 0 om den finns på flera ställen.

'''R1''' ABR mellan area 0 och 1
 router ospf 1
  network 10.0.1.0 0.0.0.255 area 1
  network 1.1.1.0 0.0.0.255 area 0
  area 1 virtual-link 3.3.3.3  #Router-ID

'''R3''' ABR mellan area 1 och 2
 router ospf 1
  network 10.0.1.0 0.0.0.255 area 1
  network 10.0.2.0 0.0.0.255 area 2
  network 3.3.3.0 0.0.0.255 area 2
  area 1 virtual-link 1.1.1.1  #Router-ID

'''Verify'''
 show ip ospf virtual-links
 show ip ospf border-routers

'''Authentication'''
 area 2 virtual-link 2.2.2.2 authentication message-digest message-digest-key 10 md5 CISCO

==Redistribution==
Default seed metric: 1 för BGP, 20 för övrigt.
 default-metric 20

Med OSPF behövs ordet subnets annars redistribueras endast classful networks. I nyare IOSer kan "subnets" auto-konfas i vissa lägen, man får kolla konfigurationen.
 redistribute maximum-prefix 100

'''NSSA''' &lt;br/&gt;
En NSSA-redistribution kan man styra om den ska nå endast NSSA-arean eller får göras om och skickas vidare till andra areor. Routrar som är med i flera areor gör detta automatiskt.
 redistribute isis nssa-only

'''Static''' 
 redistribute static
Notera att default route inte kan redistribueras med ''redistribute static'', inte ens om en route-map används utan '''default-information originate''' bör användas.

'''[[Cisco_RIP|RIP]]'''
 router ospf 1
  redistribute rip subnets

'''[[Cisco_EIGRP|EIGRP]]'''
 router ospf 1
  redistribute eigrp 1 subnets tag 90

'''[[Cisco_BGP|BGP]],''' seed metric för bgp är 1. När man redistribuerar prefix från BGP så sätts senaste AS i pathen som route tag i LSA:n.
 router ospf 1
  redistribute bgp 100 subnets

==NX-OS==
Här följer [[Cisco_Nexus|Nexus]]-specifik syntax. Några grundläggande skillnader mot IOS är att referensbandbredden för cost default är 40Gbps, Loopback0 väljs som Router-ID oavsett IP, det finns inget network-kommando, loopbacks är passive default och man kan konfa flera VRF:er under samma OSPF-process.

 feature ospf
 
 router ospf 1
  log-adjacency-changes
  bfd
 
 interface loopback0
  ip router ospf 1
 
 interface Ethernet1/1
  ip router ospf 1

Maintenance mode
 router ospf 1
  isolate

Verify and troubleshoot
 show run ospf
 show ip ospf neighbors
 show ip ospf 1 event-history rib 
 show ip ospf 1 event-history redistribution

==IOS-XR==
En skillnad emot IOS är att External LSA:er installeras i RIB även fast forwarding address inte är lärd av ospf. 

Här följer [[Cisco_IOS-XR|IOS-XR]]-specifik syntax.
 router ospf 1
  log adjacency changes detail
  router-id 100.0.0.10
  bfd minimum-interval 100
  bfd fast-detect
  bfd multiplier 3
  mpls ldp sync
  mpls ldp auto-config
  max-lsa 12000
  security ttl
  auto-cost reference-bandwidth 1000000
  max-metric router-lsa on-startup 30
  max-metric router-lsa on-proc-restart 10
  area 0
   authentication message-digest
   message-digest-key 1 md5 encrypted 12411A1A0D13271D030A791111
   fast-reroute per-prefix remote-lfa tunnel mpls-ldp
   !
   interface Loopback0
    passive enable
   !
   interface HundredGigE0/0/0/0
    network point-to-point
    flood-reduction enable

Verify
 show run router ospf
 show ospf
 show ospf neighbor
 show ospf interface brief
 show ospf database

[[Category:Cisco]]</text>
      <sha1>e6lm8biah0vhbooe2r18k9c9lo0upto</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco OSPFv3</title>
    <ns>0</ns>
    <id>253</id>
    <revision>
      <id>3071</id>
      <parentid>2236</parentid>
      <timestamp>2019-11-19T18:58:01Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4726">För huvudartikel, se [[Cisco_OSPF|Cisco OSPF]]. OSPF Version 3 (RFC 5340) togs fram för att stödja IPv6. Man använder termen link istället för network. De flesta features som finns i v2 finns i v3 och fungerar i princip likadant men kan konfigureras lite annorlunda. För OSPF-kommunikation används alltid link-local adresser (med undantag virtual links). Största anledningen till skillnaderna mellan OSPFv2 och v3 är pga att IPv4 och IPv6 fungerar på lite olika sätt. Från och med IOS 15.1(3)S och 15.2(1)T har OSPFv3 stöd för adressfamiljer och man kan använda det både för IPv4 och IPv6, dock är control plane alltid IPv6 med v3. [[Cisco_IOS-XR|IOS-XR]] har inte stöd för OSPFv3 IPv4.

===LSA types===
Det finns en ny typ av LSA, Link LSA som gäller för link-local scope. 
===Network Types===
NBMA

==Konfiguration==
Prereq
 ipv6 unicast-routing
Process, det måste finnas en RID som är 32-bitar och skrivs som en IPv4-adress. Den väljs på samma sätt som i OSPFv2. Finns det ingen IPv4-adress konfigurerad så måste man konfigurera detta manuellt innan processen kan starta. 
 ipv6 router ospf 1
  router-id 1.1.1.1
Interface, det finns inget network-kommando utan man slår på det per interface. Finns det flera adresser på ett interface kommer alla att annonseras av OSPFv3. IPv6-granne konfigureras under interface och inte processen.
 interface gi2
  ipv6 ospf 1 area 0
  ipv6 ospf neighbor 2000:1::2
  ipv6 ospf priority 1
  ipv6 ospf hello-interval 10
  ipv6 ospf dead-interval 40

Verify
 show ipv6 ospf neighbor
 show ipv6 ospf database

'''Instance''', OSPFv3 har stöd för multipla instanser per länk. Endast routrar med samma instance-nummer bildar grannskap.
 interface gi2
  ipv6 ospf 1 area 2 instance 3

===Authentication===
Den första varianten av OSPFv3 (IPv6 only) använder IPv6’s inbyggda IPsec-autentisering så det finns ingen egen. Eftersom OSPFv3 inte använder ISAKMP för nyckelutbyte i fas 1 måste fas 2 autentisering och kryptering konfigureras manuellt.
 interface gi2
  ipv6 ospf encryption ipsec spi 2001 esp aes-cbc 256 4F814B37EA44ED42549955036FC0A68830A45FAC16424B093511EB4ACF20962D sha1 8A4481AF1A1444A92BB405F3A7FA392DF7222E5F
 
  ipv6 ospf authentication ?
    ipsec 
    null

===Prefix Suppression===
Fungerar som med OSPFv2.
 interface gi2
  ipv6 ospf prefix-suppression

===Summarization===
Fungerar som med OSPFv2.
 ipv6 router ospf 1
  area 0 range 2000:1::/60

===Redistribution===
Default metric: 1 för BGP, 20 för övrigt
 ipv6 router ospf 1
  redistribute connected metric 10
  redistribute rip RIPNG tag 123
  redistribute eigrp 100 route-map FILTER

===Virtual Links===
Virtual link kan byggas över IPv4 precis som med OSPFv2.
 ipv6 router ospf 1
  area 1 virtual-link 10.0.0.20
Verify
 show ipv6 ospf virtual-links 

==Multi AF Mode==
Denna konfigurationen är mer homogen med [[Cisco_BGP#Konfiguration|BGP AFI-format]] och [[Cisco_EIGRP#Named_mode|EIGRP Named mode]].
 router ospfv3 1
  router-id 1.1.1.1
 
  address-family ipv4 unicast
   maximum-paths 4
   redistribute connected
  exit-address-family
 
  address-family ipv6 unicast
   maximum-paths 16
   area 0 range 2001:100:1::/48
  exit-address-family
 
 interface gi2
  ospfv3 1 ipv4 area 0
  ospfv3 1 ipv6 area 0

Verify
 show ospfv3
 show ospfv3 neighbor
 show ospfv3 interface brief

Man måste köra IPv6 också eftersom det används för control plane.
 ospfv3 1 ipv4 area 0
 % OSPFv3: IPV6 is not enabled on this interface

===Authentication===
Med OSPFv3 kan man använda ESP header eller Authentication Header och det konfigureras antingen per-link eller globalt under arean.
 router ospfv3 1
  area 10 authentication ipsec spi 500 sha1 8a4481af1a1444a92bb405f3a7fa392df7222e5f
 
 interface gi2
  ospfv3 encryption ipsec spi 700 esp aes-cbc 256 4F814B37EA44ED42549955036FC0A68830A45FAC16424B093511EB4ACF20962D sha1 8A4481AF1A1444A92BB405F3A7FA392DF7222E5F

Innan OSPFv3 Authentication Trailer var IPsec det enda sättet att autentisera OSPF-paketen. 
 key chain OSPFv3
  key 1
   key-string SECRET
   cryptographic-algorithm hmac-sha-512
 
 interface gi2
  ospfv3 authentication ?
    ipsec
    '''key-chain'''
    null

Verify
 show ospfv3 interface | i Ethernet|authentication|encryption
 show crypto ipsec policy

===TTL Security===
OSPFv3 TTL security kan endast konfigureras för virtual links och sham links i Multi AF Mode. TTL Security gör ingen nytta i övrigt eftersom OSPFv3 control plane görs med link-local-adresser.

===BFD===
BFD-support för OSPFv3 kan konfigureras på två sätt, under processen eller interface. Se även [[Cisco_BFD|Cisco BFD]].
 address-family ipv4 unicast
  bfd all-interfaces
 
 interface gi2
  ospfv3 bfd 

[[Category:Cisco]]</text>
      <sha1>7s3gb2ikw1legwaiv1p7ea248q3ymv4</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco OTV</title>
    <ns>0</ns>
    <id>180</id>
    <revision>
      <id>2918</id>
      <parentid>2909</parentid>
      <timestamp>2019-01-16T12:21:20Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8141">Overlay Transport Virtualization är en tunnlingsteknik för att sträcka L2-domäner över ett L3-nät med hjälp av enkapsulering. Det är routing baserat på mac-adress och för control plane används IP-enkapsulerad [[Cisco_IS-IS|IS-IS]]. OTV lär sig MAC-IP par genom MAC address learning på internal interface, IGMP snooping och OTV control plane (IS-IS) updates. Alla MAC-adresser sparas i OTV Routing Information Base (ORIB) med VLAN ID och associerad remote IP.

Det finns inbyggd felisolering tack vare att broadcast och unknown unicast droppas vid edge istället för att floodas över tunneln. ARP optimeras också genom att Edge Devices kan svara på ARP-frågor för enheter som finns på andra sidan, detta genom att lyssna på ARP-trafik på den lokala siten och cachea den. OTV går även att kombinera med en krypterad transport, t.ex. [[Cisco_IPsec#GET_VPN|GET VPN]]. IPsec kan då terminera i samma box som OTV och det funkar både ihop med OTV unicast och multicast mode.

===Termer===
'''Edge Device:''' Gränsenhet mellan lanet och utsidan, där OTV-enkapsulering görs.

'''Authoritative Edge Device:''' Enhet som är aktiv på siten. Endast en i taget, vlan lastdelas.

'''Join Interface:''' L3-interface som ska kunna nå andra OTV-siters join interface.

'''Internal Interface:''' L2-interface som når de VLAN som ska sträckas.

'''Overlay Network:''' Det logiska nätverk där L2-trafiken går över Transport Network. Inga BPDUer går över detta nät.

'''Transport Network:''' Det nätverk som kopplar ihop de olika siterna, kan vara WAN/internet eller en blandning. Ska finnas rum för 42 extra bytes MTU.

==Neighbors==
Innan trafik kan forwarderas måste det upprättas grannskap. För detta krävs Source Specific multicast-stöd av nätverket emellan (om transportnätverket inte stödjer multicast så kan en unicast-funktion i OTV som heter Adjacency Server användas). Edge devices skickar IGMP membership report och sedan OTV-enkapsulerade hello packets. Alla edge devices ska bilda adjacency. Neighbors delar MAC-adress reachability med varandra genom att skicka uppdateringar med multicast. 

===Fast Convergence===
* VLAN AED synchronization
* Site ID and proactive advertisments
* Prepopulation
* BFD and route tracking
* Graceful insertion
* Graceful shutdown
* Prioritized processing of LSPs

Om man använder multihoming, dvs flera edge devices per site är det starkt rekommenderat att slå på spanning-tree på OTV-routrarna. Genom att göra det kan de skicka ut topology change notification (TCN) när de märker att AED failar och rollen ska flyttas. Detta får switcharna att reducera sin aging timer till 15 sekunder vilket skyndar på konvergensen. 

OTV-noder sparar remote unicast MAC addresses i sin ORIB även för non-AED vlan, detta för att snabba upp konvergens vid AED failover.

=Konfiguration=
Notera att "OTV cannot be configured when MPLS features are enabled on the router".

site bridge-domain är samma sak som site-vlan.
 otv site bridge-domain 100
 otv site-identifier 0000.0000.0101
 
 otv isis Overlay1
  log-adjacency-changes

Overlay-interface
 interface Overlay1
  no ip address
  otv join-interface GigabitEthernet3
  otv use-adjacency-server 10.0.0.10 unicast-only
 
  service instance 200 ethernet
   description Test-vlan
   encapsulation dot1q 200
   bridge-domain 200

Verify
 show otv site
 show otv adjacency
 show otv overlay 1

Internal interface
 interface GigabitEthernet4
  description Internal-interface
  no ip address
  negotiation auto
  service instance 100 ethernet
   encapsulation dot1q 100
   bridge-domain 100
 
  service instance 200 ethernet
   description Test-vlan
   encapsulation dot1q 2
   rewrite ingress tag translate 1-to-1 dot1q 200 symmetric  #VLAN translation 2 &lt;-&gt; 200
   bridge-domain 200

Det går även att ta in det otaggat.
 interface GigabitEthernet2
  service instance 201 ethernet
   encapsulation untagged
   bridge-domain 201

Verify
 show otv route
 show otv vlan
 show otv arp-nd-cache

AED håller även koll på multicast senders på den lokala siten. Show OTV multicast routing table for overlays.
 show otv mroute
Default skickas alla paketen över overlay med DF-biten satt. För att tillåta fragmentation of IP packets över overlays måste man slå på det. OBS alla edge devices i overlayen bör supportera reassembly in hardware.
 otv fragmentation join-interface port-channel 1

===Enkapsulering===
I nya versioner av hårdvara/mjukvara kan man välja vilken enkapsulering man ska använda, default används [[Cisco_GRE|GRE]]/[[Cisco_MPLS|MPLS]] men nu kan man även använda [[Cisco_VXLAN|UDP/VXLAN]]. Väljer man den VXLAN blir det overhead 50 Bytes per paket.
 otv encapsulation-format ip gre | udp

===FHRP===
Om man har en design där båda sidor har FHRP active router måste FHRP-paket filtreras så de ej korsar OTVn. 
 interface Overlay1
  otv filter-fhrp
Native-stöd även för NX-OS är planerat, lösning sålänge är att man använder VLAN-ACL i kombination med OTV MAC route filter och arp-inspection filter (feature dhcp).

=Nexus=
OTV är kompatibelt med ett IPv4 transport network.

 feature otv

VLAN
 vlan 1000
  name OTV-SITE-VLAN
 vlan 2000
  name OTV-TEST1
 vlan 2001
  name OTV-TEST2
 exit

 no ip dhcp relay
 no ipv6 dhcp relay

'''Join interface''' &lt;br/&gt;
Alla core och core facing L3 interface ska ha stöd för jumbo frames eftersom OTV sätter DF-biten i IP-headern på alla control och data plane packets. Vill man ha bättre load-balancing i sitt core (depolarization) kan man konfa flera IP-adresser (secondary) på sina join-interface, då kommer OTV att hasha och kunna använda alla IP-adresser som source på OTV-enkapsulerade paket. Transportnätverket måste supportera ASM eller PIM-Bidir men slå ej på PIM på join interfacet. Exempel, för SSM.
 interface po1
  no ip redirects
  ip igmp version 3
  no shut

'''Site VLAN'''
 otv site-vlan 1000
 otv site-identifier 0x2
 
 otv-isis default 
  vpn Overlay1
 
 interface vlan1000
  no ip redi
  no ipv6 redi
  ip add 10.1.1.1/30
  no shut

'''Overlay''' &lt;br/&gt; 
The site VLAN must not be extended into the OTV.
 int Overlay1
  otv join-interface po1
  otv control-group 239.4.4.1
  otv data-group 232.8.8.0/26
  otv extended-vlan 2000
  otv extended-vlan add 2001
  no shut

'''BFD''' &lt;br/&gt;
Man kan köra [[Cisco_BFD|BFD]] över site-vlan:et för att snabbt upptäcka forwarderingsproblem inom siten.
 interface vlan1000
  no ip redirects
  ip address 10.1.1.1/30
 
 otv site-vlan 1000
  otv isis bfd
 
 otv-isis default
  track-adjacency-nexthop
Verify
 show otv isis track-adjacency-nexthop
 show bfd neighbors

'''Static flood''' &lt;br/&gt;
Undantag för unknown unicast (t.ex. silent hosts). Broadcast går ej.
 otv flood mac 0011.2233.4455 vlan 160
 
 otv flood mac FF:FF:FF:FF:FF:FF vlan 160
 ''The flood mac can not be a broadcast mac.''

'''VLAN Mapping''' &lt;br/&gt;
Man kan skriva om VLAN ID:n på frames som gör över tunneln. Detta är inte supporterat på Cisco M3- och F3-moduler men man kan då använda per-port vlan-översättning (switchport vlan mapping). 
 interface overlay 5
  otv vlan mapping 10,14-16 to 20-21,25,28
  otv extended-vlan 10,14-16
Show
 show otv vlan-mapping

===Loopback Join Interface===
Med NX-OS 8 kan man använda ett loopback som join interface, detta gör att man kan ha multipla routade upplänkar till sitt multicast core. Upplänkar och loopback ska köra PIM för att detta ska funka. Unicast (Adjacency Server) stöds inte med denna typ av join interface.
 feature pim
 
 interface loopback1
  ip address 10.10.10.2/32
  ip router ospf 100 area 0.0.0.0
  ip pim sparse-mode
 
 interface Overlay1
  otv join-interface loopback1

===PVLAN===
I nyare releaser av NX-OS kan man sträcka [[Cisco_VLAN#Private_VLAN|Private VLAN]] över OTV och därmed behålla segmenteringen.
 feature pvlan
 
 vlan 100
    private-vlan primary
    private-vlan association 101-103
 vlan 101
    private-vlan community
 vlan 102
    private-vlan community
 vlan 103
    private-vlan isolated
 
 interface overlay 1
    otv extend-vlan 100
Show
 show otv vlan private-vlan

[[Category:Cisco]]</text>
      <sha1>5oapcwkc6j4rf1ksav21589thi587vn</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco PCE</title>
    <ns>0</ns>
    <id>546</id>
    <revision>
      <id>3010</id>
      <timestamp>2019-09-04T07:02:06Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Tanken med Path Computation Element är att en enskild entitet har visibilitet över och håller koll på LSPer i en hel domän oavsett antal areor och IGPer. Detta gör att m..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1541">Tanken med Path Computation Element är att en enskild entitet har visibilitet över och håller koll på LSPer i en hel domän oavsett antal areor och IGPer. Detta gör att man kan få fungerande TE både inter-area och inter-AS. PCE består av Traffic Engineering Database (TED) och Path Computation Client (PCC). 

SR-PCE är en IOS-XR multi-domain stateful SR Path Computation Element (PCE) som kan köras både virtuellt och fysiskt (kallas då XR Transport Controller). XTC kan prata ISIS, OSPF och BGP-LS för att få topologi-information ifrån flera domäner. SR-PCE är SR-optimerat och kan updatera SRTE-policys allt eftersom. Man deployar det likt RR. Se även [[Cisco_SR|Segment Routing]].

==Konfiguration==
BGP-LS på P/PE
 router isis 1
  distribute link-state
  address-family ipv4 unicast
 
 router bgp 100
  neighbor 11.11.11.11
   remote-as 100
   update-source Loopback0
   address-family link-state link-state
 
 show bgp link-state link-state summary

XTC
 pce
  address ipv4 11.11.11.11   #own loopback
 
 show pce ipv4 peer

PCC på P/PE
 segment-routing
  traffic-eng
   maximum-sid-depth 5
   pcc
    source-address ipv4 1.1.1.1   #own loopback
    pce address ipv4 11.11.11.11  #XTC
    !
    report-all
 
 show segment-routing traffic-eng pcc ipv4 peer brief

Förutom vanlig IGP link metric information kan PCE även lära sig prefix SID och adjacency SID för alla länkar. Detta gör att PCE kan göra path computation baserat på IOS-XR's CSPF-algoritmer. 
 show pce ipv4 topology summary

[[Category:Cisco]]</text>
      <sha1>gokdxsbxjc5gc1p1nfbbmw5t23labrc</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco PE-CE</title>
    <ns>0</ns>
    <id>290</id>
    <revision>
      <id>3052</id>
      <parentid>2778</parentid>
      <timestamp>2019-11-12T10:01:51Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7027">PE routers redistribuerar routes till BGP och konverterar dem till VPNv4 NLRI. Denna NLRI annonseras till andra PE med hjälp av MP-BGP. Dessa PE konverterar tillbaka VPNv4 routes och skickar det vidare till CE. &lt;br/&gt; Se även [[Cisco_BGP|Cisco BGP]], [[Cisco_Routing|Cisco Routing]] och [[Cisco_MPLS|Cisco MPLS]].

==RIP==
RIP är det simplaste protokollet och om man använder '''transparent''' så kommer RIPs metric att tas ifrån BGP MED attribute som är en kopia av RIP metricen från andra sidan. Detta gör att man kan få till bra path selection även om det finns backdoor links. RIPv1 stöds inte. Se även [[Cisco_RIP|Cisco RIP]].
 router rip
  version 2
  address-family ipv4 vrf Cust_A
   redistribute bgp 100 metric transparent
   network 192.168.1.0
 
 router bgp 100
  address-family ipv4 vrf Cust_A
   redistribute rip
  exit-address-family

==OSPF==
OSPF för PE-CE (RFC 4577), se även [[Cisco_OSPF|Cisco OSPF]]. MPLS-nätet skickar OSPF VRF routing information i MP-BGP-uppdateringar och det kommer att agera som en OSPF super-backbone vilket gör att man faktiskt inte behöver köra med area 0 någonstans men man kan såklart göra det. Man kan t.o.m. ha area 0 på flera siter. När routes går från MP-BGP till OSPF ska down biten sättas, detta för att förhindra loopar. När routes redistribueras från OSPF till MP-BGP ska domain-id vara konfat. Om OSPF domain-id är samma på båda sidor kommer routes att exporteras som type-3 inter-area LSA och om de inte är samma kommer routes att exporteras som type-5 external LSA. Om man inte specifikt anger något Domain ID på IOS så kommer process ID att användas. På IOS-XR sätts NULL ifall man inte har konfigurerat något. 

 interface gi0/0
  description Link to CE
  vrf forwarding Cust_A
  ip ospf 2 area 0
 
 router ospf 2 vrf Cust_A
  router-id 10.0.0.10
  '''domain-id 1.1.1.1'''
  redistribute bgp 100 subnets
 
 router bgp 100
  address-family ipv4 vrf Cust_A
   redistribute ospf 2 vrf Cust_A
  exit-address-family

OSPF har inbyggd loop prevention genom att tagga alla routes som har redistribuerats från MPLS-nätet till OSPF med en down bit i LSA:n. Om detta kommer till en VRF-aware OSPF-process (t.ex. på en annan PE) kommer det att droppas. Så detta behövs på en CE som kör VRF Lite annars kommer LSA:er som kommer ifrån MPLS Superbackbone att ignoreras. I nyare IOS sätts down bit på både typ 3 och typ 5 LSA, förr var det endast typ 3. Det finns även en domain tag som skickas med prefixen, default är det 208.0.0.0 + ASN fast i decimal format. Syftet med domain tag är loop prevention, det är fallback för DN bit som man kan behöva att kringgå om man kör vrf-lite.
 router ospf 1 vrf Cust_A
  capability vrf-lite 

===Sham-Link===
Om kund har en bakväg mellan sina siter av t.ex. redundansskäl kommer OSPF att föredra den framför MPLS-nätet eftersom routes som gått över L3-VPN:n skickas med BGP och då blir inter-area eller externa för OSPF. Intra-area routes är preferred över inter-area och external routes oavsett metric. OSPF sham link tillhandahåller en logisk länk mellan två VRFer på PE. Det är en tunnel som ser ut som en point-to-point länk för OSPF. Med hjälp av detta kan man lura OSPF att tro att den bästa vägen är över MPLS-nätet. Detta är endast control plane dvs för SPF calculations och best-path selection medans forwarding görs som vanligt med information från MP-BGP. Sham-links har source på interface som finns i kundens VRF, t.ex. Loopbacks uppsatta för detta ändamål. Deras IP-adresser bör annonseras på något annat sätt än OSPF (typ BGP). 

PE1
 interface Loopback 20
  ip vrf forwarding Cust_A
  ip address 3.3.3.3 255.255.255.255
 
 router ospf 2 vrf Cust_A
  area 0 sham-link 3.3.3.3 1.1.1.1 cost 10
PE2
 interface Loopback 20
  ip vrf forwarding Cust_A
  ip address 1.1.1.1 255.255.255.255
 
 router ospf 2 vrf Cust_A
  area 0 sham-link 1.1.1.1 3.3.3.3 cost 10
Verify
 show ip ospf sham-links

==EIGRP==
När man använder EIGRP som PE-CE skickas metric values, route type, source AS#, remote Router ID med i BGP-uppdateringarna som extended communities. Detta gör att när man kör EIGRP &lt;-&gt; BGP (VPN) &lt;-&gt; EIGRP blir routsen internal, däremot om routsen har kommit från något annat än EIGRP, dvs saknar dessa communities, blir de external ur EIGRPs perspektiv. EIGRP-prefix som redistribueras in i BGP kommer också att ha ett Cost value som används för path selection. Se även [[Cisco_EIGRP|Cisco EIGRP]].

 router eigrp 100
  address-family ipv4 vrf Cust_A autonomous-system 200
   redistribute bgp 100 metric 10000000 0 255 1 1500
   no auto-summary
  exit-address-family
 
 router bgp 100
  address-family ipv4 vrf Cust_A
   redistribute eigrp 200
  exit-address-family

===Site-of-Origin===
SoO skickas som extended community (både i BGP och EIGRP) och används för loop prevention för VPN-kunder som är multi-homed. Kommer det in routes med SoO satt till det man själv har discardas dem. Samma resultat går också att uppnå med route tagging men är lite mer omständigt att konfigurera. Beroende på designval så sätter man samma SoO-värde på båda PE downlinks. 

 route-map SoO permit 10
  set extcommunity soo 100:2
 
 interface Gi2
  description Link to CE
  vrf forwarding Cust_A
  ip vrf sitemap SoO

==BGP==
Om man använder BGP för PE-CE behövs ingen redistribution eftersom det är samma routing-protokoll som MPLS-nätet använder samt att skalbarhet och kontroll (policy) är bra. Det går även att köra iBGP som PE-CE, se RFC 6368.

Cost Community &lt;br/&gt;
Syftet med Cost Communities är att förhindra suboptimal routing och routing loops. Det går att stänga av.
 router bgp 100
  bgp bestpath cost-community ignore

'''SoO Attribute''' &lt;br/&gt;
Site-of-Origin används för loop prevention och konfigureras på PEs grannskap till CE. Uppdateringar med det konfigurerade SoO-värdet kommer varken skickas eller accepteras, dvs det är filtrering både ingress och egress.
 router bgp 100
  address-family ipv4 vrf Cust_A
   neighbor 1.1.1.1 soo 10:12
Samma resultat går att uppnå med en route-map som sätter denna community men det kan bli omständigt att konfigurera.

==IS-IS==
IS-IS är inget vanligt PE-CE protokoll men det går at köra på IOS. ISIS har ingen loop prevention så man måste filtrera om man ska köra dual homed/redundant kopplat till mpls-nätet. 

 router isis 10
  vrf CustA
  net 49.0000.0000.0010.00
  redistribute bgp 100 level-1-2

==Route Leaking==
Med hjälp av route targets kan man bygga vilken logisk topologi man vill för sina L3 VPN:er.
 vrf definition Cust_A
  rd 65000:1
  address-family ipv4
   route-target both 65000:1
   route-target import 65000:999
 
 vrf definition Cust_B
  rd 65000:2
  address-family ipv4
   route-target both 65000:2
   route-target import 65000:999
 
 vrf definition Shared
  rd 65000:999
  address-family ipv4
   route-target export 65000:999
   route-target import 65000:1
   route-target import 65000:2

[[Category:Cisco]]</text>
      <sha1>tpabez66db1syfhpfs8qie7dg957f34</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco PIM</title>
    <ns>0</ns>
    <id>266</id>
    <revision>
      <id>3007</id>
      <parentid>2912</parentid>
      <timestamp>2019-08-28T13:17:38Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="28542">För att routrar ska kunna veta vilka andra routrar som har multicast-källor och mottagare används något protokoll (control plane), DVMRP, MOSPF eller PIM. De berättar vilka nät som är med i olika multicastgrupper. För loop prevention används RPF och inga paket forwarderas utan att klara denna check. Det som skiljer Protocol Independent Multicast från DVMRP och MOSPF är att det inte är något routingprotokoll utan ett signaleringsprotokoll, dvs det distribuerar ingen routinginformation. PIM använder unicast RIB:en för RPF-checken medans de andra protokollen bygger sina egna tabeller och kör RPF mot. Med IPv6 körs PIM default på alla interface när man slår igång ipv6 multicast-routing.

Se även [[Cisco_Multicast|Cisco Multicast]]. Man kan även använda PIM över [[Cisco_GRE|GRE]]-tunnlar.

===Neighbor===
PIMv2 formar adjacencies och använder 224.0.0.13 neighbor discovery (Hellos) och updates. PIMv2 Hellos skickas default var 30:e sekund på interface konfigurerade för PIM. Hello innehåller holdtime som brukar vara 3 ggr Hello time. Det äldre PIMv1 använde inte Hellos utan skickade Queries till 224.0.0.2.

'''Paket'''
* PIM Hello
* PIM Join
* PIM Prune
* PIM Assert
* PIM Graft
* PIM Register

==Konfiguration==
Global enable. På vissa enheter är kommandot ''ip multicast-routing distributed''
 ip multicast-routing
 show ip multicast

'''Default konfiguration''' (detta kan skilja mellan IOS-version)

Globalt
 ip pim dm-fallback
 ip pim autorp
 ip pim bidir-offer-interval 100 msec
 ip pim bidir-offer-limit 3
 ip pim v1-rp-reachability
 ip pim log-neighbor-changes
Per interface
 ip pim join-prune-interval 60
 ip pim dr-priority 1
 ip pim query-interval 30

Gå med i grupp manuellt
 ip igmp join-group 224.10.0.10

Verify
 show ip mroute
 show ip mroute active
 show ip mroute count
 show ip pim interface
 show ip pim neighbor
 show ip rpf x.x.x.x 

'''Limiting''' &lt;br/&gt;
Global multicast mroute limit
 ip multicast limit cost &lt;ACL&gt; &lt;cost&gt;
Maximum number of multicast routes, default är 2147483647.
 ip multicast route-limit 100

Multicast boundary feature tillåter att man begränsar multicast både control plane och data plane per interface. Med standard acl filtreras grupp och med extended både grupp och källa. Detta filtrerar också Auto-RP announcements. Att begränsa multicast kan även göras med TTL scoping.
 ip multicast boundary [ACL]

'''NBMA''' &lt;br/&gt;
Det finns inbyggd loop prevention för multicast i form av split horizon. I vissa topologier (t.ex. [[Cisco_DMVPN|DMVPN]]) måste multicast-paket skickas ut på samma interface som det kom in på för att det ska fungera och det går att konfigurera per interface. PIM NBMA mode gör att PIM håller reda på OIL som interface + NBMA-adress, istället för bara interface. Detta är inte kompatibelt med PIM-DM.
 ip pim nbma-mode

'''Multipath''' &lt;br/&gt;
Att slå på ECMP Multicast Load Splitting gör att Joins till RP kommer att skickas på fler än ett interface och man måste använda en hash annars kommer RPF-check att faila.
 ip multicast multipath
 ip multicast multipath s-g-hash

=Dense Mode=
Dense mode utgår ifrån att alla subnät har någon som vill ta emot multicast-trafik därför kommer paketen att forwarderas ut på alla interface som är konfigurerade för multicast utom det som det kom in på. Alla routrar gör samma sak och alla subnät får strömmen, detta träd kallas ''source-based distribution tree'' eller ''shortest-path tree''. Det finns dock möjlighet för routrar att begära att inte få paket för vissa multicast-grupper om man inte har någon router downstream som är aktiv i gruppen samt ej heller någon enhet på ett directly connected interface som är med i gruppen. Då skickas ett Prune message upstream för att berätta detta. Prune har timeout 3 minuter, sedan återgår interfacet till forwarding. För att förhindra pendlandet mellan Pruned och Forwarding kom PIMv2 med en feature som kallas ''State refresh''. Om downstream fortfarande inte vill vara med i multicastströmmen kan den skicka ett State refresh upstream för att nollställa Prune timer, detta skickas var 60:e sekund. Behöver en router plötsligt lyssna på en multicastgrupp (för att den fått in IGMP Join) kan den "unprune" genom att skicka ett Graft message upstream som gäller så fort det kommer fram vilket sänker konvergeringstiden. Det ackas med Graft Ack. För Dense mode kan olika multicast-routingprotokoll användas. PIM Dense mode skalar inte superbra pga excessive flooding.

 interface gi2
  ip pim dense-mode
Verify
 show ip pim interface
 show ip mroute

=Sparse Mode=
Det är inte säkert att alla nät har någon mottagare av multicast, därför finns Sparse mode (RFC 4601) som inte använder lika mycket nätverksresurser som Dense mode. Den stora skillnaden är deras default-beteende. Med IPv6 finns endast Sparse mode. Default är att inte skicka vidare paket downstream om man inte fått ett Join meddelande som begär paket för en viss multicast-grupp. Detta händer när det har kommit in ett IGMP Join message på ett directly connected interface eller en annan router downstream har begärt trafik för gruppen. Multicast forwardas sålänge det kommer Join-meddelanden. Vem som ska ha vad hålls koll på av en Rendezvous Point som alla måste känna till. I små nät görs detta manuellt och i större nät kan detta göras automatiskt. 

När en Source host skickar multicast-trafik första gången kommer routern som tar emot det att enkapsulera paketet i ett PIM Register och skicka det med unicast till RP. Känner inte RP till någon downstream som begärt denna ström kommer den att svara med ett Register-Stop meddelande och den första routern ska inte forwarda denna multicast-ström. Register-Suppression timer startar då och router väntar 1 minut minus 5 sekunder sedan frågar den RP igen men denna gång utan det enkapsulerade mc-paketet utan Null-Register biten är satt istället. Däremot om RP känner till någon som vill ha multicast-strömmen kommer den att dekapsulera paketet och forwarda det. På så sätt fungerar multicast tills registration process är klar. När en PIM-SM router längs vägen får in ett PIM Join sätts interfacet i forwarding för den multicastgruppen. För att multicast ska fortsätta forwardas måste routrar forsätta skicka PIM Joins annars blir gruppen pruned. En router fortsätter med detta om den själv får in Joins eller någon host på ett directly connected interface svarar på IGMP Queries. Prune timer är default 3 minuter. 

Med sparse mode används shared trees som betecknas (*,G). RP kommer att gå med både i (*,G) men också (S,G) där S är source för strömmen. Finns det flera källor till strömmen kommer det först att gå till RP för att sedan forwardas ut shared distribution tree / root-path tree. Det finns även möjlighet för en PIM-SM router att bygga SPT direkt med källan. Ifall man har närmre till källan är det onödigt att all trafik ska gå igenom RP först. Då kan routern faktiskt meddela RP med ett Prune message att multicast-strömmen inte behöver skickas till den längre. Ciscoroutrar gör detta byte direkt efter första paketet, detta går att ändra med '''ip pim spt-threshold infinity'''.

På alla enheter (static RP):
 ip multicast-routing
 ip pim rp-address 10.0.0.10 [override]
 
 interface gi2
  ip pim sparse-mode
 interface gi3
  ip pim sparse-mode

På Rendezvous Point utöver det ovan. En router vet om att den är RP om den har ett interface med den konfigurerade rp-adressen. Man måste kör PIM på det interface man annonserar som RP.
 interface lo0
  ip address 10.0.0.10 255.255.255.0
  ip pim sparse-mode

För att förhindra att oönskade RPs och grupper blir aktiva i ens nät kan man skydda sig med filter. Man skriver standard-acler som listar de grupper som är tillåtna, till exempel tillåt endast join och prune messages från RP 10.0.0.10 som har med grupp 224.4.4.4 att göra. Det räcker att konfigurera detta på RP men det bör göras överallt.
 ip access-list standard ALLOWED_GROUPS
  permit 224.4.4.4
 
 ip pim accept-rp 10.0.0.10 ALLOWED_GROUPS

Verify
 show ip mroute
 show ip pim rp mapping
 show derived-config interface tunnel0

På RP skapas två stycken tunnel interface, ett för att enkapsulera PIM Register messages och ett för att dekapsulera.
 show ip pim tunnel

===Sparse Dense Mode===
PIM Sparse-Dense mode är en hybrid av Sparse och Dense mode operations. En “sparse” multicast-grupp är en som har RP definierat. När man kör ''ip pim sparse-dense-mode'' på ett interface så kommer det att forwardera trafik både för sparse och dense multicast groups ut på det interfacet.
 interface gi2
  ip pim sparse-dense-mode
Stänga av dense mode fallback.
  no ip pim dm-fallback

==Auto-RP==
I Sparse mode måste alla multicast-routrar känna till RP, i större nät blir detta mödosamt att konfigurera. Det finns två mekanismer för att upptäcka RP automatiskt, Auto-RP och BSR (se nästa stycke). Auto-RP är ett Ciscoproperitärt protokoll som använder 224.0.1.39 och 224.0.1.40 för kommunikation, dvs multicast som routas. Enheter som kör Auto-RP och vill vara RP (candidates) skickar först ut RP-Announce till 224.0.1.39 med sig själv satt som RP. Det skickas ut var 60:e sekund och det innehåller vilka multicast-grupper man är RP för. Detta leder till att olika routrar kan vara RP för olika grupper vilket ger lastdelning. Sedan måste någon vara mapping agent (vanligtvis samma enhet) som lär sig alla RPs och vilka grupper de är med i för att kunna sprida informationen. Genom att gå med i 224.0.1.39 får man all info från RPs. Alla Cisco-enheter som är konfigurerade för Auto-RP och Sparse mode går med i 224.0.1.40. Mapping agent skickar sedan ut RP-Discovery innehållandes RP-mappningar till 224.0.1.40 port 496 och alla kan lära sig var RP finns. Finns det flera cRPs för samma grupp väljs den som annonserar longest match annars blir det den med högst RP-IP. Finns det flera mapping agents så kommer de att höra varandra och de som inte har högst IP slutar då skicka discoveries. Anledningen till att man behöver mapping agents överhuvudtaget är för att annars skulle det kunna uppstå situationer där olika routrar har valt olika RPs för samma grupp. 

Eftersom Auto-RP kommunicerar med multicast och sparse mode inte forwardar multicast utan RP så får man antingen köra sparse-dense-mode alternativt köra en inbyggd IOS feature som gör undantag för 224.0.1.39 och 224.0.1.40, detta kallas Auto-RP Listener och konfigureras globalt.
 ip pim autorp listener

Candidate RP
 ip access-list standard GROUPS
  permit 224.0.0.0 7.255.255.255
 
 ip pim send-rp-announce Loopback0 scope 10 group-list GROUPS

Multicast mapping agent
 ip pim send-rp-discovery Loopback0 scope 10

Filtrera announcements från RPs, görs på MA med standard-acler.
 ip pim rp-announce-filter rp-list &lt;access-list&gt; group-list &lt;access-list&gt;

Verify
 show ip pim autorp
 show ip pim rp mapping
 
 clear ip pim rp-mapping

Auto-RP Cache Filtering &lt;br/&gt;
Accept only (*, G) join messages destined for the specified Auto-RP cached address. Accept join and prune messages only for RPs in Auto-RP cache.
 ip pim accept-rp auto-rp

==BSR==
En annan metod för att automatiskt hitta RP är PIM Bootstrap Router och fungerar på liknande sätt som Auto-RP. BSR fungerar som mapping agent i Auto-RP, de får in information från RPs som de sedan distribuerar vidare. Dock väljer inte BSR någon bästa RP utan information om alla skickas ut och övriga får välja själv vilken som är bäst. BSR floodar detta till all-PIMv2-routers (224.0.0.13). PIM-SM routrar floodar bootstrap messages på alla non-RPF interfaces vilket leder till att alla multicast-routrar får informationen. Kommer det in bootstrap message på non-RPF interface discardas det vilket förhindrar loopar. Alla c-RP kan berätta för BSR att de är RP och vilka grupper den är med i tack vare att alla vet unicast-adressen till BSR eftersom den har floodats till alla. RPs skickar c-RP Advertisments till BSR. Man kan ha redundanta RPs och redundanta BSRs. Har man flera RPs för samma grupp har BSR en pseudo-random funktion för att fördela lasten mellan dem. Dock kan endast en vara preferred BSR och skicka bootstrap messages, de övriga lyssnar och tar över när preferred BSR tystnar. Den som blir preferred avgörs av högst prio och sedan högst IP. BSR-meddelanden själva RPF-checkas.

BSR (default prio är 0)
 interface lo0
  ip pim sparse-mode
 ip pim bsr-candidate Loopback0 &lt;prio&gt;

RP
 interface lo0
  ip pim sparse-mode
 ip pim rp-candidate Loopback0 

Border
 interface gi3
  ip pim bsr-border

Verify
 show ip pim bsr-router 
 show ip pim rp mapping 

==Anycast RP==
Behöver man både redundans och lastdelning kan man sätta upp flera RPs med samma IP-adress och på så sätt få Anycast RP. Det är inget eget protokoll i sig utan en implementation feature och man kan använda både static RP, Auto-RP och BSR. Varje RP måste annonsera samma /32-prefix till IGP som då står för att dirigera trafiken (PIM Joins) till närmaste RP. RP-konfiguration görs som vanligt med någon av ovan nämnda metoder. Om en RP dör är konvergeringstiden den tid det tar för IGP att hitta en annan väg till samma destination. Varje RP bygger sina egna träd oberoende av eventuella övriga RPs för samma grupper men för att hålla allas information konsekvent bör man (med IOS) använda MSDP mellan RPs, se nedan.

==Bidirectional PIM==
PIM-SM fungerar bra med relativt få multicast senders men när antalet ökar blir det mindre effektivt. Bidirectional PIM kan hjälpa mot detta genom att ändra reglerna litegrann. Det är ett tillägg till Sparse mode konceptet som endast använder shared trees, dvs det finns inga source-based trees. Det är mest effektivt när de flesta receivers samtidigt också är senders. För att kunna bygga bi-directional trees utan att introducera loopar väljs designated forwarders (DFs) på varje länk. Det är endast dem som får skicka något upstream i trädet. För downstream hålls (*,G) state för varje BiDir-grupp med OIL byggd utifrån mottagna PIM Join messages som vanligt. Istället för att den första router som tar emot multicast enkapsulerar paketet och skickar det som PIM Register till RP kommer den att skicka upp det längs det delade trädet mot RP och gör så med alla multicastpaket som kommer in. RP kommer också att forwarda i det delade trädet och RP eller routern närmast källan går inte med i något SPT. Detta gör det viktigt var man placerar RP. Eftersom det inte finns någon source registration process kommer inga tunnlar att skapas.

Bidirectional PIM måste konfigureras på alla PIM-enheter.
 ip pim bidir-enable
 ip pim rp-candidate Loopback0 group-list 10 '''bidir'''
Show designated forwarders
 show ip pim interface df

'''Phantom RP''' &lt;br/&gt;
För redundans kan man använda en RP-IP som faktiskt inte finns konfad på någon enhet. Eftersom inga paket har destination RP-IP utan endast ska skickas upp mot RP behöver det inte vara en interface-adress. Det räcker med en route i routingtabellen. Man kan t.ex. konfa prefix som innehåller RP-IP:n men har olika masklängd på olika enheter, på så sätt kan andra noder ta över RP (tack vare IGP-konvergens) när primären går ner. 

 interface Loopback1
  description Primary RP
  ip address 10.10.11.1 255.255.255.252     &lt;- /30
  ip pim sparse-mode
  ip ospf network point-to-point
  ip router ospf 1 area 0.0.0.0
 
 ip pim rp-address '''10.10.11.2''' group-list 225.0.0.0/24 bidir

=Source Specific Multicast=
Med SSM kan hostarna själva välja source för trafikströmmen ifall det finns flera. Det kan även skydda mot dos-attacker eftersom mottagare berättar för nätverket vilka källor de vill få trafik ifrån. Det ger också fördelar med att överlappande grupp-adresser kommer att fungera eftersom olika källor gör det unikt. Det finns inga shared trees med SSM utan allt hanteras som source trees. Det behövs heller inga RPs eftersom källan är känd.

Source Specific Multicast kräver IGMPv3 samt någon variant av sparse mode.
 interface gi2
  ip igmp version 3
  ip pim sparse-mode

Sedan väljer man range som enheterna ska behandla som SSM, dvs droppa eventuella (*,G). ''Default'' innebär 232.0.0.0-232.255.255.255 som är IANA assigned SSM range. 
 ip pim ssm default

Verify
 show ip mroute

=MSDP=
Multicast Source Discovery Protocol (RFC 3618) används för inter-domain IPv4 multicasting och för att låta RPs i ett enskilt AS dela information om de kör Anycast RP. MSDP kan användas mellan RPs för att berätta vilka källor de känner till. När en PIM router registrerar en multicastkälla till sin RP kommer den att använda MSDP för att skicka denna info till sina peer RPs. Source Active meddelanden innehåller IP-adress för varje källa för varje grupp, enheter på andra sidan kan då bygga SPT för respektive sender. Meddelandena skickas var 60:e sekund med TCP över unicast mellan peers och blir besvarade med SA response paket. Detta grannskap måste konfigureras och unicast route till andra sidan måste finnas. [[Cisco_BGP|BGP]] eller [[Cisco_Multicast#BGP|Multicast BGP]] kan användas för detta. 

 ip msdp peer [peer_unique_address] connect-source loopback0 remote-as 100
 ip msdp originator-id [unique_address_interface]

RPF checken kräver full routing information från andra domäner för att multicast ska fungera. Om man t.ex. har en stub multicast domain och inte får in all information kan man konfigurera upstream RP som ''default-peer'' för RPF checkar används inte på default peers utan alla SA messages accepteras.
 ip msdp default-peer

Verify
 show ip msdp summary
 show ip msdp peer
 show ip msdp sa-cache

===Mesh Group===
MSDP mesh group är en optimerings-feature som reducerar mängden SA-trafik när man har fler än två MSDP peers i samma domän. Alla MSDP speakers har fully meshed MSDP-konnektivitet mellan varandra, dvs alla har peering med samtliga routrar i gruppen. Detta gör att SA flooding kan optimeras genom att SA messages inte behöver floodas till andra mesh group peers. Värt att notera är också att det inte görs någon RPF check på inkomna SA messages från mesh group peers utan de accepteras alltid när MSDP mesh group är konfigurerat.

 ip msdp peer 10.1.1.1
 ip msdp peer 10.2.2.2
 ip msdp mesh-group mesh-group1 10.1.1.1
 ip msdp mesh-group mesh-group1 10.2.2.2

=Convergence=
Multicast Subsecond Convergence är möjligt genom att använda flera olika tekniker.
 ip multicast rpf interval 10
 ip pim register-rate-limit rate 10
 ip pim spt-threshold 0
 
 interface gi2 
  ip pim query-interval 30

'''BFD''' &lt;br/&gt;
Konvergenstider går också att trimma med hjälp av [[Cisco_BFD|BFD]].
 ip pim bfd

=LAN=
Detta gäller både PIM-DM och PIM-SM.

===Prune Override===
Om det finns flera routrar i samma L2-segment som vill ha multicast kommer det att sluta funka när en av dem ber upstream router att pruna en multicastgrupp. Därför kommer den som på multiaccess-segment tar emot Prune att vänta 3 sekunder innan den slutar forwarda multicastströmmen på sitt interfacet. Eftersom Prune går till 224.0.0.13 så får alla PIM-routrar det och de som vill fortsätta få strömmen kan skicka ett vanligt Join-meddelande igen då kommer inte upstream sluta forwarda, detta kallas Prune Override. Detta är inget som konfigureras utan det är en funktion som är på default.

===Assert Message===
Om det finns flera routrar på ett LAN-segment som är aktiva för en multicastgrupp kommer det att skickas in dubbel trafikström till hostarna, detta är onödigt. När en router får in ett multicast-paket som den själv forwarderar in på nätet kommer den att skicka ett PIM Assert Message. Med hjälp av det kan routrarna jämföra path cost till källan för SPT där endast vinnaren kommer att forwarda multicastströmmen in på LANet. Path cost består av kombinationen (AD, Metric) och först jämförs AD på routingprotokollet som har lärt vägen till källan sedan kollas på IGP-metricen för att skilja. Är detta också lika går man på högst IP-adress på interface. Den som förlorar slutar att flooda multicasten. I hub-and-spoke topologier bör alltid hub vinna förutsatt att man inte köra PIM i NBMA mode.

&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
Assert message:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_PIM_Assert.PNG]]
&lt;/div&gt;
&lt;/div&gt;

===Designated Router===
PIM Designated Router (DR) väljs på varje segment där det finns multipla multicast-routrar. Syftet med DR är att ha en nod som signalerar aktiva källor till RP. Valet baseras på högsta prioritet och vid lika högsta IP-adress. Processen är preemptive så det är alltid den med bäst prio som är DR. Detta är en sparse-mode feature.
 interface gi2
  ip pim sparse-mode
  ip pim dr-priority 100
 
 show ip pim neighbor

På RP kan begränsa vem som får skicka PIM Register från olika segment med hjälp av en extended acl, dvs man kan vitlista vem som är en giltig DR.
 ip access-list extended VLAN100
  permit ip host 100.0.100.10 any
  deny   ip 100.0.100.0 0.0.0.255 any
  permit ip any any
 
 ip pim accept-register list VLAN100

===PIM Snooping===
Man kan begränsa multicastpaket för varje grupp så att endast multicast router ports som har någon downstream receiver med i gruppen får trafiken. När man slår på PIM snooping så kommer switchen att lära sig vilka mrouter-portar som ska ha vilka multicast-strömmar i varje vlan genom att lyssna på PIM hello messages, PIM join/prune messages och bidirectional PIM designated forwarder-election messages. Join och prune kommer inte att floodas på alla mrouter-portar utan skickas till den port med upstream router som finns i payloaden på join/prune messages. All information om mroutes och routrar kommer att timeas ut baserat på den information som står i hellos, joins och prunes. Dense mode trafik ses som unknown och kommer att droppas men Auto-RP-paket kommer alltid att floodas.

För att använda PIM snooping måste IGMP snooping vara på.
 ip igmp snooping
 ip pim snooping

Verify
 show ip pim snooping

=IPv6=
Multicast routing är inte på default för IPv6 men när man slår på det så enableas PIM på alla IPv6-interface. IPv6 PIM kör alltid sparse mode. Reverse-path använder routingtabellen vilket gör det protokoll-oberoende precis som för IPv4. PIM-grannskap byggs med hjälp av link-local adresser och det finns tre pakettyper: Query, Report och Done. DR väljs som vanligt och Hellos skickas var 30:e sekund. Multicast address range: FF00::/8.
 ipv6 multicast-routing
 
 interface gi2
  ipv6 mld access-group MLD_FILTER
  ipv6 mld query-max-response-time 10
  ipv6 mld query-timeout 255
  ipv6 mld query-interval 125
  ipv6 mld join-group ff08::10 

Stänga av PIM
 interface gi3
  no ipv6 pim
Static routes, dessa används endast av multicast.
 ipv6 route 2000::/64 tun0 '''multicast'''

Verify
 show ipv6 pim neighbors
 show ipv6 pim interface
 show ipv6 pim tunnel
 show ipv6 mld groups 

===RP===
Med IPv6 kan RP lösas på tre olika sätt. Det finns ingen Auto-RP eller MSDP för IPv6.

'''Static'''
 ipv6 pim rp-address 2001:20::20
 
 show ipv6 pim range-list

'''BSR''' &lt;br/&gt;
BSR fungerar på samma sätt för IPv4 men nu konfigureras det med en adress istället för interface samt att source registration process skiljer litegrann. Så fort en multicast-router lär sig RP-adressen skapar den en tunnel dit som kör multicast så när det kommer inte en mc-ström så skickas den genom tunneln till RP. Tunneln används endast under registration process, sedan slår sista-hop-routern över till SPT. Man kan också konfigurera BSR med en lista på RP-kandidater genom att använda ''ipv6 pim bsr announced rp &lt;IPv6 Address&gt;'' och därmed behöver inte RPs annonsera sig själva som candidates.

 ipv6 pim bsr candidate bsr 2001:20::20
RP
 ipv6 pim bsr candidate rp 2001:20::20
Verify
 show ipv6 pim bsr election

'''Embedded RP''' &lt;br/&gt;
Med IPv6 kan också övriga routrar ta reda på vem som är RP utifrån en adress som kan bakas in i grupp-adressen (RFC 3956). Ser en router denna adress kan de räkna ut vad RP har för adress ([http://www.interlab.ait.asia/tein3/ipv6mcast/asm.php RP Calculator]) och direkt börja forwarda i det delade trädet. Endast RP behöver konfigureras och övriga kan lära sig det dynamiskt. Fungerar endast med grupper i Embedded RP address range: FF70::/12.

På default: 
 ipv6 pim rp embedded
 
 interface Tunnel0
  description Pim Register Tunnel (Encap) for Embedded RP
  no ip address
  ipv6 unnumbered Loopback0
  ipv6 enable
  tunnel source Loopback0
  tunnel destination ::
  tunnel ttl 65

RP (loopback-adressen måste annonseras i IGP så alla kan hitta dit)
 interface Loopback1
  ipv6 address 2006:6666::5/128
 
 ipv6 pim rp-address 2006:6666::5

Receivers
 ipv6 mld join-group FF7E:540:2006:6666::1

Verify
 show ipv6 mroute
 show ipv6 pim group-map

'''Anycast RP''' &lt;br/&gt;
Man kan använda anycast för att öka tillgängligheten på RP. Att distribuera RP-infon görs med någon ovan nämnd metod, detta är endast för att hålla mroute-tabellerna synkade mellan alla RPs. Loopback-adressen måste annonseras i IGP så alla kan hitta dit.

RP1
 ipv6 pim anycast-rp 2001:20::20 10::2
 interface Loopback1
  ipv6 add 10::1/128
  ipv6 add 2001:20::20/128
RP2
 ipv6 pim anycast-rp 2001:20::20 10::1
 interface Loopback1
  ipv6 add 10::2/128
  ipv6 add 2001:20::20/128
Verify
 show ipv6 pim anycast-rp

===SSM===
IPv6 SSM fungerar ungefär som embedded RP multicast fast det inte finns något embedded RP prefix eftersom MLD tillhandahåller den informationen. SSM mapping kan användas för hostar som inte stödjer MLDv2, då kan man antingen använda DNS eller static maps för att kolla upp källan i MLDv1 report.
 interface gi3
  ipv6 mld join-group FF36:10::10 2001:20::20

=NX-OS=
Här följer [[Cisco_Nexus|Nexus]]-specifik information. Beroende på skillnader i hårdvara mellan de olika Nexusplattformarna finns det stöd för olika multicast capabilities, referera alltid till Ciscos dokumentation. Några grundläggande skillnader mot IOS är att det saknas stöd för IGMP version 1 och Version 3 Lite, PIM version 1 och dense mode operation. PIM har även SSM group range 232.0.0.0/8 by default (även i VRF:er). Se även [[Cisco_IGMP#NX-OS|IGMP]] för NX-OS. 

===Konfiguration===
 feature pim
 
 ip pim log-neighbor-changes
 ip pim rp-address 172.16.1.10 group-list 224.0.0.0/4
 ip pim bfd
 
 interface Ethernet1/1
  ip address 192.168.1.1/24
  ip pim sparse-mode

'''VRF'''
 vrf context Tenant1
  ip pim rp-address 172.16.1.10 group-list 224.0.0.0/4

'''Auto-RP'''
 ip pim auto-rp rp-candidate loopback1 group-list 224.0.0.0/4
 ip pim auto-rp mapping-agent loopback1
 ip pim auto-rp forward listen

'''BSR'''
 ip pim bsr bsr-candidate loopback1
 ip pim bsr rp-candidate loopback1 group-list 224.0.0.0/4
 ip pim bsr forward listen

'''Neighbor Authentication'''
 interface Ethernet1/1
  ip pim sparse-mode
  ip pim hello-authentication ah-md5 3 a667d47acc18ea6b

'''Anycast RP''' &lt;br/&gt;
Anycast-RP (RFC 4610) innebär att man assignar en grupp routrar till en RP-adress som finns konfad på flera routrar. PIM messages skickas till den router som routingtabellen tycker är närmast. Detta ger lastdelning och redundans. Denna feature finns inte på IOS. 
 interface loopback10
  description Anycast-RP-Address
  ip address 172.16.1.10/32
  ip pim sparse-mode
 
 ip pim rp-address 172.16.1.10
 ip pim anycast-rp 172.16.1.10 192.168.10.1
 ip pim anycast-rp 172.16.1.10 192.168.10.2

'''Verify'''
 show running-configuration pim
 show ip mroute
 show ip pim interface
 show ip pim group-range
 show ip route rpf
 show ip static-route multicast

Maintenance mode &lt;br/&gt; 
Man kan isolera routern (ur ett PIM-perspektiv) genom att skicka ut PIM Hello message med holdtime 0 (goodbye) till alla grannar, då rivs alla PIM-grannskap direkt.
 ip pim isolate

=IOS-XR=
IOS-XR har SSM group range 232.0.0.0/8 by default.

'''Konfiguration'''
 multicast-routing
  address-family ipv4
   interface HundredGigE0/0/0/0
    enable
   !
  !
 !
 router pim
  address-family ipv4
   rp-address 10.0.0.10
   log neighbor changes

Verify
 show pim group-map 
 show mfib route
 show pim rpf 192.168.0.10
 show pim rpf hash

[[Category:Cisco]]</text>
      <sha1>2sl7h8z58dmn291hi5ik01u23vy9i8s</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco PfR</title>
    <ns>0</ns>
    <id>263</id>
    <revision>
      <id>2210</id>
      <parentid>2003</parentid>
      <timestamp>2017-01-04T13:17:19Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3858">Performance Routing (PfR) är "Application Path Optimization". Det är en vidareutveckling av Optimized Edge Routing (OER) som gav prefix-based route optimization. PfR och OER använder sig av packet loss, response time, path availability och traffic load distribution för att fatta beslut. Det PfR också tar hänsyn till är application type och application performance requirements. PfR kan klassificera trafik utifrån IP-adresser, protokoll, portnummer, DSCP och i nyare versioner av IOS även [[Cisco_QoS#NBAR|NBAR]]. Man behöver en Master Controller (som fattar besluten) och en eller flera Border Routers. Authentication är inbyggt för all kommunikation till och från MC och man måste använda sig av key-chains (t.o.m. om MC och BR finns på samma router). Kommunikation mellan MC och BR görs med TCP och performance metrics samlas med [[Cisco_NetFlow|NetFlow]] and [[Cisco_Routing#IP_SLA|IP SLA]] probes som konfigureras automatiskt. PfR route-maps sätts på Internal Interface och för att dynamiska route-maps ska fungera krävs L3-konnektivitet mellan BRs annars möts inte PfR's PBR requirement och dynamiska route-maps fungerar ej. Om Master Controller går ner så märker Border Routers att deras kommunikation till MC inte längre är aktiv. Det som händer då är att de kollar vilka routes som är från PfR och tar bort dessa och allt återgår till normal routing. Nätverket blir som det var innan PfR slogs på. PfR är inte VRF-aware.

==Terminologi==
'''Master Controller:''' monitorerar utgående trafikflöden för att kunna optimera routingen med hjälp av policy. En MC kan ha hand om 10 border routers eller 20 external interfaces. Den behöver inte finnas i data plane forwarding path. 

'''Border Router:''' har ett eller flera external interfaces. Dessa rapporterar in prefix- och transit link measurements till MC som sedan fattar policy beslut. MC berättar sedan för BR vad den ska göra. 

'''Internal interfaces:''' är interface mot resten av nätet och används för att kommunicera med control plane manager för PfR. MC dikterar vad som är internal interfaces.

'''External interfaces:''' används för att skicka paket till det lokala nätverket. Det är dessa som performance mäts på. MC dikterar vad som är external interfaces.

'''Local interfaces:''' finns på routern och är source för kommunikationen med Master Controller.

==Operational Phases==
PfR delas in i olika faser som fyller olika syften. 

* '''Profile Phase:''' Lära sig vilka flows som har hög latency och throughput. MTC list innehåller alla Monitored Traffic Classes.

* '''Measure Phase:''' Samla in och räkna på performance metrics för all trafik på MTC list.

* '''Apply Policy Phase:''' Skapa low och high thresholds för att veta vad som är in-policy och vad som är out-of-policy.

* '''Control Phase:''' Påverka trafik genom att manipulera routes eller använda PBR.

* '''Verify Phase:''' Kontrollera ifall något är out-of-policy för att isåfall rätta till det.

==Konfiguration==
Key chain måste skapas på alla enheter.
 key chain PFR
  key 1
   key-string SECRET
 
 show key chain

'''MC''' &lt;br/&gt;
Det krävs minst 2 external interfaces (totalt) för att MC ska bli aktiv.
 pfr master
  border 2.2.2.2 key-chain PFR
   interface gi2 internal
   interface gi3 external
  border 3.3.3.3 key-chain PFR
   interface gi2 internal
   interface gi3 external

Defaults
 pfr master
  learn
   throughput
   periodic-interval 0
   monitor-period 1
 
  border 2.2.2.2 key-chain PFR
   interface GigabitEthernet3 external
    max-xmit-utilization percentage 90
    maximum utilization receive percentage 100

Verify
 show pfr master border
 show pfr master exits

'''Border'''
 pfr border
  master 1.1.1.1 key-chain PFR
  local loopback 0
  logging
Verify
 show pfr border
 show ip sla summary

[[Category:Cisco]]</text>
      <sha1>j3puq7gem6c098yqh9nl75lybysbaoi</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco QoS</title>
    <ns>0</ns>
    <id>277</id>
    <revision>
      <id>3082</id>
      <parentid>2980</parentid>
      <timestamp>2020-01-03T10:30:00Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="24146">Quality of Service är användbart om en länk eller interface går fullt och viss trafik är viktigare än annan. Man kan klassificera och markera paket som man vill att intermediate systems ska prioritera och skicka iväg i första hand. IP/ATM/Frame Relay-headers har fält som kan användas för detta, t.ex. IP DSCP (RFC 3260). QoS är endast aktivt när det är överbelastat. QoS går att ha time based genom att matcha mot time based ACLer. Se även [[Cisco_RSVP|Cisco RSVP]].

'''QoS Features'''
* Classification: Kolla packet headers och bestämma kö
* Drop policy: Regler för vad som ska droppas när det går fullt
* Scheduling: Logiken som bestämmer vad som ska skickas härnäst
* Number of queues: Unika klasser av paket för queueing tools
* Queue length: Maximala antalet paket i en enskild kö

==MQC==
Modular QoS CLI togs fram för att skapa en homogen syntax för QoS på [[Cisco_IOS|IOS]]-enheter. Det förenar QoS features under ett gränsnitt och man kan konfigurera allt som har med classification, congestion management, traffic metering, marking och traffic shaping att göra. Man kan även använda en route-map för att sätta markeringar på paket men det är inte det rekommenderade sättet.

* Class Map – Definiera typer av trafik
* Policy Map – Definiera vad som ska göras med trafiken, t.ex. sätta QoS-markering eller shapea.
* Service Policy – Definiera interface och riktning 

Class, man kan bl.a. matcha på ACLer/MAC-adresser/QoS-markeringar/protokoll. Det går att välja mellan AND-logik (''match-all'') eller OR-logik (''match-any'') om man behöver flera match-statements. Det går även att använda nested class-maps för mer avancerad logik.
 class-map CLASS-MAP
  match access-group name &lt;ACL&gt;
  match cos &lt;cos&gt;
  match mpls experimental
  match not destination-address mac
 
 show class-map

Policy
 policy-map POLICY-MAP
  class CLASS-MAP
   set ip dscp &lt;0-63&gt;
 
 show policy-map interface

Interface
 interface Gi0/0
  service-policy input POLICY-MAP
 
 show policy-map interface brief
 show run | i interface|service-policy
Om service-policy rejectas kan det bero på avsaknad av [[Cisco_CEF|CEF]] på enheten.

==Packet Marking==
[[File:Cisco_QoS_Markings.png]]

På vissa plattformar när man kör med L2 etherchannel måste man slå på att qos ska titta på vlan-taggade paket. 
 interface Port-channel4
  platform qos vlan-based

'''Non-IP Marking''' &lt;br/&gt;
Alla enheter kanske inte har möjligheten att kolla på L3-headern, t.ex. en LSR ([[Cisco_MPLS|MPLS]]) ser endast labels. Det man kan göra är att låta ingress LSR föra över QoS-klassificeringen till MPLS-headern som har ett 3-bitars fält för detta (EXP).

===NBAR===
Vill man matcha på ett visst protokoll i sin class-map kan man använda Network Based Application Recognition som finns inbyggt i IOS. Det finns väldigt många fördefinierade protokoll. NBAR är i passive och active mode beroende på hur det används.
 class-map NBAR
  match protocol ?

NBAR på [[Cisco_CSR|CSR 1000V]] matchar inte ICMP echo packets under icmp utan har eget kommando.
 class-map match-any ICMP
  match protocol icmp
  match protocol ping

Man kan också använda NBAR för att samla trafikdata om paketen som går över ett interface.
 interface gi2
  ip nbar protocol-discovery
 
 show ip nbar protocol-discovery

Behöver man lägga in ett nytt protokoll får man ladda ner en PDLM-fil från Cisco och ladda upp till IOS-enheten och aktivera.
 ip nbar pdlm ''name''

==Congestion Management==
Köer som skapas på interface av queueing tools kallas software queues och håller det paket som inte kan skickas iväg på en gång. När sedan paketen kan skickas iväg flyttas de till en liten FIFO queue i hardware, denna kallas Tx ring (a special buffer control structure). När ett paket har lämnat Tx ring kan nästa encodas och skickas iväg utan software interupt till CPU, detta möjliggör full användning av interfacets bandbredd. Denna kö använder alltid FIFO-logik och kan inte påverkas av IOS queuing tools. Det är när tx ring går full som ett interface är överbelastat. Det som händer när man använder queuing tools är att hardware queue minskas lite för att ge mjukvaran mer utrymme att spela med eftersom mer trafik då hamnar i software queue. 
 show controllers

tx_ring är hardware queue, hold queue är software queue
 interface gi2
   tx-ring-limit
   hold-queue 375 in
   hold-queue 40 out

'''Catalyst 3850''' &lt;br/&gt;
Soft Buffers är assignade till en kö men kan delas med andra köer och interface om de inte används. Det totala antalet tillgängliga buffrar default är mindre än vad hårdvaran klarar av men detta kan ökas globalt i switchen. 
 qos queue-softmax-multiplier 1200
 qos queue-stats-frame-count
Även "hold-queue out" är lite snålt ställt default på 3850.

===Selective Packet Discard===
SPD används när input queue är full och det innebär att mer minne tillåts ifall det är control plane packets som ska till CPU. Input queue kommer börja tömmas för ge utrymme ifall det kommer in ytterliggare control plane packets. SPD är på default både för IPv4 och IPv6.

 show ip spd

===CBWFQ===
Tanken med Class-Based Weighted Fair Queueing är att använda samma scheduling logic som WFQ fast med konfigurerbara klasser som har extra låg weight vilket gör dem mer viktiga än den dynamiska omvandlingen. Det fungerar som WFQ fast man har mer flexibel flow classification med MQC syntax. Det är skapat från legacy-metoderna PQ och CQ. CBWFQ reserverar bandbredd för varje kö för att sedan använda WFQ för paket i default-kön. Default-kön finns alltid och behöver inte konfigureras, där hamnar paket som inte matchar någon class-map. Finns det tomma köer kan den bandbredden användas av andra klasser sålänge det inte går fullt. Summan av alla bandbreddsreservationer kan inte överstiga 75% av interfacets bandbredd pga max-reserved-bandwidth defaults. Det går ej att kombinera bandwidth och bandwidth percent kommandona i samma policy-map.

 class-map match-all R2
  match access-group name R2
 
 policy-map CBWFQ
  class R2
   bandwidth percent 5
  class class-default
 
 interface Gi 0/1
  bandwidth 1000
  service-policy output CBWFQ

Verify
 show policy-map interface

===LLQ===
Low Latency Queueing fungerar som CBWFQ men utökar det med priority queues även kallat low-latency queues. Det som behandlas först är paket i prio-köerna. LLQ förhindrar även starvation av övriga köer eftersom den prioriterade köns bandbredd förutom garanterad minimum också är policed max-bandbredd (vid congestion). Har man flera klasser som är prioriterade är det FIFO som gäller eftersom det endast finns en intern prio-kö. Fördelen med detta är att man kan styra så att man kan ha flera prioriterade klasser men ingen kan ta upp all bandbredd. Endast paket inom den konfigurerade bandbredden/procenten kommer att prioriteras men i övrigt får flödena använda all bandbredd, dvs LLQ används endast när hardware queues går fulla. Notera att LLQ policern tar hänsyn till L2 framesens längd.

 class-map http
  match protocol http
 class-map voice
  match protocol rtp
 
 policy-map VOICE_PRIO
  class http
   bandwidth percent 20
  class voice
   priority percent 50

Verify
 show policy-map interface

[[File:Cisco_QoS_Queues.png]]

===Ethernet Subinterface===
Subinterfaces har inget eget sätt att veta om det är fulla köer på huvudinterfacet därför tillåter inte Cisco IOS att policy-maps med queuing policies appliceras direkt på subinterfacen. Det man kan göra är att ha en policy på huvudinterfacet och matcha på vlan-taggningen för att kunna använda queuing policies på subinterfacen.

 class-map match-any Server
  match vlan 10
 class-map match-any DMZ
  match vlan 20
 
 policy-map Vlans
  class Server
   bandwidth percent 20
  class DMZ
   police cir 10000000 bc 1875000
 
 interface GigabitEthernet1
  no ip address
  service-policy output Vlans

==Congestion Avoidance==
När en kö är full har inte routern plats för paket utan de droppas vilket påverkar nätverksprestandan. TCP skickar så mycket som möjligt tills paket droppas och/eller delay (RTT) ökar och då sänks sending rate lite. När transmit buffer (egress) fylls helt blir det tail drops. Detta får påverkan på annan trafik som också blir droppad. Global synkronisering uppstår när flera TCP-hostar minskar sina överföringshastigheter som svar på packet drops för att sedan öka sin överföringshastigheter igen när trängseln minskar. För att förhindra trafikspikar som leder till att många paket droppas hjälper det att droppa några paket när en kö börjar bli full för att göra så att TCP-hostar sänker sending rate tidigare. Detta ökar overall throughput. Cisco har utvecklat Weighted Random Early Detection som håller koll på köerna och undviker global synchronization. För att avgöra när paket ska börja droppas används average queue depth som mäts mot minimum och maximum queue threshold och agerar sedan utifrån det. Ligger average queue depth under minimum droppas ingenting, ligger det mellan minimum och maximum droppas en stigande procent av paketen på random och ligger det över maximum droppas alla nya paket. Eftersom WRED tittar på köer måste det konfigureras ihop med en kö och alla kömekanismer har inte stöd för WRED. 

Fysiskt interface (allt blir en FIFO på interfacet)
 interface gi0/0
  random-detect
 
 show queueing random-detect

För att slå på WRED i class-default kan man antingen konfigurera en bandbreddsreservation för att göra om klassens kö till FIFO och sedan slå RED eller slå på RED med WFQ. Då aktiveras RED dropping istället för Congestive Discard Threshold-based drops.

===ECN===
TCP Explicit Congestion Notification är ett slags tillägg till WRED som kan användas för att signalera att trafikflödena ska sakta ner istället för att det faktiskt börjar droppas paket. Nätverket signalerar till TCP flow receiver att man är nära att börja droppa paket som då kan reagera på detta, t.ex. signalera till sender att sänka sending rate. Detta leder till bättre TCP-prestanda overall jämfört med drops som leder till TCP slow start och att paket måste skickas om. TCP ECN fungerar tillsammans med RED genom att byta exceed action från random drops till ECN marking. Denna marking använder de två least-significant bitarna av TOS-byten i IP-headern, se bilden ovan.
 random-detect ecn 

IOS använder inte ECN default, global inställning.
 ip tcp ecn

=Traffic Shaping=
Det finns två sätt att begränsa mängden trafik som lämnar ett interface, policing och shaping. Traffic shaping förhindrar bit raten på de paket som lämnar ett interface från att överstiga konfigurerat värde. Shaping monitors håller koll på det som skickas och om det överskrider gränsvärde så hålls paketen kvar i en shaping queue och släpps iväg över tiden för att på så sätt ge en viss rate. Därför är shaping alltid outbound och det har potentialen att utnyttja bandbredden mer effektivt än policing för att det blir ett jämnare flöde på TCP-strömmarna. Routrar skickar bits enligt den fysiska kapaciteten/frekvensen på sina interface, för att kunna ha en lägre bandbredd måste routern medvetet växla mellan att skicka och att vara tyst. Ett sådant tidsinterval kallas Tc och mäts i millisekunder. Under Tc får det endast skickas en viss mängd bitar, denna mängd kallas commited burst (Bc). Har man varit tyst ett tag kan man bursta lite extra, denna bitmängd kallas Be (excess burst). I äldre IOS-versioner användas Generic Traffic Shaping (GTS), det är grundläggande och man kan styra vad som ska shapeas med ACL. Det rekommenderade sättet är dock att använda class-based shaping som finns i IOS 15. Då skapar man class-maps och policy-maps med MQC vilket ger mer granulär kontroll över shaping. 

 policy-map SHAPE
  class CLASS
   shape average 500000  #BW
 
 interface Gi2
  service-policy output SHAPE
Man kan välja att shapea '''average''', '''adaptive''' eller '''peak'''. 

Verify
 show policy-map interface
 show traffic-shape  ''#Legacy''
 show traffic-shape queue

==Policing==
Class-Based Policing är en funktion som håller koll på bit raten på interface och om konfigurerat värde överskrids kan policing agera, t.ex. sätta en viss DSCP/Precedence-markering eller droppa paketen. Det fungerar både ingress och egress på interface och subinterface. Man kan konfigurera en enskild bit rate och paket kommer att kategoriseras som conforming eller exceeding, detta kallas Single-Rate Two-Color Policing. Vill man ha lite utrymme för burst får man sätta upp Single-Rate Three-Color Policing och då finns det även en violate-kategori som konfigureras som paket kan hamna i. Detta tillåter tillfälliga bursts och trafikmängden måste gå ner för att det ska kunna burstas igen. Vill man tillåta lite längre perioder med burst kan man använda Two-Rate Three-Color Policing, då konfigurerar man även en Peak Information Rate (PIR). Man kan även ta flera aktioner med paketen, t.ex. sätta flera olika markeringar, detta kallas multi-action policing. 

 ip access-list extended ACL-HTTP
  permit tcp any any eq http
 
 class-map HTTP
  match ip access-list ACL-HTTP
 
 policy-map POLICE
  class HTTP
   police 64000 12000 24000 conform-action transmit exceed-action drop 
  class class-default
   police cir percent 25 bc 500 ms be 500 ms conform-action transmit exceed-action drop
 
 int Gi1
  service-policy input POLICE

Verify
 show policy-map interface

'''Single-Rate Three-Color'''
 policy-map POLICE
  class HTTP
    police cir 64000
     conform-action set-prec-transmit 1
     exceed-action set-prec-transmit 0
     violate-action drop

'''Two-Rate Three-Color''' &lt;br/&gt;
Detta är hierarkisk policing med three color.
 policy-map POLICE
  class HTTP
   police cir 64000
    service-policy SUBRATE_POLICER
 
 policy-map SUBRATE_POLICER
  class SITE1
   police cir 32000 
    conform-action set-prec-transmit 1
    exceed-action set-prec-transmit 0
    violate-action drop
  class SITE2
   police cir 32000 
    conform-action set-prec-transmit 1
    exceed-action set-prec-transmit 0
    violate-action drop

'''CAR''' &lt;br/&gt;
Committed Access Rate är ett äldre alternativ till CB-Policing som inte använder MQC-syntax. Det tillåter burst men endast Single-Rate Two-Color. 

=Layer 2 QoS=
L2 QoS kan skilja sig mycket mellan switchmodeller eftersom hur QoS fungerar beror på switch-arkitekturen och hårdvaran. QoS baseras på intern DSCP som tas ut baserat på den trust configuration som finns. Trust betyder vilka fält som kollas för att få fram internal DSCP för varje paket. Default är L2 QoS inte påslaget men om man enablear det globalt så kommer internal DSCP tas från interfacets default CoS som är 0 och därmed ta bort eventuell marking. Väljer man att lita på CoS så kollas L2-headern i ISL eller det 802.1Q-taggade paketet. Litar man på DSCP eller IP precedence tas QoS-nivån ifrån L3 headern. Att lita på CoS är endast giltigt på trunk-länkar och DSCP/precedence fungerar endast på IP-paket.

[[File:Cisco_QoS_L2.png]]

Global
 mls qos
 mls qos monitor packets
 ip precedence to dscp mapping
 no mls qos rewrite ip dscp

'''Verify'''
 show mls qos interface g0/3 statistics

Switch Database Management, används för att dela upp TCAM.
 show sdm prefer

===Catalyst 3560===
En Catalyst 3560 switch har köer både för input och output. Det finns två köer för input och scheduler använder Shared Round-Robin (SRR) för att skicka paketen till internal switch fabric. För att bestämma discard thresholds för varje kö används Weighted Tail Drop (WTD) när QoS slås på. Weight för respektive kö är konfigurerbart med relativa värden, dvs ratio. Default när man slår på QoS hamnar paket med COS 5 i kö 2 och övrig trafik i kö 1. Kö 2 har även 10% bandbredd reserverat. När man ska prioritera trafik konfigurerar man den ena kön för det. Ingress QoS konfigureras globalt så det gäller alla interface.
 mls qos srr-queue input priority-queue 2 bandwidth 30
Kö 2 kommer att få 30% av bandbredden och resterande delas mellan köerna. 
 show mls qos input-queue
Man kan dela på resterande bandbredd med en ratio, default är 4:4.
 srr-queue input bandwidth 4 4
Man kan mappa annan trafik till kö 2, t.ex. COS 6.
 mls qos srr-queue input cos-map queue 2 6
Verify
 show mls qos maps cos-input-q

'''Egress''' &lt;br/&gt;
Cisco 3560 har fyra köer för egress per interface och man kan mappa COS/DCSP, använda weight och sätta drop thresholds per kö. SRR används för att undvika queue starvation om man har en prio-kö. Egress QoS konfigureras per interface med undantag buffers och WTD som görs globalt. Det finns Sharing och Shaping, båda fungerar lika bra när det finns paket i alla köer och servar eventuell prio-kö direkt när Tx är ledigt. Men Shaping sätter rate-limit på köerna så att de inte överstiger tilldelad bandbredd.

Per interface, ratio mellan fyra köer
 interface Gi2
  queue-set 1
  srr-queue bandwidth share &lt;1&gt; &lt;2&gt; &lt;3&gt; &lt;4&gt;
  srr-queue bandwidth shape &lt;1&gt; &lt;2&gt; &lt;3&gt; &lt;4&gt;
  priority-queue out

Buffer och WTD
 mls qos queue-set output 1 buffers &lt;1&gt; &lt;2&gt; &lt;3&gt; &lt;4&gt;
 mls qos queue-set output 1 threshold 2 &lt;1&gt; &lt;2&gt; &lt;3&gt; &lt;4&gt;

Verify
 show mls qos interface Gi2 queueing

=MPLS=
När man gör label imposition är default beteende att kopiera IP Precedence till MPLS EXP på alla labels som impose:as. Se även [[Cisco_MPLS|Cisco MPLS]].

===Pipe mode===
I detta mode rör inte SP kundens paketmärkningar utan policy genom nätverket baseras enbart på SP-märkning. Policy enforceas på ingress PE som sätter EXP. Även policy på edge mot kund baseras på EXP-bitar men kunds märkningar är intakta. Kunden får veta hur paket ska märkas för att hamna i de olika klasser/köer som SP erbjuder. 

Ingress PE
 class-map match-all PREC6
  match ip precedence 6
 !
 policy-map from-ce
  class PREC6
   set mpls experimental imposition 3
 !
 int gi2
  service-policy input from-ce

Egress PE
 mpls ldp explicit-null
 !
 class-map match-all EXP3
  match mpls experimental topmost 3 
 !
 policy-map from-core
  class EXP3
   set qos-group 3
 !
 int gi1
  service-policy input from-core
 !
 class-map match-all GROUP3
  match qos-group 3
 !
 policy-map to-ce
  class GROUP3
   bandwidth percent 15
 !
 int gi2
  service-policy output to-ce

===Short Pipe mode===
Short pipe mode funkar på samma sätt som pipe mode men SP kommer att konfigurera egress policy utifrån kundens paketmärkningar, dvs DSCP i IP-headern. Eftersom top label EXP marking till egress PE inte behövs kan man köra med default implicit null, PHP. 

Ingress PE
 class-map match-all PREC6
  match ip precedence 6
 !
 policy-map from-ce
  class PREC6
   set mpls experimental imposition 3
 !
 int gi2
  service-policy input from-ce

Egress PE
 class-map match-all PREC6
  match ip precedence 6 
 !
 policy-map to-ce
  class PREC6
   bandwidth percent 5 
 !
 int gi2
  service-policy output to-ce

===Uniform mode===
I detta mode kommer egress PE att kopiera ner EXP till IP-headern innan paketen skickas till CE, dvs corets MPLS-märkning reflekters till IP-paketen. Det betyder att man har en uniform end-to-end qos-policy. Det vanliga är att kund märker paket ingress och om det ändras nånstans längs MPLS-vägen så kommer även IP-paketen på andra sidan ha dessa nya märkningar. Detta mode används oftast när man själv äger MPLS-nätet. 

Egress PE  
 mpls ldp explicit-null
 !
 class-map match-all EXP3
  match mpls experimental topmost 3 
 !
 policy-map from-core
  class EXP3
   set qos-group 3
 !
 int gi1
  service-policy input from-core
 !
 class-map match-all GROUP3
  match qos-group 3
 !
 policy-map to-ce
  class GROUP3
   set ip precedence 3
 !
 int gi2
  service-policy output to-ce
Ingress PE gör inget speciellt.

=AutoQoS=
AutoQoS är ett macro man kan använda för att smidigt slå på fördefinierad QoS-konfiguration utifrån Ciscos rekommendationer. Man kan använda det för VoIP och Enterprise. VoIP är gjort för video och voice och finns både på routrar och switchar. Man slår på det per interface men det genererar konfiguration både på interface och globalt. På accessportar används [[Cisco_IOS#CDP|CDP]] för att kolla om det finns telefoner och ställer då in QoS, finns ingen telefon blir det DSCP 0. På trunkar litas det på DSCP och COS värden som kommer in. Ingress och egress köer konfigureras på interfacen samt class-maps och policy-maps enableas. Känd trafik som voice, video, real-time, routingprotokoll och BPDUer prioriteras av AutoQoS voip.

'''VoIP'''
 interface Gi0/0
  auto qos voip
Uplink
  auto qos voip trust
Verify
 show auto qos interface
 show mls qos

'''Enterprise''' &lt;br/&gt;
Gäller VoIP plus andra applikationer och kräver att interface bandwidth är konfigurerat samt att CEF är på. NBAR används för trafikigenkänning.
 interface Gi0/0
  auto discovery qos
Discovery bör stå på ett tag så att NBAR hinner samla in information om paketen som går över interfacet. Sedan slår man på QoS och då skapas lämpliga class-maps och policy-maps.
  auto qos
Verify
 show auto discovery qos
 show auto qos

=NX-OS=
NX-OS använder MQC men har ett lite annorlunda QoS-upplägg jämfört med IOS. NX-OS slår alltid på en system-defined default queuing policy på varje port och port-channel. QoS-statistik är också på default. 

NX-OS har tre typer av QoS. 
* '''network qos''' - Defines the characteristics of QoS properties network wide.
* '''qos''' - Defines MQC objects that you can use for marking and policing.
* '''queuing''' - Defines MQC objects that you can use for queuing and scheduling.

Verify
 show policy-map
 show policy-map vlan
 show policy-map interface e1/15 type queuing 
 show policy-map interface e1/15 type qos 
Notera att "type queuing" visar L2 MTU och "type qos" visar L3 MTU.

'''Shared Policer''' &lt;br/&gt;
Med en shared policer kan man ha en policy som gäller för flera interface samtidigt. 
 qos shared-policer type qos POLICE cir 4 gbps conform transmit exceed drop
 
 policy-map type qos PMAP
  class type qos class-default
   police aggregate POLICE

 show qos shared-policer POLICE

'''Network QoS''' &lt;br/&gt;
Med en network qos policy kan man konfa pause behavior, congestion control mechanisms, MTU. Man kan även välja vilket protokoll som gäller för ett visst CoS-värde, t.ex. FCoE, iSCSI eller TCP. Det används sedan i DCB Exchanges. Default för drop CoS så används tail drop. Att välja en template med no-drop CoS betyder inte att det automatiskt blir no-drop beteende utan det funkar bara för de CoS-värdena på portar där PFC är påslaget och successfully negotiated. Att byta network qos policy är disruptive. Kör man med VDC:er så går det endast använda den i default-VDC:n. 

 system qos
  service-policy type network-qos my_template
 
 show policy-map type network-qos
 show policy-map system type network-qos

'''Default CoS''' &lt;br/&gt;
Man kan ange att frames med CoS 0 ska få en viss CoS-märkning när de kommer in på ett interface.
 interface e1/1
  untagged cos 4

'''Mutation mapping''' &lt;br/&gt;
Mutation mapping är ett sätt att ändra ett QoS-fält i alla paket på ett interface. Notera att på ingress så händer det före traffic classification och alla andra actions. Medans på egress så händer det efter traffic classification men före andra actions. Man kan applicera det på CoS, DSCP och IP precedence fält. 

 table-map mutate_dscp
  default copy
  from 0 to 0
  from 1 to 1
  from 2 to 1
  from 63 to 46
 
 policy-map type qos parent_policy
  class class-default
   set dscp dscp table mutate_dscp
   service-policy type qos child_qos_policy

'''Session Manager''' &lt;br/&gt;
Vill man dubbelkolla att QoS-konfen är giltig och att det finns tillräckligt med resurser innan man lägger det i running kan man dra nytta av session manager. 

 configure session myQoS
  ...
  &lt;qos konfig&gt;
  ...
 
 verify
 commit / abort

[[Category:Cisco]]</text>
      <sha1>lgxrwuw70797qc4hazvni6zv15499jk</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco RIP</title>
    <ns>0</ns>
    <id>234</id>
    <revision>
      <id>2625</id>
      <parentid>2238</parentid>
      <timestamp>2017-09-07T13:38:02Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="16388">Routing Information Protocol är ett distance vector routing protocol som använder hop count som metric, det är designat för små nätverk. I denna artikel används RIP synonymt med RIPv2 (RFC 2453), RIPv1 skickar inte med subnet mask i uppdateringarna och har därmed inte stöd för VLSM så det är väldigt legacy. Varje router kan annonsera sina directly connected networks plus det som de lär sig från andra RIP-routrar. Som med övriga distance vector routing protocols på IOS annonseras endast nätverk som hamnar i routingtabellen vidare, dvs annonsera endast det som routern själv använder. Man skickar kända nätverk med deras metric med multicast så alla som lyssnar på 224.0.0.9 får uppdateringar. Med tanke på att man inte känner till hela topologin utan endast nätverk och riktning är det större risk för loopar än med t.ex. link-state routing protokoll. En stor nackdel med RIP är konvergenstiden.

'''Type:''' Distance Vector

'''Algorithm:''' Bellman-Ford

'''AD:''' 120

'''Protocols:''' IP

'''Packets:''' 2

==Packets==
RIP-routrar byter information med varandra genom att skicka uppdateringar på alla RIP-enableade interface baserat på update timer (30 sec default). Man skickar all information man har varje gång, max 25 route entries får plats per enskilt paket. Det skickas inga Hellos och inga grannskap upprättas utan uppdateringar skickas till 01:00:5E:00:00:09 224.0.0.9 UDP port 520 var 30 sekund. RIP har två meddelandetyper, Requests och Responses. Requests används för att be en granne skicka en partial eller full update direkt utan att vänta på Update timer. Skickar en router en request som innehåller en rad med address family ID 0 och metric 16 vill den ha en full update. Annars ska grannen svara med uppdateringar för de nät som står speccade i Requesten, dvs partial update, dock är inte partial requests implementerat på IOS. Full update frågas efter när en Ciscorouter bootar upp, ett RIP-interface kommer upp eller ''clear ip route *'' körs. [[Cisco_CSR|CSR]]:er verkar inte använda sig av Requests överhuvudtaget.

&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
Response packet:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_RIP_Update.PNG]]
&lt;/div&gt;
&lt;/div&gt;

===Metric===
För metric används hop count och upp till 15 är användbart, 16 anses som infinity. Som med alla distance vector protokoll används den route med lägst metric, dvs bästa vägen, och övriga vägar påverkar inte routingtabellen. Enda undantaget till denna regel är om next-hop skickar en högre metric än tidigare då accepteras den direkt, t.ex. vid route poisoning. Enda sättet att få påverkningsmöjlighet är att annonsera lägst metric. Om en route failar kan man skicka ut en triggered update om denna routen med en metric satt till infinity då propagerar uppdateringen till alla routrar och de slutar använda den failade routen, detta kallas route poisoning. Däremot sparas routen i den interna RIP-databasen men markeras som possibly down. En skillnad med RIP kontra [[Cisco_EIGRP|EIGRP]] och RIPng är att metric läggs på när en route skickas iväg istället för när den kommer in. Finns det flera väger till en destination med samma metric installeras det default upp till 4 routes i routingtabellen. Detta går att ändra med '''maximum-paths'''-kommandot, max är 16. 

===Split Horizon===
För att förhindra loopar används flera tekniker. Split Horizon, istället för att skicka exakt alla routes till en granne X tas routes med next-hop granne X bort från uppdateringen. Detta är påslaget default på alla interface förutom fysiska Frame Relay och ATM. En ännu kraftfullare variant är att lägga till Poison Reverse, då skickas uppdateringarna med next-hop granne X till granne X men med en metric satt till infinity. Detta har inte Cisco RIPv2 stöd för. 

Om två routrar känner till samma nät kommer den som annonserade ut det först att vara den som gäller för övriga routrar oavsett hop count eftersom split horizon gör att routes man får in på ett interface aldrig annonseras ut på det interfacet. Så även om den "sena" routern har en bättre väg kan den inte berätta det för någon eftersom den har fått in en uppdatering om routen på de interface där det finns RIP-routrar. Secondary addresses kommer inte heller att annonseras om man inte stänger av split horizon. Det går att stänga av split horizon men det är inte rekommenderat. Det kan dock behövas stängas av på [[Cisco_DMVPN|DMVPN]]-hubb.
 no ip split-horizon

Om två routergrannar ser sig själva som next-hop för samma nätverk (kan hända om Split Horizon är avstängt) kommer de att turas om att uppdatera varandra med grannens metric plus 1 och den blir högre och högre för att tillslut nå infinity och den ena slutar. Med RIP kan detta ta lång tid. Detta kallas Counting to infinity och är en möjlig konsekvens av distance vector protokoll. 

'''Source Validation''' &lt;br/&gt;
RIP har en inbyggd kontrollmekanism som kollar på source-adressen på uppdateringarna som kommer in. Detta går att ändra så att man kan godta uppdateringar oavsett vilken IP de kommer ifrån. Följande RIP-kommando stänger av sanity checks against source address of routing updates. Unnumbered IP interfaces har inte denna check.
 no validate-update-source

'''Route tag''' &lt;br/&gt;
Med RIPv2 kom stöd för route tags, det är ett 2 byte integer value som man kan sätta på routes för att tagga dem. Route tagging stöds endast vid redistribution och används om man vill skilja på internal och external routes.

=Konfiguration=
RIP-processen startar inte utan ett network-kommando.
 router rip
  version 2
  no auto-summary
  distance 120
  network 10.0.0.0

Version per interface
 interface gi2
  ip rip send version 1
  ip rip receive version 1

Ett passivt interface skickar inte ut några uppdateringar men däremot tas fortfarande uppdateringar emot och behandlas.
  passive-interface default
  no passive-interface gi2

Verify
 show ip protocols
 show ip rip database

Clearing routing process
 clear ip route *

Debug
 debug ip ripv2
 debug ip ripv2 events

'''Unicast''' &lt;br/&gt;
RIP bygger inga grannskap men man kan använda unicast. Det skickas då dubbla uppdateringar, en till konfigurerad granne med unicast och en till multicast/broadcast som vanligt. Neighbor-kommandot används på vissa nätverkstyper, t.ex. multipoint Frame Relay subinterface. 
 neighbor 10.0.0.10

'''Broadcast''' &lt;br/&gt;
255.255.255.255
 interface gi2
  ip rip v2-broadcast
Subnet broadcast
 interface gi2
  ip broadcast-address 10.0.0.255

==Authentication==
En RIP-router vet om någon annan stödjer autentisering genom att kolla på AFI-fältet i uppdateringen, 0xFFFF betyder authentication. Det finns stöd för plain-text och MD5 och implementeras med hjälp av key-chain. Ett högre nyckelvärde godtar lägre nyckelvärde om key-string är samma men ej tvärtom. Använder man autentisering sänks antalet prefix som får plats i ett RIP-meddelande från 25 till 24. Key chain måste skapas innan det används för RIP authentication!

 key chain RIP-KEYS
  key 1
   key-string HACKER
 
 interface gi2
  ip rip authentication mode md5
  ip rip authentication key-chain RIP-KEYS
Verifiera vilka interface som använder vilken key chain
 show ip protocols | b rip

==Convergence== 
Optimization &amp; Scalability

Om det ska skickas fler routes än vad som får plats i ett Response packet kommer det att skickas flera paket direkt efter varandra. Detta kan överbelasta CPU på mindre routrar om det handlar om många paket. Man kan konfigurera ett tidsintervall mellan paketen för att ta hänsyn för detta. 
 output-delay &lt;milliseconds&gt;
Hur många obehandlade uppdateringar som tillåts.
 input-queue 150

'''Triggered Updates''' &lt;br/&gt;
RIP går att göra till ett event-drivet protokoll (RFC 2091), då skickas en full update en gång först för att sedan endast skicka partial updates vid förändringar. RIP har stöd för triggered updates på serial point-to-point interface, dvs om en förändring sker kan en partial update skickas ut direkt. Eftersom RIP använder UDP går det inte att lita på att exakt alla paket är rätt. Det konfigureras per interface och shut/noshut för att aktivera.
 ip rip triggered

Suppress triggered updates when next regular update due within 10 seconds
 flash-update-threshold 10
 show ip protocols | i Flash

'''Timers''' &lt;br/&gt;
Varje router har för varje route en tillhörande ''invalid after'' timer (default 180 sekunder) som tickar varje sekund och resetas varje gång den kommer in en uppdatering innehållandes routen. Kommer det inte in någon uppdateringen med routen blir den invalid och ''holddown timern'' startar. Då börjar routern skicka ut uppdateringar om att denna route inte är nåbar (infinte metric) genom sig själv eftersom det har hänt något med routen ur det egna perspektivet så övriga routrar får hitta en annan väg. Samtidigt som den inte accepterar några uppdateringar gällandes denna route tills holddown timear ut (default 180 sekunder). Huvudsyftet med holddown är fördröja processandet av uppdateringar om nätverk vars nåbarhet inte är säker eftersom de mottagna uppdateringarna kanske inte innehåller up-to-date information.

Det finns också en ''flushed after'' timer som tickar och resetas på samma sätt som invalid after. Om routern inte hör något på 240 sekunder (default) tas routen bort från routingtabellen. Denna finns för att en route inte ska vara oviss för evigt. Eftersom invalid after är 180 sekunder och flushed after är 240 får inte holddown köra klart utan det bryts efter 60 sekunder. Det finns även en sleep timer som avgör hur länge en inkommen flash update ska ligga innan routing-infon används, denna timer är disabled default.

Timers går att tuna men det bör vara samma överallt.
 timers basic 10 60 60 80 100 
 show ip protocols | include seconds
Per interface
 ip rip advertise &lt;seconds&gt;

'''BFD''' &lt;br/&gt;
[[Cisco_BFD|BFD]] kan användas med RIP unicast.
 router rip
  bfd all-interfaces
  neighbor 1.1.1.1 bfd
RIP requires you to be advertising a route other than the transit link for the BFD relationship to establish.
 show ip rip neighbors

==Summarization==
Make RIPv2 classless
 no auto-summary

Eftersom RIP är ett distance vector routingprotokoll görs summary per interface. Det måste finnas en mindre specifik route i rib för att summeringen ska annonseras ut. Däremot installerar inte RIP någon discard route default men man kan manuellt skapa null routes om man vill.
 int gi2
  ip summary-address rip 10.0.0.0 255.255.0.0
''no auto-summary'' behövs också för detta.

==Default route==
Det finns flera olika metoder för att skicka en default route till en granne. Det krävs ingen gateway of last resort för att RIP ska kunna originera en default route.
 int gi2
  ip summary-address rip 0.0.0.0 0.0.0.0
Default-information
 router rip
  default-information originate
Static
 ip route 0.0.0.0 0.0.0.0 null 0
 router rip
  network 0.0.0.0      #Alt 1
  redistribute static  #Alt 2
Default-network (deprecated)
 ip route 20.0.0.0 255.0.0.0 null 0
 ip default-network 20.0.0.0 

Finns det en default route i rib så skickas det ut men metricen måste vara valid för RIP. 
 router rip
  default-metric 3

'''Conditional Default Routing''' 
 ip prefix-list TRACK seq 5 permit 1.1.1.1/32
 route-map TRACK_ROUTE permit 10
  match ip address prefix-list TRACK
 router rip
  default-information originate route-map TRACK_ROUTE

==Filtering==
'''Prefix-list'''
 router rip
  distribute-list gateway     #Filtering incoming updates based on gateway
  distribute-list prefix      #Filter prefixes in routing updates
Exempel, filtrera allt från en RIP sender.
 ip prefix-list ROUTERS seq 5 deny 192.168.0.3/32
 ip prefix-list ROUTERS seq 10 permit 0.0.0.0/0 le 32
 ip prefix-list PREFIXLIST seq 10 permit 0.0.0.0/0 le 32
 
 router rip
  distribute-list prefix PREFIXLIST gateway ROUTERS in

'''ACL''' &lt;br/&gt;
Extended ACL tolkas av RIP distribute som:
 access-list 100 permit ip host &lt;sending router&gt; host &lt;prefix&gt;
Exempel
 access-list 100 deny ip host 10.0.0.10 host 172.20.0.0
 access-list 100 permit ip any any
 
 router rip
  distribute-list 100 in Gi2
Det går även att blockera specifika avsändare med hjälp av interface ACL
 access-list 10 deny 2.2.2.2 0.0.0.0
 access-list 10 permit any
 
 interface gi2
  ip access-group 10 in

'''Offset list''' &lt;br/&gt;
Lägg till 5 på hop count till det som skickas ut på interface Gi2
 router rip
  offset-list 10 out 5 Gi2
 access-list 10 permit any
 
 show ip protocols | i metric
''offset-list 0'' träffar alla routes

'''Administrative Distance''' &lt;br/&gt;
Det går att filtrera routes med hjälp av AD. Exempel: filtrera vissa prefix från en viss granne. AD 255 = UNKNOWN.
 access-list 10 permit 192.168.0.0
 access-list 10 permit 172.30.0.0
 
 router rip
  distance 255 20.0.0.20 0.0.0.0 10
Filtrera routes som träffar acl 10 men kan komma från alla routrar.
  distance 255 0.0.0.0 255.255.255.255 10

==Redistribution==
Med auto-summary påslaget redistribueras endast classful networks. RIP har heller ingen seed metric. 
 router rip
  no auto-summary
  redistribute ospf 1 metric 3
Detta sätter samma metric på alla routes som redistribueras. Vill man ha ökad flexibilitet kan man använda en route-map som matchar routes mot ACLer och sätter metric därefter. Default-metric används som fallback ifall en route inte träffar route-mapen. T.ex. redistribuerade OSPF E2 routes (cost 20) kommar att ha infinite metric när '''transparent''' används om man inte manipulerar metricen.
 default-metric 5

Om man redistribuerar mellan t.ex. RIP och [[Cisco_OSPF|OSPF]] på flera punkter måste man förhindra suboptimal routing. Ett sätt att göra detta är genom att flagga redistribuerade routes med högre AD lokalt på redistributionsnoderna. RIP kan inte skilja på internal och external routes så det andra routingprotokollet får lösa det.
 router ospf 1
  distance ospf external 180
Man kan också tagga routes som blivit redistribuerade för att kunna filtrera bort dem och på så sätt undvika routingloop.
 route-map TAG
  set tag 100
 route-map FILTER-TAG deny 10
  match tag 100
 route-map FILTER-TAG permit 20
 
 router rip
  redistribute ospf 1 route-map TAG
  distribute-list route-map FILTER-TAG in

=RIPng=
RIP Next Generation är RIP för IPv6. Även om namnet låter flashigt har inte mycket av de underliggande mekanismerna förändrats även om UDP 521 istället för 520 nu används för att undvika krock med RIPv1/v2. Destinationsaddress för uppdateringarna är FF02::9. 15 hop är max metric och 16 är infinity men däremot ökas metric vid mottagandet av annonsering istället för skickandet som i tidigare versioner. Allt loopundvikande sker på samma sätt. En uppdatering kan innehålla så många entries som får plats i packetet vars max storlek avgörs av IPv6 MTU på länken. RIPng har inte stöd för autentisering utan precis som med [[Cisco_OSPFv3|OSPFv3]] sköts detta av IPsec, däremot har inte Ciscos implementation stöd för detta. Passive interfaces och static neighbors finns inte heller men nyheter är Route Poisoning (utökning av Split Horizon) och multipla RIPng-processer. 

&lt;div class="mw-collapsible mw-collapsed" style="width:310px"&gt;
Response packet:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_RIPng_Update.png]]
&lt;/div&gt;
&lt;/div&gt;

===Konfiguration===
Prereq
 ipv6 unicast-routing
 ipv6 cef
En del features konfigureras under RIP-processen.
 ipv6 router rip 1
  poison-reverse
  no split-horizon
  maximum-paths 16  #Max är 32
  distance 120

Sätt IP-adresser på interfacen och enablea sedan RIP.
 interface gi 0/0
  ipv6 address 2001:10:10:10::1/64
  ipv6 rip 1 enable
Verify
 show ipv6 rip
 show ipv6 protocols
 show ipv6 rip next-hops
 debug ipv6 rip events

Annonsera endast default route. Precis som med RIPv2 behöver det inte finnas någon default-route i RIB för att det ska kunna annonseras. Default metric för denna är 1.
 interface gi2
  ipv6 rip 1 default-information only 
Aggregate
 interface gi2
  ipv6 rip 1 summary-address 2001:10:10:10::/64
Filtering
 ipv6 router rip 1
  distribute-list prefix-list FILTER in
Slå på [[Cisco_Routing#VRF|VRF]]-stöd.
 ipv6 rip vrf-mode enable

[[Category:Cisco]]</text>
      <sha1>c0iiopzkkhjhnbh6pyk2lvilau6kxpb</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco Routing</title>
    <ns>0</ns>
    <id>250</id>
    <revision>
      <id>2239</id>
      <parentid>2172</parentid>
      <timestamp>2017-01-26T10:03:49Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8555">För dynamiska routingprotokoll se: [[Cisco_BGP|BGP]], [[Cisco_OSPF|OSPF]], [[Cisco_EIGRP|EIGRP]], [[Cisco_IS-IS|IS-IS]] och [[Cisco_RIP|RIP]]. Se även: [[Cisco_PfR|Cisco PfR]] och [[Cisco_PE-CE|Cisco PE-CE]].

===RIB===
Kolla routingprocesser som kan populera RIB.
 show ip protocol summary

IOS har en inbyggd funktion för att profilera RIBen dvs kolla hur mycket som ändras i den över tid.
 ip route profile
 show ip route profile

Med debug kan man se det mesta som rör routingtabellen. Bör ej användas i produktionsmiljöer.
 debug ip routing ?

==Static Routes==
Man kan konfigurera statiska routes med både forwarding address och outgoing interface. Däremot installeras inga recursive static routes default i RIB, detta ändras med '''ip route static install-routes-recurse-via-nexthop'''.
* '''Next-hop IP:''' routen är giltig sålänge det finns en route för next-hop value.
* '''Outgoing interface:''' routen är giltig sålänge som interfacet är UP/UP. 
* '''Both next-hop value and outgoing interface:''' routen är giltig sålänge som next-hop value är reachable över det specificerade interfacet.
 ip route 0.0.0.0 0.0.0.0 Gi0 10.10.3.4

'''Floating'''
 ip route 172.16.10.0 255.255.255.0 10.10.20.2 '''210'''

Verify
 show ip static route

'''VRF,''' default tillåts static routes att peka på interface i andra VRF:er.
 ip route static inter-vrf

=IPv6=
EUI-64
 interface Gi0
  ipv6 address 2001:2:3:4::/64 eui-64

'''ULA''' &lt;br/&gt;
Unique Local Address (RFC 4193) är motsvarigheten till IPv4 RFC 1918. Adressblocket är FC00::/7.

'''Router Advertisments''' 
 interface gi2
  ipv6 nd ra lifetime 1800
  ipv6 nd ra interval 200
Man kan annonsera prefix med ND RA men hostar får ej använda det för auto-config.
 ipv6 nd prefix 2000::/64 14400 no auto-config

OBS RA har AD 1 vilket kan därmed trumfa routingprotokoll.

Verify
 show ipv6 interface gi2 prefix

=VRF=
Man kan se VRF:er som virtuella routrar fast med delat management. VRF:er utan [[Cisco_MPLS|MPLS]] kallas VRF Lite. 
 show vrf
 show cef vrf
Konfiguration
 vrf upgrade-cli multi-af-mode common-policies
 show vrf detail | i CLI
Kolla vilka interface som tillhör vilken vrf.
 show ip vrf interfaces
Man kan i EXEC mode hoppa mellan vrf:er och kommandon som ''show ip route'' visar då den aktuella RIB:en.
 routing-context vrf Cust-A

'''Import/Export''' &lt;br/&gt;
Det går att styra vad och vilken community som ska sättas på det som ska importeras och exporteras med hjälp av route-maps. 

 ip prefix-list Cust-A_DENY seq 5 permit 172.20.0.0/24
 
 route-map Cust-A_EXPORT deny 10
  match ip address prefix-list Cust-A_DENY
 route-map Cust-A_EXPORT permit 20
 
 ip vrf Cust-A
  export map Cust-A_EXPORT

'''VRF Selection''' &lt;br/&gt;
Man kan styra på IP vilken VRF som paket ska hamna i men detta är varken skalbart eller smidigt.
 vrf selection source 172.16.1.0 255.255.255.0 vrf VRF1
 vrf selection source 0.0.0.0 0.0.0.0 vrf VRF2
 
 interface gi2
  ip vrf select source
  ip vrf receive VRF1
  ip vrf receive VRF2

=IP SLA=
IP SLA låter en enhet mäta och hålla koll på response time, latency, jitter, packet loss eller bara connectivity mot en punkt utifrån konfigurerbara tröskelvärden. Enheten kan sedan låta andra processer tracka detta och fatta routingbeslut utifrån det. T.ex. om primär WAN gateway går ner slå automatiskt över till sekundär gateway. IP SLA kan också använda MD5-autentisering, detta konfigureras med '''ip sla key-chain'''.
 ip sla 1
  icmp-echo 100.0.0.20 source-interface GigabitEthernet1
  threshold 2000
  timeout 2000
  frequency 5
 ip sla schedule 1 life forever start-time now
Verify
 show ip sla 1
 show ip sla configuration 
 show ip sla statistics

===Tracking===
För att andra processer ska kunna utnyttja IP SLA binder man IP SLA-objekten via tracking-processen. Tracking kan göras med [[Cisco_IOS#CDP|CDP]] och IP SLA och polling interval går att konfigurera globalt med '''track timer'''. Tracking kan t.ex. användas av [[Cisco_HSRP#Tracking|HSRP]].

Object Tracking
* Interface IP or line-protocol: Track either the line-protocol (up/down) or the presence of an IP address.
* IP route: Track a route present in the routing table.
* IP SLA: Track an IP SLA object.
Man kan även använda en lista för att kombinera flera track objects baserat på vikt/procent eller boolean AND/OR.
 track 10 ip sla 1 state
 ip route 0.0.0.0 0.0.0.0 10.10.10.2 track 10
Verify
 show ip route track-table
 show track timers
 show track brief
 show track resolution
 debug track

=PBR=
Policy routing låter routern forwardera trafik baserat på konfigurerbara kriterier utan att använda routingtabellen. Om trafik inte träffas av någon entry i route-map används routingtabellen som vanligt. Vill man ha drop-beteende med PBR kan man använda '''set interface Null0'''.

PBR prioriterar set-kommandona i följande ordning:
# Next-hop
# Next-hop recursive
# Interface
# Default next-hop
# Default interface

Konfigurationsexempel
 access-list 1 permit 192.168.1.10 
 access-list 2 permit 192.168.1.20
 
 route-map TEST permit 10 
  match ip address 1 
  set ip next-hop 10.10.10.2
 route-map TEST permit 20 
  match ip address 2 
  set ip next-hop 10.10.10.60
 
 interface Gi0/0 
  ip policy route-map TEST 
 
 show ip policy

'''Recursive''' &lt;br/&gt;
PBR Recursive Next Hop feature låter route-maps konfigureras med next-hops som inte är directly reachable via något interface. Dessa installeras då i routingtabellen och gör att man kan dra nytta av CEF load sharing. Om next-hop IP inte är möjlig att resolva så går paketen på default routen. Med IPv6 fungerar det men stödjer ej load sharing.
 set ip next-hop recursive 10.10.10.2

'''Default''' &lt;br/&gt;
Det går ändra endast default next-hop (eller interface) för det som matchas av en route-map. Då kommer routingtabellen kollas som vanligt förutom att gateway of last resort inte kommer att användas.
 route-map TEST permit 10 
  match ip address 1
  set ip default next-hop 10.0.0.10

'''VRF''' &lt;br/&gt;
Man kan med hjälp av en route-map ta in viss trafik i en annan vrf än det som interfacet tillhör. De kommandon som sätter vrf-tillhörighet har företräde över de andra ''set interface, next-hop'' etc.
 route-map VRF permit 10
  match ip address 10
  set ip vrf &lt;name&gt;

'''Continue''' &lt;br/&gt;
Vanligtvis är en route-map first match only men vill man ändra det kan man använda '''continue''' för att hoppa vidare till nästa entry. 

 route-map TEST permit 10 
  set metric 150
  continue
 route-map TEST permit 20 
  match ip address 1
  set ip next-hop 10.10.10.2
OBS funkar inte med redistribution.

===Local Policy Routing===
LPR påverkar trafik genererad av routern själv och konfigureras globalt.
 ip local policy route-map ROUTE-MAP
 show ip local policy

===Reliable PBR===
IP SLA och Enhanced Object Tracking
 route-map POLICY_ROUTING permit 10
  set ip next-hop verify-availability 100.0.1.5 1 track 1

CDP, reachability verifieras genom att kolla att det finns någon [[Cisco_IOS#CDP|CDP]]-granne som har 100.0.1.5. Detta går också att använda ihop med ''set ip default next-hop''. Alla kommandon som ändrar routing programmeras i hårdvara utom ''set ip next-hop verify availability'' eftersom CDP-info ej finns i linecards.
 route-map POLICY_ROUTING permit 20
  set ip next-hop 100.0.1.5
  set ip next-hop verify-availability

=Others=
'''On-demand routing''' &lt;br/&gt;
ODR är ett slags simpelt routingprotokoll som har administrative distance 160. Det använder CDP som bärare för uppdateringarna så fungerande CDP är ett prereq. ODR har stöd för det grundläggande som filtrering, redistribution, timers och passiva interface. Inga ändra routingprotokoll bör köras.
 router odr
  network 0.0.0.0
Verify
 show ip protocols
 show ip route odr

'''Backup Interface''' &lt;br/&gt;
Det primära interfacet bör vara ett point-to-point interface annars kan inte up/down status avgöras. Backup interfacet får ej vara ett subinterface eftersom dess state avgörs av main interfacet.
 interface gi2
  backup interface gi4
  backup delay 3 60 
Verify
 show backup

'''IRDP''' &lt;br/&gt;
En router kan hitta en gateway router med hjälp av ICMP Router Discovery Protocol. IRDP skickar ut ICMP Router Advertisement (ICMP type 9 packets) på subnätet för att informera om att det finns en potentiell gateway. Detta funkar endast om IP routing och proxy ARP är avslaget på enheterna som tar emot ICMP RA. 
 ip subnet-zero
 show ip irdp

'''IP Event Dampening'''
 interface gi2
  dampening 30
 show dampening

[[Category:Cisco]]</text>
      <sha1>osginxpubqtzvrl3f8jxf1x0q8o9w09</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco SNMP</title>
    <ns>0</ns>
    <id>195</id>
    <revision>
      <id>2833</id>
      <parentid>2274</parentid>
      <timestamp>2018-08-24T08:20:30Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3069">Simple Network Management Protocol är ett protokoll definierat av IETF som används för att övervaka och hantera nätverk baserade på TCP/IP. En SNMP-agent är en router eller en switch med information som kan frågas om med SNMP. Vilken typ av information som hålls av enheten kallas en MIB (Management Information Base), [http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do SNMP Object Navigator]. SNMPv1 does not support 64 bit counters, only 32 bit counters.

=Konfiguration=
 snmp-server contact Admin
 snmp-server location Molnet
 snmp-server community Hackernet
 
 show snmp
 show snmp community

Maintain ifindex values across reboots. Detta kommando hette tidigare ''snmp-server ifindex persist''. Det går även att göra per interface.
 snmp ifmib ifindex persist
 show snmp mib ifmib ifindex

===Access control===
Vitlista de som ska få prata SNMP.
 access-list 10 permit 172.16.0.0 0.0.0.255
 access-list 10 deny any log
 
 snmp-server community PUBLIC ro 10

===Views===
Med views kan man begränsa vad som får frågas om, t.ex. endast vissa MIB subtree. Man kan specificera object name eller OID. &lt;br/&gt;
Exempel: alla Cisco-MIBar utom de EIGRP-relaterade.
 snmp-server view CISCO cisco included
 snmp-server view CISCO ciscoEigrpMIB excluded

Users och communities går att binda till views.
 snmp-server community PUBLIC view CISCO
Verify
 show snmp view

===Traps===
SNMP Traps skickas default till UDP 162. 
 snmp-server enable traps
 snmp-server host 10.0.0.10 traps v2c-community/v3-username
 show snmp host

Det går att skicka traps vid t.ex. linkup och down på interface. 
 snmp-server enable traps snmp linkup linkdown

Per interface
 int gi2
  snmp trap link-status permit duplicates
  snmp trap ip verify drop-rate

Det går att skicka traps med [[Cisco_Logging|Syslog]]. Först skickas det lokalt till en speciell history buffer och sedan replikerar SNMP agenten det till traps.
 snmp-server enable traps syslog

=SNMPv3=
Den stora skillnaden med SNMPv3 kontra tidigare varianter är säkerheten. Med version 3 kan både autentisering och kryptering användas.
* '''noauth:''' no auth, no enrypt
* '''auth:''' auth, no enrypt
* '''priv:''' auth, enrypt

Skapa grupp för version 3. Grupper definierar access rights för users till MIBar genom att kopplas till MIB views. 
 snmp-server group v3GROUP v3 priv
 show snmp group
Skapa user, detta sparas ej i runnning conf. SNMPv3 user passwords hashas utifrån local Engine-ID.
 snmp-server user SNMPUSER v3GROUP v3 auth sha SECRETKEY priv aes 128 SECRETKEY
 show snmp user

===NX-OS===
NX-OS har inte stöd för SNMPv3 noAuthNoPriv security level.

Privacy, enforces message encryption för alla users.
 snmp-server globalEnforcePriv
Skapa user
 snmp-server user SNMPUSER network-operator auth sha SECRETKEY priv aes-128 SEVRETKEY
 show snmp user
VRF
 snmp-server host 10.1.2.4 use-vrf management
Traps 
 snmp-server host 10.1.2.4 traps version 3 priv SNMPUSER
Man kan kolla vilka interface som används som source för SNMP-paket.
 show snmp source-interface

[[Category:Cisco]]</text>
      <sha1>qgmfp4squ7jj4qn8pa2j3g2c8uccstz</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco SPAN</title>
    <ns>0</ns>
    <id>196</id>
    <revision>
      <id>3133</id>
      <parentid>3126</parentid>
      <timestamp>2021-11-14T10:27:06Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6505">Switch Port Analyzer är Ciscos namn på att spegla trafik, antingen mellan portar på samma switch eller till en remote switch. Alla typer av portar kan speglas. SPAN består av source (portar eller [[Cisco_VLAN|VLAN]]) och destination port/ar. Med RSPAN fungerar source på samma sätt men destination port finns på en annan switch så det skickas i ett RSPAN VLAN till den andra switchen. ERSPAN (Encapsulated Remote SPAN) är samma som RSPAN men att det kapslas in med [[Cisco_GRE|GRE]] så att det kan routas till en annan switch. Man kan även ha Wireshark som endpoint för GRE-tunneln. Man kan välja om rx, tx eller att både och ska speglas, default är all rx och tx med undantag vissa control plane frames (t.ex. CDP, BPDU, VTP, DTP, PAgP). SPAN ligger före trafikmodifikation för receive, t.ex. [[Cisco_Security#VACL|VACL]], [[Cisco_QoS|QoS]] och ingress policing. För tx ligger det efter så med andra ord SPAN händer längst ut. På vissa low-end switchar måste man låna en asic från en oanvänd port för att switchen ska kunna spegla trafik. 

'''Begränsningar'''
* All konfigurationen på en port inaktiveras när den blir konfad som destination port för SPAN. Inklusive [[Cisco_EtherChannel|EtherChannel]].
* Destination port har inte stöd för [[Cisco_Security#802.1x|802.1x]], [[Cisco_VLAN#Private_VLAN|Private VLAN]], [[Cisco_IOS#CDP|CDP]], [[Cisco_STP|STP]], [[Cisco_VTP|VTP]], [[Cisco_VLAN#DTP|DTP]], etc.
* Som source går det ej att mixa portar och VLAN.
* Destinationporten är best effort, dvs överflöd slängs.
* Endast en SPAN-session kan skicka trafik till en destination port.

=SPAN=
 monitor session 1 source interface fa0/2 rx
 monitor session 1 source interface fa0/3 both
 monitor session 1 destination interface fa0/10 encapsulation replicate
Encapsulation replicate gör att exakt alla frames speglas.
 monitor session 1 filter vlan 2 - 5
Speglar man en trunkport kan man filtrera så att endast vissa VLAN speglas.

'''Verify'''
 show monitor session 1
 show platform software monitor session 1

'''NX-OS''' &lt;br/&gt;
Destination
 interface Ethernet1/1
  description MONITOR-SESSION-1
  switchport
  switchport monitor
  no shutdown
Monitor session
 monitor session 1
  description SPAN-to-SERVER
  source vlan 10-20 both
  rate-limit auto
  destination interface Ethernet1/1
  no shut

=RSPAN=
Skapa RSPAN VLAN på alla switchar. RSPAN vlan stänger av mac learning och allt som kommer in floodas till alla portar som är konfigurerade som destination.
 vlan 999
  name RSPAN
  remote span
  exit
Source 
 monitor session 1 source interface fa0/3 both
 monitor session 1 destination remote vlan 999
Switch 2
 monitor session 1 source remote vlan 999
 monitor session 1 destination interface gi0/8
'''Verify'''
 show monitor session 1
 show vlan remote-span

=ERSPAN=
ERSPAN finns i två versioner. I version 1 (type II) används en ERSPAN header innan GRE-enkapsuleringen. Den innehåller metadata om sessions id och speglade VLAN. I version 2 (type III) är headern större vilket ger mer flexibilitet, t.ex. finns det även plats för info om performance och latency analysis. PTP timestamp information används för att räkna ut packet latency över edge, aggregate och core switches. De skiljs åt med hjälp av GRE Protocol Type value, 0x88BE och 0x22EB.

Source
 monitor session 1 type erspan-source
 source interface gi0/1 both
 no shut
 destination
  erspan-id 101
  ip address 10.0.0.20
  origin ip address 172.20.0.10
Destination
 monitor session 1 type erspan-destination
 destination interface gi0/2 
 no shut
 source
  erspan-id 101
  ip address 10.0.0.20
Verify
 show monitor session 1
 show capability feature monitor erspan-source
 show capability feature monitor erspan-destination

'''NX-OS'''
 monitor erspan origin ip-address 10.1.2.1
 monitor session 1 type erspan-source
  description ERSPAN direct to Sniffer PC
  erspan-id 32                              # required, # between 1-1023
  vrf default                               # required
  destination ip 10.1.2.3                   # IP address of Sniffer PC
  source interface port-channel1 both       # Port(s) to be sniffed
  filter vlan 3900                          # limit VLAN(s) (optional)
  no shut                                   # enable
Verify
 show monitor session all

=Embedded Packet Capture=
På vissa enheter går det att göra en lokal packet capture. Man kan fånga paket i båda riktningen på ett interface samt begränsa så att inte allt fångas. Man kan såklart ha en permit ip any any acl men något slags filter måste konfigureras. Detta är IOS-XE syntax.
 ip access-list extended CAPTURE
  permit udp host 172.17.0.13 host 172.16.0.14 eq 53
  permit udp host 172.16.0.14 host 172.17.0.13 eq 53
 
 monitor capture 1 access-list CAPTURE interface g0/0 both
Start / Stop / Clean up
 monitor capture 1 start
 monitor capture 1 stop
 no monitor capture 1
Show 
 show mon cap 1 buffer brief
 show mon cap 1 parameter

=Ethanalyzer=
Ethanalyzer är ett protocol analyzer-verktyg för [[Cisco_Nexus|NX-OS]]. Det är en CLI-variant av Wireshark med stöd för filter.
* capture-filter: tcpdump capture filter syntax
* display-filter: wireshark display filter syntax

Exempel: titta på trafik till och från supervisor på mgmt-interface.
 ethanalyzer local interface mgmt
 ethanalyzer local interface mgmt capture-filter "host 10.0.0.10" limit-captured-frames 50 write bootflash:CAP_MGMT.pcap

Man kan inte se trafik som går i hårdvaran (ASIC) men man kan använda en ACL med log option som workaround.
 ip access-list ACL-CAP
  permit tcp 10.0.0.3/32 10.0.0.10/32 eq 5000 log
  permit ip any any
 interface e1/1
  ip access-group ACL-CAP in
 
 ethanalyzer local interface inband capture-filter “tcp port 5000”

En annan mer kraftfull workaround man kan göra är att spegla trafik från ASIC (cloud scale) till CPU och sedan använda ethanalyzer. 
 monitor session 1
  source interface e1/15
  destination interface sup-eth 0
  no shut
 
 ethanalyzer local interface inband mirror limit-captured-frames 50

=RITE=
På routrar heter SPANs motsvarighet Router IP Traffic Export och man anger en mac-adress man vill skicka paketen till, det skulle t.ex. kunna vara en IDS. Man kan matcha det man vill ska skickas mot en acl och man kan sampla.
 ip traffic-export profile IDS
  interface Gi0/0
  mac-address 0123.0005.abcd
  incoming sample one-in-every 5
 interface Gi0/2
  ip traffic-export apply IDS
Show
 show ip traffic-export

[[Category:Cisco]]</text>
      <sha1>9pgiicm5sh8p4nmzxfh6u2i1nm68i3x</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco SR</title>
    <ns>0</ns>
    <id>515</id>
    <revision>
      <id>3029</id>
      <parentid>2990</parentid>
      <timestamp>2019-10-01T11:15:14Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7553">Segment Routing (SR) är ett flexibelt och skalbart sätt att göra source routing, det är inget routingprotokoll utan ett koncept. Den första noden väljer path och kodar det i packet header genom en ordnad lista av "segment". Det går att använda MPLS data plane (labels) eller IPv6 data plane (header extensions), denna artikel fokuserar på [[Cisco_MPLS|MPLS]]. Segment Routing integrerar med dom multi-service capabilities som finns med MPLS, inklusive L3VPN, [[Cisco_L2VPN#EoMPLS.2FAToM|VPWS]], [[Cisco_L2VPN#VPLS|VPLS]] och [[Cisco_EVPN|EVPN]].

Segment representerar subpaths som en router kan kombinera för att få fram en komplett route till destination. Varje segment har en identifier (Segment Identifier) som distribueras genom nätverket med hjälp av extensions till IGP (IS-IS/OSPF). Segment routing tillåter därmed att man väljer hela pathen från ingress port till egress port utan att förlita sig på t.ex. IGP shortest path table. Det är samtidigt simplare än de flesta andra typer av traffic engineering. SR gör även ECMP till skillnad från [[Cisco_MPLS#Traffic_Engineering|RSVP-TE]]. För att tunea en path så används lokal TE policy alternativt BGP-LU, man annonserar en unicast route med en associerad MPLS label. SR kräver inget label distribution protocol så det behövs t.ex. ingen synkronisering mellan routingprotokoll och LDP.  

* '''Prefix SID''' - Ett segment ID som innehåller IP-prefix, detta måste vara globally unique. Prefix SID konfas manuellt ur SRGB-rangen. Kallas även Node SID.
* '''Adjacency SID''' - Ett segment ID som innehåller en routers adjacency till en granne, dvs det är länken mellan två routrar. Eftersom adjacency SID är relativ till en specifik router så är den locally unique och endast giltig på den nod som allokerade den. 

Man kan använda både Prefix SID och Adjacency SID för att beskriva en path. Om ett interface går ner kommer Adj-SID att finnas kvar i 30 minuter och kallas då för zombie label. 

Det går även att stitcha IGP-domäner genom att konfigurera multipla IGP-instanser på loopback på domain border nodes. Man anger samma prefix SID under flera IGP-instanser och därmed blir prefix och prefix SID nåbara i flera domäner.

=Konfiguration=
==IOS==
Segment Routing Global Block (SRGB) och Segment Routing Local Block (SRLB) är de label ranges som är reserverad för segment routing. Default value för SRGB är 16000 till 23999, det är rekommenderat att använda default SRGB range (utom vid multi vendor).
 show mpls label range
 show ip ospf segment-routing global-block

Associera SID values med lokala prefix, detta prefix måste även annonseras i IGP.
 interface Loopback0
  ip address 2.2.2.2 255.255.255.255
 
 segment-routing mpls
  connected-prefix-sid-map
   address-family ipv4
    2.2.2.2/32 index 2

Sedan går man in under IGP och slår på segment-routing, detta enablear MPLS på alla IGP-interface och lägger in MPLS labels för forwarding. För övrig konfiguration se [[Cisco_IS-IS#Konfiguration|IS-IS]] och [[Cisco_OSPF#Konfiguration|OSPF]].
 router ospf 1
  segment-routing mpls

Verify
 show segment-routing mpls state
 show mpls forwarding-table
 show ip ospf segment-routing local-prefix
 show ip ospf segment-routing sid-database
Kolla Adjacency SID
 show ip ospf neighbor detail | i Neighbor|SR

'''Node SID Redistribution''' &lt;br/&gt;
 router ospf 1
  segment-routing mpls
  distribute link-state

===BGP-SR===
Man kan även göra segment routing med hjälp av BGP-SR, då används BGP-LU. Se även [[Cisco_BGP|Cisco BGP]].

 router bgp 1
  neighbor 10.1.1.2 remote-as 2
  !
  address-family ipv4
   redistribute connected
   segment-routing mpls
   neighbor 10.1.1.2 activate
   neighbor 10.1.1.2 send-label
  exit-address-family

==IOS-XR==
Segment Routing med MPLS Data Plane. SR funkar även med Multi-topology.
 router isis 1
  address-family ipv4 unicast
   segment-routing mpls
  !
  interface Loopback0
   address-family ipv4 unicast
    prefix-sid absolute 16001

Verify
 show isis segment-routing label table
 show isis route sr-only
 show mpls label table summary

Detta gäller vid imposition
 segment-routing mpls
  set-attributes
   address-family ipv4
    sr-label-preferred

'''PHP''' &lt;br/&gt;
PHP går att stänga av per prefix SID.
 router isis 1
  interface Loopback0
   address-family ipv4 unicast
    prefix-sid index 1 explicit-null

'''Microloop Protection'''
 microloop avoidance segment-routing

'''Anycast SID''' &lt;br/&gt;
Vill man använda en prefix SID för anycast måste man stänga av att den annonseras som en nod i LSDB.
 router isis 1
  interface Loopback0
   address-family ipv4 unicast
    prefix-sid index 1 n-flag-clear

'''OAM''' &lt;br/&gt;
 ping sr-mpls 4.4.4.4/32
 traceroute sr-mpls 3.3.3.3/32 verbose

'''BGP Peer Adjacency SID''' &lt;br/&gt;
Man kan även skapa Adj-SID för eBGP-grannar, t.ex. på inter-AS-länkar. Man forwarderar där det finns en BGP-granne, detta kan användas för Egress Peering Engineering applications.
 router bgp 1
  neighbor 10.1.1.2
   remote-as 2
   egress-engineering
   address-family ipv4 unicast

===LDP===
SR kan samköras med LDP men ska man koppla ihop ett LDP-nät med SR-nät måste man sätta upp mapping servers. Alla destinationer måste ha ett prefix SID. Om en nod inte kan annonsera det själv (t.ex. en LDP-only nod) så gör mapping servern det på dennes vägnar. Alla Segment Routing routers behöver också vara mapping clients. Mapping server behöver ej finnas i data path.

Mapping server
 router isis 1
  address-family ipv4 unicast
   segment-routing prefix-sid-map advertise-local
 ! 
 segment-routing
  mapping-server 
   prefix-sid-map
    address-family ipv4
     1.1.1.1/32 1001 range 8
Range 8 betyder prefix 1.1.1.1/32 - 1.1.1.8/32 med start label 17001 vilket gör det lätt att se vilka labels som kommer ifrån mapping server. 

Mapping client
 router isis 1
  address-family ipv4 unicast
   segment-routing prefix-sid-map receive

Verify
 show isis segment-routing prefix-sid-map active-policy detail

SR vs LDP preference
 router isis 1
  address-family ipv4 unicast
   segment-routing mpls sr-prefer

==NX-OS==
Se även [[Cisco_MPLS#NX-OS|NX-OS MPLS]].
 install feature-set mpls
 feature-set mpls
 feature mpls segment-routing
 
 segment-routing mpls
 
 router bgp 65000
  address-family ipv4 unicast
    network 2.2.2.2/32 route-map assign_label
    allocate-label all
  neighbor 10.1.1.2 remote-as 65000
      address-family ipv4 labeled-unicast
         send-community extended

=SR-TE=
SR-TE kallas SR Policy. Med SR-TE behöver inte längre nätet hålla något state per-flow eller per-applikation utan man följer bara det forwarding-instruktioner som finns i paketet. Man nyttjar även bandbredd bättre eftersom man kan dra nytta av ECMP där det finns. Eftersom man låter en extern källa räkna på required paths genom nätverket lättar man lasten för övriga routrar. 

För att styra en path så används lokal TE policy alternativt BGP-LU, man annonserar en unicast route med en associerad MPLS labelstack. Se exempel med [[ExaBGP#Segment_Routing|ExaBGP]].

 segment-routing
  traffic-eng
   segment-list SIDLIST1
    index 10 address ipv4 1.1.1.3
    index 20 mpls label 24006
    index 30 mpls label 16008
   !
    policy POLICY1
     binding-sid mpls 15000
     color 10 end-point ipv4 1.1.1.10
     candidate-paths
      preference 100
       explicit segment-list SIDLIST1
Verify
 show segment-routing traffic-eng policy
 show segment-routing traffic-eng forwarding policy 

[[Category:Cisco]]</text>
      <sha1>7u0b7x2pl38nqbmnsui3nifjyfyk0un</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco STP</title>
    <ns>0</ns>
    <id>150</id>
    <revision>
      <id>2032</id>
      <parentid>2008</parentid>
      <timestamp>2016-10-08T13:26:33Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11061">Spanning Tree Protocol blockar portar på switchar så att det på L2 skapas en logisk trädtopologi och på så sätt hålls ethernetsegment loopfria. Enheter som använder STP skickar BPDU-meddelanden mellan varandra för att utbyta information. De skickas till 01:80:C2:00:00:00/01:00:0C:CC:CC:CD. Den BPDU som är superior har företräde och övriga kan ignoreras. För att avgöra vilken som är bäst jämförs följande värden i skriven ordning: Root Bridge ID, Root Path Cost, Sender Bridge ID, Sender Port ID, Receiver Port ID (RPID följer ej med i BPDUn utan switchen själv vet ju detta). Det första värdet där det skiljer sig avgör och lägst vinner. BPDUer skickas ej på non-designated portar eftersom de inte är superior och därmed onödiga att skicka. Varenda port på varenda switch i STP sparar superior BPDUn på det segmentet. Non-designated portar sparar BPDU från andra sidan och Designated portar sparar sin egen BPDU.

Se även [[Cisco MST]].

=STP=
STP (IEEE 802.1D) använder BPDUer med Version 0. Kommer det inte in någon BPDU innan MaxAge (minus MessageAge) har gått ut måste STP räkna om. Rotbryggan avgör dessa timers. Root Path Cost skickas med i varje Hello och genom att addera det med costen på interfacet där Hellon kom in vet switchen hur långt det är till rotbryggan.

&lt;div class="mw-collapsible mw-collapsed" style="width:210px"&gt;
'''BPDU'''
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_STP_BPDU.png]]
&lt;/div&gt;
&lt;/div&gt;

'''Process''' &lt;br/&gt;
STP-processen börjar med att alla switchar ser sig själva som root och skickar ut Hellos. Sedan görs följande val:
# Root Bridge: Lowest BID = Priority + MAC  (Den ursprungliga STP-varianten hade ej med VLAN ID)
# Root Port: Av alla BPDUer på alla portar vilken är superior. Dvs bästa vägen bandbreddsmässigt till rotbryggan, en per nonroot switch.
# Designated Port: Superior BPDU på ett segment
# Non Designated: Övriga
På rotbryggan finns det ingen root port utan alla är designated. STP-processen slutar aldrig utan varje BDPU som kommer in ska jämföras.  

PVST-processen skiljer sig lite grann:
* Root Bridge: Lowest BID (Priority + '''VLANID''' + MAC)

'''Topology Change''' &lt;br/&gt;
Det finns en slags BPDU i 802.1D som heter TCN (Topology Change Notification), den används för att informera övriga om en förändring. Detta skickas om: det kommer in en TCN BPDU på en designated port, en port går från Learning till Forwarding eller Blocking, en switch blir rotbrygga. Kom ihåg att vanliga BPDUer som inte är superior ignoreras därför måste en TCN skickas till root (görs genom root port) som sedan kan skicka ut det till alla. En TCN skickas med varje Hello tills en TCA (Acknowledgement) fås som svar, sedan gör nästa switch samma sak till det når root. Rotbryggan sätter nu TC-biten i sina utgående BPDUer som instruerar övriga att förkorta Aging Time till ForwardDelay för att påskynda konvergens. 

'''Timers''' &lt;br/&gt;
Det finns flera olika typer av timers som skickas med i BPDUerna. MessageAge är en uppskattning på hur länge sedan BPDUn lämnade rotbryggan (med detta satt till 0). Övriga switchar brukar plussa på 1 innan de skickar det vidare. MaxAge, HelloTime och ForwardDelay är värden satta på rotbryggan, har andra switchar andra värden konfigurerade spelar det ingen roll för det är rotbryggan som bestämmer. Hellos skickas default var 2 sekund.
 spanning-tree vlan 1-4094 hello-time 2
 spanning-tree vlan 1-4094 forward-time 15
 spanning-tree vlan 1-4094 max-age 20

'''Interface states''' &lt;br/&gt;
När nätverket konvergerar kan portar byta mellan Blocking och Forwarding men detta kan inte göras direkt utan att riskera tillfälliga loopar. Därför går interfacen igenom olika tillstånd. Längden på transitory statesen avgörs av ForwardDelay, 15 sek default.

{| class="wikitable"
!State
!Forwards data frames
!Learns source MACs of received frames
!Stable
|-
|Blocking
|No
|No
|Stable (show spanning-tree blockedports)
|-
|Listening
|No
|No
|Transitory
|-
|Learning
|No
|Yes
|Transitory
|-
|Forwarding
|Yes
|Yes
|Stable
|-
|Disabled
|No
|No
|Stable
|}

=Rapid ST=
Rapid Spanning Tree Protocol (802.1w) och RPVST+ (Cisco) förbättrar konvergens avsevärt, under 1 sekund i bra byggda nät. Man har introducerat att länkar är point-to-point för att kunna ha bättre mekanismer för recovery (konvergenstid). Det finns också ''shared links'' men det bör alltid vara p2p nuförtiden om inget är half duplex. 

Man använder 2 nya porttyper.
* '''Alternate Port:''' prospekt till root port. Går root port ner kan denna ta över snabbt.
* '''Backup Port:''' prospekt till designated port. Finns om switchen har flera portar i samma segment.

'''BPDU''' &lt;br/&gt;
I RSTP finns endast en sorts BDPU (Version 2) som används för allt. Man har uppdaterat flag fields och skillnad från tidigare finns nu Proposal bit, Port role bits, Learning bit, Forwarding bit och Agreement bit. Alla switchar originerar sina egna BPDUer oavsett BPDUn på root porten vilket leder till att de är mer pålitliga som Hello-mekanism. Om det slutar komma BPDU väntar en switch 3x Hello interval sedan blir BPDUn på den porten age out. MessageAge används nu endast för hop count och är det samma eller högre än MaxAge discardas BPDUn. 

Med STP ignoreras inferior BPDUer men i RSTP accepteras de direkt och switchen utvärderar sin roll och state på interfacet som vanligt. Detta leder till att switchen snabbt kan agera ifall den som brukade skicka superior BDPUer har disruption till root bridge. Kanske finns det en ny root bridge eller så har costen till root ökat den vägen, hursom ska det ageras på direkt. 

'''Proposal/Agreement Process''' &lt;br/&gt;
När man lägger till en länk i topologin kan en tillfällig switching-loop uppstå eftersom en switch då kan välja den tillagda länken som ny root port och övriga switchar inte känner till det direkt. För att skydda mot detta har RSTP en Proposal/Agreement-mekanism på p2p-länkar (vilket alla länkar bör vara). Eftersom man inte kan styra andra switchar måste det loop-skyddas lokalt när man byter root port. Genom att sätta alla (inklusive gamla root) non-edge designated portar i discarding state innan den nya root port blir forwarding förhindrar man en loop. Dock stängs länkar och det tar lite tid att återställa så genom att ha ett signaling scheme mellan enheterna som används för att försäkra sig om att det är safe att sätta designated portar i forwarding kan man uppnå snabb konvergens, detta kallas Proposal/Agreement. Proposal står för de portar som vill bli forwarding och Agreement står för tillåtelse att göra så. När en ny p2p-länk kommer upp mellan två switchar blir port state Designated Discarding på non-edge portar. När porten blir Learning skickas BPDUer med Proposal-biten satt. 

'''Topology Change''' &lt;br/&gt;
Till skillnad från 802.1D är den enda gång en topologiändring anses hända när en non-edge port går från non-forwarding till forwarding. Den nya portan kan ha en bättre väg för MAC-adresserna och CAM-tabellen måste uppdateras. Går en port från forwarding till non-forwarding spelar det ingen roll för då är de MAC-adresserna unreachable, dyker de upp någon annanstans är det för någon annan port har gått från non-forwarding till forwarding och då är det en topologiändring iallafall. I 802.1D skickades en TCN upstream, i RSTP floodas BPDUer med TC-biten satt till alla non-edge designated ports och root port utom porten där ändringen kom in på. Samt flusha alla MAC-adresser på den porten. 

För att RSTP/RPVST+ ska kunna tillhandahålla snabb konvergens måste alla switchar köra RSTP eller RPVST+, alla inter-switchlänkar måste vara p2p och alla portar mot end systems måste vara edge ports. Annars kommer prestandan att degraderas. 

'''Interface states''' &lt;br/&gt;
Med RSTP har man gått från 5 interface states till 3.  

{| class="wikitable"
!Administrative State
!STP
!RSTP
|-
|Enabled
|Blocking
|Discarding
|-
|Enabled
|Listening
|Discarding
|-
|Enabled
|Learning
|Learning
|-
|Enabled
|Forwarding
|Forwarding
|-
|Disabled
|Disabled
|Discarding
|}
Discarding lyssnar och skickar (beroende på roll) fortfarande BPDUer och övrig control plane traffic till och från switchen. Forwarding och Discarding är stable state medans Learning är transitory.

=Konfiguration=
Bridge ID med VLAN, detta är default och går ej att ta bort på nyare switchar för det konsumerar fler MAC-adresser. Kolla den lokala MAC-adressen som används till Bridge ID: '''show version | i bia|Base'''
 spanning-tree extend system-id
 spanning-tree mode rapid-pvst
 show spanning-tree

'''Cost''' &lt;br/&gt;
802.1D-1998, 1G = 4
 spanning-tree pathcost method short
802.1D-2004, 1G = 20000
 spanning-tree pathcost method long
 show spanning-tree pathcost method

'''Root Bridge''' &lt;br/&gt;
Konfigurera root brygga. Priority 0 är det absolut lägsta medans root primary sätter prio till 24k förutsatt att det ger root-rollen, detta ändras inte dynamiskt.
 spanning-tree priority 0
 spanning-tree root primary
Verify
 show spanning-tree root
Default-värden
 default spanning-tree vlan 1-4094 priority

'''Portar''' &lt;br/&gt;
Root Port och Designated Port
 interface range gi0/7
  spanning-tree cost 1000
  spanning-tree port-priority 128
Restart the protocol migration process
 clear spanning-tree detected-protocols

'''Troubleshoot'''
 test spanning-tree diameter 3
 test spanning-tree get configuration vlan
 debug spanning-tree events
 debug spanning-tree backbone fast
 debug spanning-tree pvst+

==Legacy Extensions==
Det finns många tillägg till Spanning-tree som bör användas, de hjälper till att öka stabilitet, säkerhet och kompabilitet. Se även [[Cisco_MST#Extensions|MST Extensions]].

'''UplinkFast''' &lt;br/&gt;
Cisco-proprietary teknik som låter en alternate port gå direkt till forwarding om root port går ner. För att försäkra sig att en switch med uplinkfast inte blir en transit switch sätts bridge priority automatiskt till 49152 och port costen blir 3000. Detta kan därför inte användas på en switch som har sin STP prio modifierad. När överslag görs så skickas dummy frames till mac 01:00:0c:cc:cc:cc från alla adresser i cam tabellen för att snabba upp konvergens i övriga nätet. Uplinkfast på default och konfigureras globalt.
 spanning-tree uplinkfast
 show spanning-tree uplinkfast

'''BackboneFast''' &lt;br/&gt;
Cisco-proprietary teknik som används för att snabba upp konvergens vid indirect link failure genom att låta MaxAge timer gå ut direkt. Om någon annan plötsligt hävdar sig vara root kanske den tappat sin uplink till root och då kan man timea ut den tidigare BPDU:n man fått från den enheten för att snabba upp konvergens. RLQ skickas också till root för att dubbelkollla att man sjäv inte tappat root. RSTP och MST har detta inbyggt men bör i övrigt användas på alla enheter, så förhoppningsvis inga...
 spanning-tree backbonefast
 show spanning-tree backbonefast

[[Category:Cisco]]</text>
      <sha1>pminjhubnmpiku5lm3n0dwdddmw8qsf</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco Security</title>
    <ns>0</ns>
    <id>268</id>
    <revision>
      <id>2991</id>
      <parentid>2989</parentid>
      <timestamp>2019-06-25T07:55:57Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>/* Control Plane */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4695">[[Cisco_IOS|Cisco IOS]] har stöd för många säkerhetsmekanismer och protokoll. Se även [[Cisco_L2_Security|L2 Security]], [[Cisco_L3_Security|L3 Security]], [[Cisco_DMVPN|DMVPN]] och [[Cisco_IPsec|Cisco IPsec]].

=Device Security=
Login enhancements
 login block-for [seconds] attempts [attempts] within [seconds]
 login on-failure log every 3
 
 show login
 show login failures

Lägg till undantag
 ip access-list standard TRUSTED_HOSTS
  permit host 10.0.0.10
 login quiet-mode access-class TRUSTED_HOSTS

Default genereras det ett syslog-meddelande om det görs 8 misslyckade inloggningsförsök inom en minut. Detta tröskelvärde går att konfigurera.
 security authentication failure rate 8 log 

Password recovery är på default men går att stänga av.
 no service password-recovery

===SSH===
 ip ssh version 2
 crypto key generate rsa modulus 2048
 
 line vty 0 15
  transport input ssh

Verify
 show ssh
 show ip ssh
 show users

'''Public key SSH authentication''' &lt;br/&gt;
Ens SSH-nyckel får inte plats på en rad utan man får lägga in det på flera rader och avsluta med exit.
 ip ssh pubkey-chain
  username cisco
   key-string
    AAAAB3NzaC1yc2EAAAADAQABAAABAQDLf...
    VPrV/fn35p1xq5Pc7b2oTxhe2sPEssVM7...
    exit

Enable key based authentication only. Ordning på authentication methods är default: publickey, keyboard-interactive, password.
 ip ssh server algorithm authentication publickey

===Control Plane===
Det är viktigt att skydda CPU i sina enheter, man kan styra accessen (Control-Plane Policing) och man kan överbelastningsskydda (Control-Plane Protection). CoPP skyddar route processor genom att behandla det som en separat enhet med eget ingress interface. Man kan styra trafik till control plane med hjälp av ACL:er och [[Cisco_QoS|QoS]]-filter.

 class-map match-all COPP-IN-IP
  match protocol ip
 
 policy-map COPP-INBOUND
  class COPP-IN-IP
   police rate 10 pps conform-action transmit  exceed-action drop 
 
 control-plane
  service-policy input COPP-INBOUND
 
 show policy-map control-plane

Default CoPP
 cpp system-default 

Management Plane Protection
 control-plane host
  management-interface GigabitEthernet 0/1 allow ssh https
 
 show management-interface

'''AutoSecure''' &lt;br/&gt;
AutoSecure finns i två modes, Interactive och Noninteractive där det senare "Automatically executes the recommended Cisco default settings" vilket bland annat stänger av ICMP redirects, unreachables och Proxy-ARP på alla interface.
 auto-secure no-interact
 show auto secure config

=AAA=
AAA authentication på IOS kan konfigureras att använda upp till fyra olika metoder för autentisering. Enheten kommer att använda metoderna i ordning och det är endast vid error som nästa metod används, detta gör att man kan ha fallbacks. ''aaa new-model'' gör att lokala usernames och passwords på enheten används vid avsaknad av andra AAA statements. 
 aaa new-model
 aaa authentication username-prompt "Enter Username:"
 aaa authentication password-prompt "Enter Password:"
 
 aaa authentication enable default group tacacs+ enable
 aaa authentication login default group tacacs+ local
Debug
 debug aaa authentication

Fallback user account ifall AAA-server är unreachable
 username fallback privilege 15 secret SECRETS

Max failed attempts to lock the user
 aaa local authentication attempts max-fail 10
 show aaa local user lockout
 clear aaa local user locked

===TACACS===
TACACS+ är Ciscoproperitärt och all trafik är krypterad. Tacacs kommunicerar på TCP port 49.
 aaa group server tacacs+ 
  server-private 10.0.0.20 key 7 078905478...
  server-private 10.0.0.21 key 7 134272319...
  ip vrf forwarding Mgmt
  ip tacacs source-interface gi0
 
 aaa authentication login default group tacacs+ local
 aaa authorization exec default group tacacs+ if-authenticated

Verify
 test aaa group tacacs+ USER SECRET123 new-code
 show tacacs

===Radius===
Cisco IOS RADIUS använder AV pairs, UDP port 1645-1646 eller 1812-1813, accounting är separat från authentication och authorization. Endast lösenord är krypterat. 

 radius server ISE1
  address ipv4 10.0.0.30 auth-port 1812 acct-port 1813
  key 7 01300F175804575D72
 
 aaa group server radius ISE-GROUP
  server name ISE1
  server name ISE2
  ip vrf forwarding mgmt
  ip radius source-interface Vlan100
  retransmit 2
  timeout 4
  deadtime 1
 
 aaa authentication login VTY-LINES group ISE-GROUP local
 aaa authorization exec default group radius local

Verify
 test aaa group radius USER SECRET123 new-code
 show radius

=IPS=
IOS kan sättas upp som ett Intrusion Prevention System.
 mkdir ips
 ip ips config location flash:/ips
 ip ips name IPS
 
 show ip ips config

[[Category:Cisco]]</text>
      <sha1>6suo2805xeu3oix128x1vm7uaqd62rn</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco Services</title>
    <ns>0</ns>
    <id>255</id>
    <revision>
      <id>3128</id>
      <parentid>3093</parentid>
      <timestamp>2021-11-05T09:27:54Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5295">[[Cisco IOS]] har stöd för diverse protokoll för mgmt och filöverföring.

Kontrollera vilka portar som är aktiva: '''show control-plane host open-ports'''

Samt vilken service som använder vilken port: '''show ip port-map'''

=HTTP=
 ip http server
 ip http secure-server 
 show ip http server all

Filöverföring med HTTP brukar vara snabbare än tftp och scp.
 copy http://10.0.0.10/ios.bin flash:

=DNS=
Server
 ip dns server
 ip dns spoofing 2.2.2.2
 ip name-server 8.8.4.4 8.8.8.8 
 ip domain round-robin
Verify
 show ip dns primary
 debug domain
Hosts
 ip host r1 10.0.0.10
 show hosts

=NTP=
NTP är väldigt effektivt för att synkronisera klockan mellan två system, ett paket i minuten räcker för att synka det till en millisekunds noggrannhet. I nyare versioner av IOS används NTPv4 (''show ntp information'') och det finns därmed stöd för IPv6. Det går dock att ställa NTP-version per interface eller peer. Offset måste vara mindre än 1000 msec för att servern ska anses ''sane''. Om det är mycket offset så kommer synk-processen att ta lång tid.

Packet types
* Control messages: peer status och set management parameters
* Update/request messages: time synchronization
&lt;div class="mw-collapsible mw-collapsed" style="width:200px"&gt;
Client:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_NTP_client.png]]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:200px"&gt;
Server:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_NTP_server.png]]
&lt;/div&gt;
&lt;/div&gt;

 ntp logging
 debug ntp all

'''Tidszon''' (Sverige)
 clock timezone CET 1
 clock summer-time CEST recurring last sunday march 02:00 last sunday october 03:00

'''Server'''
 ntp master &lt;stratum&gt;  #8 är default
 show ntp packets mode server

'''Klient'''
 ntp server 10.0.0.10
 ntp server vrf Mgmt 130.236.254.102
''OBS det kan ta lång tid innan klient synkar med server första gången.''

'''Peer''' &lt;br/&gt;
Båda enheter kan uppdatera sina klockor mot varandra, som ett NTP-kluster
 ntp peer 10.0.0.10 [key 20]

'''Verify''' &lt;br/&gt;
För att veta att NTP fungerar som det ska kan man kolla på reach-fältet. Det är en 8-bitars buffer där varje lyckat paket representeras av en 1:a och det som står i reach-fältet är på basen 8 så det man vill se är 377, annars betyder det att någon av de senaste 8 ntp-paketen inte kommit fram. När server och klient närmar sig synk och inga paket droppas kommer poll-intervallet att öka över tid, till max 1024. Det går ej att ändra routerns NTP poll intervall eftersom det bestäms av en heuristisk algorithm. 
 show ntp status
 show ntp associations 
Ställ klockan manuellt. Kan göras för att skynda på klocksynkronisering.
 clock set 12:00:00 20 July 2020

'''Access control''' &lt;br/&gt;
Med ACL, NTP Access control levels:
 ntp access-group ipv4 &lt;ACL&gt;

'''Authentication''' &lt;br/&gt;
enable authentication, configure a key with a key index, trust the key.
 ntp authenticate
 ntp authentication-key 20 md5 SECRET
 ntp trusted-key 20
 
 show ntp associations detail  | inc auth

'''Broadcast''' &lt;br/&gt;
NTP-paket går även att skicka med broadcast eller multicast, detta händer alltså utan att klienten "beställer" det.
 interface gi2
  ntp broadcast|multicast
  ntp broadcast key 20

Receiver
 int vlan 101
  ntp broadcast|multicast client

'''Others''' &lt;br/&gt;
Default-inställningar
 ntp max-associations 100
 ntp allow mode control 3
 ntp mindistance 1
 ntp maxdistance 8
Enable hardware clock synchronization
 ntp update-calendar
If my peer or configured master's clock is more than 1,000 seconds (default) off of my clock, reject the update and syslog.
 ntp panic update
Distance, 1 är slow convergence, 16 är fast
 ntp maxdistance &lt;1-16&gt;
Orphan kicks in when we lose sync with our server. The number here is a stratum number, and must be a number lower than your real upstream NTP server 
 ntp orphan &lt;1-16&gt;

===NX-OS===
NX-OS kör också NTPv4. 
 feature ntp
 ntp logging

Cisco Fabric Services (CFS) kan användas för att distribuera NTP-konfigurationen mellan Nexus-switchar. När man gör NTP-konfiguration så blir NTP låst network-wide (Fabric Lock).
 ntp distribute
 
 ntp master
 ntp server 10.0.1.10
 ntp source-interface loopback0
 
 ntp commit / abort

Verify
 show ntp status
 show ntp peers

Notera att det endast är en [[Nexus_VDC|VDC]] som synkar klockan i switchen. 
 clock protocol ntp vdc &lt;vdc-id&gt;

=SCP=
Secure copy protocol på IOS kräver AAA för user authentication och authorization eftersom copy är ett exec-kommando.

Server
 ip scp server enable

Push ios to switch
 scp ios.bin admin@10.0.0.10:ios.bin

Fetch ios from server
 copy scp://10.0.0.10:ios.bin flash:ios.bin

=TFTP=
Server, dela ut fil med TFTP.
 tftp-server nvram:startup-config alias TEST

Klient
 ip tftp source-interface loopback0
 copy tftp://10.0.0.10/TEST null:

För att säkerställa interoperability med gamla TFTP-servrar kan man behöva ställa ner blocksize.
 ip tftp blocksize 1024

Debug
 debug tftp events

=FTP=
Server, because of numerous vulnerabilities (bug ID CSCse29244, IOS crash when transferring files via FTP) Cisco has removed the FTP server functionality from recent IOS releases.

Klient
 no ip ftp passive
 ip ftp source-interface Loopback0
 ip ftp username USER
 ip ftp password SECRET

[[Category:Cisco]]</text>
      <sha1>gyv9317a3nm3ej5h78ravrn83wbqwnd</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco TCLSH</title>
    <ns>0</ns>
    <id>160</id>
    <revision>
      <id>1016</id>
      <timestamp>2015-09-07T11:24:21Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Cisco IOS Tcl shell designades för att kunna köra tcl-kommandon direkt i IOS. Man kan köra script i detta skal.  #tclsh  ==Ping sweeps== Flera hostar  foreach ip {  192.168..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="461">Cisco IOS Tcl shell designades för att kunna köra tcl-kommandon direkt i IOS. Man kan köra script i detta skal.
 #tclsh

==Ping sweeps==
Flera hostar
 foreach ip {
 192.168.0.5
 192.168.0.6
 8.8.8.8} {
 ping $ip repeat 2 timeout 1 }

Ett subnät
 for {set i 1} {$i &lt; 255} {incr i} { 
 ping 192.168.0.$i re 2 ti 0

Flera subnät
 foreach subnet {
 14
 15
 100 } {
 for {set i 1} {$i &lt; 255} {incr i} {
 ping 172.0.$subnet.$i re 2 ti 0
 }
 }

[[Category:Cisco]]</text>
      <sha1>m1ep83x1p8jz5lztqnm1i0t11cp2g05</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco UDLD</title>
    <ns>0</ns>
    <id>154</id>
    <revision>
      <id>2959</id>
      <parentid>2131</parentid>
      <timestamp>2019-04-02T08:09:47Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2525">UDLD är en echo-mekanism på lager 2 som gör att enheter som är anslutna via fiberoptiska eller partvinnade Ethernet-kablar kan övervaka det fysiska välmåendet av interface och kablar för att kunna upptäcka när en enkelriktad länk existerar. UDLD-meddelanden skickas var 7:e sekund på koppar och var 15:e sekund på fiber, med destination 01:00:0C:CC:CC:CC. Meddelandet innehåller switch-id, port-id och Timeout Echo Value som tillsammans bildar originator samt en lista på switch/port-par som hörts på segmentet. Om det kommer ett UDLD-meddelande där switchen själv inte finns med betyder det att andra sidan inte hör switchen och man kan utgå ifrån unidirectional link. Kommer det in UDLD med sig själv som originator betyder det self-looped port. Om något av detta händer blir interfacet error disabled (oavsett mode). UDLD är good guy protocol som kan användas i kombination med [[Cisco_STP|STP]]/[[Cisco_MST|MST]]. Om man inte kör Bridge Assurance eller [[Cisco_BFD|BFD]] bör man köra UDLD.

&lt;div class="mw-collapsible mw-collapsed" style="width:200px"&gt;
UDLD-paket:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_UDLD.png]]
&lt;/div&gt;
&lt;/div&gt;

===Normal vs Aggressive mode===
Vad som ska hände när det slutar komma in UDLD-meddelanden beror på vilket mode UDLD är konfigurerat i. I Normal mode försöker switchen aktivt återuppta grannskap genom att skicka 8 UDLD frames, sedan händer ingenting och porten förblir up. Med Aggressive mode försöker switchen att återuppta grannskap genom att skicka 8 UDLD frames men om det inte lyckas blir porten error disable. I Aggressive mode blir ett interface endast error disable om länken går “Bidirectional” -&gt; “Unidirectional”, dvs den måste först ha varit uppe och haft fungerande grannskap.

Normal och Aggressive mode är kompatibelt med varandra eftersom det endast handlar om lokalt beteende vid avsaknad av UDLD-meddelanden. 

===Konfiguration===
Global, gäller fiberportar.
 udld enable|aggressive
Per interface, gäller oavsett media.
 interface gi0/20
  udld port [aggressive]
Verify
 show udld
 show udld neighbors
Restore alla interface som är error-disabled pga link failure.
 udld reset
Auto Recovery
 errdisable recovery cause udld
 show errdisable recovery
På vissa plattformar kan man välja att UDLD endast ska rapportera errors istället för att err-disablea porten.
 udld fast-hello error-reporting
Time in seconds between sending of messages in steady state.
 udld message time &lt;7-90&gt;


[[Category:Cisco]]</text>
      <sha1>0nh4mamps5xgq6j4r2z1orjzc6ebwut</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco VLAN</title>
    <ns>0</ns>
    <id>230</id>
    <revision>
      <id>2962</id>
      <parentid>2916</parentid>
      <timestamp>2019-04-11T07:11:43Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>/* Bridging */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9996">Virtual LAN är alla broadcastdomäner som är partitionerade och isolerade på lager 2 i ett nätverk. Vill man managera VLAN på många Cisco-switchar centralt kan man använda [[Cisco_VTP|VTP]]. Det kan maximalt finnas 4094 VLAN, för att skala förbi det se [[Cisco_VXLAN|Cisco VXLAN]].

'''Standard:''' 1-1005 (1002-1005 är reserverade)

'''Extended:''' 1006-4094

==VLAN==
Stäng ett VLAN lokalt i switchen och suspenda det i VTP.
 vlan 20
  shutdown
  state suspend
Show
 show vlan brief
 show vlan internal usage

'''Layer 2 Traceroute''' &lt;br/&gt;
Man kan tracea mac-adresser i ett vlan. OBS [[Cisco_IOS#CDP|CDP]] är ett prereq för detta annars blir det ''Unable to send a l2trace request''. Max hops är 10.
 traceroute mac 0050.5600.0001 0000.aabb.ccdd vlan 20
Det går även att ta reda på vilken väg en frame tar utifrån IP-adresser. ARP används för IP-to-MAC resolution och båda adresserna måste finnas i samma subnät.

'''Voice'''
 interface GigabitEthernet0/1
  switchport mode access
  switchport access vlan 20
  switchport voice vlan 30
Alternativt konfigurera en trunk som tillåter voice-vlanet. Så fort man använder kommandot ''switchport voice vlan'' enableas portfast.

'''Database mode''' &lt;br/&gt;
Är gammalt och stöds inte längre på alla switchar.
 vlan database
  vlan 20 name Old-school
 apply

=Trunking=
IEEE 802.1q är standarden för att supportera VLAN över ethernet. 

Vitlista VLAN
 switchport trunk allowed vlan 1-5,8
 show interface trunk
Se till att native VLAN matchar på trunkar, både CDP och DTP kan upptäcka mismatch.
 switchport trunk native vlan 20
Man kan tagga alla frames på en trunk.
 vlan dot1q tag native
 show vlan dot1q tag native

==DTP==
Dynamic Trunking Protocol är ett Cisco-properitärt protokoll som används av switchar för att förhandla med andra sidan om ett interface ska vara trunk eller ej samt ISL eller 802.1q. DTP advertisements skickas med destination mac 01:00:0C:CC:CC:CC var 30:e sekund och innehåller VTP domain name så det måste matcha för att DTP ska kunna förhandla upp trunk (ena sidan kan ha vtp domain NULL så funkar det också). DTP är påslaget default och skickas både som vanlig ethernet men också ISL-enkapsulerat. DTP är inte supporterat på någon Nexus-plattform.
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
DTP frame:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_DTP.png]]
&lt;/div&gt;
&lt;/div&gt;

 show dtp

Port Modes, vissa switchmodeller har desirable som default (3560) och vissa har auto (2960)
* '''dynamic desirable:''' switchen kommer aktivt att försöka förhandla trunk genom att generera DTP frames.
* '''dynamic auto:''' switchen lyssnar och accepterar DTP frames men skickar inga själv.

Stänga av DTP. OBS porten måste vara konfad som något för att kunna använda nonegotiate, annars blir det ''Conflict between 'nonegotiate' and 'dynamic' status.''
 switchport mode trunk / access
 switchport nonegotiate

Verify
 show dtp interface
 show interfaces switchport | i Name|Negotiation

=Private VLAN=
Vanligtvis kan allt i ett VLAN nå övrigt i samma VLAN obehindrat men det kan finnas situationer när man vill begränsa konnektivitet inom en broadcastdomän. För att lösa det togs protected ports fram, det konfas per interface med ''switchport protected''. Om en port var protected kunde den endast nå portar som inte var protected i det VLANet, dvs två protected portar kan aldrig prata med varandra. Detta funkade lokalt inom switchen men ej mellan switchar och var därför inte så praktiskt i miljöer med fler än en switch. För att lösa det implementerades Private VLAN (RFC 5517). Detta används vanligtvis hos service providers som vill segmentera kunder från varandra men bara använda ett IP-nät. PVLAN är en mekanism som delar upp ett VLAN (primary) i secondary VLANs. Secondary VLAN finns i två varianter, isolated och community. Secondary VLAN måste tillhöra exakt ett primary VLAN. Det kan finnas flera community men isolated får det bara finnas ett av per primary. 

Inom en PVLAN-domän finns det tre separata porttyper. Varje porttyp har sin egen unika uppsättning regler som reglerar en ansluten enhets förmåga att kommunicera med andra anslutna enheter inom samma private VLAN. &lt;br/&gt;
* '''Isolated port:''' En isolated port kan inte prata med någon annan port i private VLAN-domänen med undantag för promiscuous ports.

* '''Community port:''' En community port är en del av en grupp med portar. Portar i en community kan ha L2 kommunikation med varandra och kan även prata med en promiscuous port. 

* '''Promiscuous port:''' En promiscuous port kan prata med alla andra typer av portar och tillhör primary VLANet.

Private VLAN fungerar över trunklänkar och därmed mellan switchar. Kommer en frame från ett secondary VLAN och ska skickas över en trunklänk så taggas den med sitt VLAN ID. Kommer det en frame på en promiscuous port så taggas den med primary VLAN. Dvs om en frame ska från en isolated port på en switch till en promiscuous port på en annan och sedan tillbaka kommer den ha olika VLAN-taggar på dit och tillbakavägen, såkallad assymetrisk VLAN-taggning. Det sker aldrig någon dubbeltaggning men switcharna måste ändå ha stöd för private VLAN och vara konfade likadant (PVLAN-mässigt) annars vet inte switcharna hur VLANen är associerade med varandra. 

Det finns undantag till detta beteende t.ex. om man har en router-on-stick så vet inte den vad PVLAN är. Då kan man använda ''promiscuous PVLAN trunk'' och på den skickas det aldrig ut något som är taggat med ett secondary VLAN utan allt skrivs om till primary VLAN ID. Det finns även ''isolated PVLAN trunk'', det fungerar tvärtom, då skickas det alltid ut taggat som ett secondary vlan. Det är användbart om man ska koppla ihop PVLAN med en switch som inte har stöd för det utan endast kan köra protected ports.

Det är möjligt för två isolerade hostar att kommunicera om '''ip local-proxy-arp''' är konfigurerat på gateway. Det fungerar som proxy ARP fast inom subnätet. Funktionerna DHCP Snooping, ARP Inspection och Source Guard på primary VLANet enablear det även på secondary VLANs.

===Konfiguration===
 vtp mode transparent
Alternativt kan [[Cisco_VTP|VTP]] version 3 användas.

VLAN
 vlan 101
  private-vlan isolated
 vlan 102
  private-vlan community
 vlan 100
  private-vlan primary
  private-vlan assoc 101,102

Access Ports
 interface g0/1
  description Gateway
  switchport mode private-vlan promiscuous
  switchport private-vlan mapping 100 101-102
 
 interface g0/2
  description Isolated
  switchport mode private-vlan host
  switchport private-vlan host-association 100 101
 
 interface g0/3
  description Community
  switchport mode private-vlan host
  switchport private-vlan host-association 100 102

Other switch 
 interface g0/4
  switchport mode trunk

Promiscuous PVLAN Trunk Port
 interface g0/5
  switchport private-vlan trunk allowed vlan 100-103
  switchport private-vlan mapping trunk 103 130-135
  switchport mode private-vlan trunk promiscuous
Notera att primary vlan ska vara med i allowed vlan list. Om man har t.ex. en [[Cisco_ASA|ASA]] kan man köra med en vanlig switchport mode trunk om man vill för ASA har native stöd för PVLAN.

SVI
 interface Vlan100
  ip address 10.0.0.1 255.255.255.0
  private-vlan mapping 101,102

Verify
 show vlan private-vlan
 show interfaces vlan100 private-vlan mapping
 ping 255.255.255.255

=Q-in-Q=
Med IEEE 802.1Q tunneling kan man bygga en simpel L2 VPN genom att dubbeltagga Ethernet-frames. 

prereq
 system mtu 1504
 reload
 show system mtu
Port
 switchport mode dot1q-tunnel
 l2protocol-tunnel cdp
Verify
 show dot1q-tunnel

Dubbeltaggning på router
 int gi2
  mtu 1504
 int gi2.10
  encapsulation dot1q 10 second-dot1q 100,101

=Bridging=
Med bridging kan man ändra en routers beteende att bli mer likt hur en switch fungerar. För IOS-XE se längre ner.

'''Transparent''' &lt;br/&gt;
Routern blir precis som en L2-switch, dvs ingen IP routing och [[Cisco_STP|STP]] används för loop prevention.
 no ip routing
 bridge 1 protocol vlan-bridge
 
 interface gi0
  bridge-group 1
 interface gi1
  bridge-group 1
Verify
 show bridge

'''CRB''' &lt;br/&gt;
Transparent bridging har en stor nackdel, en router kan inte både routa paket och brygga interface, därför finns Concurrent Routing and Bridging som tillåter både routing och bridging samtidigt. Dock inte på samma interface-grupper.
 bridge crb
 ip routing
 
 bridge 1 protocol vlan-bridge
 
 interface gi0
  bridge-group 1
 interface gi1
  bridge-group 1
Verify
 show bridge

'''IRB''' &lt;br/&gt;
En nackdel med CRB är att det inte går att koppla ihop en routed domain med en bridged domain inom samma enhet, därför finns Integrated Routing and Bridging. Då skapas Bridge Group Virtual Interface (BVI) som fungerar som SVI på L3-switchar. 

Prereqs &amp; Configuration
 bridge irb
 ip routing
 
 bridge 1 route ip 
 bridge 1 protocol vlan-bridge
 
 interface gi0
  bridge-group 1
 interface gi1
  bridge-group 1
 interface bvi1
  ip address 10.0.0.10 255.255.255.0
Verify
 show bridge

'''Fallback Bridging''' &lt;br/&gt;
Fallback Bridging används för att brygga icke-routebara protokoll mellan SVIer och routade interface. Ett protokoll kan routas medans det andra bryggas, t.ex. IPv4 kan routas medans IPv6 bryggas. 
 bridge 1 protocol vlan-bridge
 
 interface Gi0/2
  no switchport
  ip address 10.0.2.10 255.255.255.0
  bridge-group 1
 
 interface Vlan10
  ip address 10.0.10.10 255.255.255.0
  bridge-group 1

'''IOS-XE''' &lt;br/&gt;
På IOS-XE görs bridging med bridge domains och Ethernet flow points (EFP).
 interface gi0/0/1
  service instance 1 ethernet
   encapsulation untagged
   bridge-domain 1
 
 interface gi0/0/2
  service instance 1 ethernet
   encapsulation untagged
   bridge-domain 1
   l2protocol peer stp
   mac limit maximum addresses 50
 
 interface bdi1
  ip address 10.0.0.10 255.255.255.0

Verify
 show bridge-domain

[[Category:Cisco]]</text>
      <sha1>a1kqn9lm1xzmuegtk9s4rboat3fdu7u</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco VSS</title>
    <ns>0</ns>
    <id>142</id>
    <revision>
      <id>2994</id>
      <parentid>2977</parentid>
      <timestamp>2019-06-25T10:36:28Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5266">Virtual Switching System används för att göra två stycken fysiska switchar till en logisk enhet. Fysiskt är det två switchar och man kan dra allt kablage redundant. Med detta behöver man inte använda [[Cisco_HSRP|HSRP]] eller [[Cisco_FHRP|VRRP]] samt att L2-topologin går att hålla loopfri. En fördel är att det blir färre manageringspunkter, en nackdel att ett fel kan få större blast radius. VSS har stöd för [[Cisco_EtherChannel|EtherChannel]] så detta är en variant av MLAG. När switcharna bootar upp använder de Link Management Protocol (LMP) och Role Resolution Protocol (RRP) för att förhandla om vem som ska vara active och således blir den andra standby. Båda switcharna står för data plane men endast den aktiva står för management och control plane. Mellan switcharna har man en Virtual Switch Link som all sorts trafik går på, däremot har control plane och management högre prio på denna länk. Denna bör dimensioneras kraftigt.

== Installation ==
Man behöver 2st cisco 4500-x, 4500-e eller 6500-e. I e-modellerna så behövs Cisco Catalyst Supervisor Engine 7-E eller 7-LE men i x-modellerna är den inbyggd.

== Konfiguration ==
sätt Virtual Switch domain samt switch nummer
 SW1#conf t
 Enter configuration commands, one per line. End with CNTL/Z.
 SW1(config)#switch virtual domain 10
 Domain ID 10 config will take effect only
 after the exec command 'switch convert mode virtual' is issued
 SW1(config-vs-domain)#switch 1
 SW1(config-vs-domain)#exit
 SW1(config)#

 SW2#conf t
 Enter configuration commands, one per line. End with CNTL/Z.
 SW2(config)#switch virtual domain 10
 Domain ID 10 config will take effect only
 after the exec command 'switch convert mode virtual' is issued
 SW2(config-vs-domain)#switch 2
 SW2(config-vs-domain)#exit
 SW2(config)#

Konfigurera VSL Port Channel
 SW1(config)#int port-channel 5
 SW1(config-if)#switchport
 SW1(config-if)#switch virtual link 1
 SW1(config-if)#no shut
 SW1(config-if)#exit
 *Jan 24 05:19:57.092: %SPANTREE-6-PORTDEL_ALL_VLANS: Port-channel5 deleted from all Vlans

 SW2(config)#int port-channel 10
 SW2(config-if)#switchport
 SW2(config-if)#switch virtual link 2
 SW2(config-if)#no shut
 SW2(config-if)#exit
 SW2(config)#
 *Jan 24 05:14:17.273: %SPANTREE-6-PORTDEL_ALL_VLANS: Port-channel10 deleted from all Vlans

Konfigurera VSL portarna
 SW1(config)#int range gig7/3 - 4
 SW1(config-if-range)#switchport mode trunk
 SW1(config-if-range)#channel-group 5 mode on
 WARNING: Interface GigabitEthernet7/3 placed in restricted config mode. All extraneous configs removed!
 WARNING: Interface GigabitEthernet7/4 placed in restricted config mode. All extraneous configs removed!
 SW1(config-if-range)#exit

 SW2(config)#int range gig4/45 - 46
 SW2(config-if-range)#switchport mode trunk
 SW2(config-if-range)#channel-group 10 mode on
 WARNING: Interface GigabitEthernet4/45 placed in restricted config mode. All extraneous configs removed!
 WARNING: Interface GigabitEthernet4/46 placed in restricted config mode. All extraneous configs removed!
 SW2(config-if-range)#exit

Switcha över till VSS från vanlig
 SW1#switch convert mode virtual 

 SW2#switch convert mode virtual 

Kolla så att det fungerar
 SW1#show switch virtual 
 
 Executing the command on VSS member switch role = VSS Active, id = 1 
 
 Switch mode                  : Virtual Switch
 Virtual switch domain number : 10
 Local switch number          : 1
 Local switch operational role: Virtual Switch Active
 Peer switch number           : 2
 Peer switch operational role : Virtual Switch Standby 
 
 Executing the command on VSS member switch role = VSS Standby, id = 2  
 
 Switch mode                  : Virtual Switch
 Virtual switch domain number : 10
 Local switch number          : 2
 Local switch operational role: Virtual Switch Standby
 Peer switch number           : 1
 Peer switch operational role : Virtual Switch Active

=== Dual-Active Detection ===
Förhindra att båda supervisors blir aktiva vid VSL link failure.

 switch virtual domain 10
  dual-active detection fast-hello
 
 interface te1/1/24
  description VSS Fast-Hello
  no switchport
  no ip address
  no cdp enable
  dual-active fast-hello
  no shut
Verify
 show switch virtual dual-active fast-hello

=== Felsökning ===
 show switch virtual 
 show switch virtual role
 show switch virtual link

'''Giants''' &lt;br/&gt;
Om man ser giants counter gå upp på VSL interface så är det normalt eftersom VSL inter-switch 
control frame packets skickas som 1518 bytes + 32 byte DBUS header mellan switcharna.  

=== Tips N Trix ===
Man kan använda sig av 10ge interface också och inte enbart 1ge som står i guiden. Kommando för att byta vilken switch som är aktiv.
 redundancy force-switchover

=StackWise=
För de lite mindre switchmodellerna finns StackWise för att koppla ihop flera enheter till en logisk. Switcharna kopplas ihop med speciella StackWise-kablar på baksidan. Man väljer en switch som man konfigurerar som master och sedan kopplar man ihop dem och bootar upp dem.
 switch 1 priority 15

Kolla status på stacken
 show switch
 show switch stack-bandwidth
 show switch stack-mode

Firmware
 software auto-upgrade enable

Reset the switch mode to N+1
 switch clear stack-mode

[[Category:Cisco]]</text>
      <sha1>10rqb3dnuk9igvj3wbw2hm95hjjm7db</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco VTP</title>
    <ns>0</ns>
    <id>149</id>
    <revision>
      <id>2812</id>
      <parentid>2276</parentid>
      <timestamp>2018-08-13T12:12:12Z</timestamp>
      <contributor>
        <username>Zunken</username>
        <id>3</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8923">VTP står för VLAN Trunking Protocol men tänk VLAN Management Protocol då det används för att managera VLAN-databaser på flera switchar centralt från en switch. Det går endast över ISL/802.1q-länkar så trunk mellan switcharna är ett måste. VTP annonserar VLAN ID, namn, typ och tillstånd men dock inget om vilka portar som tillhör vilket VLAN. VTP jobbar med revisionsnummer för att veta vilka databas som är korrekt uppdaterad, högre revisionsnummer vinner. 
Se även [[Cisco_VLAN|Cisco VLAN]].

''OBS'' VTP har potentialen att sänka en hel L2-miljö på några enstaka sekunder, förstå hur det fungerar och räkna med riskerna.

===Max VTP Vlan===
I varje switchmodell så finns det ett max antal vlan den kan få ifrån servern, slår detta i taket så går switchen in i transparent mode, dvs den tar inte emot nya utan kör på det som finns.
{| class="wikitable"
|-
! Switch
! Max Vlan
|-
| 2960TT,2960S,2960CX
| 255
|-
| 2960CG,2960X,3750
| 1005
|-
|3650
|4096
|}
===Versioner===
VTP finns i version 1, 2 och 3. VTPv1 är default. 

Skillnader mellan v1 och v2.
* Stöd för diverse Token Ring VLAN
* Stöd för unknown TLV records, v1 ignorerar dessa. 
* VLAN-databasen konsistenscheckas ej om ändringen kommer med VTP. Implementation optimization.

==Pakettyper==
Gäller VTPv1 och v2. &lt;br/&gt;
'''Summary advertisements''' &lt;br/&gt;
Skickas av server och client var 5 minut eller vid VLAN-modifikation och innehåller allt utom själva VLAN-databasen. Innehåller VTP domain name, revision number, identity of last updater, time stamp of last update, MD5 sum of VLAN database, VTP password och antalet efterkommande Subset advertisements. 
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_VTP_Summary.png]]
&lt;/div&gt;
&lt;/div&gt;


'''Subset advertisement''' &lt;br/&gt;
Skickas ut efter en VLAN-förändring och innehåller hela databasen. Kan dock behövas flera paket ifall det är en stor databas.
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_VTP_Subset.png]]
&lt;/div&gt;
&lt;/div&gt;


'''Advertisement requests''' &lt;br/&gt;
Skickas av server och client när de vill ha hela VLAN-databasen, t.ex. när de får in en Summary Advertisement med högre revisionsnummer. Skickas även av klienter när de startas om eller blir client.
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_VTP_Request.png]]
&lt;/div&gt;
&lt;/div&gt;


'''VTP join messages''' &lt;br/&gt;
Skickas av server och client var 6 sekund om pruning är påslaget. Berättar om vilka VLAN som är aktiva.
&lt;div class="mw-collapsible mw-collapsed" style="width:250px"&gt;
Exempel:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_VTP_Join.png]]
&lt;/div&gt;
&lt;/div&gt;

=Konfiguration=
 vtp version [version]
Vill man byta vlan.dat kan man göra det, det har bara lokal signifikans.
 vtp file ''filename''
VTP kan stängas av per interface
 no vtp
 show vtp interface
Debug
 debug sw-vlan vtp events
 debug sw-vlan vtp packets

===Domain===
Domän måste vara samma på alla enheter annars ignoreras updates, har man inget domännamn konfigurerat lånar man det som andra sidan skickar med i sina paket (v3 gör ej så). Byt namn på domän för att resetta revision number.
 vtp domain [domain]
 show vtp status

Använd lösenord för att skydda din miljö annars kan t.ex. domäner propagera till switchar automatiskt. Detta skyddar ej mot eavesdropping utan endast mot unauthorized switches. En MD5-summa räknas fram av VLAN-databasen och lösenordet för att sedan skickas med Summary advertisement. Hidden password är VTPv3 only och då hashas lösenordet i vlan.dat också, v1/2 funkar inte ifall det finns ett hidden password konfigurerat.
 vtp password SECRETZ {hidden|secret}
 show vtp password

===Modes===
'''Server''' &lt;br/&gt;
På VTP-servrar skapar, modifierar och tar man bort VLAN, detta propageras sedan ut till klienter och övriga servrar. Detta är default för Cisco IOS men uppdateringar skickas inte förrens VTP domain är konfigurerat. Uppdateringar accepteras från server och client och VLAN sparas i vlan.dat.
 vtp mode server

'''Client''' &lt;br/&gt;
Behöver ej ha VTP domain konfigurerat utan tar det från den första VTP-uppdateringen som tas emot. Dock måste vtp mode client konfigureras. Uppdateringar accepteras från server och client och VLAN sparas i vlan.dat. Eftersom klienter originerar uppdateringar kan en klient med högre revisionsnummer uppdatera databasen på en server.
 vtp mode client

'''Transparent''' &lt;br/&gt;
Enheter i VTP mode transparent släpper igenom VTP frames om VTP domain matchar men behandlar dem aldrig själv, ''VTP LOG RUNTIME: Relaying packet received on trunk Gi0/2 - in TRANSPARENT MODE''. VLAN på dessa enheter sparas lokalt i running config och vlan.dat. OBS transparent mode forwarderar VTP om domain är NULL.
 vtp mode transparent

'''Off''' &lt;br/&gt;
Finns endast med VTPv3 och stänger av VTP-forwarding helt.
 vtp mode off

===Pruning===
VTP pruning erbjuder en dynamisk mekanism som automatisk konfigurerar vilka VLAN som ska tillåtas på trunkar inom VTP-domänen. Slå på pruning för att hindra flooding i alla VLAN till switchar som inte har portar i alla VLAN. För utbyte av information om aktiva VLAN används VTP join messages. VTP pruning kan läras av VTP-klienter, så om man slår på det på en VTP-server och den börjar skicka ut join messages så kommer också klienterna att slå på pruning automatiskt.
 vtp pruning

By default är alla VLAN utom 1 prune eligible. Vill man att endast vissa VLAN ska vara med i VTP pruning kan man lägga dem per trunk i Prune Eligible List.  
 switchport trunk pruning vlan VLAN-RANGE

Verify
 show interface trunk

=VTPv3=
Med VTPv3 introduceras ''primary server'' och det är bara dennes VLAN-databas som får modifieras och skickas ut i domänen. Alla andra servrar blir secondary. Vilken switch som är primary server måste switcharna vara eniga om för att kommunicera. Är switchar oeniga blir det konflikt och ingen databas synkas, '''show vtp devices conflicts'''. Detta minskar ytterliggare risken för att oavsiktligt skriva över en VLAN-databas. 

Skillnader mellan v2 och v3.
* Möjligt att använda krypterade lösenord även i vlan.dat.
* Stöd för private och extended vlan, dvs över 1005. 
* Off mode, alla VTP-meddelanden droppas, globalt eller per interface.
* Stöd för mer än bara VLAN-databassynk, det finns även en instans för [[Cisco_MST|MST]]-konfiguration samt forwarda VTP-frames för UNKNOWN features ifall det hittas på något i framtiden.
* Stöd för att flagga VLAN som [[Cisco_SPAN#RSPAN|RSPAN]], dvs disables MAC learning i VLANet på alla switchar.
* Serverrollen, se nedan.

Bakåtkompabilitet får man när man kör v1/v2 på ena sidan och v3 på den andra då kommer v3 känna av det och återgå till v2 vilket tvingar den första switchen att använda v2-only. v2-sidan kan aldrig uppdatera v3-domänen så allt i v2 bör vara client.

Konfiguration
 vtp domain hackernet.se
 vtp version 3
Skapa VLAN
 vtp mode server
 vlan 100
 ''VTP VLAN configuration not allowed when device is not the primary server for vlan database.''

För att bli primary krävs lösenordet. Primary är endast operational state, det är inget som sparas i running eller startup. 
 vtp primary

Ta primary utan att först kontrollera efter conflicting devices (som annars kan ta lite tid).
 vtp primary vlan force

Verify
 show vtp status
 show vtp devices  #Endast v3-enheter syns
 show vtp counters

===Extended VLANs===
Varje gång man skapar en routed port eller SVI i en L3-switch binds ett VLAN till det interfacet för intern kommunikation till control plane. Detta görs lokalt och kan därmed skilja mellan switcharna i miljön. Detta leder till att om man skapar ett högnummer-VLAN på en VTP server switch utan SVI:er så funkar det bra men det kanske inte skapas på alla switchar även om VTP fungerar som det ska, ''"VLAN_CREATE_FAIL"'' pga "VLAN 1007 currently in use by GigabitEthernet0/3". Vilka VLAN en switch använder till detta beror på global policy i switchen.
 show vlan internal usage

Default är att starta allokering på VLAN 1006 och gå uppåt.
 vlan internal allocation policy ascending
På nyare switchar kan man ändra detta till att starta på vlan 4094 och gå neråt istället.
 vlan internal allocation policy descending

===MST===
[[Cisco_MST|MST]]-konfiguration kan också distribueras med hjälp av VTPv3. Precis som för VLAN får endast ändringar göras på primary server (som ej behöver vara samma som för feature VLAN).
 vtp mode server mst
 vtp mode client mst
''OBS att ändra VTP mode för MST påverkar spanning tree så det bör göras under kontrollerade former.''

Ta primary-rollen
 vtp primary mst 
 vtp primary mst force
Verify
 show vtp status

[[Category:Cisco]]</text>
      <sha1>tlouux809lsiuw5ffjjx5it5gn129c4</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco VXLAN</title>
    <ns>0</ns>
    <id>207</id>
    <revision>
      <id>3006</id>
      <parentid>2843</parentid>
      <timestamp>2019-08-28T11:31:11Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5809">Virtual Extensible LAN (VXLAN) är en network virtualization technology, med andra ord enkapsuleringsteknik (overlay). Det maximala antalet VLAN på ett Ethernet-nätverk är 4094 (IEEE 802.1Q). Med VXLAN höjs denna gräns till 16 miljoner. Ethernet frames enkapsuleras i IP-paket och transporteras med UDP, default UDP destination port är 4789. Tack vare att det är vanliga IP-paket som traverserar fabricen kan alla länkar användas och det finns stöd för ECMP. VXLAN i sig har inget separat control plane utan signalering får skötas av en extern controller, BGP EVPN eller flood and learn. Vid det senare så kommer L2 flooding (unknown unicast, broadcast) att emuleras med multicast och VTEP:arna kommer på så sätt att lära sig vilka MAC-adresser som finns på andra sidan. Detta leder till att VXLAN i sig har ingen inbyggd felisolering så som t.ex. [[Cisco_OTV|OTV]] har. VXLAN har inte stöd för service tags så som t.ex. Geneve har. Ska NX-OS manageras av en third-party controller måste man slå på NXDB. Se även [[Cisco_VLAN|Cisco VLAN]].

==Flood and Learn==
VXLAN Gateway använder sig av Network Virtualization Endpoint (NVE) Interface. För att kunna använda multicast måste man köra [[Cisco_PIM|PIM]] på underlay network. Om man ska enkapsulera frames som är VLAN-taggade måste man ta bort taggen när det skickas VLAN -&gt; VXLAN och sätta på den igen i andra riktningen, se exemplet (BD-oriented mode). 
 interface lo0
  ip address 11.11.11.11 255.255.255.255
 
 interface nve1
  source-interface Loopback0
  member vni 5001 mcast-group 239.0.10.10
 
 interface GigabitEthernet2
  service instance 1 ethernet
   encapsulation dot1q 100
   rewrite ingress tag pop 1 symmetric
 
 bridge-domain 1
  member vni 5001
  member GigabitEthernet2 service-instance 1

'''Unicast''' &lt;br/&gt;
Om man inte kan köra multicast går det lösa med unicast och headend replication (HER). Då konfigurerar man ''member vni'' utan mcast-group och istället pekar ut andra sidan VTEP:s manuellt.
 interface nve1
  ingress-replication 22.22.22.22 

Verify
 show nve vni
 show nve peers
 show bridge-domain 1
 show mac address-table nve

===Nexus===
VXLAN är en vanlig overlay-teknik i datacenter. Underlay ska lösa routing mellan IPv4-loopbacks samt ha stöd för jumbo frames (mtu 9216). Man kan köra IP Unnumbered mellan leaf och spine. UDP port number är 4789, detta går ej att ställa om. ARP suppression är supporterat. För tenants IGMP notera att interface nve1 default är en static mrouter-port. 
 feature nv overlay
 feature vn-segment-vlan-based
 interface nve1
   no shutdown
   source-interface loopback0
Bridge domain med static flood list.
 vlan 100
  vn-segment 10100
 
 interface nve1
   member vni 10100
     ingress-replication protocol static
      peer-ip 10.0.0.3
      peer-ip 10.0.0.4
      peer-ip 10.0.0.5

Verify
 show nve int nve1
 show nve peers
 show nve vni
 show nve vni ingress-replication 

'''Multicast underlay''' &lt;br/&gt;
Ingress replication supporteras på Nexus 9000 men inte Nexus 5600 eller Nexus 7000. Man får då lösa BUM med multicast. Alla noder måste routa multicast. Best practice är att ha RP i spine-lagret. Använd anycast RP för lastdelning samt redundans. Notera att multicast kontra unicast är ett designval som innebär en trade-off mellan control plane scalability och data plane efficiency.

Spine
 ip pim rp-address 10.0.0.100 group-list 224.0.0.0/4 
 ip pim anycast-rp 10.0.0.100 10.0.0.2 
 ip pim anycast-rp 10.0.0.100 10.0.0.3 
 
 show ip mroute

'''Nexus 5600''' &lt;br/&gt;
Nexus 5600 måste köra i store-and-forward switching mode för att supportera VXLAN encapsulation.
 hardware ethernet store-and-fwd-switching
 copy run start
 reload
 show switching-mode

====vPC====
När man kör [[Nexus_vPC|vPC]] med VXLAN måste man sätta en secondary IP address på det loopback som är source för NVE. Denna ska vara samma på både vPC-peers och det är så dom presenterar sig själva som en enda VTEP till remote NVE peers. CFS dubbelkollar att man har gjort rätt. Däremot om peer-linken går ner så kommer loopback primary address att användas som source på de VXLAN-enkapsulerade paketen som skickas iväg. 

vPC Best practice när man kör VXLAN.
 vpc domain 1
  peer-switch
  peer-keepalive destination 10.0.0.2 source 10.0.0.1
  peer-gateway
  ipv6 nd synchronize
  ip arp synchronize

Man bör också sätta upp ett nve-peer-link-vlan för att förhindra suboptimal routing. Detta vlan ska endast tillåtas på trunken som är peer-link. 
 vlan 10
 
 vpc nve peer-link-vlan 10
 
 interface vlan10
  ip router ospf 1 area 0
  ip ospf cost 2
  ip pim sparse-mode
  no shut

==EVPN==
Se [[Cisco_EVPN|Cisco EVPN]].

==GPE==
VXLAN Generic Protocol Extension finns till för att ge VXLAN tillägg såsom OAM och versionsmöjligheter.
 interface Tunnel1 
  ip address 192.168.1.1 255.255.255.0 
  tunnel source GigabitEthernet2 
  tunnel mode vxlan-gpe ipv4 
  tunnel destination 10.0.0.20
  tunnel vxlan vni 12345

==FHRP över VXLAN==
Man kan använda [[Cisco_FHRP|FHRP]]-protokoll tillsammans med VXLAN. De skickar hello packets som då floodas över VXLAN overlayet. Man måste ge tcam till detta, ''hardware access-list tcam region arp-ether 256''. Detta funkar endast med flood and learn VXLAN.
 interface vlan 100
  ip address 192.168.1.2/24
   hsrp 100
    ip 192.168.1.1

==Q-in-VNI==
Endast VXLAN Bridging funkar med Q-in-VNI.
 interface nve1
  overlay-encapsulation vxlan-with-tag
 
 interface ethernet 1/4
  switchport mode dot1q-tunnel
  switchport access vlan 100
  spanning-tree bpdufilter enable
Man kan även släppa över LACPDU:er.
 interface nve1
  overlay-encapsulation vxlan-with-tag tunnel-control-frames lacp
QinQ-QinVNI
 interface Ethernet1/4
  switchport trunk allow-multi-tag

[[Category:Cisco]]</text>
      <sha1>ffkp8hz28l347al8x46doj1yv11823r</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco WAN</title>
    <ns>0</ns>
    <id>245</id>
    <revision>
      <id>2638</id>
      <parentid>2596</parentid>
      <timestamp>2017-09-22T07:21:19Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6644">Den vanligaste L2-tekniken nuförtiden är Ethernet men det finns andra.

=HDLC=
Ciscos implementation av HDLC har ett 2-byte stort Type-fält som gör det properitärt, detta för att stödja multipla protkoll över HDLC-länkar. HDLC är default enkapsulering på seriella interface på Cisco-routrar och keepalives skickas default var 10:e sekund. DCE-änden av kabeln står för clockrate. 

DCE eller DTE?
 show controllers serial 0/0

HDLC är default.
 interface serial 0/0
  encapsulation hdlc
 show interface serial 0/0

=PPP=
PPP använder likadan header som ursprungs HDLC men har ett Protocol-fält så det blir i princip Cisco HDLC. Det har dessutom fler features. PPP använder kontrollprotokoll för L2 och L3. För L2 heter dessa Link Control Protocol (LCP) och för L3 heter de Network Control Protocol (NCP). Ett exempel på PPP NCP är IPCP för IP och möjliggör dynamic address assignment. När LCP har förhandlat klart om Link Quality Monitoring, Looped link detection, LB/MLPPP och autentiseringsmetoder och sett resultat av dessa tar NCP vid. 

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
LCP Request:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_WAN_LCP_Request.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
LCP Ack:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_WAN_LCP_Ack.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
IPCP Request:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_WAN_IPCP_Request.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
IPCP Ack:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_WAN_IPCP_Ack.png]]
&lt;/div&gt;
&lt;/div&gt;

 interface serial 0/0
  encapsulation ppp
 show interface serial 0/0

LQM ställs med:
 ppp quality &lt;%&gt;

Peer neighbor route är en PPP feature som låter connected interfaces som inte är på samma subnät att kommunicera. Detta är användbart t.ex. när man använder ip unnumbered interfaces på PPP-länken men kan stängas av om interfacen befinner sig på samma subnät. Detta är påslaget default på Cisco IOS när man använder PPP-enkapsulering.
 interface &lt;ppp-interface&gt;
  no peer neighbor-route

===Authentication===
PPP har bl.a. stöd för PAP, CHAP, MS-CHAPv1/v2 och EAP.

PAP
 username R2 password SECRET
 
 interface serial 0/0
  ppp authentication pap
  ppp pap sent-username R1 password SECRET

CHAP, default används routerns hostname som username.
 username R2 password SECRET
 
 interface serial 0/0
  ppp authentication chap
  ppp chap hostname R1
  ppp chap password SECRET

Använd andra metoden som fallback genom att ange dem på samma rad.
 ppp authentication chap pap
Troubleshoot
 debug ppp authentication

===Compression===
Det finns två typer av compression, layer 2 payload compression och TCP/RTP header compression. Payload compression funkar bäst med stora paket medans header compression funkar bäst med små paket. L2 payload compression kan göras med ''stacker'', ''MPPC'' eller ''predictor''. De första två använder lite mer CPU men brukar resultera i bättre ratio.
 compress predictor

TCP Header. Detta är legacy-metoden för att konfigurera det, man kan också använda [[Cisco_QoS#MQC|MQC]].
 ip tcp header-compression

Encryption
 ppp encrypt mppe 40 required
Verify
 show compress details
 show ppp mppe

===MLPPP===
Multilink PPP är en teknik för att L2-lastdela på två eller fler parallella seriella länkar. MLPPP fragmenterar frames och skickar dem över olika länkar. 
 interface multilink1
  encapsulation ppp
  ppp multilink
  ppp multilink group 1
 
 interface serial 0/0
  encapsulation ppp
  ppp multilink
  ppp multilink group 1

Verify
 show ppp multilink
 show interface multilink1

'''Interleaving''' &lt;br/&gt;
För att förhindra att små delay-känsliga paket hamnar bakom stora paket som tar lång tid att serialisera kan man använda LFI. Det är ett Cisco QoS tool som gör att de små paketen kan skickas mellan fragmenten av de stora paketen. 
 interface multilink1
  ppp multilink fragment-delay 10
  ppp multilink interleave

=PPPoE=
PPPoE (RFC 2516) är enkapsulering av PPP över ethernet och används mest i gamla DSL-tjänster. Det använder en ethernet-baserad discovery-funktion för att klient ska hitta till server. PPPoE har inte support för MLPPP.

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
Initiation (broadcast):
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_WAN_PPPoE_PADI.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
Offer:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_WAN_PPPoE_PADO.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
Request:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_WAN_PPPoE_PADR.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
Session-confirmation:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_WAN_PPPoE_PADS.png]]
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="mw-collapsible mw-collapsed" style="width:270px"&gt;
Termination:
&lt;div class="mw-collapsible-content"&gt;
[[File:Cisco_WAN_PPPoE_PADT.png]]
&lt;/div&gt;
&lt;/div&gt;

När MAC-adressen för servern är känd och sessionen är upprättad kan PPP ta vid. 

===Server===
På ethernet-interfacen behöver man inte ha någon IP-adress alls eftersom discovery-funktionen är ethernet-baserad.
 bba-group pppoe global
  virtual-template 1
  sessions per-mac limit 2
 
 interface gi2
  no ip address
  pppoe enable group global
 
 interface virtual-template 1
  ip address 192.168.0.1 255.255.255.0
  peer default ip address pool PPPoE
 
 ip local pool PPPoE 192.168.0.10 192.168.0.20

===Klient===
PPPoE-klienter bör ha MTU 1492 på sina dialer interface för att undvika fragmentering på ethernet-interface eftersom PPPoE lägger på 8 bytes header. Man kan använda statiska ip-adresser, ip unnumbered eller dynamiska med hjälp av IPCP på PPP-interfacet.
 interface Fa0/1
  no shut
  pppoe enable 
  pppoe-client dial-pool-number 1
 
 interface Dialer1
  ip mtu 1492
  ip tcp adjust-mss 1452
  encapsulation ppp
  ip address negotiated   ''#IPCP''
  dialer pool 1

Verify
 show pppoe summary
 show ppp all
 show pppoe session
 show derived-config interface virtual-access1.1

'''Default route''' &lt;br/&gt;
PPP kan dynamiskt installera en default route när IPCP-förhandlingen lyckas och ta bort den igen när dialer-interfacet går ner. Denna route är en static route och får därmed AD 1 så det går ej att trumfa den.

 interface Dialer1
  encapsulation ppp
  ppp ipcp route default

'''SNMP'''
 snmp-server enable traps pppoe

[[Category:Cisco]]</text>
      <sha1>bkws931vtvfg1i201dn6lt66mb6jd3n</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco Wireless</title>
    <ns>0</ns>
    <id>83</id>
    <revision>
      <id>2686</id>
      <parentid>1124</parentid>
      <timestamp>2017-11-30T09:24:31Z</timestamp>
      <contributor>
        <username>Zunken</username>
        <id>3</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1416">
==WLC Discovery==
# Broadcast
# DNS
# DHCP option 43
# Hardcoded
# Previous WLC

==IP helper==
 ip forward-protocol udp 5246
 ip helper [WLC-IP]

==AP Join Troubleshooting==
# Layer 3 connectivity (ping)
# AP Policy
# Controller time in relation to AP cert
# regulatory domain
# license limit
# AP model not supported on WLC version
# Mesh APs - AP Auth
# no AP Manager
== Tips N Trix ==
Om accesspunkt inte kopplar upp sig via DHCP eller dns så måste man hårdkoda WLCn då det är en bugg i den firmwaren som skickas med men uppgraderas när den får kontakt med WLC
 "Capwap AP controller IP address x.x.x.x" Där x.x.x.x är IP adressen på din WLC
Om du har en MESH ap så måste du lägga till en exception i WLCn för den skall koppla upp sig. Tex 1532E
 Security-&gt;AAA-&gt;AP policys där under lägger du in macadressen på APn sen får man gå in på den under Monitor-&gt; Detail all APs-&gt; sen den valda APn och byta från Bridge mode till Local så fungerar den som en vanlig 
 accesspunkt igen. Där under kan du också byta namn på den.
Om du vill Byta aktiv WLC i ett HA cluster använder du kommandot:
 Redundancy force-switchover
Lägg till radius server (webgui)
 Logga in på WLC sen Security-&gt;AAA-&gt;Radius-&gt;Authentication där fyller du i IP adressen till din radius server samt den PREshared key du använder dig av.
Se hur redundansen ser ut på enheten
 show redundancy summary

[[Category:Cisco]]</text>
      <sha1>ko9azv2fz8adg67740ygmgr6qpjk1a9</sha1>
    </revision>
  </page>
  <page>
    <title>Cisco pyATS</title>
    <ns>0</ns>
    <id>562</id>
    <revision>
      <id>3143</id>
      <timestamp>2022-01-18T11:59:43Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Cisco pyATS är ett testing framework skrivet i python. Det kan användas för att ta en snapshot på "state" i nätverket. pyATS ssh:ar runt och samlar in show-kommandon ifr..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="708">Cisco pyATS är ett testing framework skrivet i python. Det kan användas för att ta en snapshot på "state" i nätverket. pyATS ssh:ar runt och samlar in show-kommandon ifrån nätinfrastrukturen.

== Setup ==
Installera
 pip install pyats[full]
Skapa ett inventory, även kallat testbed.
 pyats create testbed interactive --output testbed1.yml --encode-password

== Diff ==
 pyats learn ospf interface routing pim mcast vrf ntp arp vlan config --testbed-file=aci_ipn.yml --output=before_change
 
 **make change to network**
 
 pyats learn ospf interface routing pim mcast vrf ntp arp vlan config --testbed-file=aci_ipn.yml --output=after_change
 
 pyats diff before_change after_change

[[Category:Cisco]]</text>
      <sha1>ntskcgg58mtwgrv0khu0vec1siw4of4</sha1>
    </revision>
  </page>
  <page>
    <title>Clogin</title>
    <ns>0</ns>
    <id>186</id>
    <revision>
      <id>1435</id>
      <parentid>1147</parentid>
      <timestamp>2016-01-13T09:03:23Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1042">Clogin är ett script som används för inloggning på Ciscoenheter. Det är en komponent för [[Rancid]]. 

=Installation=
 sudo apt-get -y install rancid

=Förberedelser=
Kopiera clogin till ditt hem-directory, t.ex. cp /var/lib/rancid/bin/clogin ~/

cloginrc
 cd &amp;&amp; nano .cloginrc
 #add autoenable * 1
 add method * ssh
 add user * cisco
 add password * cisco cisco
Skydda filen så gott det går
 chmod 600 .cloginrc

Script
 nano clogin-execute.sh
 #!/bin/bash
 for line in $(cat device-iplist.txt | grep -v '#')
 do
 /home/$USER/clogin -x commands.txt $line
 done
Rättigheter
 chmod +x clogin-execute.sh

=Konfiguration=
Lista vilka enheter kommandona ska köras på.
 nano device-iplist.txt
 # Kommentera ut med #
 10.0.0.100
 10.0.0.101
 #10.0.0.102
 ...

Lista vilka kommandon som ska köras på varje enhet. Exempel, skapa vlan.
 nano commands.txt
 show vlan id 50 | i 50
 conf t
  vlan 50
   name Vlan50
   mode fabricpath
  exit
 exit
 show vlan id 50 | i 50
 wr
 exit

Exekvera scriptet
 ./clogin-execute.sh

[[Category:Cisco]]</text>
      <sha1>e1h6otlhw3rgj8p6tlf0iencljc9pfh</sha1>
    </revision>
  </page>
  <page>
    <title>Cron</title>
    <ns>0</ns>
    <id>79</id>
    <revision>
      <id>563</id>
      <parentid>537</parentid>
      <timestamp>2015-06-16T09:34:47Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1031">Cron är det generella namnet på den service som kör schemalagda jobb och är ett klassiskt verktyg inom UNIX oxh Linuxvärlden. Med cron kan man automatisera återkommande uppgifter. Crond är namnet på daemonen som körs i bakgrunden.

===Crontab===
Cron tables är filer som läses av crond och innehåller de schemalagda jobben. Detta kan även kallas cronjobs. Den generella formen för crontab:
 minute hour day-of-month month day-of-week  command
Visa aktuella cronjobs för nuvarande användare
 crontab -l
Editera cronjobs
 crontab -e

===Output===
Cron skickar per default output från jobben till användarens mailbox, t.ex. output som annars skickas till stdout. Vill man slippa detta kan man skicka outputen till /dev/null. 
 &gt;/dev/null
Vill man även slippa error-output till sin mailbox kan man ignorera allt.
 &gt;/dev/null 2&gt;&amp;1

===Access Control===
För att styra vilka som får schemalägga jobb kan man skriva användarnamn i följande filer:
* /etc/cron.d/cron.allow
* /etc/cron.d/cron.deny

[[Category:Tools]]</text>
      <sha1>82c1b8j8uy0uftf9p45shovlxl9y6zy</sha1>
    </revision>
  </page>
  <page>
    <title>Cumulus EVPN</title>
    <ns>0</ns>
    <id>513</id>
    <revision>
      <id>2810</id>
      <parentid>2772</parentid>
      <timestamp>2018-08-13T10:20:44Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4685">Ethernet VPN (RFC 7432) är en modernare variant än [[Cisco_VPLS|VPLS]] för att tillhandahålla Ethernet multipoint services över IP (VXLAN) eller MPLS utan att behöva en central controller. EVPN är en adressfamilj i BGP som används för peer discovery och för att distribuera lokala MAC-adresser och MAC/IP bindings till andra tunnel endpoints. Man använder både L2 och L3 forwarding information och det fungerar ihop med externa IP-prefix. Next-hop i EVPN-uppdateringarna är antingen egress Label Switch Router eller VXLAN Tunnel Endpoint. EVPN skalar bra och har bl.a. features för att hålla koll på hostar som flyttar mellan datacenter (sekvensnummer-community i annonseringarna) och kan då konvergera snabbt. Ett EVPN-nätverk kan göra både bridging och routing och har inbyggd support för multi-tenancy (VPN). 

Protokollet är öppet så det finns interoperability med andra network vendors, se t.ex. [[Arista_EVPN|Arista]], [[Cisco_EVPN|Cisco]] och [[Quagga#EVPN|Quagga]] EVPN. 

=Konfiguration=
EVPN kan konfigureras på olika sätt beroende på hur designen ser ut. Denna artikel har fokus på VXLAN för data plane encapsulation.

===Underlay===
Underlay routing kan göras med IGP, iBGP eller eBGP. Alla VTEP:s måste kunna nå varandra. Simpelt exempel:

 net add loopback lo ip address 1.1.1.1/32
 net add ospf redistribute connected
 net add ospf network 0.0.0.0/0 area 0

===Overlay===
EVPN-peering kan göras både med iBGP och eBGP, det är designen som avgör. Om man kör eBGP mellan leaf och spine får inte spine ändra next-hop i EVPN-uppdateringarna. Man kan välja att alla lokala VNI:er ska annonseras med BGP.
 net add bgp autonomous-system 65000
 net add bgp neighbor 172.16.0.2 remote-as 65000
 net add bgp neighbor 172.16.0.2 update-source lo
 net add bgp l2vpn evpn neighbor 172.16.0.2 activate
 net add bgp l2vpn evpn advertise-all-vni

EBGP EVPN
 net add bgp bestpath as-path multipath-relax

Show
 net show bgp evpn summary

====Bridging====
På varje leaf switch mappas local VLAN till ett VNI (VLAN-based mode). Man bör disablea data plane MAC learning eftersom EVPN tar hand om att utbyta mac-adresser mellan VTEP:s. VNI membership utbyts mellan VTEP:s med hjälp av EVPN type-3. RD/RT-derivering samt import och export görs automatiskt.

 net add vlan 100
 
 net add vxlan VNI100 vxlan id 10100
 net add vxlan VNI100 vxlan local-tunnelip 1.1.1.1
 net add vxlan VNI100 bridge access 100
 net add vxlan VNI100 bridge learning off
 net add vxlan VNI100 mtu 9216

Show
 net show evpn vni
 net show bridge macs

====L3====
Cumulus kan göra både symmetric och asymmetric VXLAN-routing och har stöd för L3 multi-tenancy. För asymmetric mode behövs ingen mer konf än att man per tenant skapar ett anycast SVI på alla leaf. För symmetric mode routing behöver BGP en 1-till-1 mappning mellan L3VNI och tenant-VRF, detta måste vara samma överallt. Man installerar mac-adresser för remote VTEP:s samt genererar RMAC lokalt med ett "dummy"-SVI per switch. RT-import och export görs automatiskt utifrån ASN och VNI.

Distributed symmetric routing

 net add vrf Tenant1
 
 net add vxlan VNI30001 vxlan id 30001
 net add vxlan VNI30001 bridge access 2301
 net add vxlan VNI30001 vxlan local-tunnelip 1.1.1.1
 net add vxlan VNI30001 bridge learning off
 net add vxlan VNI30001 bridge arp-nd-suppress on
 net add bridge bridge ports VNI30001
 
 net add vlan 2301 vrf Tenant1
 net add vrf Tenant1 vni 30001

Show
 net show evpn vni
 net show evpn rmac vni all

'''Anycast GW'''
 net add vlan 100 ip address-virtual 00:00:11:11:22:22 10.0.0.1/24
 net add vlan 100 vrf Tenant1

'''ARP/ND Suppression''' &lt;br/&gt;
Man kan låta en lokal ARP-proxy hantera requests för att suppressa ARP flooding över VXLAN så mycket som möjligt. MAC+IP address advertisement behövs för ARP suppression.
 net add vxlan VNI100 bridge arp-nd-suppress on
Show
 net show evpn arp-cache vni all

'''Type-5 Routes''' &lt;br/&gt;
Prefix-based routing används primärt för destinations utanför DC. EVPN-routes har L3-VNI och RMAC enligt symmetric routing model.
 net add bgp vrf Tenant1 autonomous-system 65000
 net add bgp vrf Tenant1 l2vpn evpn advertise ipv4 unicast

===MLAG===
Cumulus har stöd för dual-attached hosts i VXLAN active-active mode. Det krävs ingen speciell konfiguration för detta mer än att alla VNI:er måste konfas identiskt och att peerlinken tillhör bridge. MAC synchronization görs inte med EVPN utan med MLAG.

 interface lo
  address 1.1.1.1/32
  clagd-vxlan-anycast-ip 1.1.1.100
Denna anycast-adress sätts som next-hop i de EVPN-uppdaterignar som skickas ut så den adressen måste annonseras i underlay.

[[Category:Cumulus]]</text>
      <sha1>fqnib8h3xy5v4js8scyso53zz0sut36</sha1>
    </revision>
  </page>
  <page>
    <title>Cumulus Linux</title>
    <ns>0</ns>
    <id>510</id>
    <revision>
      <id>2768</id>
      <parentid>2741</parentid>
      <timestamp>2018-04-08T15:10:50Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3169">Cumulus Linux är ett öppet Network OS som man kan köra på white-box switches. Det är baserat på [[Debian]] och man har tillgång till allt som Debian är kapabelt till. Cumulus står för en switch daemon, asic drivers och Network Command Line Utility (NCLU) och kan bootstrapas med ONIE. Routingmotorn i Cumulus Linux är Free Range Routing (FRR) och allt som FRR stödjer fungerar. Default är ARP-timeouten 18 minuter. Cumulus-mjukvaran i sig är gratis att använda men det krävs en licens för att aktivera front-panel interfaces. 

===Cumulus VX===
Cumulus Linux finns som free virtual appliance att ladda ner från Cumulus Networks hemsida. Det finns image för [[KVM]] och [[VMware_ESXi|VMware]]. Se även [[EVE-NG]].

===Architecture===
[[File:Cumulus_Linux_Architecture.PNG]]

==Konfiguration==
Här nedan följer hur man gör grundläggande konfiguration av Cumulus Linux. Är man osäker på hur något konfas kan man alltid kolla exempel med hjälp av '''net example ''&lt;feature&gt;'''''.

Hostname
 net add hostname Cum01

Configuration, kan visas i olika format
 net show configuration
 net show configuration commands

Commit
 net pending
 net commit
 
 net show commit last 
 net show commit history

Switch upgrade
 sudo apt-get update &amp;&amp; sudo apt-get upgrade

Mgmt VRF. Notera att services som syslog, ntp etc default ligger i default-tabellen och måste bindas om ifall de ska nyttja mgmt-vrf:en.
 net add vrf mgmt

Skapa vlan. Cumulus reserverar default vlan 3000-3999 för internal usage men det går att ändra.
 net add vlan 100-200

Access port
 net add interface swp4 bridge access 100

SVI
 net add vlan 100 ip address 192.168.10.1/24

Switchport trunk allowed vlan
 net add interface swp3 bridge vids 200,205

Det spelar inte någon roll vad man väljer att konfigurera först. När man commitar något switchrelaterat så skapas det en global switch (bridge).

Useful show commands
 net show version
 net show interface
 net show bridge vlan
 net show bridge macs

Factory reset, detta rensar ej mgmt vrf.
 net del all

Adding Question Mark Ability to NCLU. Logga ut, logga in för att ändringen ska läsas in.
 sed -i "s/# ?: complete/ ?: complete/g" /home/cumulus/.inputrc

===Prescriptive Topology Manager===
PTM används för att validera att man har kopplat kablar rätt. Man skapar en fil med hur det ska vara kopplat, denna distribuerar man sedan till alla switchar som jämför denna målbild med vilka LLDP-grannskap som finns. På så sätt kan man upptäcka om något har kopplats fel.

===Zero Touch Provisioning===
ZTP görs genom att mgmt-porten (eth0) vid boot ropar efter DHCP option 239. Man pekar ut ett shell script som ska tankas ner och exekveras. Detta kan vara bash, [[Python|python]], perl, ruby vilket ger flexibilitet.

Exempel:
&lt;syntaxhighlight lang="bash"&gt;
#!/bin/bash

#CUMULUS-AUTOPROVISIONING

apt-get update -y

net add vrf mgmt
net commit

exit 0
&lt;/syntaxhighlight&gt;

Ska man aktivera mgmt-vrf bör det göras sist.

Enable ztp on next switch boot.
 sudo ztp -e

Status &amp; Debugging
 sudo ztp -s
 sudo systemctl -l status ztp.service
 sudo ztp -v -r http://192.168.0.50/ztp-script.sh

[[Category:Cumulus]]</text>
      <sha1>oazwfgo8xo7e629jatfikanrpvbc3bw</sha1>
    </revision>
  </page>
  <page>
    <title>DNF</title>
    <ns>0</ns>
    <id>182</id>
    <revision>
      <id>1494</id>
      <parentid>1128</parentid>
      <timestamp>2016-02-07T14:52:19Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="639">DNF är en ersättare för yum. De flesta kommandon är likadana men det finns även lite nya funktioner.
Dokumentation:  http://dnf.readthedocs.org/en/latest/index.html &lt;br/&gt;
Grunder
 dnf search open-vm-tools
 dnf install screen
 dnf remove htop
 dnf info firefox
Repository
 dnf repolist
 dnf repoquery --whatprovides &lt;command&gt;
History
 dnf history list
Rollback
 dnf history undo 7

===System Upgrade===
Uppgradera operativsystemet med hjälp av dnf.
 sudo dnf update --refresh
 sudo dnf install dnf-plugin-system-upgrade
 sudo dnf system-upgrade download --releasever=23  #[[Fedora]]
 sudo dnf system-upgrade reboot

[[Category:Tools]]</text>
      <sha1>t54vsms9nnv61mp642xbg59ghb7kk7g</sha1>
    </revision>
  </page>
  <page>
    <title>Dd</title>
    <ns>0</ns>
    <id>10</id>
    <revision>
      <id>1769</id>
      <parentid>1520</parentid>
      <timestamp>2016-05-12T19:30:56Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1190">dd är verktyp som går att använda för diverse ändamål.

Skriva över en disk med nollor
 dd if=/dev/zero of=/dev/sda bs=1M status=progress

Vissa dd-operationer kan ta lång tid och det finns olika sätt att kolla progress. T.ex. kan man följa det med hjälp av watch-kommandot (i en ny session om man inte la till &amp;-tecken efter dd-kommandot).
 watch 'killall -USR1 dd'

Default intervallet för watch är 2 sekunder, detta går att ställa själv.

==Prestandatester==

Följande exempel är simpla prestandatester som inte säger allt men fungerar som en fingervisning.

===Disk/share===
Write
 dd if=/dev/urandom of=/home/$USER/DDfile bs=1M count=4096 oflag=direct #urandom flaskar
 dd if=/dev/[[frandom]] of=/home/$USER/DDfile bs=1M count=4096 oflag=direct

 dd if=/dev/zero of=/home/$USER/DDfile bs=1M count=4096 oflag=direct
Istället för oflag=direct kan conv=fdatasyn användas.

Read &lt;br/&gt;
''Cachning kan behövas stängas av vid readtesterna.''
 dd if=/home/$USER/DDfile of=/dev/null bs=1M count=4096 iflag=direct

Med detta exemplet skapas det en 4GB stor fil, glöm inte ta bort den efteråt.

===CPU===
 dd if=/dev/zero bs=1M count=1024 | sha512sum

[[Category:Tools]]</text>
      <sha1>stjtw7b5b60r8gpa2vm8pkrqt8g00nv</sha1>
    </revision>
  </page>
  <page>
    <title>Debian</title>
    <ns>0</ns>
    <id>64</id>
    <revision>
      <id>2612</id>
      <parentid>737</parentid>
      <timestamp>2017-08-30T08:18:20Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Pakethanterare */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="975">[[Category:Distar]]
Debian är en dist som är inriktad på stabilitet.

=First 5 minutes=
Debian server installeras med rootkontot som enda kontot. Gör följande för att öka säkerheten. Logga in som root:

===User===
 adduser trevor
 apt-get update &amp;&amp; apt-get install sudo
 usermod -a -G sudo trevor
 sed -i -r 's/PermitRootLogin yes/PermitRootLogin no/g' /etc/ssh/sshd_config
 systemctl restart ssh

===Hostname===
 echo "hostname" &gt; /etc/hostname
 hostname -F /etc/hostname

===Tidszon===
 dpkg-reconfigure tzdata

=Pakethanterare=
[[Apt]]

=Goodies=
Debian Goodies är en uppsättning verktyg som är bra att känna till.
 apt-get install debian-goodies
När man installerar ett nytt paket kan det hända att program som redan körs använder filer som blivit uppgraderade. För att ta reda på detta:
 checkrestart
 checkrestart -v
Vilket installerat paket tar mest plats:
 dpigs
Felsök varför något slutat fungera vid uppdatering
 which-pkg-broke ''packagename''</text>
      <sha1>7zz36lke1n66hqv8dpog5zy2jym7v9b</sha1>
    </revision>
  </page>
  <page>
    <title>Dialog</title>
    <ns>0</ns>
    <id>114</id>
    <revision>
      <id>763</id>
      <timestamp>2015-07-09T13:21:18Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Dialog är ett program som skapar snygga dialogrutor inifrån shell scripts. Det finns t.ex. rutor för yes/no, menu, input, message.   dnf -y install dialog Några exempel p..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="460">Dialog är ett program som skapar snygga dialogrutor inifrån shell scripts. Det finns t.ex. rutor för yes/no, menu, input, message.

 dnf -y install dialog
Några exempel på dialogrutor.
 dialog --textbox /etc/hosts 22 70
 dialog --title "Message" --yesno "Big box?" 19 75
 dialog --infobox "Stuff is happening" 10 30 ; sleep 8
 dialog --inputbox "Enter something:" 8 40 2&gt;answer
 dialog --menu "Choose one:" 10 30 3 1 red 2 green 3 blue

[[Category:Tools]]</text>
      <sha1>97u0yrbzjpzosh8vlnxxqfnvcz2knhx</sha1>
    </revision>
  </page>
  <page>
    <title>Digitala Certifikat</title>
    <ns>0</ns>
    <id>35</id>
    <revision>
      <id>2254</id>
      <parentid>1238</parentid>
      <timestamp>2017-03-05T14:08:22Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Let's Encrypt */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5649">Ett digitalt certifikat är en datafil som består av kryptonycklar. Certifikatet kan användas för kryptering, digitala signaturer och autentisering (OBS ej SSH autentisering). Certifikat utfärdas av en certifikatauktoritet, CA. Den senaste standarden är X.509 version 3&lt;br/&gt;
X509-certifikat används av alla sorts system och hur du hanterar dina certifikat är plattformsoberoende. Här är kort läsning om certifikatshantering på Windows och Red Hat:&lt;br/&gt;
http://techworld.idg.se/2.2524/1.498006/windows-vs-linux---nu-avgors-kampen/sida/5/terminalfunktioner-och-certifikattjanster

Om man inte litar på Microsoft CryptoAPI kan man använda t.ex. OpenSSL för att generera nycklarna och sedan Windowsverktyg för att hantera och signera certifikaten.
Med OpenSSL kan du generera i princip hur stora RSA-nycklar som helst förutsatt att du har en superdator alternativt evigt liv. Hur stora nycklar som går att använda varierar från applikation till applikation, t.ex. OpenVPN klarar inte större än 4096-bitar annars blir meddelandena "för långa".

==Format==
'''DER''' is a binary encoding of a certificate. Typically these use the file extension of .crt or .cer.

'''PEM''' is a Base64 encoding of a certificate represented in ASCII therefore it is readable as a block of text. This is very useful as you can open it in a text editor work with the data more easily.
==Let's Encrypt==
Let’s Encrypt är en certificate authority som är gratis, automatiserad och öppen. Det är ett initiativ av Internet Security Research Group som backas upp av en mängd stora företag där målet är att tillhandahålla TLS helt gratis.
&lt;br&gt;
Läs mer på [[Let%27s_Encrypt|Let's Encrypt]] hur du kan skapa dina egna godkända certifikat.

==Self-signed==
Man kan skapa certifikat och signera dem själv med OpenSSL.
 openssl req -newkey rsa:4096 -nodes -keyout selfsigned.key -x509 -days 3650 -out selfsigned.crt

==XCA==
XCA är ett smidigt och kompetent verktyg för certifikatshantering som kör OpenSSL för den kryptografiska biten. Det jobbar mot en databasfil som är viktig att hålla reda om du inte har backup på dina kryptonycklar. Databasfilen måste också lösenordsskyddas. &lt;br/&gt;
 http://sourceforge.net/projects/xca/

===Egen CA===
Tänk igenom noggrant hur du vill ha det för när rootcertet är skapat och du börjar rulla ut signerade certifikat till servrar och klienter går det inte att ändra något i efterhand!  

Starta xca.exe, skapa en ny databas med File -&gt; New DataBase. Lägg databasen på lämpligt ställe och välj ett säkert lösenord. För att kunna skapa ett certifikat måste man ha kryptonycklar. Dessa kan man importera till databasen eller generera nya med det inbyggda verktyget, Private Keys -&gt; New Key.

Börja med att skapa ett certifikat som ska vara rootcert för din CA. Detta används för att signera dina certifikat och ska distribueras till alla klienter som ska kunna verifiera dina certifikat.

Välj Certificates -&gt; New Certificate. Här ska all information om rootcertet fyllas i. 

====Source====
Ditt rootcert måste vara self signed men kan ha valfritt serienummer.&lt;br/&gt;
Signature algorithm: Valfritt (md5 ej rekommenderat)&lt;br/&gt;
Det följer med en CA-template som är en bra utgångspunkt, Apply all.

====Subject====
 Internal name: Används endast lokalt i din databas, sätt något informativt.
Här kan du välja vad du vill. Nedan är exempel från GeoTrusts rootcert som bland annat har signerat Googles hemsidecertifikat.
 countryName: US
 stateOrProvinceName:
 localityName:
 organizationName: GeoTrust Inc.
 organizationalUnitName
 commonName: GeoTrust Global CA
 emailAddress:

Private key: Välj en befintlig nyckel eller generera en ny

====Extensions====
Det som följer med templaten fungerar bra. T.ex. 10 års validitet.

Det som är viktigt på denna sida är X509v3 Distribution Points och Authority Information Access. Här behövs ett designval göras. Man kan lämna dessa tomma och det fungerar ändå. Den klara nackdelen med det blir att man aldrig någonsin kan göra ett signerat certifikat ogiltigt. Dvs berätta för klienterna att ett certifikat inte ska litas på. Detta kan göras på olika sätt med respektive för och nackdelar.

'''CRL vs OCSP'''
(Arbete pågår, lämnar denna länk sålänge: https://www.fir3net.com/Security/Concepts-and-Terminology/certificate-revocation.html)

====Key usage====
Certificate- och CRL sign fungerar bra. Detta är endast informationsfält så man vet vad certifikatet är tänkt att användas till.

====Netscape====
Allt här kan tas bort. Finns endast med för bakåtkompabilitet med gamla gamla standarder.

====Advanced====
Översikt över ditt certifikat. Kolla igenom så allt är korrekt. 

OK = klart

====Distribution====
Nu kan ditt rootcert börja skickas ut. Du kan exempelvis lägga det på en publik webbserver så kan vem som helst enkelt ladda ner det.

==ECC==
Elliptic Curve Cryptography erbjuder mindre nycklar med liknande säkerhet som traditionell kryptering med öppen nyckel, vilket leder till högre krypteringsprestanda. OpenSSL har stöd för Elliptic Curve Cryptography-certifikat men tyvärr har inte XCA det.&lt;br/&gt;
Working directory
 sudo mkdir /etc/nginx/ssl
Skapa privat nyckel
 sudo openssl ecparam -out /etc/nginx/ssl/nginx.key -name prime256v1 -genkey
Skapa CSR
 sudo openssl req -new -key /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/csr.pem
Nu kan du signera csr:n med ditt rootcert alternativt själv-signera med följande:
 sudo openssl req -x509 -nodes -days 365 -key /etc/nginx/ssl/nginx.key -in /etc/nginx/ssl/csr.pem -out /etc/nginx/ssl/nginx.pem 


[[Category:Guider]]</text>
      <sha1>3n3rbb8qdbzh0i6x5mgg36m7461qb9a</sha1>
    </revision>
  </page>
  <page>
    <title>Distributed Switch</title>
    <ns>0</ns>
    <id>537</id>
    <revision>
      <id>2922</id>
      <timestamp>2019-01-23T20:27:14Z</timestamp>
      <contributor>
        <username>Kessemess</username>
        <id>15</id>
      </contributor>
      <comment>Created page with "vSphere Distributed Switch (vDS) är en mer skalbar variant av virtuell switch som är tillgänglig via Enterprise Plus-licensen.  == Grundläggande om vDS == Till skillnad fr..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="15862">vSphere Distributed Switch (vDS) är en mer skalbar variant av virtuell switch som är tillgänglig via Enterprise Plus-licensen.

== Grundläggande om vDS ==
Till skillnad från vSphere Standard Switchar är Distributed Switcharna just distribuerade mellan de hostar i ett Datacenter som kopplats till dem. Uplinks och Port Groups är därför också automatiskt distribuerade till alla hostar.
För att skapa en vDS, Högerklicka på '''Datacenter'''-objektet -&gt; '''Distributed Switch''' -&gt; '''New Distributed Switch...''', konfigurera därefter grundinställningarna:
# Namn och lokation.
# Version, välj alltid senaste så länge dina hostar har stöd för det.
# Modifiera antalet Uplinks, slå på/av Network IO Control (NIOC) och skapa en default Port Group om så önskas.&lt;br /&gt;


Angående de olika vDS-versionerna, se nedan.
{| class="wikitable"
|-
! Version !! Kompatibilitet !! Nya features/förbättringar
|-
|vDS 6.5.0|| 6.5&lt; || Port Mirroring Enhancements
|-
|vDS 6.0.0|| 6.0&lt; || NIOC v3 och IGMP/MLD Snooping
|-
|vDS 5.5.0|| 5.5&lt; || Traffic Filtering &amp; Marking och förbättrat LACP-stöd.
|-
|vDS 5.1.0|| 5.1&lt; || Management Network Rollback &amp; Recovery, Health Check, Enhanced Port Mirroring och LACP-stöd.
|-
|vDS 5.0.0|| 5.0&lt; || Användardefinierade resurspooler i NIOC, Netflow och Port Mirroring.
|}

För fortsatt konfiguration, klicka på din '''vDS''' -&gt; '''Actions''' -&gt; '''Settings'''. Under '''"Edit Settings"''' kan allt som nämnts ovan ändras. Under samma meny (Settings) finns även nedan inställningar.
* Private VLAN
* Netflow
* Health Check
* Export/Restore configuration

Under Advanced kan MTU, Multicast filtering (Basic eller IGMP/MLD snooping), Discovery protocol (Type: CDP/LLDP/Disabled, Operation: Listen/Advertise/Both) samt Administrator Contact ändras.

För att radera en vDS, ta först bort alla hostar och associerade Uplinks, högerklicka sedan på din '''vDS''' och välj '''Delete'''.

=== dvPort Groups ===
vNetwork Distributed Port Groups kallas portgrupperna som används av en vDS. Lägg till en ny dvPort Group genom att högerklicka på din '''vDS''' -&gt; '''Distributed port group''' -&gt; '''New distributed port group'''. Följ wizarden och konfigurera de olika settings som finns:&lt;br /&gt;

'''Port Binding''' - Styr hur en virtuell port tilldelas till en VM. Det finns tre olika möjligheter.&lt;br /&gt;
* Static Binding: En port tilldelas då VM:en ansluts till dvPort Group:en.&lt;br /&gt;
* Dynamic Binding: Tilldelar en port första gången en VM startar efter den kopplats till dvPort Group. Deprecated sedan 5.5.&lt;br /&gt;
* Ephemeral - no binding: Ingen port binding alls, det går att tilldela en VM till en dvPort Group med Ephemeral port binding även då man är direktansluten till hosten.&lt;br /&gt;

'''Port allocation''' - Hur portar allokeras till en vDS.&lt;br /&gt;
* Elastic - Default 8 portar, när alla portar tilldelats allokeras 8 nya portar till switchen. Denna allokering är default.&lt;br /&gt;
* Static - Default 8 portar, inga nya portar allokeras när de befintliga blivit tilldelade.&lt;br /&gt;

'''Number of ports''' - Antalet portar i dvPort Group:en.&lt;br /&gt;

'''Network resource pool''' - Används för att tilldela dvPort Group till en network resource pool.&lt;br /&gt;

'''VLAN''' - Vilken sorts VLAN-teknik som skall användas:&lt;br /&gt;
* None - Använd inte VLAN (otaggad trafik).&lt;br /&gt;
* VLAN - Använd VLAN, 1-4094 (taggad trafik).&lt;br /&gt;
* VLAN Trunking - Använd VLAN, range:ar tillåts, Virtual Guest Tagging (taggad trafik).&lt;br /&gt;
* Private VLAN - Använd ett Private VLAN som finns på switchen.

För att radera en dvPort Group, se först till att alla virtuella nätverkskort och VMKernel-adaptrar migrerats till en annan portgrupp. '''vDS''' -&gt; '''Networks''' -&gt; '''Distributed Port Groups''' -&gt; Välj '''dvPort Group''' -&gt; i '''Actions'''-menyn, välj '''Delete'''.

=== Uplinks ===
De fysiska NIC (pNIC) som kopplas till vDS:en mappas mot en Uplink, som konfigureras identiskt på samtliga hostar. För att lägga till en Uplink, gå till '''vDS''' -&gt; i '''Actions'''-menyn, välj '''Add and Manage Hosts''' -&gt; '''Manage host networking''' -&gt; '''Next'''. Välj vilket/vilka pNIC som ska mappas mot Uplink:en och tryck '''Assign Uplink'''. Därefter väljer man manuellt vilken Uplink som ska användas, eller '''Auto-assign'''. Efter du tryckt '''Next''' utvärderas om iSCSI kommer att påverkas eller inte.

=== VMkernel Adapters ===
VMkernel Adapters används för olika sorters tjänster/trafik i vSphere, vilka följer nedan:
* vMotion traffic
* Provisioning traffic
* Fault Tolerance (FT) traffic
* Management traffic (HA Heartbeat, namnet är missvisande)
* vSphere Replication Traffic (outgoing)
* vSphere Replication NFC traffic (incoming)
* vSAN traffic
En default VMkernel Port kan endast användas för IP Storage (iSCSI/NFS) och management.

För att lägga till en VMkernel-adapter i en vDS, navigera till din '''vDS''' -&gt; i '''Actions'''-menyn, välj '''Add and Manage Hosts''' -&gt; '''Manage host networking''' -&gt; '''Next'''. Välj '''Manage VMkernel adapters''', och tryck '''Next''' -&gt; '''New Adapter'''. En wizard öppnas:
# Välj '''dvPort Group''' under '''Select target device'''.
# '''Port properties''', här konfigureras '''IP Settings''' (IPv4/IPv6/Båda) samt vilka typer av trafik som tillåts på adaptern (vMotion etc). Det går även att byta TCP/IP-stack (Default, vMotion &amp; Provisioning finns fördefinierade, dock kan fler läggas till via esxcli.
# På nästa sida konfigureras IP-adress &amp; subnätmask.
# En review-sida visas innan du trycker '''Finish'''.

== Konfiguration av vDS ==

==== Koppla host till vDS ====
För att koppla på en host, gå till '''vDS''' -&gt; '''Actions''' -&gt; '''Add and Manage Hosts''' -&gt; '''Add Hosts''' -&gt; '''Next''' -&gt; '''New hosts''' -&gt; '''OK'''. Konfigurera sedan antalet fysiska NIC (pNIC) för Uplinks, migrera VMKernel Adapters och VM Networking.

En host kan även användas som ett slags template för nätverkskonfiguration av andra hostar på vDS:en. I '''Add and Manage Hosts'''-menyn kan '''Configure identical networking settings on multiple hosts''' väljas för att kopiera inställningarna från en host till övriga hostar. Värden som måste vara unika, t ex IP-adresser fylls i som en range, t ex 1.1.1.1#3, så tilldelas de i tur och ordning till hostarna.

==== Ta bort host från vDS ====
Innan en host kan tas bort från en vDS måste alla fysiska adaptrar, VMKernel-adaptrar och VM:ars nätverksadaptrar migreras till en annan switch. Hosten tas sedan bort via '''vDS''' -&gt; '''Actions''' -&gt; '''Add and Manage Hosts''' -&gt; '''Remove Hosts''' -&gt; '''Next''' -&gt; '''Välj host(ar)''' -&gt; '''Finish'''.

==== Migrera VMs till/från vDS ====
Navigera till din '''vDS''' -&gt; i '''Actions'''-menyn, välj '''Add and Manage Hosts''' -&gt; '''Manage host networking''' -&gt; '''Next'''. Välj '''Migrate virtual machine networking''', tryck '''Next''' -&gt; Välj '''Source''' (specific/no network) och '''Destination network''', dvs '''dvPort Group''', '''Next''' -&gt; Välj vilka VMs som ska migreras.


== vDS Policies &amp; Security ==

==== vDS Port Blocking ====
Under '''Edit Settings''' på en dvPort Group, i '''Miscellaneous'''-menyn finns en inställning för '''"Block all ports"'''. Om den ställs in på '''Yes''', kommer samtliga virtuella portar i portgruppen att stängas ned.
Det går även att blockera enskilda portar och Uplinks under '''Networks''' -&gt; Dubbelklicka på en '''dvPort Group'''/'''Uplink''' under '''Distributed Port Groups'''/'''Uplink Port Groups''' -&gt; '''Ports'''-fliken.
# Välj en port i listan.
# Klicka på '''Edit distributed port settings'''.
# Under '''Miscellaneous''', bocka för '''Override'''-rutan och välj om porten ska blockas eller inte.
# '''OK'''.

==== Load Balancing &amp; Failover Policies ====
Förutom lastbalansering för LACP finns även fem olika val för Uplinks och vanliga vSwitchar, de är:
* Route based on IP hash
* Route based on source MAC hash
* Route based on originating virtual port
* Use explicit failover order (ingen LB alls)
* Route based on physical NIC load (endast tillgänglig för vDS)
Failover order använder sig av '''Active''', '''Standby''' och '''Unused'''-status. Om Active-NIC:arna är aktiva kommer de att användas, i kombination med Load balancing-policyn. När inga portar från Active-listan är aktiva längre, kommer portarna i Standby att användas.

De övriga inställningar som finns är:
'''Network Failure Detection''' - Hur ESXi känner av störningar i nätverket.&lt;br /&gt;
'''Link status only''' - Endast det fysiska NIC:ets länkstatus används för att avgöra om nätet anses fungera.&lt;br /&gt;
'''Beacon probing''' - Beacons skickas ut via broadcast varje sekund och registreras av övriga adaptrar. Denna info används tillsammans med länkstatus för att avgöra om nätet fungerar optimalt. Använd inte detta med färre än tre adaptrar i ditt failover team, annars kan inte ESXi avgöra vilken enskild adapter som upplever problem.&lt;br /&gt;
'''Failback''' - Avgör huruvida en nätverksadapter som varit offline ska sättas tillbaka som aktiv igen efter den kommit online. &lt;br /&gt;
'''Notify switches''' - Om detta är påslaget skickas RARP-meddelande ut för att informera de fysiska switcharna om en failover för att de så snabbt som möjligt ska uppdatera sina lookup tables. Detta används även vid vMotion för att minska antalet tappade paket.

==== Private VLAN ====
Private VLAN fungerar "som vanligt", Primary/Promiscuous-VLAN:et innehåller Secondary-VLAN:en som måste skicka sin trafik tillbaks till Primary. Portarna i Secondary VLAN:en är antingen Isolated (kommunicerar bara med Promiscuous-portar, dvs inte med "grann-VM:ar") eller Community (kommunicerar med grann-VMs i samma secondary-VLAN och med promiscuous-portar).

För att använda Private VLAN måste även den fysiska nätverksutrustingen implementera detta korrekt.

==== Traffic Shaping ====
En traffic shaping policy appliceras per port i en portgrupp. Policyn definieras med average bandwidth, peak bandwidth och burst size. På en vDS sker shaping både inkommande och utgående, en standard vSwitch shape:as endast ugående trafik.
'''Average Bandwidth''' - Hur många kbit/s som tillåts på en port, i genomsnitt över tid.&lt;br /&gt;
'''Peak Bandwidth''' - Maximalt antal kbit/s som tillåts vid en trafik-burst.&lt;br /&gt;
'''Burst Size''' - Maximalt antal Kilobyte som tillåts i en burst. När en port vill förbruka mer bandbredd än vad som angetts som Average kommer den att använda denna s k Burst bonus, om den är tillgänglig.

== vDS och LACP ==
Med vDS kommer stöd för LACP och ett antal nya algoritmer för lastbalansering. Högst 64 LAG-grupper kan konfigureras per vDS och en host har stöd för 32 som mest. Som vanligt med LACP konfigureras Active eller Passive Mode. De load balancing modes som finns är:
* Source and destination IP address, TCP/UDP port and VLAN
* Source and destination IP address and VLAN
* Source and destination MAC address
* Source and destination TCP/UDP port
* Source port ID
* VLAN

Endast en aktiv LAG kan användas per dvPort Group, till skillnad från enskilda Uplinks, det går inte heller att blanda LAG:ar med vanliga Uplinks. Att ha andra LAG:ar eller Uplinks som Standby är inte supporterat, utan måste sättas som Unused i Failover Order. Under migrering från Uplinks till LAG är det supporterat att en LAG sätts som Standby före skiftet.

Skapa en LAG via '''vDS''' -&gt; '''Configure''' -&gt; '''Settings''' -&gt; '''LACP''' -&gt; klicka på '''Plustecknet'''.
# Sätt ett namn på LACP-gruppen.
# Ange antal portar.
# Ange Active/Passive Mode för LACP.
# Sätt Load Balancing mode.
# VLAN och NetFlow policies kan överskridas här, om overrides tillåtits på vDS-nivå.
# Klicka OK för att skapa LAG:en.
&lt;br /&gt;
För att flytta dvPort Groups till din LAG, gå till '''vDS''' -&gt; i '''Actions'''-menyn, välj '''Distributed Port Group''' -&gt; '''Manage Distributed Port Groups''' -&gt; Välj '''Teaming and failover''', tryck '''Next'''.
# Välj vilka dvPort Groups som ska använda LAG:en, Next.
# Under Failover Order, sätt LAG:en som Standby, Next.
# En review-sida visas, tryck Finish.
&lt;br /&gt;
Efter detta ska fysiska NIC tilldelas LAG:en; gå till '''vDS''' -&gt; i '''Actions'''-menyn, välj '''Add and Manage Hosts''' -&gt; '''Manage host networking''' -&gt; '''Next''' -&gt; '''Manage physical adapters''' -&gt; '''Next''' -&gt; Tilldela härifrån pNIC:ar till LAG:en från respektive host -&gt; '''OK'''.

Nu återstår bara att gå tillbaks till '''Failover Order''' (se ovan) och flytta LAG:en till '''Active''' och alla övriga Uplinks till '''Unused'''. '''Standby'''-listan ska vara tom efter detta. Efter du tryckt på '''Finish''' kommer trafiken flyttas till LAG:en, detta är non-disruptive.

==== Begränsningar med LACP ====
* Inkompatibelt med iSCSI multipathing.
* Finns inte settings för LACP i Host Profiles.
* Ingen support för Nested ESXi.
* Fungerar inte med ESXi dump collector.
* Port mirroring fungerar inte.

== vDS Auto-Rollback ==
Som ett skydd mot att permanent tappa kontakt med vCenter pga felkonfiguration utförs en rollback av konfigurationen på en vDS om kontakten skulle försvinna efter en ändring. Denna funktion är påslagen per default sedan version 5.1.

Det finns två typer av rollbacks, Host Networking Rollback och vDS Rollback.
En Host Networking Rollback sker då konfiguration ändrats på en host som gör att kommunikationen med vCenter fallerar, exempel på detta:
* Ändring av speed/duplex på pNIC
* DNS-/routing-ändringar.
* Ändring av teaming &amp; failover eller traffic shaping på en port group som innehåller management Vmkernel-adaptern.
* Ändring av VLAN på portgruppen som innehåller management Vmkernel-adaptern.
* Ändringar av MTU på managment Vmkernel-adaptern och dess switch till värden som inte stöds av den fysiska infrastrukturen.
* Ändringar av IP-adressering på management Vmkernel-adaptern.
* Borttagning av management Vmkernel-adaptern från en standard vSwitch eller vDS.
* Borttagning av ett pNIC från en vDS/vSwitch som innehåller management Vmkernel-adaptern.
* Migrering av management Vmkernel-adaptern från vSwitch till vDS.

En Distributed Switch Rollback sker när felaktiga ändringar görs på en vDS, dvPort Group eller dvPort. Exempel på ändringar som kan trigga en rollback:
* Ändring av MTU på vDS-nivå.
* Ändring av Teaming &amp; Failover, VLAN eller Traffic Shaping på dvPort Group:en som innehåller management VMkernel-adaptern.
* Blockering av alla portar i dvPort Group:en som innehåller management VMKernel-adaptern.
Det går också att återfå anslutningen för management via DCUI. Gå till '''Network Restore Options''' -&gt; Välj '''Restore vDS''' -&gt; Konfigurera uplinks och ev VLAN för management-nätet -&gt; '''Apply''':a konfigurationen.
Vad som sker då är att DCUI skapar en lokal ephemeral-port som konfigureras enligt de angivna värdena. VMkernel-adaptern för management-nätet flyttas till den nya porten för att återfå anslutning mot vCenter.

Under vissa omständigheter kan det vara önskvärt att inte ha rollback påslaget, för att slå av rollback gör man följande: navigera till en '''vCenter'''-instans -&gt; '''Configure''' -&gt; '''Settings''' -&gt; '''Advanced Settings''' -&gt; '''Edit''' -&gt; Ändra värdet på '''config.vpxd.network.rollback'''-nyckeln till '''false''' -&gt; '''OK''' -&gt; Starta om vCenter för att applicera ändringen.
Det går också att göra detta via config-filen '''vpxd.cfg''' som ligger under '''C:\ProgramData\VMware\CIS\cfg\''' i Windows-varianten och under '''/etc/''' i appliance-varianten. Under '''&lt;network&gt;'''-elementet, ändra elementet '''&lt;rollback&gt;''' till false.&lt;br /&gt;
&lt;code&gt; 
 &lt;config&gt;
  &lt;vpxd&gt;
   &lt;network&gt;
     &lt;rollback&gt;false&lt;/rollback&gt;
   &lt;/network&gt;
  &lt;/vpxd&gt;
 &lt;/config&gt; 
&lt;/code&gt;&lt;br /&gt;
Spara och stäng filen, och starta om vCenter.

[[Category:VMware]]</text>
      <sha1>90hxfzt3xqvyovj73bno9jdwowrbfij</sha1>
    </revision>
  </page>
  <page>
    <title>Dnstracer</title>
    <ns>0</ns>
    <id>260</id>
    <revision>
      <id>2973</id>
      <parentid>1710</parentid>
      <timestamp>2019-05-02T09:53:29Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="735">Dnstracer är som traceroute fast för dnsuppslag.

=Installation=
Debian/Ubuntu
 apt-get install dnstracer

=Växlar=
*-c
**Stäng av lokal cache.
*-C
**Sätt på negative cache.
*-o
**Visa ett mer lätt läst resultat.
*-q
**Ändra query-class, default är A. Eller nån av följande a, aaaa, a6, soa, cname, hinfo, mx, ns, txt och ptr.
*-r
**Antal dns försök, default 3.
*-s
**Vilken DNS server som ska användas, ifall ingen anges så används systemets DNS server. Om en punkt skrivs så kommer den använda A.ROOT-SERVERS.NET.
*-v
**Verbose output på vad som skickats och tagits emot.
*-4
**Använd bara IPv4 servrar.
*-S
**Ändra vilken source adress som används.

=Exempel=
 dnstracer -o4s . hackernet.se
[[Category:Tools]]</text>
      <sha1>ax5zd1z7j4vxv3xntnpivnyfxmh6xih</sha1>
    </revision>
  </page>
  <page>
    <title>Docker</title>
    <ns>0</ns>
    <id>101</id>
    <revision>
      <id>3138</id>
      <parentid>2895</parentid>
      <timestamp>2021-12-01T11:53:12Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3803">Docker är ett open source-projekt som automatiserar utrullning av applikationer i containers genom att lägga ett extra lager av abstraktion och automatisering av virtualisering på Linux. Docker använder resursisoleringsfunktioner i Linuxkärnan, såsom cgroups och kernel namespace för att tillåta oberoende "containers" att köra i en och samma Linuxinstans. Detta minskar overhead jämfört med virtuella maskiner.&lt;br/&gt;
Mer info: http://www.nkode.io/2014/08/24/valuable-docker-links.html

==Installation==
Fedora 23
 sudo dnf -y install docker-io
Ubuntu 14.04
 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9
 sudo sh -c "echo deb https://get.docker.com/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list"
 sudo apt-get update &amp;&amp; sudo apt-get -y install lxc-docker
'''Alternativt'''
 wget -qO- https://get.docker.com/ | sh

===Starta===
 sudo docker daemon &amp;
Add user till grupp
 sudo usermod -aG docker $(whoami)

==Imagehantering==
Snapshots av containers eller OS-images, t.ex. ubuntu
 sudo docker search ubuntu
 sudo docker pull ubuntu
Visa tillgängliga images
 sudo docker images
Starta en container utifrån en image.
 docker run -i -t ubuntu /bin/bash
För att spara det man har gjort i en image måste man commita
 sudo docker commit [container ID] [image name]
Remove image
 docker image ls
 docker rmi &lt;IMAGE ID&gt;

==Containerhantering==
Kolla aktiva och inaktiva containers.
 sudo docker ps
 sudo docker ps -l
Starta och stoppa en container.
 sudo docker run [container ID]
 sudo docker stop [container ID]
Öppna ett bash skal i en container
 sudo docker exec -it [container namn] bash
Starta och stoppa alla containers:
 docker stop $(docker ps -aq)
 docker start $(docker ps -aq)
Ta bort alla containers:
 docker rm $(docker ps -aq)
Ta bort alla images:
 docker rmi $(docker images -q)

==Inspect==
Med docker inspect kan man få ut info om images och containers. T.ex. IP-adresser, hostname, kommentarer mm.
 docker inspect myself/myimage
 docker inspect container-id
 docker inspect --format "{{ .NetworkSettings.IPAddress }}" $(docker ps -q)

==Clean up==
Städa bort alla stoppade containrar, oanvända networks, dangling images samt dangling build cache. 
 docker system prune
För att även ta bort alla unused images. 
 docker system prune -a

==Dockerfile==
 nano Dockerfile
 sudo docker build -t my_test .  

==registry.hub.docker.com==
Docker Hub är en central punkt för Docker, där hostas offentliga images.&lt;br/&gt;
Vill man ladda upp det man har gjort måste man först regga sig på hemsidan. Sedan kan man pusha imagear.
 sudo docker push username/imagename

==Central hantering==
Central Dockerhantering gör det möjligt att managera images, containers, hostar och övriga Dockerresurser från ett och samma ställe. Exempel på detta är [[Shipyard]], Swarm och [[Rancher]]

==Network==
Fr.o.m version 1.9 finns ''docker network''. Nu använder man Docker Engine för att skapa virtuella nätverk som kan spänna över flera hostar. Overlay görs med VXLAN. 
 docker network --help
 docker network ls
Default finns det 3 nätverk. &lt;br/&gt;
'''Host mode:''' containern kopplas till samma L2-domän som hosten.
 docker run -d --name webb1 --net=host
'''Bridge mode:''' (default) containern hamnar bakom hostens ip och man kan portforwarda. 
 docker run -d --name webb1 -p 8081:80
'''None mode:''' inget nätverk.
 docker run -d --name webb1 --net=none

New bridge network
 docker network create --driver=bridge --subnet=192.168.100.0/24 --gateway=192.168.100.1 --ip-range=192.168.100.128/25 testbridge
IP-adresser till containerar allokeras från rangen.
 docker network connect testbridge webb1

===Overlay===
 docker network create -d overlay --subnet=10.10.0.0/24 testoverlay

[[Category:Guider]]</text>
      <sha1>3lq18ydq48svvndesxdk5wkyfp0suvg</sha1>
    </revision>
  </page>
  <page>
    <title>Dumpcap</title>
    <ns>0</ns>
    <id>183</id>
    <revision>
      <id>1132</id>
      <timestamp>2015-10-19T09:57:45Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Dumpcap är ett network traffic dump tool. Det ingår i wireshark-sviten och är det som används av wireshark och tshark. För att få trafik till dumpcap kan t.ex. en nätve..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="814">Dumpcap är ett network traffic dump tool. Det ingår i wireshark-sviten och är det som används av wireshark och tshark. För att få trafik till dumpcap kan t.ex. en nätverkstapp eller span-port användas. Default filformat är pcap-ng.

===Installation===
 sudo apt-get install wireshark-common
Lista möjliga interface
 sudo dumpcap -D
Exempel, spara data i samma fil under 1h, påbörja sedan nästa fil, upprepa 24 gånger. Dvs ett dygn.
 sudo dumpcap -i eth0 -b duration:3600 -b files:24 -w packets.pcap
Exempel, filesize i kB, sedan ny fil. 5GB totalt.
 sudo dumpcap -i eth1 -b filsize:1000000 -b files:5 -w /pcap/packets.pcap
Se även till att paketdumparna, som kan bli väldigt stora, ligger på ett eget filsystem för att förhindra att diskutrymme tas upp för operativsystemet.

[[Category:Tools]]</text>
      <sha1>esm0y87a46chjfkxb5zttdcrxmj8ed0</sha1>
    </revision>
  </page>
  <page>
    <title>EFI</title>
    <ns>0</ns>
    <id>9</id>
    <revision>
      <id>1721</id>
      <parentid>808</parentid>
      <timestamp>2016-04-28T19:29:32Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="746">EFI gör det möjligt att lägga till och utveckla en rad funktioner som inte är möjligt med ett vanligt BIOS.

efibootmgr: a Linux user-space application to modify the Intel Extensible Firmware Interface (EFI) Boot Manager.

 apt-get install efibootmgr

==Tips n Tricks==
Ändra boot order utan att stänga av maskinen:

Kolla nuvarande boot entries

 efibootmgr -v

Rensa bort nuvarande boot order i EFI NVRAM

 efibootmgr --delete-bootorder

Ta bort oönskade entries

 efibootmgr --delete-bootnum --bootnum 0003

Konfigurera boot menu timeout

 efibootmgr --timeout 10

Konfigurera den ordning du vill ha, t.ex.

 efibootmgr -o 0000,0002,0003,0001

Lägg boot entry högst endast för nästa omstart

 efibootmgr -n 0003

[[Category:Tools]]</text>
      <sha1>mnjg678mt07fvpa12cq0kh9pnzl75mc</sha1>
    </revision>
  </page>
  <page>
    <title>ELK</title>
    <ns>0</ns>
    <id>93</id>
    <revision>
      <id>1250</id>
      <parentid>1244</parentid>
      <timestamp>2015-11-12T12:59:25Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2260">Elasticsearch, Logstash, och Kibana 4 för centraliserad loggning. Det är användbart för att försöker identifiera problem med servrar och program, eftersom det tillåter att söka igenom alla loggar på ett och samma ställe.

'''Elasticsearch''' lagrar alla loggar&lt;br/&gt;
'''Logstash''' är ett open source-verktyg för att samla in loggar. Logstash kan samla loggar av alla slag.&lt;br/&gt;
'''Kibana 4''' är ett webbgränssnitt som kan användas för att söka och visa loggarna som Logstash har indexerat.

==Installation==
''Ubuntu 14.04''&lt;br/&gt;
'''Java'''
 sudo apt-get -y install software-properties-common
 sudo add-apt-repository -y ppa:webupd8team/java
 sudo apt-get update &amp;&amp; sudo apt-get -y install oracle-java8-installer

'''Elasticsearch'''
 wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | sudo apt-key add -
 echo "deb http://packages.elastic.co/elasticsearch/2.0/debian stable main" | sudo tee -a /etc/apt/sources.list.d/elasticsearch-2.0.list
 sudo apt-get update &amp;&amp; sudo apt-get -y install elasticsearch
 sudo sed -i 's/#network.host: 192.168.0.1/network.host: localhost/g' /etc/elasticsearch/elasticsearch.yml

''Init.d''
 sudo service elasticsearch restart
 sudo update-rc.d elasticsearch defaults 95 10

'''Kibana'''
 echo 'deb http://packages.elastic.co/kibana/4.1/debian stable main' | sudo tee /etc/apt/sources.list.d/kibana.list
 sudo apt-get update &amp;&amp; sudo apt-get -y install kibana
 sudo sed -i 's/host: "0.0.0.0"/host: "localhost"/g' /opt/kibana/config/kibana.yml
 sudo update-rc.d kibana defaults 96 9
 sudo service kibana start

'''Nginx'''
 sudo apt-get -y install nginx apache2-utils
 sudo htpasswd -c /etc/nginx/htpasswd.users kibanaadmin
 sudo nano /etc/nginx/sites-available/default

 server {
    listen 80;
    server_name kibana.local;
 
    auth_basic "Restricted Access";
    auth_basic_user_file /etc/nginx/htpasswd.users;
 
    location / {
        proxy_pass http://localhost:5601;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;        
    }
 }
 sudo service nginx restart
http://IP

'''Logstash'''&lt;br/&gt;
Se [[Logstash]]

[[Category:Guider]]</text>
      <sha1>bar13ooq1n8t12vkhiyz1t4h3t82c5c</sha1>
    </revision>
  </page>
  <page>
    <title>ESXi Secure Boot</title>
    <ns>0</ns>
    <id>527</id>
    <revision>
      <id>2857</id>
      <parentid>2856</parentid>
      <timestamp>2018-09-19T16:58:07Z</timestamp>
      <contributor>
        <username>Kessemess</username>
        <id>15</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2477">== Secure Boot ==
ESXi 6.5 har inbyggt stöd för Secure Boot, för att kunna säkerställa att ESXi endast startar med en signerad bootloader. Osignerad kod kan inte heller köras i hypervisorn.
VMware:s implementation består av följande komponenter:
==== Boot Loader ====
Som vid klassisk Secure Boot verifierar UEFI bootloaderns digitala signatur. ESXi:s bootloader är signerad med Microsoft UEFI Public CA och innehåller även en publik VMware-nyckel. Denna nyckel används för validering av VMKernel och ett fåtal systemfunktioner, däribland Secure Boot Verifier, som används för att validera VIB:ar.
==== VMKernel ====
VMKernel är signerad med VMware:s privata nyckel och valideras av bootloadern mha ovan nämnda publika nyckel. Det första VMKernel själv gör är att köra Secure Boot Verifier.
==== Secure Boot Verifier ====
Secure Boot Verifier validerar varje signerad VIB mot VMware:s publika nyckel.

Man kan köra följande skript för att verifiera om Secure Boot kan slås på eller inte:
 /usr/lib/vmware/secureboot/bin/secureboot.py -c

== VIB:ar &amp; Secure Boot ==
Vid uppgradering av vSphere uppdateras VIB:arnas signaturer, så länge de finns med i nyare version bland uppgraderingspaketen. En uppgradering via ESXCLI kommer dock inte att uppgradera bootloadern vilket kommer resultera i fel ifall Secure Boot slås på, den enda workarounden är ominstallation.
Community-VIB:ar kan inte installeras på en host som använder Secure Boot, då de inte signeras. Alla VIB-paket måste vara minst PartnerSupported.
En host som upptäckt en osignerad VIB efter påslagning av Secure Boot kommer att få PSOD med ett meddelande om vilken VIB som orsakat detta. För att lösa problemet måste VIB:en tas bort eller uppdateras till en supporterad version. Secure Boot måste först stängas av i UEFI, ESXi startas sedan för att administratören ska kunna ta bort/uppdatera VIB-paketet. Efter detta slår man på Secure Boot i UEFI igen och startar ESXi.

== Virtuella Maskiner och Secure Boot ==
Det finns vissa krav för att en virtuell maskin ska stödja Secure Boot:
* VMware Tools 10.1 eller senare.
*  Linux-maskiner måste stänga av "VMware Host-Guest Filesystem" i VMware Tools.
*  Virtual Hardware 13 eller senare.
*  OS:et måste ha stöd för UEFI Secure Boot.
För att slå på VM Secure Boot: '''Edit Settings''' -&gt; '''VM Options''' -&gt; ändra '''Firmware''' från "'''BIOS'''" till "'''EFI'''" och tryck '''OK'''.


[[Category:VMware]]</text>
      <sha1>5wt4t893vtsm5ztvdptusoze1yky5ms</sha1>
    </revision>
  </page>
  <page>
    <title>ESXi Security</title>
    <ns>0</ns>
    <id>528</id>
    <revision>
      <id>2858</id>
      <timestamp>2018-09-19T17:25:08Z</timestamp>
      <contributor>
        <username>Kessemess</username>
        <id>15</id>
      </contributor>
      <comment>Created page with "== ESXi Security Hardening == Trots att vSphere 6.5 kommit med många förbättringar på säkerhetssidan finns det en hel del att göra för att öka säkerheten på dina ESX..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3384">== ESXi Security Hardening ==
Trots att vSphere 6.5 kommit med många förbättringar på säkerhetssidan finns det en hel del att göra för att öka säkerheten på dina ESXi:er.

=== Host Profiles ===
Även om de inte ökar säkerheten i sig, är de ett väldigt bra verktyg att använda för att nå eventuella säkerhetskrav. En Host Profile kan ses som en mall som appliceras på en ESXi-host och ändrar de definierade inställningarna i profilen, däribland säkerhetsinställningar.

För att slå på en Host Profile: '''Cluster''' -&gt; '''Manage''' -&gt; '''Settings''' -&gt; '''Configuration''' -&gt; '''Profiles''', tryck på "'''Attach...'''"

=== Security Profile (Firewall &amp; Services) ===
Tillåt endast nödvändiga tjänster när de används, t ex SSH.
För att ändra en brandväggsregel/tjänst: '''Host''' -&gt; '''Configure''' -&gt; '''System''' -&gt; '''Security Profile'''.

En brandväggsregel i ESXi avgör vilka inkommande/utgående portar och protokoll som används för en tjänst, samt status på Daemon:en i ESXi. Vissa tjänster går även att starta/stoppa/starta om via Security Profile. Startup Policy går också att ändra, detta avgör ifall tjänsten startar samtidigt som ESXi, när porten är öppen, eller manuellt.

=== Managed Object Browser ===
MOB används för att utforska objektmodellen i ESXi, vilket kan användas för att utföra skadliga konfigurationsändringar. Sedan 6.0 är MOB avstängt som standard, men behövs för bla att extrahera gamla certifikat.
MOB slås av/på via Advanced System Settings på en Host, värdet som ändras är &lt;code&gt;Config.HostAgent.plugins.solo.enableMob&lt;/code&gt;

== Lockdown Mode ==
Lockdown mode är en säkerhetsfunktion som stänger av lokal management på ESXi-hostar; management kan enbart ske via vCenter (utantag finns). Det finns två olika lägen, normal och strict lockdown.
==== Normal Lockdown ==== 
DCUI körs fortfarande på hosten. Priviligerade konton kan fortfarande logga in och stänga av Lockdown. Bara de konton med administrativ behörighet som specificerats i Exception User-listan för Lockdown kan göra detta. Exception Users är också till för service-konton som behöver utföra specifika tasks direkt på hosten. Det finns även en advanced option (DCUI.Access), som ger en användare (även icke-admins) möjligheten att logga på DCUI och stänga av Lockdown Mode.
==== Strict Lockdown ====
DCUI-tjänsten stoppas; om kommunikationen till vCenter försvinner och inte kan återupprättas finns ingen annan utväg än ominstallation. Dock finns det ett sätt att förebygga detta, om SSH och/eller ESXi Shell aktiverats på hosten. Då kan en admin-användare på Exception User-listan logga på hosten via CLI:t.

==== Aktivera Lockdown ====
För att slå på Lockdown Mode: '''Host''' -&gt; '''Configure''' -&gt; '''System''' -&gt; '''Security Profile''' -&gt; "'''Edit'''"-knappen under '''Lockdown Mode''', välj sedan '''Enable'''.

När Lockdown Mode slås på termineras alla sessioner för de användare som inte är med på Exception User-listan.

== SSH/DCUI/Shell Access ==
Dessa tre tjänster går att slå av manuellt via '''Host''' -&gt; '''Configure''' -&gt; '''System''' -&gt; '''Services'''.
SSH och ESXi Shell kan även slås av via '''DCUI''' -&gt; '''F2''' -&gt; '''Troubleshooting options''', här kan även timeout-värden för dessa två tjänster, samt DCUI, ändras.


[[Category:VMware]]</text>
      <sha1>qt4mnpik89qdqz5t6wa2sc98sueturd</sha1>
    </revision>
  </page>
  <page>
    <title>ESXi pktcap</title>
    <ns>0</ns>
    <id>198</id>
    <revision>
      <id>1763</id>
      <parentid>1209</parentid>
      <timestamp>2016-05-09T17:26:24Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>/* Användning */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="646">pktcap-uw är efterföljare till tcpdump-uw och innehåller några nya funktioner. Det används för paketanalys och ingår default sedan 5.5. Man kan fånga trafik från vmk-interface, vmnicar och fysiska nicar.

=Användning=
Lista interface
 esxcli network nic list
 esxcli network ip interface list
Fysisk NIC
 pktcap-uw --uplink vmnic0
Spara capture till fil med -o
 pktcap-uw --vmk vmk0 -o vmk0.pcap
Specifik IP
 pktcap-uw --vmk vmk0 --ip x.x.x.x
Specifik port
 pktcap-uw --vmk vmk0 --tcpport 443
Använd esxtop för att ta reda på en virtuell maskins vswitch Port ID
 esxtop  #press n
 pktcap-uw --switchport 33554439

[[Category:VMware]]</text>
      <sha1>q79vvz7nox0bea4jnrg60q3ycly9ir2</sha1>
    </revision>
  </page>
  <page>
    <title>EVE-NG</title>
    <ns>0</ns>
    <id>483</id>
    <revision>
      <id>2708</id>
      <parentid>2633</parentid>
      <timestamp>2017-12-20T13:37:58Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2114">EVE-NG (Emulated Virtual Environment New Generation) är en uppdaterad variant av Unetlab som det tidigare hette. EVE-NG fungerar precis som [[GNS3]] där man kan virtualisera sin nätverksmiljö med routrar, brandväggar, switchar men även klienter och servrar som Windows, [[Linux]] och [[VMware_ESXi|ESXi]].

EVE-NG är clientless så det enda som behövs är en webbläsare för att kunna nå sina enheter.

Kolla denna [http://www.eve-ng.net/index.php/documentation/supported-images lista] över vilka enheter EVE-NG har support för. 

Några märken som EVE-NG har stöd för är '''Cisco, Juniper, Extreme Network, Arista, PaloAlto, VyOS, pfSense, F5, Fortigate'''.

{{ambox
|nocat=true
| type  = notice
| text  = EVE-NG tillhandahåller inga images själva. Utan dom måste man själv ordna.
}}

=Installation=
Tanka hem deras senaste '''ova''' eller '''iso''' från deras hemsida.
 http://www.eve-ng.net/index.php/downloads/eve-ng
Surfa sedan in på den IP du gett EVE-NG, default username och password är '''admin/eve'''

==Installera images==
För att lägga in en Qemu supportad enhet så måste man döpa den på ett specifikt sätt och ladda upp filen till '''/opt/unetlab/addons/qemu/'''

EVE tillhandahåller en [http://www.eve-ng.net/index.php/documentation/images-table lista] på hur man ska döpa en image.

===Cumulus===
Download URL: [https://cumulusnetworks.com/products/cumulus-vx/download/ Cumulus VX]

Cumulus VX har ingen schysst device icon i EVE men det går att lägga till själv genom att lägga png-filer i "/opt/unetlab/html/images/icons/". Default har Cumulus VX templaten för lite minne vilket gör att netd krashar. 
 sed -i 's/= 256/= 512/' /opt/unetlab/html/templates/cumulus.php

===[[Network#Extreme_Networks|Extreme]]===
Download URL: [https://stackingtool.extremenetworks.com/github/EXOS-VM_v21.1.1.4-disk1.qcow2 EXOS-VM_v21.1.1.4-disk1.qcow2] &lt;br/&gt;
Filen ska döpas till '''extremexos-21.1.1.4/hda.qcow2'''

Extreme Network har även lagt upp några images på deras [https://github.com/extremenetworks/Virtual_EXOS GitHub] som man kan använda.

[[Category:Guider]]</text>
      <sha1>222gyzcn6fo2pbyu8e90l7rgr9zxcwt</sha1>
    </revision>
  </page>
  <page>
    <title>Emby Server</title>
    <ns>0</ns>
    <id>139</id>
    <revision>
      <id>1066</id>
      <parentid>927</parentid>
      <timestamp>2015-09-25T14:21:40Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1070">[[Category:Guider]] [[Category:Sparco]]
Emby är en opensource media server. Emby fungerar lite som Netflix fast man måste själv stå för filmerna.
 http://emby.media/

==Installation==
'''Debian Jessie'''
 wget -qO - http://download.opensuse.org/repositories/home:emby/Debian_8.0/Release.key | sudo apt-key add -
 sudo sh -c "echo 'deb http://download.opensuse.org/repositories/home:/emby/Debian_8.0/ /' &gt;&gt; /etc/apt/sources.list.d/emby-server.list"
 sudo apt-get update
 sudo apt-get install mono-runtime mediainfo libsqlite3-dev imagemagick-6.q8 libmagickwand-6.q8-2 libmagickcore-6.q8-2
 sudo apt-get install emby-server

Ett fel som jag fick under installationen som dom håller på att fixa är att &lt;code&gt;/usr/lib/emby-server/emby-server.sh&lt;/code&gt; hade permissions fel. Det löstes med detta kommandot,
 chmod +x /usr/lib/emby-server/emby-server.sh

Starta emby-server
 service emby-server start

Surfa in på webinterfacet och följ wizarden.
 http://&lt;IP&gt;:8096

==Tips'n'Trix==
Emby kan inte spela upp filmer som ligger i rar arkiv. Använd därför [[rar2fs]].</text>
      <sha1>67703gicykrqbc5q0jhluzkfhp4y2g9</sha1>
    </revision>
  </page>
  <page>
    <title>ExaBGP</title>
    <ns>0</ns>
    <id>232</id>
    <revision>
      <id>2788</id>
      <parentid>1619</parentid>
      <timestamp>2018-06-08T12:53:31Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2389">ExaBGP är en BGP route announcer som det går att scripta mot. Se även [[Cisco_BGP|Cisco BGP]] och [[Arista_BGP|Arista BGP]].

=Installation=
 pip install exabgp

=Konfiguration=
Exempel där man kan skicka in väldigt mycket routes till BGP.

Script för att generera prefix: [http://www.blackhole-networks.com/OSPF_overload/bs-prefixes.py bs-prefixes.py]
 chmod +x bs-prefixes.py

Script för att annonsera prefix
 touch announce.sh &amp;&amp; chmod +x announce.sh
cat announce.sh
&lt;syntaxhighlight lang="bash"&gt;
#!/bin/sh

# ignore Control C
# if the user ^C exabgp we will get that signal too, ignore it and let exabgp send us a SIGTERM
TEMPFILE=/tmp/prefixes.bgp
PREFIXES=50000
BLOCK=128

trap '' SIGINT

# Dump our prefixs in a file for parsing a block at a time
/path/to/bs-prefixes.py $PREFIXES &gt; $TEMPFILE

# Pause a bit to let BGP sessions come up
sleep 10

LINE=0
while [ $LINE -lt $PREFIXES ]; do
   LINE=$(( $LINE + $BLOCK ))
   for pfx in `head -n $LINE $TEMPFILE | tail -n $BLOCK`; do
      echo "announce route $pfx next-hop 10.0.0.0"
   done
   sleep 2
done
&lt;/syntaxhighlight&gt;

Konfigurationsfil för exaBGP, edit ''exabgp.conf''

 neighbor 10.0.0.11 {
  description "R2";
  router-id 66.66.66.66;
  local-address 10.0.0.10;
  local-as 666;
  peer-as 101;
  hold-time 600;
  graceful-restart;
 
   # advertise prefixes
   process service-1 {
        run /path/to/announce.sh;
   }

Kör
 exabgp exabgp.conf

==Segment Routing==
ExaBGP kan användas för att skicka in segment-lista dvs göra traffic engineering. ExaBGP kan också parsea IS-IS segment routing extensions genom BGP-LS. Detta betyder att man kan ta emot segment identifiers (node och adjacency id:s) genom samma BGP-LS session. Med label-informationen kan man programera LSP:er via BGP-LU sessionen till PE. Se även [[Arista_SR|Arista SR]] och [[Cisco_SR|Cisco SR]].

cat ./config/exabgp 
 neighbor 172.16.0.20 { 
    group-updates true; 
    local-address 172.16.0.10; 
    peer-as 65000; 
    local-as 65000; 
    family { 
       ipv4 nlri-mpls;
    }
    static {
       route 10.1.1.15/32 {  
          next-hop 10.0.0.2;  
          label [ 800005 800007 800006 800008 ];
       }
       route 10.1.1.15/32 {          #egress PE loopback
          next-hop 10.0.0.3;         #physical next-hop in core to get towards egress PE
          label [ 800005 800006 800008 ];
       }
    }
 }

[[Category:Network]]</text>
      <sha1>bapo0khq7pxam0piobz7wdp8arec2pt</sha1>
    </revision>
  </page>
  <page>
    <title>Extreme VLAN</title>
    <ns>0</ns>
    <id>249</id>
    <revision>
      <id>1588</id>
      <timestamp>2016-03-29T13:39:13Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Konfiguration== '''Skapa vlan'''  create vlan [vlan-name] tag [vlan-id]  '''Access port'''  configure vlan [vlan-name] add ports 1 untagged  '''Trunk port'''  configure vlan..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="228">==Konfiguration==
'''Skapa vlan'''
 create vlan [vlan-name] tag [vlan-id]

'''Access port'''
 configure vlan [vlan-name] add ports 1 untagged

'''Trunk port'''
 configure vlan [vlan-name] add ports 1 tagged

[[Category:Extreme]]</text>
      <sha1>b9wys0y5bruai02ra72s1i7vzysrzby</sha1>
    </revision>
  </page>
  <page>
    <title>Extreme XOS</title>
    <ns>0</ns>
    <id>248</id>
    <revision>
      <id>1587</id>
      <parentid>1586</parentid>
      <timestamp>2016-03-29T13:36:18Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1176">Extreme XOS bygger på linux kärnan och busybox.

==Konfiguration==
'''Hostnamn'''
 configure snmp sysName [hostname]

'''Sommartid/vintertid'''
 configure timezone name MET 60 autodst  begins every last sunday march at 2 0 ends every last sunday october at 3 0

'''Mgmt port'''
 configure vlan Mgmt ipaddress 192.168.0.1 255.255.255.0
 configure iproute add default [gw] vr VR-Mgmt

'''Skapa användare'''
 create account admin [username] [password]

'''Sätta password på användare'''
 configure account [konto] password

'''Enable SSH'''

SSH modulen kan man behöva lägga på i efterhand. Man lägger på modulen på samma sätt som man lägger på ny firmware. 
 enable ssh

'''LLDP'''
 enable lldp ports all
 configure lldp ports all advertise port-description
 configure lldp ports all advertise system-name
 configure lldp ports all advertise management-address

==Firmware==
'''Byt mellan primary och secondary image.'''
 use image primary/secondary
===TFTP===
'''Från VR-Mgmt(mgmt port)'''
 download image [ip] firmware/images/exos/[image]

'''Från VR-Default(vanlig port/vlan)'''
 download image [ip] firmware/images/exos/[image] vr vr-d

[[Category:Extreme]]</text>
      <sha1>rbtd69rbqmt72zy3m4lygm8i0mumqup</sha1>
    </revision>
  </page>
  <page>
    <title>F5 Big-IP</title>
    <ns>0</ns>
    <id>505</id>
    <revision>
      <id>2725</id>
      <parentid>2724</parentid>
      <timestamp>2018-01-13T15:21:32Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2294">[[Category:F5]]

F5 Big-IP är en plattform utfärdad av företaget F5 med möjlighet att köra lastbalancering, remote vpn, ddos skydd på olika nivåer. Alla funktionerna styrs till olika moduler på den Linuxbaserade enheten och man kan specificera hur många kärnor man vill lägga till vilken adc. En adc kallas den enhet som kör flera VMar på den fysiska appliancen med berörda moduler och hårdvaruspecifikation tilldelat till sig.

== Moduler ==
* [https://www.f5.com/pdf/products/big-ip-local-traffic-manager-ds.pdf LTM (Local Traffic Manager)]
* [https://www.f5.com/pdf/products/big-ip-access-policy-manager-ds.pdf APM (Access Policy Manager)]
* [https://www.f5.com/pdf/products/big-ip-advanced-firewall-manager-datasheet.pdf AFM (Advanced Firewall Manager)]
* [https://www.f5.com/pdf/products/big-ip-application-acceleration-manager-datasheet.pdf AAM (Application Acceleration Manager)]
* [https://www.f5.com/pdf/products/big-ip-application-security-manager-ds.pdf ASM (Application Security Manager)]
* [https://www.f5.com/pdf/products/big-ip-global-traffic-manager-ds.pdf GTM (Global Traffic Manager)]
* [https://www.f5.com/pdf/products/big-ip-link-controller-ds.pdf Link Controller]
* PSM (Procotol Security Module)

== Big-IP Appliance ==
Hårdvaruplattformen som modulerna i fråga aktiveras på finns det olika specifikation på beroende på throughput och portdensitet. Modelerna som är aktuella i dagsläget är de som börja på (i). Det finns även chassibaserade enheter som kallas Viprion. Dessa körs i stor skala hos de större leverantörena och kan i sitt chassi basera på konfiguration simulera flera mindre ADC enheter eller köra en all-in-one lösning.

== HTTP2 ==
Detta protokoll är mycket användbart framförallt för att man utöckar möjligheten att hämta information från en webbfront mycket snabbare och säkrare. HTTP2 bygger på en ny struktur istället för HTTP1.0/1.1. Man har i HTTP2 möjlighet att köra följande features.
* Multiplexing
* Server Push
* Header Compression
* Binary format
* Extended Security
# Minimum Keys
# Ephemeral key
# TLS 1.2
Alla dessa features bidrar till en snabbare och säkrare publicering av webbtjänster och F5an har möjlighet att publicera HTTP2 när servern bakom inte kan eller endast kan köra HTTP1.1.</text>
      <sha1>l4lertuop3x79csonsa58ex4e8j9tks</sha1>
    </revision>
  </page>
  <page>
    <title>Fabric</title>
    <ns>0</ns>
    <id>359</id>
    <revision>
      <id>2308</id>
      <parentid>2307</parentid>
      <timestamp>2017-05-02T19:35:29Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Installation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3512">Fabric är ett bibliotek och command-line verktyg för att automatisera deployment och diverse tasks via ssh.

I grunden följer det med en bibliotek av funktioner för antingen lokal eller remote kommandon samt uppladdning / nerladdning av filer. 
Man kan även bygga egna moduler för att utöka funktionerna av fabric.

=Installation=
 sudo apt-get install fabric 
Eller med hjälp av Python PIP.
 pip install -e git+https://github.com/paramiko/paramiko/#egg=paramiko
 pip install -e git+https://github.com/fabric/fabric/#egg=fabric

=Konfiguration=

Exempel: Fabric fil
&lt;syntaxhighlight lang="python"&gt;
from __future__ import with_statement
from fabric.api import *
from fabric.utils import warn
from fabric.contrib.files import exists
from fabric.contrib.project import  rsync_project
from fabric.contrib.files import sed
from fabric.contrib.files import append
from fabric.colors import *
import os.path
import server
server.setup_fabric()
env.user = 'root'
def upgrade_packages():
    run('apt-get update &amp;&amp; apt-get -y upgrade')

def pkg_list_backp():
    package_list = './backups/packageLists/%s.packagesList' % env.host_string
    run('dpkg --get-selections &gt; /var/backups/packages.list')
    get('/var/backups/packages.list', package_list)

def conf_sshd():
    sed('/etc/ssh/sshd_config',
        '#PasswordAuthentication yes',
        'PasswordAuthentication no' )
    sed('/etc/ssh/sshd_config',
        'PasswordAuthentication yes',
        'PasswordAuthentication no' )
    sed('/etc/ssh/sshd_config',
        'X11Forwarding yes',
        'X11Forwarding no' )
    sed('/etc/ssh/sshd_config',
        'AllowTcpForwarding yes',
        'AllowTcpForwarding no' )
    run('echo "AllowTcpForwarding no" &gt;&gt; /etc/ssh/sshd_config')
    run ('echo "AllowUsers root op"  &gt;&gt; /etc/ssh/sshd_config')
    run ('service ssh restart')

def deploy_gluster():
    put('./upload/glusterfs/gluster.list','/etc/apt/sources.list.d/') #Lägger den lokala filen gluster.list i remote foldern
    dist = run('lsb_release -cs') 
    sed('/etc/apt/sources.list.d/gluster.list', 'precise', (dist) ) #ersätter "precise" med versionen som körs
    run("apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3FE869A9")
    run("apt-get update")
    run("apt-get install -y glusterfs-client")

def doitall():
    upgrade_packages()
    pkg_list_backp()
    conf_sshd()
    deploy_gluster()

&lt;/syntaxhighlight&gt;

=Server Lista=
För att göra olika tasks enklare och överskådligare rekommenderas det att skapa serverdeffinitioner med olika roller och platser.
Exempel server.py
&lt;syntaxhighlight lang="python"&gt;
from fabric.api import env
class Server:
   def __init__(self, name, rack, roles):
        self.name = name
        self.rack = rack
        if isinstance(roles, list):
            self.roles = roles
        else:
            self.roles = list(roles)
servers = [
    Server('upload1',      'A1', ['sr04', 'ipmi', 'metal',  'bm', 'upload']),
    Server('upload2',       'A2', ['sr04', 'ipmi', 'esxi',  'drz', 'upload']),
    Server('csgo1',       'A2', ['sr04', 'ipmi', 'kvm',  'drz', 'csgo']),
    Server('voip1',         'A3', ['sr04', 'ipmi', 'metal',  'drz', 'voip']),
&lt;/syntaxhighlight&gt;

För att sedan använda listan importerar du den bara i ditt huvudfabric skript med 
import server
server.setup_fabric()

=Kör bara Kör!=
Med serverlista och roller 
&lt;syntaxhighlight&gt;
fab -R Roll task
&lt;/syntaxhighlight&gt;
Med enskilda hostar
&lt;syntaxhighlight&gt;
fab -H host1,host2 task
&lt;/syntaxhighlight&gt;
[[Category:Guider]]</text>
      <sha1>smkt7cmt4p1lcis0r74yz674x638joh</sha1>
    </revision>
  </page>
  <page>
    <title>Fail2Ban</title>
    <ns>0</ns>
    <id>259</id>
    <revision>
      <id>1706</id>
      <parentid>1694</parentid>
      <timestamp>2016-04-26T19:14:19Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Konfiguration */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3457">[[Category:Guider]]
Fail2ban söker av log filerna för olika tjänster som ssh, apache etc och letar efter tex bruteforce attacker eller om en exploit försökt köras. Fail2ban uppdaterar då brandväggen att blocka all trafik från den IP'n i ex antal minuter.

=Installation=
'''Deb baserad.'''
 apt-get install fail2ban

'''RPM baserad'''
 yum install fail2ban

=Konfiguration=
Fail2ban kommer med bra inställningar ifrån början. Vill man ändra dom gör man det i &lt;code&gt;/etc/fail2ban/jail.conf&lt;/code&gt;

{| class="wikitable"
|-
|maxretry||Antalet gånger något får hända. Tex 5 felaktiga lösenord.
|-
|findtime||Hur många gånger man får skriva tex felaktigt lösenord under en tidsperiod. 
|-
|bantime||Hur länge en IP blir bannad. Skrivs i sekunder, '''-1''' ger en permanent ban.
|}

==SSH Repeater permanent ban==
Om en IP försöker bruteforca dig så kan det vara skönt att blocka IP'n permanent istället.

Skapa följande fil &lt;code&gt;/etc/fail2ban/action.d/iptables-repeater.conf&lt;/code&gt;
  # Fail2ban configuration file
 #
 # Author: Phil Hagen &lt;phil@identityvector.com&gt;
 #
 
 [Definition]
 
 # Option:  actionstart
 # Notes.:  command executed once at the start of Fail2Ban.
 # Values:  CMD
 #
 actionstart = iptables -N fail2ban-REPEAT-&lt;name&gt;
               iptables -A fail2ban-REPEAT-&lt;name&gt; -j RETURN
               iptables -I INPUT -j fail2ban-REPEAT-&lt;name&gt;
               # set up from the static file
               cat /etc/fail2ban/ip.blocklist.&lt;name&gt; |grep -v ^\s*#|awk '{print $1}' | while read IP; do iptables -I fail2ban-REPEAT-&lt;name&gt; 1 -s $IP -j DROP; done
 
 # Option:  actionstop
 # Notes.:  command executed once at the end of Fail2Ban
 # Values:  CMD
 #
 actionstop = iptables -D INPUT -j fail2ban-REPEAT-&lt;name&gt;
              iptables -F fail2ban-REPEAT-&lt;name&gt;
              iptables -X fail2ban-REPEAT-&lt;name&gt;
 
 # Option:  actioncheck
 # Notes.:  command executed once before each actionban command
 # Values:  CMD
 #
 actioncheck = iptables -n -L INPUT | grep -q fail2ban-REPEAT-&lt;name&gt;
 
 # Option:  actionban
 # Notes.:  command executed when banning an IP. Take care that the
 #          command is executed with Fail2Ban user rights.
 # Tags:    &lt;ip&gt;  IP address
 #          &lt;failures&gt;  number of failures
 #          &lt;time&gt;  unix timestamp of the ban time
 # Values:  CMD
 #
 actionban = iptables -I fail2ban-REPEAT-&lt;name&gt; 1 -s &lt;ip&gt; -j DROP
             # also put into the static file to re-populate after a restart
             ! grep -Fq &lt;ip&gt; /etc/fail2ban/ip.blocklist.&lt;name&gt; &amp;&amp; echo "&lt;ip&gt; # fail2ban/$( date '+%%Y-%%m-%%d %%T' ): auto-add for repeat offender" &gt;&gt; /etc/fail2ban/ip.blocklist.&lt;name&gt;
 
 # Option:  actionunban
 # Notes.:  command executed when unbanning an IP. Take care that the
 #          command is executed with Fail2Ban user rights.
 # Tags:    &lt;ip&gt;  IP address
 #          &lt;failures&gt;  number of failures
 #          &lt;time&gt;  unix timestamp of the ban time
 # Values:  CMD
 #
 actionunban = /bin/true
 
 [Init]
 
 # Defaut name of the chain
 #
 name = REPEAT

Skapa sedan ett jail i &lt;code&gt;/etc/fail2ban/jail.conf&lt;/code&gt;
 ...
 [ssh-repeater]
 enabled  = true
 filter   = sshd
 action   = iptables-repeater[name=ssh]
            sendmail-whois[name=SSH-repeater, dest=root, sender=root]
 logpath  = /var/log/auth
 maxretry = 10
 findtime = 7200
 bantime  = -1
 ...

Denna regeln gör att en IP blir permbannad om den skrivit fel lösenord över SSH mer än 10 gånger dom senaste 2 timmarna.</text>
      <sha1>nmbk6jtwl5ae7wq3xe67lhuckkmtuzw</sha1>
    </revision>
  </page>
  <page>
    <title>FastNetMon</title>
    <ns>0</ns>
    <id>228</id>
    <revision>
      <id>2291</id>
      <parentid>1726</parentid>
      <timestamp>2017-04-19T13:22:00Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1466">High performance DoS/DDoS load analyzer. Kan lyssna på bl.a. [[Cisco_NetFlow|Netflow]], IPFIX, sFLOW, PCAP, [[Cisco_SPAN|SPAN]] och [[Ntopng|PF_RING]]. Om en överbelastningsattack upptäcks exekveras ett script. Vad scriptet gör avgör man själv, t.ex. maila/SMSa admin eller null routa prefix med [[ExaBGP]]. 

=Installation=
''Debian, Ubuntu, CentOS, Fedora''
 wget https://raw.githubusercontent.com/pavel-odintsov/fastnetmon/master/src/fastnetmon_install.pl -Ofastnetmon_install.pl 
 sudo perl fastnetmon_install.pl
Första gången man startar det skapas konf-filer.
 sudo /opt/fastnetmon/fastnetmon --daemonize

=Konfiguration=
Det mesta görs i huvudkonf-filen.
 nano /etc/fastnetmon.conf
Starta i screen
 screen -S fastnetmon -d -m /root/fastnetmon/fastnetmon

===Networks===
Lägg in dina egna IP-nät så fastnetmon vet vad som är lokalt.
 nano /etc/networks_list
 10.10.0.0/24
 20.20.0.0/24

===Klient===
Kolla live.
 /opt/fastnetmon/fastnetmon_client

===Notify===
Default: notify_script_path = /usr/local/bin/notify_about_attack.sh &lt;br/&gt;
Skapa script
 nano /usr/local/bin/notify_about_attack.sh
 chmod +x /usr/local/bin/notify_about_attack.sh

===NetFlow===
 netflow_port = 2055
 netflow_host = 0.0.0.0
 netflow_sampling_ratio = 1

===Graphite===
Det finns även integration med [[Graphite]] (och således [[Grafana]])
 graphite = on
 graphite_host = 127.0.0.1
 graphite_port = 2003

===Loggar===
 tail -f /var/log/fastnetmon.log

[[Category:Guider]]</text>
      <sha1>msuxovtrh3vh1at04pnohejqnaormiw</sha1>
    </revision>
  </page>
  <page>
    <title>Fedora</title>
    <ns>0</ns>
    <id>108</id>
    <revision>
      <id>1688</id>
      <parentid>1430</parentid>
      <timestamp>2016-04-22T14:21:04Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1776">Fedora är en RPM-baserad linuxdistribution främst utvecklad av Red Hat. Hela distributionen är fri programvara och används som en bas (läs PoC) för den kommersiella distributionen Red Hat Enterprise Linux. &lt;br/&gt;
Kickstartfil: [[Kickstart_Fedora|Fedora]].

==Pakethanterare==
Se [[Yum]]&lt;br/&gt;
Se [[DNF]]

==Network==
 systemctl stop NetworkManager.service &amp;&amp; systemctl disable NetworkManager.service
 systemctl enable network.service &amp;&amp; systemctl start network.service

==Uppgradering==
Till 23 med hjälp av fedup som tankar alla nödvändiga filer.
 sudo dnf -y update &amp;&amp; sudo dnf -y install fedup &amp;&amp; sudo fedup --network 23
 reboot

==Auto update==
 sudo dnf -y install dnf-automatic
 sudo systemctl enable dnf-automatic.timer
''Default kollas det efter uppdateringar en gång per dygn''

==SSH==
 sudo systemctl enable sshd.service

==Gnome==
I det grafiska gränsnittet går det bara att sätta 15 minuter som max på Blank screen under Power saving. Högre värde går att sätta med kommando.
 gsettings set org.gnome.desktop.session idle-delay 3600   #sekunder
 gsettings set org.gnome.desktop.screensaver lock-delay 10

Desktop
 gsettings set org.gnome.desktop.background show-desktop-icons true
 gsettings set org.gnome.nautilus.desktop home-icon-visible false

==GRUB menu==
Fedora använder GRUB2 som bootloader och default visas menyn i 5 sekunder vid uppstart. Detta går att ta bort genom att ändra/lägga till följande.
 sudo nano /etc/default/grub
 GRUB_TIMEOUT=0
 GRUB_HIDDEN_TIMEOUT=1
 GRUB_HIDDEN_TIMEOUT_QUIET=true
Hidden timeout 1 ger möjligheten att komma åt menyn med ESC i 1 sekund under uppstart.
 
Uppdatera GRUB
 sudo grub2-mkconfig -o /boot/grub2/grub.cfg
OBS Kör man UEFI kan filen heta /boot/efi/EFI/fedora/grub.cfg

[[Category:Distar]]</text>
      <sha1>lxtfm5ebsyui5jwgjaxu892d53aedvu</sha1>
    </revision>
  </page>
  <page>
    <title>FirewallD</title>
    <ns>0</ns>
    <id>63</id>
    <revision>
      <id>2270</id>
      <parentid>2268</parentid>
      <timestamp>2017-03-21T21:02:38Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Skapa egen tjänst */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4293">FirewallD ersätter iptables i RHEL 7, centOS 7 och Fedora 18. Den främsta fördelen är att man kan göra alla ändringar utan att behöva starta om tjänsten. Denna artikel innehåller grunderna för FirewallD.

=Grunder=
'''Kolla status'''
 firewall-cmd --state
'''Detaljerad status'''
 systemctl status firewalld.service
'''On/Off'''
 systemctl enable firewalld.service
 systemctl disable firewalld.service
'''Panic mode'''
(Blockar all traffik)

'''On'''
 firewall-cmd --panic-on
'''Off'''
 firewall-cmd --panic-off

OBS Om man har flera interface måste man slå på IPv4-forwarding
 sudo sed -i -r 's/net.ipv4.ip_forward=0/net.ipv4.ip_forward=1/g' /etc/sysctl.conf
 sysctl -p

=Zoner=
FirewallD jobbar med säkerhetszoner och följande zoner finns default:
* Public – For use in public areas. Only selected incoming connections are accepted.
* Drop – Any incoming network packets are dropped, there is no reply. Only outgoing network connections are possible.
* Block – Any incoming network connections are rejected with an icmp-host-prohibited message for IPv4 and icmp6-adm-prohibited for IPv6. Only network connections initiated within this system are possible.
* External – For use on external networks with masquerading enabled especially for routers. Only selected incoming connections are accepted.
* DMZ – For computers DMZ network, with limited access to the internal network. Only selected incoming connections are accepted.
* Work – For use in work areas. Only selected incoming connections are accepted.
* Home – For use in home areas. Only selected incoming connections are accepted.
* Trusted – All network connections are accepted.
* Internal – For use on internal networks. Only selected incoming connections are accepted.

Alla interface ligger default i zonen public. Varje zon är definierad i en XML-fil som ligger i '''/usr/lib/firewalld/zones'''

'''Kolla vilka zoner som finns'''
 firewall-cmd --get-zones
'''Kolla aktiva zoner'''
 firewall-cmd --get-active-zones
'''Kolla en zones permanenta konfiguration'''
 firewall-cmd --permanent --list-all --zone=public
'''Kolla alla zoner detaljerat'''
 firewall-cmd --list-all-zones
'''Ändra default zone'''
 firewall-cmd --set-default-zone=home
'''Skapa en ny zone'''
 firewall-cmd --permanent --new-zone=test
 firewall-cmd --reload

==Aktivera zonen==
För att en zone ska gälla behöver man aktivera den på interfacet eller på CIDR-notation.&lt;br/&gt;
'''Kolla vilka zoner som körs på ett interface'''
 firewall-cmd --get-zone-of-interface=eth0
'''Aktivera en zone tillfälligt'''
 firewall-cmd --zone=home --change-interface=eth0 
'''Aktivera en zone permanent'''
 firewall-cmd --permanent --zone=home --change-interface=eth0
'''Aktivera på en CIDR-notion'''
 firewall-cmd --permanent --zone=work --add-source=192.168.0.0/24
 firewall-cmd --permanent --zone=work --list-sources

=Services=
Det finns ett gäng fördefinerade tjänster men man kan enkelt lägga till en egna för att slippa göra portöppningar.

'''Lista alla tjänster'''
 firewall-cmd --get-services

Vill du kolla in varje tjänst mer detaljerat så kan du läsa XML filerna under '''/usr/lib/firewalld/services/ssh.xml'''.
==Skapa egen tjänst==
För att lägga till en egen tjänst, skapa en XML under '''/etc/firewalld/services/''' med följande innehåll.
&lt;div class="toccolours" style="width:40em"&gt;
&lt;center&gt;'''HAProxy.xml'''&lt;/center&gt;
&lt;div class="toccolours" style="width:40em"&gt;
&lt;syntaxhighlight lang=xml&gt;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;service&gt;
 &lt;short&gt;HAProxy&lt;/short&gt;
 &lt;description&gt;HAProxy load-balancer&lt;/description&gt;
 &lt;port protocol="tcp" port="80"/&gt;
&lt;/service&gt;
&lt;/syntaxhighlight&gt;
&lt;/div&gt;
&lt;/div&gt;
Bra att känna till är att en tjänst under '''/etc/firewalld/services/''' har högre prioritet än en tjänst under '''/usr/lib/firewalld/services/'''.

==Lägga till en tjänst i en zone.==
För att sedan lägga till tjänsten på en zone permanent.
 firewall-cmd --permanent --zone=public --add-service=HAProxy
 firewall-cmd --reload

==Portforwarding==
 firewall-cmd --zone=external --add-forward-port=port=80:proto=tcp:toport=8080:toaddr=192.168.0.50

'''Iptables'''&lt;br/&gt;
Man kan byta tillbaka om man känner sig gammalmodig.
http://www.certdepot.net/rhel7-disable-firewalld-use-iptables/

[[Category:Tools]]</text>
      <sha1>smyv7mnob6yfevc9c4x08cq36742ikc</sha1>
    </revision>
  </page>
  <page>
    <title>Flexget</title>
    <ns>0</ns>
    <id>26</id>
    <revision>
      <id>2743</id>
      <parentid>1457</parentid>
      <timestamp>2018-02-12T10:00:35Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Sparcos YAML fil */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1946">Flexget är ett avancerat automatiserings program för att tanka hem torrents, serier, filmer mm. Det kan ta RSS-feeds, html sidor, csv-filer eller sökmotorer som källa för att ladda hem. Det finns även plugins för vissa sidor som inte har någon bra feed att följa.

== Installation ==
För att installera Flexget verifera att du har Python''' 2.6.x - 2.7.x.'''

&lt;code&gt;python -v&lt;/code&gt;

Sedan behöver du pip.

&lt;code&gt;apt-get update &amp;&amp; apt-get install python-pip&lt;/code&gt;

Installera sedan Flexget med kommandot.

&lt;code&gt;pip install flexget&lt;/code&gt;

Verifera att Flexget är installerat med 

&lt;code&gt;flexget -V&lt;/code&gt;

== Konfiguration ==
Flexget använder sig av en configurations fil som man skriver i YAML.

Se [http://flexget.com/wiki/Cookbook Flexgets Cookbook] för flera olika exempel på hur man kan skriva.

==Tips n Trix ==
Har du conf filen i din hemmapp måste du använda växeln &lt;code&gt;-c&lt;/code&gt; tex, &lt;code&gt;flexget -c /home/user/flexget.yml&lt;/code&gt;

För att validera din conf fil att den fungerar använd kommandot.

&lt;code&gt;flexget -c flexget.yml check&lt;/code&gt;

För att köra flexget använd kommandot

&lt;code&gt;flexget -c flexget.yml execute&lt;/code&gt;

=== Crontab ===
Flexget kan både köras som en deamon och använda ett inbyggt schema för när den ska kolla efter saker eller så kan man använda crontab.

För att köra Flexget var 30e minut.

&lt;code&gt;*/30 * * * * /usr/local/bin/flexget -c /root/flexget.yml execute&lt;/code&gt;

=== Pushover ===
[https://pushover.net/ Pushover] är en tjänst för att kunna skicka pushnotiser till din Android, IOS eller webbläsare. Man kan få Flexget att skicka en pushnotis varje gång den laddar hem något för att inte missa nerladdningen. 

Enda man behöver är några få rader i din YAML fil och ett konto hos pushover.
 pushover:
 userkey:
 - uasdfVQ
 apikey: aasdf6
 title: Downloading &lt;nowiki&gt;{{series_name}}&lt;/nowiki&gt;
 message: Episode &lt;nowiki&gt;{{series_id}}&lt;/nowiki&gt;

[[Category:Guider]]</text>
      <sha1>ticxeyoqg9v01x5wfuzntimgi198uaa</sha1>
    </revision>
  </page>
  <page>
    <title>Foreman</title>
    <ns>0</ns>
    <id>361</id>
    <revision>
      <id>2951</id>
      <parentid>2742</parentid>
      <timestamp>2019-03-23T20:38:45Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3436">Foreman är ett lifecycle management tool för on-premise VM's, bare-metal eller i cloud hos Amazon, Google, Microsoft eller Rackspace. Foreman klarar av provisioning och configuration till orchestration och monitorering. Till hjälp har man en Foreman Smart-Proxy som managerar TFTP, DHCP, DNS, Puppet, Puppet CA, Ansible, Salt och Chef. 

Foreman styrs med hjälp av ett webbaserat GUI, CLI eller ett REST API och klarar av allt från 1 server till 10 000 servrar.

=Foremans arkitektur=
Foreman agerar frontend mot användarna. Smart-Proxyn förser tjänster med ett API som foreman kan agera mot.
[[File:Foreman architecture.png|790px]]

=Installation=
&lt;ul class="nav nav-tabs"&gt;
   &lt;li class="active"&gt;&lt;btn data-toggle="tab" class=""&gt;#tab1|CentOS 7&lt;/btn&gt;&lt;/li&gt;
   &lt;li&gt;&lt;btn data-toggle="tab" class=""&gt;#tab2|Ubuntu 16.04&lt;/btn&gt;&lt;/li&gt;
 &lt;/ul&gt;

 &lt;div class="tab-content"&gt;
   &lt;div id="tab1" class="tab-pane fade in active"&gt;
Börja med att lägga till Puppet 5.X repot som är det rekommenderade.
 yum -y install https://yum.puppetlabs.com/puppet5/puppet5-release-el-7.noarch.rpm
Installera sedan EPEL (Extra Packages for Enterprise Linux) och Foreman repot.
 yum -y install http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
 yum -y install https://yum.theforeman.org/releases/1.16/el7/x86_64/foreman-release.rpm
Ladda sedan hem Foreman.
 yum -y install foreman-installer
   &lt;/div&gt;
   &lt;div id="tab2" class="tab-pane fade"&gt;
Börja med att lägga till Puppet 4.X repot som är det rekommenderade. 
 apt-get -y install ca-certificates
 wget https://apt.puppetlabs.com/puppet5-release-xenial.deb
 dpkg -i puppet5-release-xenial.deb
Lägg sedan till Foreman repot.
 echo "deb http://deb.theforeman.org/ xenial 1.16" &gt; /etc/apt/sources.list.d/foreman.list
 echo "deb http://deb.theforeman.org/ plugins 1.16" &gt;&gt; /etc/apt/sources.list.d/foreman.list
 apt-get -y install ca-certificates
 wget -q https://deb.theforeman.org/pubkey.gpg -O- | apt-key add -
Ladda sedan hem Foreman.
 apt-get update &amp;&amp; apt-get -y install foreman-installer
   &lt;/div&gt;
 &lt;/div&gt;
{{ambox
|nocat=true
| type  = notice
| text  = Kör sedan &lt;code&gt;ping $(hostname -f)&lt;/code&gt; och se till att den visar din riktiga ip och inte 127.0.1.1. Ändra eller ta bort entryt i /etc/hosts annars.
}}
Kör sedan Foreman installer.
 foreman-installer -i \
 --enable-foreman-compute-vmware \
 --enable-foreman-plugin-templates \
 --enable-foreman-plugin-setup \
 --enable-foreman-cli \
 --enable-foreman \
 --enable-foreman-proxy \
 --enable-puppet \
 --foreman-proxy-tftp=true 

Installationen körs i en non-interactive läge som standard. Men konfigurationen kan ändras genom att lägga till options från '''foreman-installer --help'''. Eller så kan man välja att köra installern i interaktivt läge med '''foreman-installer -i'''.

Installern här över är baserad på en miljö där DHCP och DNS sköts av sig självt eller genom andra system. Och Foreman kommer bara att ta hand om TFTP servern och provisionering med hjälp av Puppet. Installerar också pluginet för att kunna skapa VM's på en vmware miljö. 

När installern kört klart så ska man få upp liknande info ruta.
 * Foreman is running at https://foreman.hackernet.se
        Initial credentials are admin / 3ekw5xtyXCoXxS29
 * Foreman Proxy is running at https://foreman.hackernet.se:8443
 * Puppetmaster is running at port 8140
 The full log is at /var/log/foreman-installer/foreman-installer.log</text>
      <sha1>kf1tl7mz3abeh5mjn68fvdns5pbu9ti</sha1>
    </revision>
  </page>
  <page>
    <title>Frandom</title>
    <ns>0</ns>
    <id>29</id>
    <revision>
      <id>566</id>
      <parentid>138</parentid>
      <timestamp>2015-06-16T09:36:00Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="263">Trött på att urandom är flaskar.

 wget http://billauer.co.il/download/frandom-1.1.tar.gz
 tar xzf frandom-1.1.tar.gz
 cd frandom-1.1
 make
 install -m 644 frandom.ko /lib/modules/`uname -r`/kernel/drivers/char/
 depmod -a
 modprobe frandom

[[Category:Tools]]</text>
      <sha1>pe4p7vb68f56jzytc2qlroa02jvmhka</sha1>
    </revision>
  </page>
  <page>
    <title>FreeIPA</title>
    <ns>0</ns>
    <id>239</id>
    <revision>
      <id>3121</id>
      <parentid>2574</parentid>
      <timestamp>2021-04-07T12:24:46Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8847">FreeIPA är ett open source projekt för centraliserad Identity, Policy och Auditing (IPA) för unix/linux-system, likt Microsofts Active Directory. I botten används 389 Directory Server för LDAP, MIT's Kerberos 5 för authentication och single sign-on, [[BIND]] för integrerad DNS och Samba för integration mot Active Directory. Man sparar lösenord och SSH-nycklar centralt som autentisering på övriga maskiner kan kolla mot. Man kan skapa användargrupper och styra sudo policy centralt. Det är sponsrat av Red Hat.  

'''DNS''' &lt;br/&gt;
Namnuppslag måste fungera. T.ex. för en server måste man använda fqdn och det ska vara resolvable. Det går att lösa med hosts-filen i en testsetup.

=Server=
==Installation==
'''Fedora'''
 sudo dnf -y install freeipa-server

'''CentOS'''
 yum install ipa-server

==Konfiguration==
Starta wizarden som automatiskt konfigurerar upp din FreeIPA med det nödvändigaste.
 sudo ipa-server-install

Kör kommandot '''kinit admin''' så får du en kerberos ticket som du behöver för att kunna köra IPA tools tex ipa user-add.

===DNS records===
Skapa följande records om du kör en DNS server som inte FreeIPA sköter. Dessa records gör att autodiscovery fungerar och gör det mycket enklare att konfigurera upp klienter.
 
 ; ldap servers
 _ldap._tcp              IN SRV 0 100 389        freeipa
 
 ;kerberos realm
 _kerberos               IN TXT HACKERNET.SE
 
 ; kerberos servers
 _kerberos._tcp          IN SRV 0 100 88         freeipa
 _kerberos._udp          IN SRV 0 100 88         freeipa
 _kerberos-master._tcp   IN SRV 0 100 88         freeipa
 _kerberos-master._udp   IN SRV 0 100 88         freeipa
 _kpasswd._tcp           IN SRV 0 100 464        freeipa
 _kpasswd._udp           IN SRV 0 100 464        freeipa
 
 ;ntp server
 _ntp._udp               IN SRV 0 100 123        freeipa
 
 ; CNAME for IPA CA replicas (used for CRL, OCSP)
 ipa-ca                  IN A                    IP-to-FreeIPA

===Brandväggsöppningar===
Beroende på vilken dist du använder kanske du inte behöver öppna portar i din egna brandvägg.
 firewall-cmd --permanent --add-service=ntp
 firewall-cmd --permanent --add-service=http
 firewall-cmd --permanent --add-service=https
 firewall-cmd --permanent --add-service=ldap
 firewall-cmd --permanent --add-service=ldaps
 firewall-cmd --permanent --add-service=kerberos
 firewall-cmd --permanent --add-service=kpasswd
 firewall-cmd --reload

===Skapa user===
 ipa user-add
 ipa passwd &lt;user&gt;

===Web UI===
Nås på https://IP-to-FreeIPA

===Replikering===
Det går att replikera datan mellan servrar.
 ipa-replica-manage list

===System account===
Vissa LDAP tjänster behöver ett förkonfat konto tex LDAP Autofs och sudo. Oftast så använder man en användares uppgifter när man bindar mot en LDAP server men det är inte alltid möjligt. Anledningen till varför man skapar ett service konto istället för ett vanligt användar konto är att ett system kontot endast finns för att binda mot LDAP servern och är alltså inget POSIX konto och kan därför inte logga in mot några system.

Skapa ett system account så här:
 ldapmodify -x -D 'cn=Directory Manager' -W
 
 dn: uid=system,cn=sysaccounts,cn=etc,dc=hackernet,dc=se
 changetype: add
 objectclass: account
 objectclass: simplesecurityobject
 uid: 1337
 userPassword: secret
 passwordExpirationTime: 20380119031407Z
 nsIdleTimeout: 0
 &lt;blank line&gt;
 ^D(CTRL+D)

===GroupOfUniqueNames===
GroupOfUniqueNames är en objectclass som finns i grupper, vissa program söker i LDAP databasen efter denna class. Bland annat [[VMware vCenter]].

Logga in på '''IPA WebUI''' gå till '''IPA Server''' ---&gt; '''Configuration''' --&gt; '''Group Options''' --&gt; '''Add''' --&gt; Fyll i '''GroupOfUniqueNames''' --&gt; '''Save''' --&gt; '''Refresh'''.

Skapa sedan en '''Posix''' grupp och lägg till användarna i gruppen.

Kör sedan följande kommando för varje användare.
 ipa group-mod '''&lt;group_name&gt;''' --addattr="uniqueMember=uid='''changeme''',cn=users,cn=accounts,dc=hackernet,dc=se"

===Active directory trust===
FreeIPA har stöd för att sätta upp en trust med ett AD. 

Din FreeIPA domän och AD domän får inte vara samma för att det ska fungera.

Installera AD trust paketet:
 yum install ipa-server-trust-ad

Kör ipa ad trust install för att lägga till nödvändiga object och skapa nya DNS records:
 ipa-adtrust-install --netbios-name=IPA_NETBIOS -a admin_password

Ifall din freeipa inte kan uppdatera din DNS med nya records så behöver du skapa följande annars kan du skippa detta steget:
 _ldap._tcp.dc._msdc.&lt;freeipa_domän&gt;. 3600 IN SRV 0 100 389 &lt;freeipa_server&gt;
 _kerberos._tcp.dc._msdcs.&lt;freeipa_domän&gt;. 3600 IN SRV 0 100 88 &lt;freeipa_server&gt;
 _kerberos._udp.dc._msdcs.&lt;freeipa_domän&gt;. 3600 IN SRV 0 100 88 &lt;freeipa_server&gt;
 _ldap._tcp.Default-First-Site-Name._sites.dc._msdcs.&lt;freeipa_domän&gt;. 3600 IN SRV 0 100 389 &lt;freeipa_server&gt;
 _kerberos._tcp.Default-First-Site-Name._sites.dc._msdcs.&lt;freeipa_domän&gt;. 3600 IN SRV 0 100 88 &lt;freeipa_server&gt;
 _kerberos._udp.Default-First-Site-Name._sites.dc._msdcs.&lt;freeipa_domän&gt;. 3600 IN SRV 0 100 88 &lt;freeipa_server&gt;

För att en trust ska fungera så måste AD servern kunna slå upp FreeIPA domänen och tvärtom. Verifiera det med följande kommando.

'''AD DC'''
 C:\&gt; nslookup
 set type=srv
 _ldap._tcp.ad_domain
 _ldap._tcp.ipa_domain
'''IPA server'''
 dig SRV _ldap._tcp.ipa_domain
 dig SRV _ldap._tcp.ad_domain

Om det inte fungerar så kan man behöva forwarda request direkt till motsvarande domäns dns server.

'''AD DC'''
 C:\&gt; dnscmd 127.0.0.1 /ZoneAdd ipa_domain /Forwarder ipa_ip_address
'''IPA server'''
*IPA v3.x:
 ipa dnszone-add ad_domain --name-server=ad_hostname.ad_domain --admin-email='hostmaster@ad_domain' --force --forwarder=ad_ip_address --forward-policy=only --ip-address=ad_ip_address
*IPA v4.x:
 ipa dnsforwardzone-add ad_domain --forwarder=ad_ip_address --forward-policy=only

====Skapa och verifiera cross-realm trust====
 ipa trust-add --type=ad ad_domain --admin Administrator --password
Vid prompt ange lösenordet till AD domänens Administrator konto eller ett annat konto som är med i '''Domain Admins''' gruppen, om allt är uppsatt korekt så kommer IPA att sätta upp en two-way forest trust med AD och validera den.

Skapa sedan en external group och en POSIX group. 
*External group funkar som en container där dina trusted domän användare finns.
*Lägg sedan till den den externa gruppen i en POSIX group så att dina AD domän användare får ett group id(gid) som kan användas som default group.

 ipa group-add --desc='ad_domain admins external map' ad_admins_external --external
 ipa group-add --desc='ad_domain admins' ad_admins
 ipa group-add-member ad_admins_external --external 'ad_netbios\Domain Admins'
När den frågar om '''member user''' och '''member group''' så lämna det blankt och tryck enter.

Lägg sedan till den externa gruppen i posix gruppen.
 ipa group-add-member ad_admins --groups ad_admins_external

För att verifera att det fungerar så ska det gå att logga in på en IPA ansluten server med ett AD konto. När du ansluter till en server måste du ange '''ad_user@ad_domain''' som username.

===Let's Encrypt webui SSL===
För att kunna använda Let's Encrypts certifikat med FreeIPA behöver man importera deras root certifikat.

Börja med att clona följande repo.
 git clone https://github.com/Hackernet-se/freeipa-letsencrypt &amp;&amp; cd freeipa-letsencrypt
Importera root certen.
 ipa-cacert-manage install "DSTRootCAX3.pem" -n DSTRootCAX3 -t C,,
 ipa-cacert-manage install "LetsEncryptAuthorityX3.pem" -n letsencryptx3 -t C,,
Uppdatera sedan databasen.
 ipa-certupdate

När dom två certifikaten är inlagda så kan man importera certifikaten man fått från Let's Encrypt.
 ipa-server-certinstall -w fullchain.pem privkey.pem
Starta sedan om http tjänsten och dirsrv.
 systemctl restart dirsrv@REALM.service
 systemctl restart httpd.service

=Klient=
==Installation==
Varje klient måste ha ett fully qualified domain name. Default kerberos domain är din domän, t.ex. hackernet.se.

'''Ubuntu'''
 apt-get install freeipa-client

'''Fedora'''
 dnf install freeipa-client

==Enroll host till FreeIPA==
Kör följande kommando för att starta en wizard som enrollar din klient i freeipa.
 sudo ipa-client-install
Om autodiscovery fungerar som det ska så är alla fält i fyllda och det enda du behöver ange är en användare som har behörighet att enrolla klinter till freeipa.

Man kan fylla i användarnamn och lösenord i förväg så slipper svara på frågor.
 sudo ipa-client-install -p admin -w secretpw --unattended --mkhomedir

==IPA Advise==
Med kommandot &lt;code&gt;ipa-advise&lt;/code&gt; på servern kan du få konfigurations förslag på hur du konfigurerar en klient mot freeipa om du inte har tillgång till ipa klienten.
[[Category:Guider]]</text>
      <sha1>6wqect56vhue9py8kz8ig5pxroczgag</sha1>
    </revision>
  </page>
  <page>
    <title>GNS3</title>
    <ns>0</ns>
    <id>34</id>
    <revision>
      <id>2295</id>
      <parentid>2294</parentid>
      <timestamp>2017-04-25T19:02:09Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Installation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1908">GNS3 är en programvara där du kan emulera nätverks enheter så som Cisco routrar, Juniper brandväggar och Extreme switchar och mycket mera. Sedan kopplar man ihop enheterna i en topologi så att man kan pröva tex nya features eller öva inför certifikat utan att behöva köpa hem riktig hårdvara. Ska man köra stora labbar så kommer GNS3 att kräva en hel del CPU och RAM från din hårdvara.

GNS3 är uppdelat i en server och en client så att man inte behöver emulera på sin egen laptop tex.

=Supported hårdvara=
Hårdvara som kan emuleras av GNS3 finns längst ner på följande sida:
 https://docs.gns3.com/1FFbs5hOBbx8O855KxLetlCwlbymTN8L1zXXQzCqfmy4/index.html

=Images=
Vissa tillverkare har lagt ut images på nätet som man kan tanka utan att behöva registrera sig. Medans vissa kräver att man har ett konto hos dom.

==Cisco==
Några Cisco images finns på denna sidan.
 http://commonerrors.blogspot.se/search/label/GNS3%20IOS
==Extreme Networks==
 https://github.com/extremenetworks/Virtual_EXOS

=Installation=
Det rekommenderade sättet att köra GNS3 är att deploya deras färdiga server VM och sedan ansluta mot den med clienten.

==Server==
Ladda ner servern till den hypervisor du tänkt använda.
 https://gns3.com/software/download-vm

Packa upp filen och deploya den.

Default username och password är '''gns3'''.

==Client==
För att slippa registrera sig på deras hemsida så kan man tanka hem clienten via deras Github.
 https://github.com/GNS3/gns3-gui/releases

Filen man ska tanka heter '''all-in-one''' och innehåller allt man behöver för att köra en lokal instans av GNS3 också.

Efter installationen är klar starta GNS3 och välj '''Run everything on a remote server'''.

=Tips n Tricks=
==Dynamips==
Om dynamips kraschar testa följande:
* Öka på mängden ram images har blivit tilldelad.
* Pröva en annan image.
* Byt platform.

[[Category:Guider]]</text>
      <sha1>2qi0fb7zd2qlo8ru3bexskf7m614p7t</sha1>
    </revision>
  </page>
  <page>
    <title>Gammu</title>
    <ns>0</ns>
    <id>158</id>
    <revision>
      <id>1064</id>
      <parentid>1013</parentid>
      <timestamp>2015-09-25T14:21:07Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1824">Gammu är ett program för att kunna styra din mobiltelefon eller 3G modem. Gammu körs med kommandon men finns också webinterface att använda. Gammu kan prata med enheten över bluetooth, usb eller serielt.
Med Gammu kan du göra följande,
*Skicka, backupa och ta emot SMS.
*Ta emot MMS.
*Visa, importera och exportera telefonboken och kalendern.
*Komma åt filsystemet.
*Visa information om telefonen och dess nätverk.
*Lista, initiera och hantera inkommande samtal.

==Förberedelse==
Du behöver en mobil eller modem som Gammu har stöd för. Se deras [http://wammu.eu/phones/ databas].

==Installera==
 apt-get install gammu usb-modeswitch

Usb-modeswitch behöver man om man ska använda ett usb modem som visar sig som både ett usb storage och 3g modem.

==Konfiguration==
Skriv kommandot &lt;code&gt;gammu-detect&lt;/code&gt; så listar den en tty som den tror gammu har stöd för.
Kör sedan &lt;code&gt;gammu-config&lt;/code&gt; för att skapa en konfig fil mot rätt port samt välja vilken drivrutin den ska använda.

Filen kommer sparas i &lt;code&gt;$HOME/.gammurc&lt;/code&gt; vill du använda samma fil för flera användare flytta den till &lt;code&gt;/etc/gammurc&lt;/code&gt;.

==Kommandon==
Ta reda på om du behöver slå in pin eller puk kod.
 gammu --getsecuritystatus

Slå in pin eller puk kod.
 gammu --entersecuritycode PIN/PUK &lt;kod&gt;

Skicka ett SMS
 echo Gammu SMS | gammu sendsms TEXT &lt;nummer&gt;

==Huawei==
För att få igång ett Huawei E367 3G modem behövde jag använda usb-modeswitch. Samma knep funkar säkert på fler Huawei modem.

 cd /etc/usb_modeswitch.d
 sudo tar xzf /usr/share/usb_modeswitch/configPack.tar.gz 12d1:1446
 sudo sed -i -e 's/14ac"/14ac,1506"/' 12d1:1446
 modprobe usbserial vendor=0x12d1 product=0x1506

Sedan krävs det att man startar om eller återansluter modemet.

[[Category:Guider]] [[Category:Sparco]]</text>
      <sha1>lwszqhg5qcw5yla02a74lc3b0j4xje0</sha1>
    </revision>
  </page>
  <page>
    <title>Git</title>
    <ns>0</ns>
    <id>203</id>
    <revision>
      <id>3162</id>
      <parentid>3141</parentid>
      <timestamp>2022-10-07T13:21:27Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2571">Git är ett versionshanteringsprogram som är gratis och open source. Det skapades 2005 för att hantera källkoden till Linuxkärnan. Ens lokala repository består av tre "trees" som git håller koll på. 
* Working Directory: håller alla filer som man jobbar med.
* Index: är där filerna mellanlandar när man addar dem, innan commit. 
* HEAD: pekar på den senaste commiten man gjort.

===Overview===
[[File:Hackernet-Git.PNG]]

==Installation==
 sudo apt-get install git
Alternativt git-all för att få med alla subpackages.

=Usage=
CLI
 git status
 git log
 git shortlog
 git config color.ui true
Det finns flera grafiska program för git.

===Repo===
Skapa nytt lokalt repo.
 mkdir ~/reponame &amp;&amp; cd ~/reponame
 echo "reponame" &gt;&gt; README.md
 git init
 git add README.md
 git commit -m "first commit"

Skapa en working copy av ett lokalt repo.
 git clone /path/to/repository

Lägg till ändring till Index.
 git add &lt;filename&gt;
 git add *

Commit till HEAD, dock är det fortfarande lokalt.
 git commit -m "Commit message"

Pusha ändring till remote repo.
 git push origin master

För att uppdatera det lokala repot med de senaste commitsen.
 git pull

===Branch===
Branches används för att utveckla features isolerat från varandra. Man kan utveckla flera branches parallellt för att sedan mergea tillbaka dem till Master. Master branch är "default" när man skapar ett repo. 

Skapa en ny branch
 git checkout -b NAME
Byt till en annan branch
 git checkout NAME
Kolla branches
 git branch

===.gitignore===
Är en fil som används för att man ska skydda sig så att man av misstag inte commitar filer man inte vill eller som är onödiga tex swp filer, log filer, lösenord eller databas filer.
[https://github.com/github/gitignore Github .gitignore templates]
 sparco@jumpgate:~/ircbot$ cat .gitignore
 *.swp
 test.py
 __pycache__/
 config.ini
 *.log

=GitHub=
GitHub är en webb-baserad Git repository hosting service. Det är gratis att skapa ett konto och man kan pusha sin kod dit för att dela med sig till andra.

Author name and email address
 git config --global user.name "Skeletor"
 git config --global user.email "user@hackernet.se"

Connect local repository to a remote server, add the server to be able to push to it
 git remote add origin https://github.com/user/reponame.git
 git remote -v
 git push -u origin master

Password cache
 git config --global credential.helper cache
 git config --global credential.helper 'cache --timeout=3600'

Klona repo från GitHub
 git clone https://github.com/username/reponame.git

[[Category:Guider]]</text>
      <sha1>ouueenwkw5e8gfjkjrft2g85poxm3kv</sha1>
    </revision>
  </page>
  <page>
    <title>Gitlab</title>
    <ns>0</ns>
    <id>257</id>
    <revision>
      <id>3122</id>
      <parentid>3119</parentid>
      <timestamp>2021-04-11T18:33:52Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4273">[[Category:Guider]]
Gitlab är ett webbaserad git repositry manager med bland annat en inbyggd wiki. Gitlab fungerar som Github gör och dom erbjuder att så man kan hosta sin egna lösning på sin egen server. Se även [[Git]].

Det finns 2 version av Gitlab:
*Gitlab CE: Community Edition.
*Gitlab EE: Enterprise Edition.

=Installation=
Installera dom nödvändiga paketen. Postfix kan man skippa om man har en annan mailserver.
 sudo apt-get install curl openssh-server ca-certificates postfix
Lägg till Gitlab's repo och installera sedan Gitlab CE.
 curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash
 sudo apt-get install gitlab-ce
Konfigurera sedan Gitlab och starta det.
 sudo gitlab-ctl reconfigure

=Konfiguration=
Att konfigurera är väldigt enkelt. Man gör sina ändringar i &lt;code&gt;/etc/gitlab/gitlab.rb&lt;/code&gt; efter det kör man &lt;code&gt;sudo gitlab-ctl reconfigure&lt;/code&gt; för att dom ska börja gälla.

==HTTPS==
Ändra följande rad:
 external_url "https://git.hackernet.se"

Eftersom hostnamnet är '''git.hackernet.se''' så kommer gitlab leta efter private key och certificate filen som heter '''git.hackernet.se.key/crt''' under &lt;code&gt;/etc/gitlab/ssl/&lt;/code&gt;.

Om du behöver ändra vart cert filerna finns och vad dom heter ändra dessa 2 rader.
 nginx['ssl_certificate'] = "/opt/cert/fullchain.pem"
 nginx['ssl_certificate_key'] = "/opt/cert/privkey.pem"

'''Redirect HTTP till HTTPS''' &lt;br/&gt;
Ändra följande rad till true.
 nginx['redirect_http_to_https'] = true

==LDAP authentication==
För mer info kolla [https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/ldap.md Gitlab LDAP document]
 gitlab_rails['ldap_enabled'] = true
 gitlab_rails['ldap_servers'] = YAML.load &lt;&lt;-'EOS' # remember to close this block with 'EOS' below
 main: # 'main' is the GitLab 'provider ID' of this LDAP server
      label: 'Hackernet'
      host: 'openldap.hackernet.se'
      port: 389
      uid: 'uid'
      method: 'plain'
      bind_dn: '&gt;ldap bind username&gt;'
      password: '&lt;ldap bind password&gt;'
      active_directory: false
      allow_username_or_email_login: true
      block_auto_created_users: false
      base: '&lt;base DN&gt;'
      user_filter: ''
      attributes:
        username: ['uid', 'userid', 'sAMAccountName']
        email:    ['mail', 'email', 'userPrincipalName']
        name:       'cn'
        first_name: 'givenName'
        last_name:  'sn'
      ## EE only
      group_base: 'dc=hackernet,dc=se'
      admin_group: 'cn=wiki'
      sync_ssh_keys: false
  EOS

'''Gör LDAP användare till admin''' &lt;br/&gt;
För att göra en LDAP användare till admin kör följande kommando i shell:
 sudo gitlab-rails console
 u = User.find_by_username("LDAPadmin")
 u.admin = true
 u.save
 exit

==Schemalagd backup==
Simpel backup görs mha crontab och /var/opt/gitlab/backups kan sedan rsync:as iväg till remote site.
 0 4 * * 7 /opt/gitlab/bin/gitlab-backup create CRON=1
 1 4 * * 7 cp /etc/gitlab/gitlab-secrets.json /var/opt/gitlab/backups/ &gt;/dev/null
 1 4 * * 7 cp /etc/gitlab/gitlab.rb /var/opt/gitlab/backups/ &gt;/dev/null

Limit backup lifetime to 60 days, /etc/gitlab/gitlab.rb.
 gitlab_rails['backup_keep_time'] = 5184000

=CI/CD=
I ditt gitlab repo kan du skapa en fil som heter '''.gitlab-ci.yml'''. 

Det är i denna filen som du specificerar vad din pipeline ska göra. 
==YAML Lint==
Pipeline som kollar att du har skrivit rätt YAML syntax i ditt repo. Funkar bra tillsammans med tex [[Puppet#Hiera|Puppet]] hiera config. 
&lt;syntaxhighlight lang="json"&gt;
stages:
 - lint

lint-yaml:
  stage: lint
  image:
    name: cytopia/yamllint:latest
    entrypoint: ["/bin/ash", "-c"]
  script:
   - yamllint -f colored .
&lt;/syntaxhighlight&gt;
Om du vill att pipelinen ska skippa vissa filer eller du vill ändra configen så kan du skapa en fil i rooten på ditt repo som heter '''.yamllint.yml''':
&lt;syntaxhighlight lang="yaml"&gt;
extends: default

ignore: |
  .yamllint.yml
  .gitlab-ci.yml

rules:
  # 80 chars should be enough, but don't fail if a line is longer
  line-length:
    max: 80
    level: warning

  # accept both     key:
  #                   - item
  #
  # and             key:
  #                 - item
  indentation:
    indent-sequences: whatever
&lt;/syntaxhighlight&gt;</text>
      <sha1>nnyt1vfjs5qqv2nmxvzw7p3ozgeaj1x</sha1>
    </revision>
  </page>
  <page>
    <title>GlusterFS</title>
    <ns>0</ns>
    <id>238</id>
    <revision>
      <id>1493</id>
      <timestamp>2016-02-06T21:09:24Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "GlusterFS är ett open source och skalbart network-attached storage file system som numera utvecklas av Red Hat. Genom att klustra ihop resurser (servrar, diskar, filsystem et..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2403">GlusterFS är ett open source och skalbart network-attached storage file system som numera utvecklas av Red Hat. Genom att klustra ihop resurser (servrar, diskar, filsystem etc.) kan man bygga High-Availability storage. Varje directory som ska lagra data kallas brick och med bricks bygger man volymer. Volymer kan spänna över flera servrar och kommunikation görs med TCP (eller [https://en.wikipedia.org/wiki/InfiniBand InfiniBand]). Det finns Gluster Native Client för t.ex. linuxhostar annars går det att dela ut en volym med klassiska protokoll som [[NFS]]. 

Det finns olika typer av volymer. Dessa går även att kombinera för att skapa en distributed-replicated volume.
* '''Distributed Mode:''' kombinera alla tillgängliga storage-resurser till en volym.
* '''Replicated Mode:''' spegla datan (mirror) mellan resurser, likt RAID 1. Synchronous replication.
Lägger man till en ny tom brick till en Distributed volym med mycket data kan man balansera ut det med kommandot '''gluster volume rebalance VOLNAME start'''. GlusterFS har inbyggd self-heal funktion i replicated mode, dvs om en brick går offline och filer modifieras så synkas det upp när den kommer tillbaka. 

=Installation=
 sudo dnf/apt-get install glusterfs-server
 systemctl status glusterfs-server
'''Klient'''
 sudo dnf/apt-get install glusterfs-client
'''Version'''
 glusterfsd --version

=Konfiguration=
För att klustra noder måste man peera och lägga till enheter till trusted server pool. Detta går även göra med hostnamn.
 sudo gluster peer probe 10.0.0.11
 gluster peer status

===Volym===
Replicated, 2 är antalet noder med datan.
 sudo gluster volume create gluster-vol replica 2 10.0.0.10:/data 10.0.0.11:/data
 sudo gluster volume start gluster-vol
Vitlista klienter baserat på IP-adresser.
 sudo gluster volume set gluster-vol auth.allow 10.0.0.*,10.5.5.10
Verify
 sudo gluster volume status
 sudo gluster volume info  

===Klient===
 mount.glusterfs 10.0.0.10:/data /mnt/glusterfs
 df -h

==Geo-replication== 
GlusterFS är designat för datacenter men vill man över t.ex. ett WAN (high latency) bör man använda geo-replication. Då används istället asynchronous och inkrementell replikering. Ena sidan är master och andra slave. Klockorna ska vara synkade och [[NTP]] bör användas.
 gluster volume geo-replication [SOURCE_DATASTORE] [REMOTE_SERVER]:[REMOTE_PATH] start

[[Category:Guider]]</text>
      <sha1>9aq40vo97atvn1vwvyi7mzeh3r2xjwc</sha1>
    </revision>
  </page>
  <page>
    <title>Golang</title>
    <ns>0</ns>
    <id>511</id>
    <revision>
      <id>2952</id>
      <parentid>2752</parentid>
      <timestamp>2019-03-23T20:43:09Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6516">[[Category:Guider]]
'''Intro''' &lt;br/&gt;
Golang är det nya hippa språket som Google har utvecklat. Det är enkelt att läsa som Python, snabbt och low level som C.

'''Golang Concurreny'''

So basically goroutines are amazing in go, they are cheap, fast and even though one might think they run in parallel they don't. So lets say that I wanna run 2k HTTP GET requests towards skooog.se. Well I can do this concurrent, but we are gonna run into several issues, one being the amount of sockets we have on our client machine.

So sockets are expensive, goroutines aren't, this is how we solve it.
&lt;syntaxhighlight line lang=go&gt;
 package main                                                                    
                                                                                 
 import (                                                                        
    "fmt"                                                                        
    "io/ioutil"                                                                  
    "net/http"                                                                   
    "sync"                                                                       
 )                                                                               
                                                                                 
 // We need something to recover in case one goroutine fails.                    
 // Otherwise our whole program might crash or hang                              
                                                                                 
 func cleanup() {                                                                
    if r := recover(); r != nil {                                                
        fmt.Println("recovered in cleanup", r)                                   
    }                                                                            
 }                                                                               
                                                                                 
 func getURL(c chan&lt;- *http.Response, wg *sync.WaitGroup, sem chan bool, url string) {
    defer wg.Done()                                                              
    defer cleanup()                                                              
    sem &lt;- true                                                                  
    data, err := http.Get(url)                                                   
    if err != nil {                                                              
        panic(err)                                                               
    }                                                                            
                                                                                                                                                        
    c &lt;- data                                                                    
    &lt;-sem                                                                        
                                                                                 
    // Tell the waitgroup we are done                                            
 }                                                                               
                                                                                 
 func main() {                                                                   
    // Declare waitgroup                                                         
    var wg sync.WaitGroup                                                        
                                                                                 
    // Make channels with buffersize to fit all our data
    c := make(chan *http.Response, 1000)                                         
                                                                                 
    /*                                                                           
     We create sem to act as a buffer, because goroutines are cheap and we can use a lot, however
     sockets aren't. So we can easily spin up 10000 of goroutines without any issues,
     but then we will start running out of sockets to use.
    */                                                                           
    sem := make(chan bool, 50)                                                   
    for i := 0; i &lt; 1000; i++ {                                                  
        // Add 1 to the queue                                                    
        wg.Add(1)                                                                
        go getURL(c, &amp;wg, sem, "http://skooog.se")                               
    }                                                                            
    // Wait until every job we added is done                                     
    wg.Wait()                                                                    
                                                                                 
    // Close channel is needed for when we use the range statement below         
    // If we don't close it range will never know when it should stop iterating, 
    // this will cause the problem to hang                                       
    close(c)                                                                     
    fmt.Println("ok")                                                            
                                                                                 
    httpResponses := [][]byte{}                                                  
                                                                                 
    for elem := range c {                                                        
        content, _ := ioutil.ReadAll(elem.Body)                                  
        //fmt.Println(string(content))                                           
        httpResponses = append(httpResponses, content)                           
    }                                                                            
                                                                                 
    for _, slice := range httpResponses {                                        
        fmt.Println(string(slice))                                               
    }                                                                            
 }
&lt;/syntaxhighlight&gt;</text>
      <sha1>ia448y33447kvoc43k0ljxxlcfsh2mp</sha1>
    </revision>
  </page>
  <page>
    <title>Google Authenticator</title>
    <ns>0</ns>
    <id>212</id>
    <revision>
      <id>1888</id>
      <parentid>1315</parentid>
      <timestamp>2016-06-22T11:41:37Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1173">Med Google Authenticator kan man använda time-based one-time password (TOTP) tillsammans med sitt vanliga lösenord på sin [[Jumpgate|SSH-server]] för att få 2-faktors-autentisering. Allt sker mellan server och mobil som båda vet när nycklar är giltiga.

=Installation=
 sudo apt-get -y install libpam-google-authenticator
 echo "#Google Authenticator $(date)" | sudo tee -a /etc/pam.d/sshd &amp;&amp; echo "auth required pam_google_authenticator.so" | sudo tee -a /etc/pam.d/sshd
 sudo sed -i 's/ChallengeResponseAuthentication no/ChallengeResponseAuthentication yes/g' /etc/ssh/sshd_config
 sudo service ssh restart

=Konfiguration=
Logga in på det lokala konto som ska köra MFA.
 google-authenticator
Svara y, starta appen och scanna qr-koden.

'''Vitlista nätverk''' &lt;br/&gt;
Man kan styra om MFA ska användas eller ej beroende på source address på SSH-sessionerna. Lägg in följande i /etc/pam.d/sshd ovanför raden ''auth required pam_google_authenticator.so''
 auth [success=1 default=ignore] pam_access.so accessfile=/etc/security/access-local.conf

 cat /etc/security/access-local.conf
 + : ALL : 10.0.0.0/24
 + : ALL : LOCAL
 - : ALL : ALL

[[Category:Guider]]</text>
      <sha1>sszh80u5e50ahojswdl64clo1l8s78j</sha1>
    </revision>
  </page>
  <page>
    <title>Grafana</title>
    <ns>0</ns>
    <id>92</id>
    <revision>
      <id>3091</id>
      <parentid>1720</parentid>
      <timestamp>2020-04-15T08:08:00Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1477">Grafana är webbaserat grafverktyg. Grafana behöver hämta datan som ska grafas ifrån någonstans. Detta kan göras från bl.a. influxDB, Elasticsearch, [[Graphite]] eller [[Prometheus]].

==Installation==
 echo "deb https://packagecloud.io/grafana/stable/debian/ wheezy main" | sudo tee -a /etc/apt/sources.list
'''Wheezy''' (och andra debianversioner)
 sudo apt-get -y install curl
 curl https://packagecloud.io/gpg.key | sudo apt-key add -
 sudo apt-get update
 sudo apt-get -y install grafana

'''Ubuntu'''
 curl https://packages.grafana.com/gpg.key | sudo apt-key add -
 sudo add-apt-repository "deb https://packages.grafana.com/oss/deb stable main"
 sudo apt-get update &amp;&amp; sudo apt-get install grafana

===Alternativ installation===
Finns officiell docker-container
 docker run -i -p 3000:3000 grafana/grafana

==Konfiguration==
Detta startar tjänsten som user grafana, som skapades under installation. Default HTTP-port är 3000 och default user är admin med pw admin.

'''Init.d'''
 sudo service grafana-server start
 sudo update-rc.d grafana-server defaults 95 10

'''Systemd'''
 systemctl daemon-reload
 systemctl start grafana-server
 systemctl status grafana-server
 sudo systemctl enable grafana-server.service

'''grafana.ini'''
I grafana.ini finns systeminställningarna. De går också att se på http://IP:3000/admin/settings
 sudo nano /etc/grafana/grafana.ini
Förslagsvis byts lösenordet för admin, det kan även göras i webguit.

[[Category:Guider]]</text>
      <sha1>3inbjtpqr534w3l5inonaiztsuppghy</sha1>
    </revision>
  </page>
  <page>
    <title>Graylog</title>
    <ns>0</ns>
    <id>237</id>
    <revision>
      <id>1497</id>
      <parentid>1496</parentid>
      <timestamp>2016-02-08T15:51:18Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4420">Graylog är en syslogserver för att man ska kunna analysera syslog, göra sökningar och se trender på ett ställe. Det är open source och är baserat på Elasticsearch, Java och MongoDB. Autentisering kan kopplas till AD eller [[OpenLDAP|LDAP]].

Dokumentation: http://docs.graylog.org/en/2.0/

=Installation=
Det snabbaste sättet att komma igång är att ladda ner färdig appliance och köra på hypervisor. https://www.graylog.org/download

Installera själv, ''Ubuntu'' &lt;br/&gt;
MongoDB
&lt;syntaxhighlight lang="bash"&gt;
sudo apt-get update &amp;&amp; sudo apt-get -y upgrade &amp;&amp; sudo apt-key adv --keyserver keyserver.ubuntu.com --recv 7F0CEB10
echo "deb http://repo.mongodb.org/apt/ubuntu "$(lsb_release -sc)"/mongodb-org/3.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.0.list
sudo apt-get update &amp;&amp; sudo apt-get -y install mongodb-org
&lt;/syntaxhighlight&gt;

Elasticsearch
&lt;syntaxhighlight lang="bash"&gt;
sudo apt-get install software-properties-common curl &amp;&amp; sudo add-apt-repository ppa:webupd8team/java
sudo apt-get update &amp;&amp; sudo apt-get -y install oracle-java8-installer
wget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
echo "deb http://packages.elastic.co/elasticsearch/1.7/debian stable main" | sudo tee -a /etc/apt/sources.list.d/elasticsearch-1.7.x.list
sudo apt-get update &amp;&amp; sudo apt-get -y install elasticsearch
sudo sed -i -e 's\#cluster.name: elasticsearch\cluster.name: graylog-prod\' /etc/elasticsearch/elasticsearch.yml
sudo sed -i -e 's\#network.host: 192.168.0.1\network.host: localhost\' /etc/elasticsearch/elasticsearch.yml
sudo sed -i -e 's\#discovery.zen.ping.multicast.enabled:\discovery.zen.ping.multicast.enabled:\' /etc/elasticsearch/elasticsearch.yml
sudo service elasticsearch restart &amp;&amp; sudo update-rc.d elasticsearch defaults 95 10
curl -XGET 'http://localhost:9200/_cluster/health?pretty=true'
&lt;/syntaxhighlight&gt;

Graylog
&lt;syntaxhighlight lang="bash"&gt;
wget https://packages.graylog2.org/repo/packages/graylog-1.3-repository-ubuntu14.04_latest.deb
sudo dpkg -i graylog-1.3-repository-ubuntu14.04_latest.deb
sudo apt-get update &amp;&amp; sudo apt-get -y install apt-transport-https graylog-server pwgen
SECRET=$(pwgen -s 96 1) &amp;&amp; sudo -E sed -i -e 's/password_secret =.*/password_secret = '$SECRET'/' /etc/graylog/server/server.conf
&lt;/syntaxhighlight&gt;

Password for user admin, ändra CHANGETHIS
&lt;syntaxhighlight lang="bash"&gt;
PASSWORD=$(echo -n CHANGETHIS | shasum -a 256 | awk '{print $1}') &amp;&amp; sudo -E sed -i -e 's/root_password_sha2 =.*/root_password_sha2 = '$PASSWORD'/' /etc/graylog/server/server.conf
&lt;/syntaxhighlight&gt;

Graylog-konf
&lt;syntaxhighlight lang="bash"&gt;
sudo sed -i -e 's\#root_timezone = UTC\root_timezone = Europe/Stockholm\' /etc/graylog/server/server.conf
sudo sed -i -e 's\#rest_transport_uri = http://192.168.1.1:12900/\rest_transport_uri = http://127.0.0.1:12900/\' /etc/graylog/server/server.conf
sudo sed -i -e 's/elasticsearch_shards = 4/elasticsearch_shards = 1/' /etc/graylog/server/server.conf
sudo sed -i -e 's/#elasticsearch_cluster_name = graylog2/elasticsearch_cluster_name = graylog-prod/' /etc/graylog/server/server.conf
sudo sed -i -e 's/#elasticsearch_discovery_zen_ping_multicast_enabled/elasticsearch_discovery_zen_ping_multicast_enabled/' /etc/graylog/server/server.conf
sudo sed -i -e 's/#elasticsearch_discovery_zen_ping_unicast_hosts/elasticsearch_discovery_zen_ping_unicast_hosts/' /etc/graylog/server/server.conf
sudo start graylog-server
&lt;/syntaxhighlight&gt;

Graylog-web
&lt;syntaxhighlight lang="bash"&gt;
sudo apt-get install graylog-web
SECRET=$(pwgen -s 96 1) &amp;&amp; sudo -E sed -i -e 's/application\.secret=""/application\.secret="'$SECRET'"/' /etc/graylog/web/web.conf
sudo sed -i -e 's\graylog2-server.uris=""\graylog2-server.uris="http://127.0.0.1:12900/"\' /etc/graylog/web/web.conf
sudo start graylog-web
&lt;/syntaxhighlight&gt;

=Konfiguration=
 http://&lt;graylog_IP&gt;:9000/
Vill man ha web ui med HTTPS kan man t.ex. lägga det bakom en [[Nginx|Nginx proxy]].

===Input===
System -&gt; Inputs -&gt; Syslog UDP -&gt; Launch:
* Title: syslog
* Port: 5514
* Bind address: graylog_private_IP
Launch

===Port 514===
Graylog får inte binda till port 514 eftersom det är en lågnummerport utan man får lösa det med en redirect.
 iptables -t nat -A PREROUTING -i eth0 -p udp -m udp --dport 514 -j REDIRECT --to-ports 5514

===Klienter===
Ställ in så dina maskiner skickar sin syslog till &lt;Graylog-IP&gt; UDP 514.

[[Category:Guider]]</text>
      <sha1>1adn268azktviyearl69559puq8mt2d</sha1>
    </revision>
  </page>
  <page>
    <title>HPE BL460c G7</title>
    <ns>0</ns>
    <id>355</id>
    <revision>
      <id>2203</id>
      <parentid>2201</parentid>
      <timestamp>2016-12-14T21:42:59Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="594">[[Category:Hardware]]
Detta är den äldre versionen av HPE's bladservrar
==Problem==
Kända problem

'''Vmware'''
* Vid installation av Vmware 6.5 med HPE iso så får den PSOD fel 13 samt 14.(detta beror på att den inte är supporterad av HPE och att Vibarna inte har stöd för G7 servrear)

'''HPE SPP'''
*NIC NC553i(emulex) slutar fungera vid firmware uppdatering till FW 11.1.183.23 som ligger med på SPP2016.10 vid nergradering till [http://whp-hou4.cold.extweb.hp.com/pub/softlib/software13/COL46628/co-154246-1/Legacy_OneConnect-Flash-10.5.160.0.iso 10.5.155.0] så fungerar den igen</text>
      <sha1>nngfnohv3gikk7qhyobl22s3tneifx6</sha1>
    </revision>
  </page>
  <page>
    <title>HPE BL460c Gen9</title>
    <ns>0</ns>
    <id>354</id>
    <revision>
      <id>2202</id>
      <parentid>2199</parentid>
      <timestamp>2016-12-14T08:07:17Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="347">[[Category:Hardware]]
Generation 9 av HPE's bladservrar.
==Problem==
Kända problem

'''Vmware'''
*"A SmartArray controller Battery status hase changed from non-OK to OK"  dock blir den aldrig non-OK detta händer om du har HPE_bootbank_hpe-smx-provider installerat på VMware 5.5U3 men försvinner om man lägger på HPE_bootbank_hpe-smx-limited.</text>
      <sha1>ryhfnyefsxymcwka1899sdtpbf7ihy5</sha1>
    </revision>
  </page>
  <page>
    <title>HashiCorp Vault</title>
    <ns>0</ns>
    <id>565</id>
    <revision>
      <id>3160</id>
      <parentid>3156</parentid>
      <timestamp>2022-06-21T13:08:39Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1651">Vault är ett system som centralt säkrar, lagrar och kontrollerar access till tokens, passwords, certificates och API keys. Allt är krypterat by default, både offline och vid transit (TLS). Vault är server/client och har CLI, web UI samt REST JSON/HTTP API. För att accessa Vault så finns ett auth-lager med backend, t.ex. LDAP eller AD. ACLer styr vem som får accessa vad och allt loggas i en audit-logg. Det finns stöd för Dynamic secrets (short-lived). 

==Installation==
Ubuntu
&lt;syntaxhighlight lang="Bash"&gt;
curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
sudo apt-get update &amp;&amp; sudo apt-get install vault
&lt;/syntaxhighlight&gt;

==Server==
Starta server
 vault server
 vault status

==Klient==
 export VAULT_ADDR='http://127.0.0.1:8200'
 export VAULT_TOKEN="s.Va50wjIqgl6zHReb4aLDb"

Write simple secret
 vault kv put secret/hello foo=world

Read secret
 vault secrets list
 vault kv get secret/hello
 vault kv get -format=json secret/hello | jq .

==Konfiguration==
===LDAP/AD login===
Enable LDAP login
 vault auth enable ldap
Konfa LDAP pluginet 
 vault write auth/ldap/config \
     url="ldaps://ad.hackernet.se" \
     userattr="sAMAccountName" \
     userdn="OU=users,DC=hackernet,DC=se" \
     groupdn="OU=groups,DC=hackernet,DC=se" \
     groupattr="cn" \
     binddn="CN=&lt;binduser&gt;,DC=hackernet,DC=se" \
     bindpass='&lt;secret password&gt;' \
     insecure_tls=false \
     starttls=true

Ge en AD/LDAP grupp login rättigheter samt default policyn. 
 vault write auth/ldap/groups/&lt;GRUPP NAMN&gt; policies=default</text>
      <sha1>clxq65uzz38fq3rkl4hj2hk8itg8ipp</sha1>
    </revision>
  </page>
  <page>
    <title>Hastebin</title>
    <ns>0</ns>
    <id>110</id>
    <revision>
      <id>2650</id>
      <parentid>1068</parentid>
      <timestamp>2017-11-28T17:29:54Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Lightweight client */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3521">Hastebin används för att tex dela kod eller nån log fil med någon. Det funkar på samma sätt som Pastebin.
Hastebin är väldigt enkelt att använda och är stilrent.
En fördel med hastebin är att dom har klienter som man kan köra i sitt skal så man kan tex köra cat på en fil och output är hastebin.

[http://paste.hackernet.se/ Hackernets egna hastebin server]

== Installation ==
Clona hastebins git repo,
 git clone https://github.com/seejohnrun/haste-server

Kör sedan. Vill du ändra nån inställning i &lt;code&gt;config.js&lt;/code&gt; gör det före detta steget.
 npm install
 npm start

== Konfiguration ==
Det finns 3 olika sätt att lagra sina paste på. Memcache, redis eller på fil.

=== Memcache ===
Förutsätter att du redan har memcache server installerat på samma eller en annan server.

Du behöver också modulen för memcache.
 npm install memcache

Under &lt;code&gt;storage&lt;/code&gt; i &lt;code&gt;config.js&lt;/code&gt; ändra till.
  "storage": {
    "type": "memcached",
    "host": "127.0.0.1",
    "port": 11211,
    "expire": 2592000
  },

expire säger hur många sekunder en paste ska finnas kvar sedan den senast öppnades.

=== Redis ===
Förutsätter också att du har en redis server och du behöver modulen för redis.
 npm install redis

Under &lt;code&gt;storage&lt;/code&gt; i &lt;code&gt;config.js&lt;/code&gt; ändra till.
  "storage": {
    "type": "redis",
    "host": "0.0.0.0",
    "port": 6379,
    "db": 2,
    "expire": 2592000
  },

=== File ===
Under &lt;code&gt;storage&lt;/code&gt; i &lt;code&gt;config.js&lt;/code&gt; ändra till.
  "storage": {
    "type": "file",
    "path": "./data",
    "expire": 2592000
  },

När du är klar med &lt;code&gt;config.js&lt;/code&gt; kör sedan.
 npm install
 npm start

Tjänsten går nu att nå på http://&lt;IP&gt;:7777

== Reverse proxy ==
Låt en reverse proxy dela ut tjänsten tex Apache.

 &lt;VirtualHost *:80&gt;
     ServerAdmin root@hackernet.se
     ServerName paste.hackernet.se
 
     &lt;IfModule mod_proxy.c&gt;
         ProxyVia On
         ProxyRequests Off
         ProxyPass / http://127.0.0.1:7777/
         ProxyPassReverse / http://127.0.0.1:7777/
         ProxyPreserveHost on
         &lt;Proxy *&gt;
             AllowOverride All
             Order allow,deny
             allow from all
         &lt;/Proxy&gt;
     &lt;/IfModule&gt;
 
         ErrorLog ${APACHE_LOG_DIR}/hastebin.log
 
         # Possible values include: debug, info, notice, warn, error, crit,
         # alert, emerg.
         LogLevel warn
 
         CustomLog ${APACHE_LOG_DIR}/access.log combined
 
 
 &lt;/VirtualHost&gt;

Se till att modulerna &lt;code&gt;proxy&lt;/code&gt; och &lt;code&gt;proxy_http&lt;/code&gt; är igång.

== Systemd service ==
Under &lt;code&gt;/etc/systemd/system&lt;/code&gt; skapa filen &lt;code&gt;haste.service&lt;/code&gt; med texten. Anpassa &lt;code&gt;/opt/haste-server&lt;/code&gt; efter vart du installerat det.
 [Service]
 ExecStart=/usr/bin/node /opt/haste-server/server.js
 Restart=always
 StandardOutput=syslog
 SyslogIdentifier=hastebin
 User=root
 WorkingDirectory=/opt/haste-server
 
 [Install]
 WantedBy=multi-user.target

Kör sedan dessa 2 kommandona för att skapa en symlänk och starta hastebin.
 systemctl enable /etc/systemd/system/haste.service
 systemctl start haste.service


== Klient ==
Dom har flera klienter för linux och för windows.

=== Lightweight client ===
Skriv denna raden i ditt skal för att klienten ska fungera.
 haste() { a=$(cat); curl -X POST -s -d "$a" https://paste.hackernet.se/documents | awk -F '"' '{print "https://paste.hackernet.se/"$4}'; }

För att använda klienten skriv,
 cat testfil.txt | haste

[[Category:Guider]]</text>
      <sha1>iqctnxk7bgs9t8nkb5v5p66homyy1ov</sha1>
    </revision>
  </page>
  <page>
    <title>Hdparm</title>
    <ns>0</ns>
    <id>105</id>
    <revision>
      <id>671</id>
      <timestamp>2015-06-30T08:58:56Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "hdparm är ett verktyg för att managera hårdvaruparametrar på hårddiskar. T.ex. GParted inkluderar hdparm.  Info om hårddisk  hdparm -i /dev/sda Läsprestandatest  hdparm..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="360">hdparm är ett verktyg för att managera hårdvaruparametrar på hårddiskar. T.ex. GParted inkluderar hdparm.

Info om hårddisk
 hdparm -i /dev/sda
Läsprestandatest
 hdparm -tT /dev/sda
Sänk ljudnivån på bekostnad av prestanda.
 hdparm -M 128 /dev/sda
Fabriksåterställning
 hdparm --yes-i-know-what-i-am-doing --dco-restore /dev/sda

[[Category:Tools]]</text>
      <sha1>mp6qba1npipol1aqrtf4czcjopaj96j</sha1>
    </revision>
  </page>
  <page>
    <title>HämligaHackerWikin:General disclaimer</title>
    <ns>0</ns>
    <id>162</id>
    <revision>
      <id>1025</id>
      <timestamp>2015-09-10T08:20:42Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Hackernet är en öppen samarbets encyklopedi; det vill säga en sammanslutning av kompisar som arbetar för att utveckla en gemensam resurs av kunskap för IT tjänster.  Str..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="678">Hackernet är en öppen samarbets encyklopedi; det vill säga en sammanslutning av kompisar som arbetar för att utveckla en gemensam resurs av kunskap för IT tjänster. 
Strukturen i projektet kan vem som helst med en Internetanslutning läsa. 
Observera att allt som finns här har granskats av personer med den kompetens som krävs för att ge dig fullständig, korrekt eller tillförlitlig information.
Det är inte att säga att du inte kommer att hitta värdefull och korrekt information i Hackernet; en stor del av den tid du kommer. 
Men Hackernet kan inte garantera giltigheten av den information som finns här. Innehållet i en viss artikel kan nyligen har ändrats.</text>
      <sha1>ipheeos9212tno7riku5see8233i2yv</sha1>
    </revision>
  </page>
  <page>
    <title>IPMI</title>
    <ns>0</ns>
    <id>85</id>
    <revision>
      <id>1814</id>
      <parentid>1813</parentid>
      <timestamp>2016-05-27T19:05:40Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>/* Ipmitool */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1264">[[Category:Tools]]
Intelligent Platform Management Interface är ett system som tillhandahåller management och övervakningsfunktioner av en server oberoende av CPU, BIOS eller operativsystem. IPMI används av systemadministratörer för out-of-band, t.ex. för att consolea till en server. Det finns olika implementationer av IPMI, t.ex. HPs kallas iLO och Dells kallas iDRAC.

Installation
 yum install OpenIPMI OpenIPMI-tools

==Ipmitool==
Ipmitool är ett verktyg som kan användas för att konfigurera IPMI på de flesta linuxsystem inklusive [[VMware_ESXi|ESXi]]. Antingen kan man kompilera det själv eller ladda ner färdig binär. Logga in på server med SSH:
 wget http://harsbo.se/filer/ipmitool
 chmod +x ipmitool
För att lista kommandoalternativ kör kommandot utan parametrar.

Skapa användare
 ./ipmitool user set name 2 admin
 ./ipmitool user set password 2 &lt;some passwd&gt;
 ./ipmitool user priv 2 4 1
 ./ipmitool channel setaccess 1 2 callin=on ipmi=on link=on privilege=4
 ./ipmitool user list 
 ./ipmitool user enable 2
IPconfig
 ./ipmitool lan set 1 ipsrc static
 ./ipmitool lan set 1 ipaddr 10.0.0.45
 ./ipmitool lan set 1 defgw ipaddr 10.0.0.1
 ./ipmitool lan set 1 netmask 255.255.255.0
 ./ipmitool lan set 1 vlan id 5
 ./ipmitool lan print</text>
      <sha1>m1d1wathnnh59ngl9uih1i3d5cbwxpw</sha1>
    </revision>
  </page>
  <page>
    <title>IPXE</title>
    <ns>0</ns>
    <id>216</id>
    <revision>
      <id>1359</id>
      <parentid>1352</parentid>
      <timestamp>2015-12-10T17:49:47Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2306">iPXE är en open source network boot firmware. Funkar precis som vanliga PXE fast med en del extra features som:
*Boota från web server via HTTP.
*Boota från ett iSCSI SAN, AoE SAN eller Fibre channel SAN via FCoE.
*Boota från Wi-Fi eller WAN koppling.
*Boota från ett Infiniband nätverk.
*Kontrollera boot processen med hjälp av script.

Man kan flasha in iPXE ROM filen på sitt nätverkskort. Vill man inte det kan man ladda iPXE över TFTP med PXE. Se även [[PXE-Deploy]]

=Förberedelse=
För att kunna bygga iPXE från source koden behövs följande paket:
*gcc (version 3 or later)
*binutils (version 2.18 or later)
*make
*perl
*syslinux (for isolinux, only needed for building .iso images)
*liblzma or xz header files
*zlib, binutils and libiberty header files (only needed for EFI builds)

=Installation=
Ladda hem senaste source koden från GIT.
 git clone git://git.ipxe.org/ipxe.git &amp;&amp; cd ipxe/src
 make

==Bootbar ISO==
iPXE har en egen [http://boot.ipxe.org/ipxe.iso bootbar ISO] om man vill prova snabbt och enkelt.

==VMware==
Du kan byta ut VMwares PXE rom med iPXE.

iPXE har stöd för följande vmware nics.
{| class="wikitable"
!
VMware name
!
iPXE driver name
!
PCI vendor:device IDs
!
iPXE ROM image
|-
|e1000
|intel
|8086:100f
|8086100f.mrom
|-
|e1000e	
|intel
|8086:10d3
|808610d3.mrom
|-
|vlance	
|pcnet32
|1022:2000
|10222000.rom
|-
|vmxnet	
|(not supported)
|15ad:0720
|
|-
|vmxnet3	
|vmxnet3
|15ad:07b0
|15ad07b0.rom 
|}

Börja med att välja en av dom supportade nics genom att ändra följande rad i din '''.vmx''' fil.
 ethernet0.virtualDev = "e1000"

Ladda hem source koden och bygg filerna med följande kommando.
 git clone git://git.ipxe.org/ipxe.git &amp;&amp; cd ipxe/src
 make bin/8086100f.mrom bin/808610d3.mrom bin/10222000.rom bin/15ad07b0.rom

Kopiera sedan över följande filer '''8086100f.mrom, 808610d3.mrom, 10222000.rom''' och '''15ad07b0.rom''' till din vmware server och lägg dom på tex ett datastore.

Lägg sedan till följande rader i din '''.vmx''' fil.
 ethernet0.opromsize = 262144
 e1000bios.filename = "/path/to/datastore/8086100f.mrom"
 e1000ebios.filename = "/path/to/datastore/808610d3.mrom"
 nbios.filename = "/path/to/datastore/10222000.rom"
 # nxbios.filename = ""
 nx3bios.filename = "/path/to/datastore/15ad07b0.rom"

[[Category:Guider]]</text>
      <sha1>ey74bvlvtewfr7pncgf5bhggivjjw74</sha1>
    </revision>
  </page>
  <page>
    <title>IPv6</title>
    <ns>0</ns>
    <id>129</id>
    <revision>
      <id>3075</id>
      <parentid>1298</parentid>
      <timestamp>2019-11-27T09:06:30Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="695">Mängden IPv4-trafik förutspås peaka år 2020, IPv6 ska ingenstans. Testa dig och dina servrar (och få en t-shirt!):
 https://ipv6.he.net/certification/

==Subnet Security==
* RA Guard
* DHCPv6 Guard
* SAVI
* IPv6 ND Inspection

==DHCP==
'''Stateless DHCPv6:''' with this option SLAAC is still used to get the IP address, but DHCP is used to obtain “other” configuration options, usually things like DNS, NTP, etc.

'''Stateful DCHPv6:''' functions exactly the same as IPv4 DHCP in which hosts receive both their IPv6 address and additional parameters from the DHCP server.

==Tunnlar==
IPv6 går att tunnla på diverse olika sätt, se [[Cisco_GRE#IPv6|Cisco IPv6]].

[[Category:Network]]</text>
      <sha1>cwdmku71i279kou3l1frkpof9j3li0c</sha1>
    </revision>
  </page>
  <page>
    <title>IRedMail</title>
    <ns>0</ns>
    <id>40</id>
    <revision>
      <id>845</id>
      <parentid>538</parentid>
      <timestamp>2015-07-24T13:21:56Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1901">[[Category:Guider]]
Att sätta upp en e-postserver är ett relativt stort projekt. Innan du börjar att installera och konfigurera de nödvändiga paketen på mailservern bör du lära dig vad allt betyder och förstå hur komponenterna samverkar för att skicka och ta emot e-post. För detta finns många resurser på internet. Det finns nackdelar med att köra sin egna mailserver. T.ex. om en användare har glömt eller vill byta lösenord måste du fixa det. Får du problem med spam blir din domän svartlistad. Du kan behöva unik relay-konfiguration för att få det att lira ut från din ISP:s nät.

Denna artikel behandlar en av de smidigaste kompletta maillösningarna idag, iRedMail. 

=== Alternativ ===
Vill man istället sätta upp alla komponenterna manuellt rekommenderar jag att man följer följande guide istället:
 https://www.linode.com/docs/email/postfix/email-with-postfix-dovecot-and-mysql
Det är den absolut bästa postfix/dovecot/mysql-guide som finns. Teoriavsnittet är också välskrivet. Att köra igenom denna guide är väldigt lärorikt men ganska tidskrävande.

==Installation==
Vill man ha samma komponenter och funktionalitet men en smidigare installationsprocess är iRedMail ett utmärkt alternativ. Man får även ett webgui för kontohantering&lt;br/&gt;
Rekommenderat OS: Ubuntu 14.04 / Debian 7
 sudo su -
 mkdir /mailroot 
 wget https://bitbucket.org/zhb/iredmail/downloads/iRedMail-0.9.2.tar.bz2
 tar xjf iRedMail-0.9.2.tar.bz2 &amp;&amp; cd iRedMail-0.9.2
 bash iRedMail.sh
Kör igenom den självförklarande guiden
 rm /root/iRedMail-0.9.2/config
 reboot

==Administration==
Domän och kontohantering görs med webgui.
 https://192.168.0.10/iredadmin
Vanlig webbmail ligger på:
 https://192.168.0.10

==SPF==

==DKIM==

==Rsync==
Rsync kan användas för att ta backup på /mailroot

==Loggar==
Kolla sammanställning av din loggfil.
 pflogsumm /var/log/mail.log</text>
      <sha1>phbkzc6q53se1drfdhybp37oxxg0fp0</sha1>
    </revision>
  </page>
  <page>
    <title>ISC DHCP</title>
    <ns>0</ns>
    <id>57</id>
    <revision>
      <id>1622</id>
      <parentid>823</parentid>
      <timestamp>2016-04-10T15:02:46Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2160">[[Category:Guider]]
"ISC's DHCP software is the most widely used open source DHCP implementation on the Internet. The same software can be used for LAN too. It is a carrier and enterprise grade solution to your host configuration needs." - nixCraft

Se även [[Kea| Kea DHCP]].

==Installation==
 sudo apt-get -y install isc-dhcp-server
 sudo sed -i -r 's/INTERFACES=""/INTERFACES="eth0"/g' /etc/default/isc-dhcp-server

==Konfiguration==
 sudo dd of=/etc/dhcp/dhcpd.conf &lt;&lt; EOF
 # Uppsatt av:
 
 # You must prevent the DHCP server from receiving DNS information 
 # from clients, set the following global option (this is a security feature):
 ddns-update-style none;
 
 # You need to set your domain name and name server:
 option domain-name "exempel.se";
 option domain-name-servers 8.8.8.8, 208.67.222.222;
 
 # Increase the lease time. The time is set in seconds:
 default-lease-time 7200;
 max-lease-time 14400;
 
 # If this DHCP server is the official DHCP server for the local
 # network, the authoritative directive should be uncommented.
 # The authoritative directive indicate that the DHCP server 
 # should send DHCPNAK messages to misconfigured clients. 
 # If this is not done, clients will be unable to get a correct 
 # IP address after changing subnets until their old lease has 
 # expired, which could take quite a long time.
 authoritative;
 
 # Use this to send dhcp log messages to a different log file (you also
 # have to hack syslog.conf to complete the redirection).
 log-facility local7;
 
 # No service will be given on this subnet, but declaring it helps the
 # DHCP server to understand the network topology.
 subnet 10.0.100.0 netmask 255.255.255.0 {
 }
 
 #Ranges
  
 subnet 10.0.1.0 netmask 255.255.255.0 {
        range 10.0.1.100 10.0.1.200;
        option subnet-mask 255.255.255.0;
        option broadcast-address 10.0.1.255;
        option routers 10.0.1.1;
 }
 
 subnet 10.0.2.0 netmask 255.255.255.0 {
        range 10.0.2.100 10.0.2.200;
        option subnet-mask 255.255.255.0;
        option broadcast-address 10.0.2.255;
        option routers 10.0.2.1;
 }
 
 ## Slut
 EOF
Testa
 sudo dhcpd -t /etc/dhcp/dhcpd.conf</text>
      <sha1>ryksj005l02hd15sor84yvfbs0t7qjf</sha1>
    </revision>
  </page>
  <page>
    <title>Icinga</title>
    <ns>0</ns>
    <id>106</id>
    <revision>
      <id>940</id>
      <parentid>891</parentid>
      <timestamp>2015-08-20T10:43:28Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6984">{{inteklar}}

Icinga är ett forkat project av Nagios det betyder att Icinga är bakåtkompatibel med nästan alla Nagios plugins och add-ons skrivna för Nagios. 

Icinga skapades för att fixa brister i Nagios utveckling och för att lägga till nya funktioner som ett moderna web 2.0 interface, fler stöd för databaser(Oracle, PostgreSQL och MySQL) och ett REST API. Dom släpper också patcher oftare och snabbare än vad Nagios gjorde.

==Arkitektur==
[[File:Icinga_Architecture_v1.5.png|200px|Arkitekturen|thumb]]
Icinga är uppdelat i tre olika delar.

'''Core''' sköter all övervakning sparar alla resultat och data på IDO DBn. Den skickar också ut en alert om något har hänt.

'''Icinga Data Out Database''' (IDODB) fungerar som lagringsyta för all övervakningsdata som add-ons eller webinterfacet kan hämta.

'''Icinga's user interface''' som hämtar data från IDODBn och visar upp resultatet. Används också för att skicka kommandon mot Core.

==Förberedelse==
Lägg till lite repon för att få senaste versionen.
===Repository===
====Debian====
'''Icinga Debian repo'''
 wget -O - http://packages.icinga.org/icinga.key | apt-key add -
 echo deb http://packages.icinga.org/debian icinga-jessie main &gt;&gt; /etc/apt/sources.list 
 echo deb-src http://packages.icinga.org/debian icinga-jessie main &gt;&gt; /etc/apt/sources.list
 apt-get update

'''Debian backports repo'''
 echo deb http://ftp.se.debian.org/debian/ jessie-backports main &gt;&gt; /etc/apt/sources.list
 apt-get update

'''Debmon repo'''
 wget -O - http://debmon.org/debmon/repo.key 2&gt;/dev/null | apt-key add -
 echo 'deb http://debmon.org/debmon debmon-jessie main' &gt;/etc/apt/sources.list.d/debmon.list
 apt-get update

====Ubuntu====
'''Icinga Ubuntu repo''''
 wget -O - http://packages.icinga.org/icinga.key | apt-key add -
 echo deb http://packages.icinga.org/ubuntu icinga-trusty main &gt;&gt; /etc/apt/sources.list
 echo deb-src http://packages.icinga.org/ubuntu icinga-trusty main &gt;&gt; /etc/apt/sources.list
 apt-get update

'''Icinga PPA repo'''
 add-apt-repository ppa:formorer/icinga
 apt-get update

==Installation==
===Core===
För att installera Icinga2 core skriv,
 apt-get install icinga2

Utan plugins vet inte Icinga hur den ska kolla en tjänst. Enklast är att tanka hem en färdig bundle med plugins.
 apt-get install nagios-plugins

===Icinga Data Out Database===
Guiden utgår ifrån att du kommer köra en lokal MySQL databas.

Installera MySQL
 apt-get install mysql-server mysql-client

Logga in och skapa en databas samt en användare med rättigheter.
 mysql -u root -p
 CREATE DATABASE icinga;
 GRANT SELECT, INSERT, UPDATE, DELETE, DROP, CREATE VIEW, INDEX, EXECUTE ON icinga.* TO 'icinga'@'localhost' IDENTIFIED BY 'icinga';

Lägg sedan till MySQL ido paketet. Paketet har en wizard som du kan använda eller skippa och göra det manuellt om du vill.
 apt-get install icinga2-ido-mysql

Om du vill få upp wizarden igen skriv &lt;code&gt;dpkg-reconfigure icinga2-ido-mysql&lt;/code&gt;

För att ansluta manuellt använd conf filen &lt;code&gt;/etc/icinga2/features-available/ido-mysql.conf&lt;/code&gt; [http://docs.icinga.org/icinga2/latest/doc/module/icinga2/chapter/object-types#objecttype-idomysqlconnection Exempel conf MySQL]

Importera MySQL schemat.
 mysql -u root -p icinga &lt; /usr/share/icinga2-ido-mysql/schema/mysql.sql

Enabla featuren ido-mysql
 icinga2 feature enable ido-mysql

Starta om icinga2 för att det ska gälla.
 service icinga2 restart


===Icinga's user interface===
Icinga erbjuder tre st web interface, Icinga Web 2, Icinga Web och Classic UI.

Guiden utgår ifrån att du har färdig [[LAMP]] server. Vill du LDAP/AD koppla inlogget krävs PHP LDAP library. 

====Icinga Web 2====
Det finns två sätt att installera Web 2. Första med hjälp av repot eller andra med git. 
Över repot sker många steg automatiskt men du får kanske inte senaste versionen.
Med GIT får du senaste versionen men får göra fler steg själv.

=====Repo=====
 apt-get install icingaweb2 icingacli

Skapa sedan en setup token med,
 icingacli setup token create

För att visa den ifall du skulle glömma av den skriv,
 icingacli setup token show

Surfa sedan till http://ip/icingaweb2/setup för att följa wizarden.

=====Git=====
Börja med att klona repot.
 git clone git://git.icinga.org/icingaweb2.git

Flytta sedan repot och gå till dess plats.
 mv icingaweb2 /usr/share/icingaweb2 &amp;&amp; cd /usr/share/icingaweb2

Skapa en konfigurationsfil till Apache eller Nginx.

'''Apache'''
 ./bin/icingacli setup config webserver apache --document-root /usr/share/icingaweb2/public &gt; /etc/apache2/sites-available/icingaweb2
 a2ensite icingaweb2
 service apache2 restart

'''Nginx'''
 ./bin/icingacli setup config webserver nginx --document-root /usr/share/icingaweb2/public

Både webusern och cli usern måste ha tillgång till conf och loggar. Permissions sköter man med en special grupp.
 addgroup --system icingaweb2 &amp;&amp; usermod -a -G icingaweb2 www-data

Skapa ett configuration directory. Default är &lt;code&gt;/etc/icingaweb2&lt;/code&gt;
 ./bin/icingacli setup config directory

Skapa en setup token med kommandot.
 ./bin/icingacli setup config directory

Visa setup token ifall du glömmer bort den.
 ./bin/icingacli setup token show

Surfa sedan till http://&lt;ip&gt;/icingaweb2/setup för att följa wizarden.

==Kommandon==
Icinga har en hög olika [http://docs.icinga.org/icinga2/latest/doc/module/icinga2/chapter/cli-commands#cli-command-feature CLI kommandon].

===Features===
Kolla vilka features som är enablat.
 icinga2 feature list

===systemctl/init===

 systemctl status icinga2
 /etc/init.d/icinga2 status
{| class="wikitable"
|+Kommando beskrivning
|-
|start||The start action starts the Icinga 2 daemon.
|-
|stop||The stop action stops the Icinga 2 daemon.
|-
|restart||The restart action is a shortcut for running the stop action followed by start.
|-
|reload||The reload action sends the HUP signal to Icinga 2 which causes it to restart. Unlike the restart action reload does not wait until Icinga 2 has restarted.
|-
|checkconfig||The checkconfig action checks if the /etc/icinga2/icinga2.conf configuration file contains any errors.
|-
|status||The status action checks if Icinga 2 is running.
|}


==Konfiguration==

{| class="wikitable"
!|Path!!Description
|-
|/etc/icinga2||Contains Icinga 2 configuration files.
|-
|/etc/init.d/icinga2||The Icinga 2 init script.
|-
|/usr/sbin/icinga2||The Icinga 2 binary.
|-
|/usr/share/doc/icinga2||Documentation files that come with Icinga 2.
|-
|/usr/share/icinga2/include||The Icinga Template Library and plugin command configuration.
|-
|/var/run/icinga2||PID file.
|-
|/var/run/icinga2/cmd||Command pipe and Livestatus socket.
|-
|/var/cache/icinga2||status.dat/objects.cache, icinga2.debug files
|-
|/var/spool/icinga2||Used for performance data spool files.
|-
|/var/lib/icinga2||Icinga 2 state file, cluster log, local CA and configuration files.
|-
|/var/log/icinga2||Log file location and compat/ directory for the CompatLogger feature.
|}</text>
      <sha1>5fjgh14bj1s1g6ms59oktklek64i50g</sha1>
    </revision>
  </page>
  <page>
    <title>InSSIDer</title>
    <ns>0</ns>
    <id>66</id>
    <revision>
      <id>1529</id>
      <parentid>793</parentid>
      <timestamp>2016-03-07T18:14:56Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="389">Wi-Fi går med ljusets hastighet men är tyvärr inte alltid pålitligt eftersom det är ett delat medium. De 3 största problemen är co-channel, overlapping och signalstörning. Med inSSIDer ser man vad som orsakar problemen. InSSIDer 3.1.2.1 är den senaste freeware-varianten. Redaktionen rekommenderar.
 http://ds.karen.hj.se/~cameljoe/resources/inSSIDer-free.msi
[[Category:Windows]]</text>
      <sha1>qyzt9npczz55iilwwqh3z9k0sz1e8ud</sha1>
    </revision>
  </page>
  <page>
    <title>InspIRCd</title>
    <ns>0</ns>
    <id>262</id>
    <revision>
      <id>2293</id>
      <parentid>2171</parentid>
      <timestamp>2017-04-19T19:01:58Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Tips n Tricks */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3002">[[Category:Guider]]
InspIRCd är en modulär IRC server. Servern är skriven från scratch för att vara stabil, modern och lättviktigt och stöd för många extra features som SSL stöd med GNUTLS eller OpenSSL, LDAP stöd för användare med mera. Servern går att köra på Linux, Windows, BSD och Mac OSX.

=Installation=
Börja med att installera paket för att kunna kompilera servern och kunna ladda ner moduler.
 apt-get install g++ clang libwww-perl pkg-config

Clona ner senaste stabila releasen från Github. 
 git clone -b insp20 git://github.com/inspircd/inspircd.git

För att kolla vilka extra features det finns kör:
 ./configure --list-extras

För att lägga till en feature tex SSL stöd med GNUTLS skriv:
 ./configure --enable-extras=m_ssl_gnutls.cpp
'''OpenSSL vs. GnuTLS'''
Det har körts benchmarks mellan GnuTLS och OpenSSL där GnuTLS har varit snabbare än OpenSSL. Därför rekommenderas det att använda GnuTLS som SSL module.

Om du vill lägga till nån extra modul använd. Det går också att lägga till moduler i efterhand med modulemanager.
 ./modulemanager

När du är klar kör följande kommando. Du kommer få en del frågor att svara på. Du behöver inte vara root för att kompilera eller starta servern.  
 ./configure
 make
 make install

=Konfiguration=
Kopiera exempel conf filerna från exempel mappen och gör dom ändringar du känner för.
 cp modules.conf.example ../modules.conf
 cp inspircd.conf.example ../inspircd.conf
 cp opers.conf.example ../opers.conf

==GnuTLS==
Om du vill att klienter ska kunna köra SSL behövs följande rader:
 &lt;bind address="" port="6667" type="clients" ssl="gnutls"&gt;
 &lt;gnutls cafile="conf/fullchain.pem" certfile="conf/cert.pem" keyfile="conf/privkey.pem" dhfile="conf/dh_4096.pem" dhbits="4096" hash="sha1"&gt;

==Hashade lösenord==
För att använda en sha256 hash i conf filerna istället för okrypterat lösenord krävs följande module i '''modules.conf''' laddad:
 &lt;module name="m_sha256.so"&gt;

Använd denna [http://www.xorbin.com/tools/sha256-hash-calculator sida] för att generera en hash.

För att använda en hash till något krävs denna raden inom samma block:
 &lt;... hash="sha256" password="SecretHash" ...&gt;

==Lösenords skydda servern==
Om du vill lösenords skydda din IRC server så ange följande i connect blocket:
 password="SecretPW"

==Skapa ett operator konto==
Ett operator konto kan vara bra att ha för att inte tappa kontrollen eller ladda om configen på servern utan att behöva starta om.

I '''oper.conf''' anger du följande rad:
 &lt;oper name="username" hash="sha256" password="SecretHASH" host="*" type="netadmin"&gt;

För att bli operator skriver du följande i din IRC klient till servern:
 /oper Username password

=Tips n Tricks=
Medans InspIRCd har många moduler och features så saknar den vissa saker som att kunna registrera sitt nickname, skydda sin kanal mot takeovers och andra bra och ha IRC tjänster.

Därför kan man behöva använda sig av [[Shaltúre]] IRC services.</text>
      <sha1>l2nc547genouzzglv0v0mzfd0tu214j</sha1>
    </revision>
  </page>
  <page>
    <title>Iperf</title>
    <ns>0</ns>
    <id>90</id>
    <revision>
      <id>3106</id>
      <parentid>1345</parentid>
      <timestamp>2021-01-21T07:48:23Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1399">Iperf är ett verktyg som används för att testa bandbredd mellan 2 noder i ett nätverk. Det sätter upp TCP- och UDP-dataströmmar för att mäta throughput.

===Iperf3===
Iperf3 är en omskrivning av Iperf från början, med målet om en mindre och enklare kodbas. Programmet funkar med både IPv4 och IPv6. Iperf3 är inte bakåtkompatibel med Iperf2.

 apt-get install iperf3
 yum install iperf3

===Server===
Den ena noden är server och lyssnar på inkommande instruktioner. Default är TCP/UDP 5201. För att starta iperf i server läge.
 iperf3 -s
Daemon mode och port 5203
 iperf3 -s -D -p 5203

'''Systemd'''&lt;br/&gt;
 sudo nano /etc/systemd/system/speedtest.service
 [Unit]
 Description=iPerf3 speed test server
 After=network.target
 
 [Service]
 ExecStart=/usr/bin/iperf3 -s -p 5500
 
 [Install]
 WantedBy=multi-user.target

 sudo systemctl daemon-reload
 sudo systemctl start speedtest.service
 sudo systemctl enable speedtest.service

===Klient===
För att starta ett test mot servern skriv.
 iperf3 -c &lt;ip till server&gt;
Ställ hur länge testat ska köra. Default är 10 sekunder.
 iperf3 -c 192.168.0.20 -t 60
Reverse mode, servern skickar till klienten.
 iperf3 -c 192.168.0.20 -R
För att köra 5 streams samtidigt skriv.
 iperf3 -c 192.168.0.20 -P 5
UDP kan användas för att mäta jitter och paketförlust. ''Klientspecifik växel.''
 iperf3 -c 192.168.0.20 -u

[[Category:Tools]]</text>
      <sha1>1yuna4mxw5nw9dgbwir2si51hziaiq0</sha1>
    </revision>
  </page>
  <page>
    <title>Iproute2</title>
    <ns>0</ns>
    <id>59</id>
    <revision>
      <id>3124</id>
      <parentid>2864</parentid>
      <timestamp>2021-09-28T13:39:45Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>TC additions</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4956">Ifconfig, arp och route-kommandona är påväg bort, vänj dig vid iproute2. De två viktigaste verktygen är ip och tc (traffic control)&lt;br/&gt;
Med dessa kommandon behöver man inte skriva ut alla bokstäver, likt switchar och routrar. T.ex. ip a s är samma som ip address show

{| class="wikitable"
|-
! Gamla kommandot 
! Nya kommandot
! Kommentar
|-
| &lt;code&gt;ifconfig&lt;/code&gt;
| &lt;code&gt;ip addr&lt;/code&gt;, &lt;code&gt;ip link&lt;/code&gt;, &lt;code&gt;ip -s&lt;/code&gt;
| Adresser och länk config 
|-
| &lt;code&gt;route&lt;/code&gt;
| &lt;code&gt;ip route&lt;/code&gt;
| Routing tables
|-
| &lt;code&gt;arp&lt;/code&gt;
| &lt;code&gt;ip neigh&lt;/code&gt;
| Neighbors
|-
| &lt;code&gt;iptunnel&lt;/code&gt;
| &lt;code&gt;ip tunnel&lt;/code&gt;
| Tunnels
|-
| &lt;code&gt;nameif&lt;/code&gt;
| &lt;code&gt;ifrename&lt;/code&gt;, &lt;code&gt;ip link set name&lt;/code&gt;
| Byt namn på ett interface
|-
| &lt;code&gt;ipmaddr&lt;/code&gt;
| &lt;code&gt;ip maddr&lt;/code&gt;
| Multicast
|-
| &lt;code&gt;netstat&lt;/code&gt;
| &lt;code&gt;ip -s&lt;/code&gt;, &lt;code&gt;ss&lt;/code&gt;, &lt;code&gt;ip route&lt;/code&gt;
| Visar nät statistik, tex vilka portar man lyssnar på
|}

==ip==
Version
 ip -V
'''ip address show'''
 ip a
 ip -br a
 ip a s eth0

'''ip routes show'''
 ip r

'''ip link''' &lt;br/&gt;
ifconfig
 ip l
 ip -br l
 ip -s l  #med statistik
ifup/ifdown
 ip link set eth0 up/down
Description
 ip link set eth0 alias "LAN interface"
Promiscuous mode på interface
 ip link set eth0 promisc on
 ip a | grep PROMISC
Macchanger
 ip link set dev eth0 address 00:11:22:33:44:55

'''ip neigh''' &lt;br/&gt;
ARP/NDP
 ip n
Flush cache
 ip n f

'''Monitor''' &lt;br/&gt;
Monitor changes in network configuration, routing tables, and ARP/NDP tables from terminal.
 ip monitor

===VXLAN===
VXLAN är ett tunnlingsprotokoll designat för att lösa skalbarhetsbegränsningar med VLAN. Det ökar från 4096 till 24 bitar (16 miljoner) id:n. Protokollet körs över en enskild konfigurerbar UDP-port. EN VXLAN-enhet kan lära sig MAC/IP-adresser tillhörande andra sidan tunneln antingen dynamiskt likt en switch eller med statiska forwarding entries.

'''Unicast'''
 ip link add vxlan0 type vxlan id 10 remote 2.2.2.2 local 1.1.1.1 dev eth0
VTEP-kommunikation görs alternativt med multicast.
 ip link add vxlan0 type vxlan id 10 group 239.1.1.1 dev eth0 dstport 4789

Vxlan-interfacet kopplas sedan till en [[Open_vSwitch|Open vSwitch]] eller [[Bridge|Linux Bridge]]. 
 brctl addif br0 vxlan0
Enablea interface
 ip link set up dev vxlan0

Kolla interface och forwarding table
 ip -d link show vxlan0
 bridge fdb show dev vxlan0

Delete interface
 ip link delete vxlan0

Disable source-address learning, detta kan t.ex. göras om man har BGP EVPN som synkroniserar FDBs.
 ip link add vxlan0 type vxlan id 10 remote 2.2.2.2 local 1.1.1.1 dev eth0 '''nolearning'''

Skapa entry manuellt
 bridge fdb add to 00:00:0c:80:bb:07 dst 2.2.2.2 dev vxlan0

===GRETAP===
Generic Routing Encapsulation on linux.
 ip link add GRETAP1 type gretap local 172.16.0.10 remote 192.168.0.10 dev eth0
 ip link add br0 type bridge
 ip link set eth1 master br0
 ip link set eth1 up
 ip link set br0 up
 ip link set GRETAP1 up
 ip link set GRETAP1 master br0
 ifconfig br0 promisc

===L2TPv3===
Layer Two Tunneling Protocol - Version 3.
 modprobe l2tp_eth
 ip l2tp add tunnel local 1.1.1.1 remote 2.2.2.2 tunnel_id 100 peer_tunnel_id 200 encap udp udp_sport 5000 udp_dport 5000
 ip l2tp add session tunnel_id 100 session_id 300 peer_session_id 300
Show
 ip l2tp show tunnel

===Network Namespace===
Skapa VRF, assigna interface och sätt adress
 ip netns add MGMT
 ip link set eth1 netns MGMT
 ip netns exec MGMT ip addr add 10.0.0.101/24 dev eth1
 ip netns exec MGMT ip route add default via 10.0.0.1
 ip netns list

===Subinterface===
 ip link add link eth1 name eth1.20 type vlan id 20
 ip address add 192.168.20.1/24 dev eth1.20 
 ip link set eth1.20 up

===MAC VLAN===
Med MAC VLAN kan man assigna flera MAC-adresser till samma interface. Man kan uppnå samma resultat som med [[Bridge]] men det är mer light-weight. Det kan skapas i 4 modes: private, vepa, bridge eller passthru beroende på säkerhetskraven. Det går att köra MAC VLAN tillsammans med [[KVM]].
 ip link add link eth0 mac0 type macvlan

===Blackhole===
Discard traffic sent to unwanted destinations
 ip route add blackhole 192.168.2.0/30

===Configuration Caching===
Ska man flytta en IP-adress från ett interface till ett annat är det bra att flusha cachen emellan för att säkerställa att det inte hänger kvar något.
 ip a flush dev &lt;OLD-device&gt;

==ss==
Socket statistics. Användbart och lättmemorerat kommando som ersätter netstat:
 ss -tulpan

==tc==
Traffic control. Command wrapper: tcconfig.

'''Network Emulator''' &lt;br/&gt;
Delay
 tc qdisc change dev eth0 root netem delay 100ms 20ms distribution normal
Packet loss
 tc qdisc change dev eth0 root netem loss 0.3% 25%
Reorder
 tc qdisc change dev eth0 root netem delay 10ms reorder 25% 50%
Policing
 tc qdisc add dev eth0 root tbf rate 2mbit burst 32kbit latency 600ms
Show config
 tc qdisc show dev eth0
Clear config
 tc qdisc del dev eth0 root

[[Category:Tools]]</text>
      <sha1>tnli86zcr6puglnzf5i6f6uonenrm7i</sha1>
    </revision>
  </page>
  <page>
    <title>Iptables</title>
    <ns>0</ns>
    <id>45</id>
    <revision>
      <id>1503</id>
      <parentid>1374</parentid>
      <timestamp>2016-02-09T16:20:14Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>/* Regelverk */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5325">Källa och väldigt bra läsning: http://www.lysator.liu.se/~kjell-e/tekla/linux/security/iptables/

Sätt upp en brandvägg för att begränsa och blockera oönskad inkommande trafik till din server, detta är valfritt men rekommenderat. Kommandot iptables används för att kontrollera netfilter, den underliggande tekniken som funnits med i linuxkärnan sedan 2.4.

=Komponenter=
=== Tables ===
Tables är de stora delarna av netfilter, och består av FILTER, NAT, och MANGLE. FILTER används för vanlig hantering av paket, och är standardtabellen om ingen annan anges. NAT används för att skriva om source och/eller destination för paket. MANGLE används för att på annat sätt modifiera paket, t.ex. modifiera olika delar av en TCP header.

=== Chains ===
Chains är sedan associerade med varje table. Chains är listor av regler inom en table, och de är associerade med platser där man kan avlyssna trafiken och vidta åtgärder. 

Dessa chains finns:

'''PREROUTING:''' Immediately after being received by an interface.

'''POSTROUTING:''' Right before leaving an interface.

'''INPUT:''' Right before being handed to a local process.

'''OUTPUT:''' Right after being created by a local process.

'''FORWARD:''' For any packets coming in one interface and leaving out another.

=== Kombinationer ===
'''FILTER''': Input, Output, Forward

'''NAT''': PREROUTING, POSTROUING, Output

'''MANGLE''': PREROUTING, POSTROUING, Input, Output, Forward

=== Targets ===
Targets bestämmer vad som kommer att hända med ett paket i en kedja om en matchning hittas med en av dess regler. De två vanligaste är DROP och ACCEPT.

=Regelverk=
Kolla regelverk
 sudo iptables -S
Skapa regelverk
&lt;syntaxhighlight lang="bash"&gt;
sudo dd of=/etc/iptables.firewall.rules &lt;&lt; EOF
*filter

# Standard
-A INPUT -i lo -j ACCEPT
-A INPUT -d 127.0.0.0/8 -j REJECT
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Portar och protokoll
-A INPUT -p tcp --dport 80 -j ACCEPT
-A INPUT -p tcp --dport 443 -j ACCEPT
-A INPUT -p tcp -m state --state NEW --dport 22 -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -j ACCEPT

# Catch all
-A INPUT -j DROP
-A FORWARD -j DROP
-A OUTPUT -j ACCEPT

COMMIT
EOF
&lt;/syntaxhighlight&gt;

Rules activate!
 sudo iptables-restore &lt; /etc/iptables.firewall.rules
 sudo iptables -L -n -v --line-numbers

===Persistent===
Behåll regler efter omstart, Debian/Ubuntu
&lt;syntaxhighlight lang="bash"&gt;
sudo dd of=/etc/network/if-pre-up.d/firewall &lt;&lt; EOF
#!/bin/sh
/sbin/iptables-restore &lt; /etc/iptables.firewall.rules
EOF
sudo chmod +x /etc/network/if-pre-up.d/firewall
&lt;/syntaxhighlight&gt;

Alternativt använd iptables-persistent
 apt-get install iptables-persistent
 iptables-save &gt; /etc/iptables/rules.v4

=Dynamisk IP=
Att ha dynamisk IP suger men så är det ibland. Som tur är kan iptables uppdatera sina regler automatiskt även om en IP-adress ändras. Det som behövs är ett DNS-namn mot IPn.
 iptables -N DYNDNS
 iptables -A INPUT -p tcp -m tcp --dport 22 -j DYNDNS
Sedan ett script som körs enligt schemaläggning
&lt;syntaxhighlight lang="bash"&gt;
sudo dd of=/etc/dyndns.sh &lt;&lt; EOF
#!/bin/bash
iptables -F DYNDNS 
iptables -A DYNDNS -s dyndns.exempel.se -j ACCEPT
EOF
sudo chmod +x /etc/dyndns.sh
echo "0 * * * * /etc/dyndns.sh" | sudo crontab -
&lt;/syntaxhighlight&gt;
Uppdatering en gång i timmen

=IPset=
IPset är ett verktyg för att hantera regler. Det är en extension till iptables som tillåter skapandet av regler som matchar mot grupper med t.ex. IP-adresser, nätverk och portar. Med grupper kan man få ner antalet regelrader vilket förenklar uppsättning och felsökning samt ökar skalbarhet och prestanda. 
 sudo apt-get install ipset
 sudo dnf install ipset

Exempelanvändning, skapa ett set.
 ipset -N myset nethash
 ipset -A myset 1.1.1.1
 ipset -A myset 2.2.2.2
 iptables -A INPUT -p tcp -m set --set myset src --dport 22 -j ACCEPT

Kolla grupper
 sudo ipset list

===Exempelscript===
&lt;syntaxhighlight lang="bash"&gt;
## Firewall script by Helikopter

# Flush old settings
iptables -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X &amp;&amp; iptables -t mangle -X &amp;&amp; iptables -Z &amp;&amp; ipset destroy

#####################################################################################
### Standardregler och policy

iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -p icmp -j ACCEPT
iptables -A INPUT -i lo -j ACCEPT

# Default policy
iptables -P INPUT DROP
iptables -P OUTPUT ACCEPT
iptables -P FORWARD DROP


#####################################################################################
### Allt gors med grupper som definieras langre ner.

# Skapa grupper
ipset -N SSH nethash
ipset -N TSM nethash
ipset -N HTTPS nethash


# Regler, detta ar alla regler.
iptables -A INPUT -p tcp -m set --match-set SSH src --dport 22 -j ACCEPT
iptables -A INPUT -p tcp -m set --match-set TSM src --dport 1501 -j ACCEPT
iptables -A INPUT -p tcp -m set --match-set HTTPS src --dport 443 -j ACCEPT


#####################################################################################
### Har definieras grupperna, lagg IP-adresser har under.

## SSH
ipset -A SSH 172.16.20.0/24


## TSM
ipset -A TSM 172.16.10.100


## HTTPS
ipset -A HTTPS 10.0.2.0/24
ipset -A HTTPS 10.0.0.0/23
ipset -A HTTPS 172.24.190.110
ipset -A HTTPS 192.168.0.10
&lt;/syntaxhighlight&gt;

[[Category:Tools]]</text>
      <sha1>1w0gktya3r18hr68iaviv0y46b0r34c</sha1>
    </revision>
  </page>
  <page>
    <title>JQ</title>
    <ns>0</ns>
    <id>540</id>
    <revision>
      <id>2974</id>
      <parentid>2971</parentid>
      <timestamp>2019-05-02T20:21:21Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>Sparco moved page [[Jq]] to [[JQ]] without leaving a redirect</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1718">jq är en command-line JSON parser. Som kan användas precis lika enkelt som [[sed]],[[awk]] och [[grep]] används för text.

=Installation=
&lt;ul class="nav nav-tabs"&gt;
   &lt;li class="active"&gt;&lt;btn data-toggle="tab" class=""&gt;#tab1|CentOS 7&lt;/btn&gt;&lt;/li&gt;
   &lt;li&gt;&lt;btn data-toggle="tab" class=""&gt;#tab2|Ubuntu 16.04&lt;/btn&gt;&lt;/li&gt;
 &lt;/ul&gt;

 &lt;div class="tab-content"&gt;
   &lt;div id="tab1" class="tab-pane fade in active"&gt;
{{Epel-repo}}
Kör sedan:
 sudo yum install jq
   &lt;/div&gt;
   &lt;div id="tab2" class="tab-pane fade"&gt;
 sudo apt-get install jq
   &lt;/div&gt;
 &lt;/div&gt;

=Användning=
Skaffa lite exempel JSON via Hackernets API där vi söker på alla sidor som innehåller ordet Cisco:
 curl 'https://hackernet.se/api.php?action=query&amp;list=search&amp;srsearch=cisco&amp;format=json'
Pretty-printa JSON koden så den blir läsbar:
 curl 'https://hackernet.se/api.php?action=query&amp;list=search&amp;srsearch=cisco&amp;format=json' | jq '.'
Filtrera ut vilka sidor du hitta:
 curl 'https://hackernet.se/api.php?action=query&amp;list=search&amp;srsearch=cisco&amp;format=json' | jq '.query.search[].title'
Filtrera ut titeln och exempel texten från sidan:
 curl 'https://hackernet.se/api.php?action=query&amp;list=search&amp;srsearch=cisco&amp;format=json' | jq '.query.search[] | {titel: .title, text: .snippet}'
Sortera sidorna efter lägst antal ord:
 curl 'https://hackernet.se/api.php?action=query&amp;list=search&amp;srsearch=cisco&amp;format=json' | jq '.query.search | sort_by(.wordcount) | .[].title'
Skapa en URL till varje sida:
 curl 'https://hackernet.se/api.php?action=query&amp;list=search&amp;srsearch=cisco&amp;format=json' | jq '.query.search[] | ("https://hackernet.se/w/"+""+.title)'
=Tips'N'Tricks=
Använd [https://jqplay.org/ jqplay] för att enkelt skriva jq filter.

[[Category:Guider]]</text>
      <sha1>18cv4yog62f90kwxcsogx3n61ln7y2l</sha1>
    </revision>
  </page>
  <page>
    <title>Jumpgate</title>
    <ns>0</ns>
    <id>39</id>
    <revision>
      <id>3105</id>
      <parentid>3083</parentid>
      <timestamp>2021-01-20T20:30:34Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5055">En jumpgate kan användas för att öka säkerheten men också för att förenkla maskinhantering genom att ha ett enda ställe man loggar in på och kan managera övriga resurser.

==Grundläggande==
Grundläggande för en jumpgate är att ha en kompetent terminal multiplexer, t.ex [[Tmux]].

===Screen===
&lt;syntaxhighlight lang="bash"&gt;
sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get -y install screen

cat &lt;&lt;'__EOF__'&gt;&gt; .screenrc
defscrollback 10000
term xterm-256color
termcapinfo xterm* ti@:te@
altscreen on
nethack on
hardstatus alwayslastline
shelltitle 'bash'
hardstatus string '%{gk} %H [%{wk}%?%-Lw%?%{=b kR}(%{W}%n*%f %t%?(%u)%?%{=b kR})%{= w}%?%+Lw%?%? %{g} ] %{W}'
screen -t $ 0
screen -t $ 1 htop
screen -t bash 2 
select 0
__EOF__
&lt;/syntaxhighlight&gt;

Ännu mer grundläggande är att ha en automagisk screen som alltid ställer upp vid login.
&lt;syntaxhighlight lang="bash"&gt;
cat &lt;&lt;'__EOF__'&gt;&gt; .bashrc
if [ -z "$STARTED_SCREEN" ] &amp;&amp; [ -n "$SSH_TTY" ]
then
 case $- in
   (*i*)
     STARTED_SCREEN=1; export STARTED_SCREEN
     mkdir -p -- "$HOME/lib/screen-logs"
     screen -R -D -S main  ||
       echo "Screen failed! continuing with normal bash startup"
 esac
fi
__EOF__
&lt;/syntaxhighlight&gt;

===Tmux===
 sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get -y install tmux

Attacha automatiskt till din tmux session vid inloggning.
&lt;syntaxhighlight lang="bash"&gt;
if  -z "$TMUX" ; then
   tmux has-session &amp;&gt; /dev/null
   if [ $? -eq 1 ]; then
     exec tmux new
     exit
   else
     exec tmux attach
     exit
   fi
fi
&lt;/syntaxhighlight&gt;

'''Keep-Alive'''&lt;br/&gt;
Håll SSH-sessioner vid liv genom att skicka ett litet paket med jämna mellanrum.
 echo "    ServerAliveInterval 120" | sudo tee -a /etc/ssh/ssh_config

==SSH Autentisering==
För att göra inloggning mot andra maskiner smidigare kan man använda sig av SSH-nycklar som autentisering. Och för att göra det mindre smidigt se [[Google_Authenticator|Google Authenticator]].

Först måste man skaffa sig nyckelpar man kan distribuera till övriga hostar. Detta görs endast en gång.
 ssh-keygen -t rsa -b 4096
 ssh-keygen -t ecdsa -b 521
 ssh-keygen -t ed25519

Sedan skicka ut nyckeln till hostarna med:
 ssh-copy-id 192.168.0.10
''Om ssh-copy-id ej finns tillgängligt''
 cat ~/.ssh/id_rsa.pub | ssh user@192.168.0.10 "mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys"
Alternativt skicka med den vid automatiserad PXE-installation.

==Användarnamn==
För att slippa skriva olika användarnamn beroende på host kan man lägga in dem så de autoanvänds vid anslutning.
 dd of=~/.ssh/config &lt;&lt; EOF
 Host server1
 User root
 
 Host 192.168.0.1
 User elnacho
 
 Host fw02
 User admin
 ServerAliveInterval 60
 EOF

==Login Notification==
Sshd kan trigga script via PAM, t.ex. om man vill få en notis i slack när någon loggar in på en server.

&lt;syntaxhighlight lang="Bash"&gt;
echo "#sshd login notify slack, $(date)" | sudo tee -a /etc/pam.d/sshd &amp;&amp; \
echo "session  optional  pam_exec.so  /usr/sbin/sshd-login_notify-slack.sh" | sudo tee -a /etc/pam.d/sshd
sudo dd of=/usr/sbin/sshd-login_notify-slack.sh &lt;&lt; EOF
#!/bin/bash
if [ "$PAM_TYPE" != "close_session" ]; then
    WEBHOOK_URL="https://hooks.slack.com/services/0FTBMMLJ/EWUYGN2J/aGq3nW2PjrNcPdhxxx"
    SERVER="$(hostname)"
    PAYLOAD=" { \"text\": \"$PAM_USER logged in to $SERVER from remote host: $PAM_RHOST.\" }"
    curl -X POST -H 'Content-Type: application/json' -d "$PAYLOAD" "$WEBHOOK_URL"
fi
exit
EOF
sudo chmod +x /usr/sbin/sshd-login_notify-slack.sh
&lt;/syntaxhighlight&gt;

Testa
 PAM_USER=test PAM_RHOST=1.2.3.4 PAM_TYPE=open_session /usr/sbin/sshd-login_notify-slack.sh

==Bastion==
En bastion fungerar som en reverse proxy för SSH-servrar. Komponenten som behövs är SSH Agent Forwarding och finns inbyggt i OpenSSH. För att göra hoppet genom proxyn transparent måste SSH-nycklar användas för autentisering. DNS-uppslag på alla maskiner måste fungera.

[[File:ssh-bastion.png|500px]]

 nano ~/.ssh/config
 Host inside-server
  ProxyJump bastion
 
 Host bastion
  User basse
  IdentityFile ~/.ssh/ed25519
  ForwardAgent yes

==.bashrc==
.bashrc är en fil som körs varje gång bash laddas. I denna filen kan du skriva egna kommandon som du kan köra i kommandoprompten.

'''Extract''' &lt;br/&gt;
Skriv &lt;code&gt;extract &lt;filnamn&gt;&lt;/code&gt; för att packa upp en fil.
&lt;source lang=bash&gt;
 extract () {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xvjf $1    ;;
            *.tar.gz)    tar xvzf $1    ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar x $1       ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xvf $1     ;;
            *.tbz2)      tar xvjf $1    ;;
            *.tgz)       tar xvzf $1    ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)           echo "don't know how to extract '$1'..." ;;
        esac
    else
        echo "'$1' is not a valid file!"
    fi
  } 
&lt;/source&gt;
[[Category:Guider]]</text>
      <sha1>pisrmyzom9g9ej3ldls2nbelzb93sph</sha1>
    </revision>
  </page>
  <page>
    <title>Juniper Aggregated Ethernet</title>
    <ns>0</ns>
    <id>516</id>
    <revision>
      <id>2795</id>
      <parentid>2794</parentid>
      <timestamp>2018-07-16T13:12:08Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1474">Aggregated Ethernet(ae) är Junipers implementation av IEEE 802.3ad som används för att bundla ihop flera fysiska interface till ett logiskt interface som kallas LAG. Med hjälp av ett ae interface kan man få högre redundans och även högre hastighet eftersom att man kan last balansera trafiken på flera portar. 

Ciscos motsvarighet heter [[Cisco_EtherChannel|EtherChannel]]

=Link Aggregation Control Protocol=
LACP är en subkomponent till IEEE 802.3ad som tillför extra kontroll för att hålla koll på din LAG och att det finns mindre risk för konfigurationsmisstag. För att LACP ska kunna fungera så krävs det att båda sidorna använder LACP. När LACP är påslaget så skickas det LACPDU en gång i sekunden med information tills förhandlingen är genomförd sedan återgår det till vad keepalive är satt till. 
*Keepalive är hur ofta enheterna skickar LACPDU där default mode slow=30s och fast=1s.
*LACP använder alltid multicast MAC adressen 01:80:c2:00:00:02 för att skicka sina frames.

Fördelen med att använda LACP är att din enhet inte kommer försöka skicka trafik mot ett interface som inte svarar på LACPDU och att kommunikationen failar för andra applikationer. 
Har man en mediaconverter på en länk mellan 2st enheter som utbyter LACPDU så kommer den ena enheten känna till om den andra enheten skulle tappa kontakten med mediaconvertern på sin sida och därav sluta skicka trafik på det interfacet.

[[Category:Juniper]]</text>
      <sha1>nwrbsh2yrkx3r0s3m7rowxy06et9f1k</sha1>
    </revision>
  </page>
  <page>
    <title>Juniper JunOS</title>
    <ns>0</ns>
    <id>242</id>
    <revision>
      <id>2925</id>
      <parentid>2924</parentid>
      <timestamp>2019-01-28T15:53:32Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Image */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4276">Junos bygger på FreeBSD och man kan därför få shell access och köra många unix kommandon på switchen.  

Junos CLI är uppdelat i två kommandolägen.
*Operational Mode
*Configuration Mode

Till skillnad från tex Cisco, HP och Extreme där en ändring sker direkt när man skrivit kommandot så måste man i JunOS skriva commit.

==Operational==
Gå till operational mode. Här kan man köra kommandon för att troubleshoota och monitorera.
 cli

Lista conf i set kommandon. Andvändbart om man behöver paste in conf.
 show configuration | display set

Lista conf efter hierarchy level.(Funkar enbart om man gått in i edit läge på tex ett interface.)
 show configuration | display set relative

Visa mac tabellen.
 show ethernet-switching table

==Configuration==
Gå till configuration mode.
 configure 

Går till configuration mode och låser den globala configurationen, så att andra användare inte kan commita förens du lämnat 

configuration mode.
 configure exclusive

Lämna configuration mode utan att commita.
 exit 

Kör operational mode kommandon i configuration mode.
 run &lt;operational mode kommando&gt;

==Commit==
Lämna configuration mode och commita ändringar.
 commit and-quit

Visa vad som kan commitas.
 show | compware

Ta bort all conf som ligger redo att commitas.
 rollback

Rollbacka till en conf vid en viss tid.
 rollback ?

Commita och kör en autorollback efter 2 miniut. För att stoppa autorollback skriv &lt;code&gt;commit&lt;/code&gt; bara.
 commit confirmed 2

==Konfiguration==
'''Hostnamn'''
 set system host-name [hostname]

'''Lösenord på root(autoencryption)'''
 set root-authentication plain-text-password

Om du redan har en krypterad sträng av lösenordet använd följande.
 set root-authentication encrypted-password

Tillåt enbart root logins över console.
 set services ssh root-login deny

'''Skapa användare'''
 set system login user admin uid 2000
 set system login user admin class super-user

'''Mgmt port'''
 set interfaces vme unit 0 family inet address 192.168.0.0/24
 set routing-options static route 0.0.0.0/0 next-hop 192.168.0.1

'''LLDP'''
 set protocols lldp interface all

'''Tid'''
 set system time-zone Europe/Stockholm
 
 set system ntp server [ip] prefer
 set system ntp server [ip]

==Firmware==
===Scp===
Börja med att skicka över imagen till JunOS.
 scp [image] root@[juniper]:/var/tmp/[image]

Från operational mode kör sedan följande.
 request system software add /var/tmp/[image] no-copy no-validate unlink reboot

===USB===
Börja med att mounta usb stickan med.
 mount_msdosfs /dev/da0s1 /mnt

Kopiera imagen till JunOS.
 cp /mnt/[image] /var/tmp/

Unmounta usb stickan.
 unmount /mnt

Gå in i operational mode.
 request system software add /var/tmp/[image] no-copy no-validate unlink reboot

==Backup==
===Configuration===
Man kan använda system som [[Rancid]] eller [[Oxidized]] för att backa upp sin JunOS device. Om man inte har något sånt system uppsatt så kan man sätta '''transfer-on-commit''' eller '''transfer-interval'''.

'''transfer-on-commit''' kommer att skicka din config fil till ditt valda '''archive-sites''' varje gång du commitar.

'''transfer-interval''' gör samma sak fast den skickar iväg configen en gång i timmen bara. 

Börja med att sätta dina '''archive-sites''' 
 set system archival configuration archive-sites scp://backupusr@10.10.10.200:/opt/backup/R1 password hackernet
Byt ut '''SCP''' mot '''FTP''' om du hellre vill använda det.
{{ombox
|nocat=true
| type  = notice
| text  = Om du har skrivit en IPv6 adress så måste du ange citat tecken runt ('''""''')  hela URL och paranteser ('''[]''') runt IPv6 adressen.
}}

Efter det så väljer du när du vill skicka configen.
 set system archival configuration transfer-on-commit
 set system archival configuration transfer-interval '''interval-in-minutes'''

Filen kommer att sparas som '''&lt;router-name&gt;_YYYYMMDD_HHMMSS_juniper.conf.n.gz'''.
===Image===
Man kan backupa en hel JunOS image och hur configen ser ut vid tillfället till en annan partition så ifall en firmware upgrade skulle gå snett kan man boota ifrån den.

'''Skapa en recovery snapshot'''
 request system snapshot recovery
På äldre platformar kör man 
 request system snapshot slice alternate




[[Category:Juniper]]</text>
      <sha1>4psimwap0hqb2db6tw8s28kchp7lhy8</sha1>
    </revision>
  </page>
  <page>
    <title>Juniper VLAN</title>
    <ns>0</ns>
    <id>246</id>
    <revision>
      <id>1580</id>
      <timestamp>2016-03-29T11:44:44Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "==Konfiguration== '''Skapa vlan'''  set vlans [VLAN-name] vlan-id [VLAN-id]  '''Access port'''  set interfaces ge-0/0/0 unit 0 family ethernet-switching vlan members [VLAN-nam..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="374">==Konfiguration==
'''Skapa vlan'''
 set vlans [VLAN-name] vlan-id [VLAN-id]

'''Access port'''
 set interfaces ge-0/0/0 unit 0 family ethernet-switching vlan members [VLAN-name]

'''Trunk port'''
 set interfaces ge-0/0/0 unit 0 family ethernet-switching port-mode trunk
 set interfaces ge-0/0/0 unit 0 family ethernet-switching vlan members [VLAN-name]

[[Category:Juniper]]</text>
      <sha1>dd4q1k0hig3olwt1yixz0qpq7e0ulx8</sha1>
    </revision>
  </page>
  <page>
    <title>Juniper VRRP</title>
    <ns>0</ns>
    <id>366</id>
    <revision>
      <id>2306</id>
      <timestamp>2017-05-02T19:29:43Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Virtual Router Redundancy Protocol (RFC 3768) är ett öppet FHRP. Det fungerar väldigt likt [[Cisco_HSRP|HSRP]] men med några skillnader. Source-IP för VRRP-paket är inte..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1408">Virtual Router Redundancy Protocol (RFC 3768) är ett öppet FHRP. Det fungerar väldigt likt [[Cisco_HSRP|HSRP]] men med några skillnader. Source-IP för VRRP-paket är interface IP, destination-IP är 224.0.0.18 och protokoll är 112. Hellos skickas default varje sekund. Man kan till skillnad från HSRP ha samma virtual ip som interface ip. Konfigurerar man det ändras VRRP-prio till 255 på den enheten som har samma IP som VIP. Backupenheter har 100 som default.

En virtual router måste använda följande mac adress 00:00:5E:00:01:XX. Där XX är Virtual Router IDentifier(VRID), som skiljer sig på alla virtual routers i nätverket.

=Konfiguration=
VRRP konfigurerar man på interfacet. Interfacet kan vara en ae, irb eller fysiskt interface.
==Basic==
 {master:0}[edit interfaces irb unit 10]
 root@R1# show
 family inet {
     address 192.168.1.2/24 {
         vrrp-group 10 {
             virtual-address 192.168.1.1;
             priority 250;
         }
     }
 }
==Autentisering==
För att säkra upp VRRP kan man använda sig av autentisering. Lösenordet kommer inte sparas i klartext.
 set interfaces &lt;interface&gt; unit &lt;no&gt; family inet address &lt;ip&gt; vrrp-group &lt;no&gt; authentication-type simple
 set interfaces &lt;interface&gt; unit &lt;no&gt; family inet address &lt;ip&gt; vrrp-group &lt;no&gt; authentication-key hackernet

==Verify==
 show vrrp
 show vrrp interface '''interface-name'''

[[Category:Juniper]]</text>
      <sha1>832vug7mrj8sw28ue60sycpkbrsd85v</sha1>
    </revision>
  </page>
  <page>
    <title>KVM</title>
    <ns>0</ns>
    <id>223</id>
    <revision>
      <id>1947</id>
      <parentid>1398</parentid>
      <timestamp>2016-07-13T08:01:13Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="787">Kernel-based Virtual Machine är en kernelmodul för hårdvaruaccelerering och med hjälp av Quick EMUlator blir det en type-1 hypervisor. QEMU själv är en type-2 hypervisor.

==Installation==
''Pre-requisites Intel CPU''
 egrep '(vmx)' /proc/cpuinfo
Installera
 dnf groupinfo virtualization
 dnf groupinstall "Virtualization"

=Usage=

'''GUI'''
 virt-manager

'''CLI'''
 virsh list
 virsh net-list

'''Top'''
 virt-top

'''OVA''' &lt;br/&gt;
Nyare versioner av KVM/QEMU har stöd för vmdk. Packa upp och använd sedan vmdk:n.
 tar -xf Appliance.ova

'''Kickstart''' &lt;br/&gt;
Skapa vm med kickstartfil
 virt-install -x ks=filename.ks

'''Migration''' &lt;br/&gt;
Requirements: CPU type, time sync, shared storage
 virsh migrate --live TestVM qemu+ssh://test2.example.com/system

[[Category:Guider]]</text>
      <sha1>5k6hsywb7ijw1bxq7i5la6iyfsn1rum</sha1>
    </revision>
  </page>
  <page>
    <title>Kali Linux</title>
    <ns>0</ns>
    <id>87</id>
    <revision>
      <id>1235</id>
      <parentid>1234</parentid>
      <timestamp>2015-11-09T21:52:26Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Captive portal */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4023">[[Category:Distar]]
Kali Linux är en Debian-baserad Linuxdistribution avsedd för digitala penetrationstester och etisk hacking. Kali är uppföljaren till BackTrack.

https://www.kali.org/

=Grundsetup=
'''IP'''
 ifconfig eth0 10.0.0.5/24 up
 route add default gw 10.0.0.1
 echo nameserver 8.8.8.8 &gt; /etc/resolv.conf
'''SSH-server'''
 start networking
 sshd-generate
 start ssh
 update-rc.d -f ssh defaults

==Docker==
Et snabbt sätt att komma igång med Kali är med docker.
 docker pull kalilinux/kali-linux-docker
 docker run -t -i kalilinux/kali-linux-docker /bin/bash
 root@aaca1ac4f5b5:/# ping 8.8.8.8

=Verktyg=
Kali är utrustat med väldigt många verktyg. Här listas några och vad de används till.

'''[[Nmap]]'''&lt;br/&gt;
Security Scanner

'''Yersinia'''&lt;br/&gt;
Attacker mot det mesta som har med nätverk att göra, inkl DHCP, STP, CDP, DTP, HSRP, VTP, 802.1q, 802.1x. Startas med:
 yersinia -G

'''ARPSpoof'''
 echo 1 &gt; /proc/sys/net/ipv4/ip_forward
 arpsoof -i eth0 -t 10.0.0.15 10.0.0.1
 arpsoof -i eth0 -t 10.0.0.1 10.0.0.15
Samla sedan data
 driftnet -i eth0
 urlsnarf -i eth0

'''TCP Synflood'''
 use auxiliary/dos/tcp/synflood
 set RHOST 192.168.1.1
 set SHOST 10.0.0.50
 run

'''Hydra'''&lt;br/&gt;
Password cracker

'''Maltego'''&lt;br/&gt;
Gather information about ip addresses and domains

'''[[Metasploit]]'''&lt;br/&gt;
Vulnerability testing

'''Burp Suite'''&lt;br/&gt;
Proxy/Spider

'''[[Scapy]]'''&lt;br/&gt;
Packet Manipulation Tool

'''Hping3''' - TCP Ping
 hping3 -S 10.10.10.10 -a 10.10.10.12 -p 22 --flood

'''Parasite6''' - IPv6 MITM
 echo 1 &gt; /proc/sys/net/ipv6/conf/all/forwarding
 parasite6 -lR eth0

=Wireless=
Börja med att konfa svenska inställningar
 iw reg set SE
 iwconfig wlan0 txpower 27

'''Uncovering Hidden SSID'''
 airmon-ng start wlan0
 airodump-ng mon0
 airodump-ng -c 11 mon0
 aireplay-ng -0 2 -a [BSSID] mon0

 iwconfig wlan0 essid [ESSID] channel 11
 macchanger -m [MAC address] wlan0

'''WPA2'''
 airmon-ng start wlan0
 airodump-ng -w OURFILE -c 11 --bssid [BSSID] mon0
 aireplay-ng -0 2 -a [BSSID] mon0
 aircrack-ng OURFILE-01.cap -w /pentest/passwords/wordlists/darkc0de.lst
 
 wpaclean &lt;out.cap&gt; &lt;in.cap&gt;
 
with crunch:
 crunch x X "characters" | aircrack-ng ".cap file" -w - -e "essid"

with john the ripper:
 john -stdout -incremental:all | aircrack-ng ".cap file" -w - -e "essid"

'''Rogue AP'''
 apt-get install dhcp3-server -y
 mv /etc/dhcp3/dhcpd.conf /etc/dhcp3/dhcpd.conf.bak
 nano /etc/dhcp3/dhcpd.conf
  ddns-update-style ad-hoc;
  default-lease-time 600;
  max-lease-time 7200;
  subnet 192.168.1.0 netmask 255.255.255.0 {
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.1.255;
  option routers 192.168.1.1;
  option domain-name-servers 192.168.1.1;
  range 192.168.1.10 192.168.1.100;
 } 

 airmon-ng start wlan0
 airodump-ng mon0
 airbase-ng --essid "Hitlerklubben" -c 11 mon0
 ifconfig at0 192.168.1.1/24 up
 route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1
 dhcpd3 -cf /etc/dhcp3/dhcpd.conf -pf /var/run/dhcp3-server/dhcpd.pid at0
 /etc/init.d/dhcp3-server start
 iptables --table nat --append POSTROUTING --out-interface eth0 -j MASQUERADE
 iptables --append FORWARD --in-interface at0 -j ACCEPT
 echo 1 &gt; /proc/sys/net/ipv4/ip_forward

'''Bridging'''
 airmon-ng start wlan0
 airodump-ng mon0
 airbase-ng --essid "Hitlerklubben" -c 11 mon0
 ifconfig at0
 brctl addbr BR1
 brctl addif BR1 eth0
 brctl addif BR1 at0
 brctl show
 ifconfig eth0 0.0.0.0 up
 ifconfig at0 0.0.0.0 up
 ifconfig BR1 192.168.1.50/24 up
 echo 1 &gt; /proc/sys/net/ipv4/ip_forward

=IPv6=
Med IPv6 finns det mycket att tänka på och testa.
 fake_router6 eth0 2001::/64
 detect-new-ip6 eth0
 dos-new-ip6 eth0
 flood_router6 eth0
 flood_advertise6 eth0
 implementation6 eth0 2001::1
 smurf6 eth0 2001::1

=Captive portal=
Många företag tex hotel använder en captive portal för att kontrollera vilka som använder deras trådlösa nätverk.

Många portaler filtrerar på MAC så om man hittar en som fungerar via en ipscan så räcker det för att komma åt internet.</text>
      <sha1>e2c2i4bavnxcdywqgz61c95fw28ee7a</sha1>
    </revision>
  </page>
  <page>
    <title>Kea</title>
    <ns>0</ns>
    <id>243</id>
    <revision>
      <id>1689</id>
      <parentid>1623</parentid>
      <timestamp>2016-04-22T19:08:27Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2728">Kea är den nya DHCPv4/DHCPv6-servern från ISC och är en ersättare för [[ISC_DHCP|ISC DHCP]]. Målet är att skapa en dhcp server med hög performance och utbyggbar med extensions för enterprises eller service providers. 

'''Features'''
*Fullt fungerande DHCPv4, DHCPv6 och Dynamic DNS server.
*OpenSSL support.
*Leases finns sparat i CSV fil, MySQL eller Postgres.
*On-Line configuration.
*Statistics
*API

==Installation==
 apt-get install build-essential libssl-dev libboost-dev libboost-system-dev make liblog4cplus-dev
 wget http://ftp.isc.org/isc/kea/1.0.0/kea-1.0.0.tar.gz &amp;&amp; tar -xvf kea-1.0.0.tar.gz
 cd kea-1.0.0
 ./configure --prefix=/
 make
 make install

'''Ubuntu'''
 sudo apt-get install kea-dhcp4-server
'''Fedora'''
 dnf install kea

==Konfiguration==
Görs i filen &lt;code&gt;/etc/kea/kea.conf&lt;/code&gt;. En lista på DHCP options finns bland kea's egna [http://kea.isc.org/docs/kea-guide.html#dhcp4-std-options-list dokumentation]. 
 # Kea DHCP conf by Hackernet.se
 
 {
 # DHCPv4 configuration starts in this line
 "Dhcp4": {
 
 # Global values
     "valid-lifetime": 4000,
     "renew-timer": 1000,
     "rebind-timer": 2000,
 
 # Next we setup the interfaces to be used by the server.
     "interfaces-config": {
         "interfaces": [ "eth0" ]
     },
 
 # And we specify the type of lease database
     "lease-database": {
         "type": "memfile",
         "persist": true,
         "name": "/var/kea/dhcp4.leases"
     },
 
 # Global options
     "option-data": [
         {
         "name": "domain-name-servers",
         "data": "192.168.1.10, 10.240.100.100"
         },
         {
         "name": "tftp-server-name",
         "data": "192.168.1.200"
         },
         {
         "code": 67,
         "data": "pxelinux.0"
         },
     ],
 
 #Some clients use siaddr field in the DHCPv4 packet, therefore use following command.
 "next-server": "192.168.1.200",
 
 
 # List subnets where we will be leasing addresses.
     "subnet4": [
         {
         "subnet": "10.240.100.0/24",
         "pools": [ { "pool": "10.240.100.20 - 10.240.100.100" } ],
         "option-data": [
         {
         "name": "routers",
         "data": "10.240.100.1"
         },
         {
         "code": 15,
         "data": "hackernet.se"
         },
       ]
     }
   ]
 
 
 # DHCPv4 configuration ends with this line
 },
 
     "Logging": {
        "loggers": [
         {
         "name": "kea-dhcp4",
         "output_options": [
           {
           "output": "/var/log/kea4.log",
           "maxsize": 20480
           }
         ],
         "severity": "INFO",
         },
       ]
     }
 
 }

Verify
 systemctl status kea-dhcp4-server.service
 cat /var/kea/dhcp4.leases

[[Category:Guider]]</text>
      <sha1>sggcdruwhojfa4agpzy148gtd1kj80i</sha1>
    </revision>
  </page>
  <page>
    <title>Keepalived</title>
    <ns>0</ns>
    <id>557</id>
    <revision>
      <id>3087</id>
      <parentid>3086</parentid>
      <timestamp>2020-02-11T13:47:50Z</timestamp>
      <contributor>
        <username>Bat</username>
        <id>4</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="405">[[BFD]] [[vrrp]] [[lvs]]

==misc_dynamic==
Misc_dynamic på en misc_check låter dig sätta vikten mot din realserver dynamiskt baserat på exitkoden från ditt script. 

Exitkod 0 är success (oförändrad vikt)

Exitkod 1 är failure (realserver tas ur poolen) 

Exitkod 2 och högre sätts som vikt-2, exitkod 252 t.ex. kommer ge dig en vikt på 250. 
 

https://www.keepalived.org/

[[Category:Tools]]</text>
      <sha1>h2u3g1tvwbwejo03t2ba15isjvil5be</sha1>
    </revision>
  </page>
  <page>
    <title>Kickstart Debian</title>
    <ns>0</ns>
    <id>100</id>
    <revision>
      <id>1436</id>
      <parentid>717</parentid>
      <timestamp>2016-01-13T13:42:10Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5180">== Unattended ==
Bootparameter
 append vga=normal initrd=os/debian7/initrd.gz preseed/url=http://&lt;url&gt;/Debian.conf interface=auto priority=critical auto=true

 ####################################################################
 #  PRESEED - Created Wed Apr  1 13:18:08 2015
 ####################################################################
 
 # Wiki: http://wiki.debian.org/DebianInstaller/Preseed
 # Great work!  Thanks for preseed and the d-i installer
 
 
 ####################################################################
 # Installation Sources
 ####################################################################
 
 # Where are we pulling bits from?
 #
 # Note:  To use your own local repository, this is what you want
 # to edit.
 #
 # It should look like this:
 #d-i     mirror/http/hostname    string (IP Address of your local server)
 #d-i     mirror/http/directory   string (HTTP Path to your Repository - like /natty )
 
 d-i     mirror/http/hostname    string ftp.se.debian.org
 d-i     mirror/http/directory   string /debian/
 d-i     mirror/suite            string 
 
 # Post install APT setup
 d-i     apt-setup/uri_type      select d-i
 d-i     apt-setup/hostname      string ftp.se.debian.org
 d-i     apt-setup/directory     string /debian/
 d-i     apt-setup/another       boolean false
 d-i     apt-setup/security-updates      boolean false
 d-i     finish-install/reboot_in_progress note
 d-i     prebaseconfig/reboot_in_progress        note
 
 d-i     apt-setup/non-free 	boolean true
 d-i     apt-setup/contrib 	boolean true
 
 ####################################################################
 # Networking
 ####################################################################
 
 # Network Configuration
 
 d-i     netcfg/get_hostname     string unassigned-hostname
 d-i 	netcfg/get_hostname 	seen true 
 d-i     netcfg/get_domain       string unassigned-domain
 d-i 	netcfg/get_domain 	seen true  
 d-i     netcfg/disable_dhcp     boolean false
 d-i	mirror/http/proxy	string	
 d-i     netcfg/choose_interface select eth0
 d-i     netcfg/wireless_wep     string
 
 ####################################################################
 # Disk Partitioning/Boot loader
 ####################################################################
 
 d-i     partman-auto/disk               string /dev/sda
 d-i     partman-auto/method             string regular
 d-i 	partman-auto/choose_recipe 	select atomic
 
 
 # This makes partman automatically partition without confirmation.
 d-i     partman/confirm boolean true
 d-i     partman-partitioning/confirm_write_new_label boolean true
 d-i     partman/choose_partition select finish
 d-i     partman/confirm_nooverwrite boolean true 
 d-i 	partman/confirm_write_new_label boolean true
 
 # This one makes grub-installer install to the MBR even if finds some other OS
 # too, which is less safe as it might not be able to boot that other OS.
 d-i     grub-installer/with_other_os    boolean true
 
 ####################################################################
 # Localizations
 ####################################################################
 
 # Install Time 
 d-i	console-tools/archs string skip-config
 d-i 	debian-installer/locale string en_US
 d-i 	console-keymaps-at/keymap select sv
 
 d-i     languagechooser/language-name-fb    select English
 d-i     debian-installer/locale             select en_US.UTF-8
 
 # Timezone
 d-i     tzconfig/gmt            boolean true
 d-i     tzconfig/choose_country_zone/Europe select Stockholm
 d-i     tzconfig/choose_country_zone_single boolean true
 d-i	time/zone	select	Europe/Stockholm
 d-i	clock-setup/utc	boolean	true
 d-i	kbd-chooser/method	select	American English
 d-i	mirror/country	string	manual
 d-i     clock-setup/ntp boolean false
 
 # X11 config
 xserver-xorg     xserver-xorg/autodetect_monitor              boolean true
 xserver-xorg     xserver-xorg/config/monitor/selection-method select medium
 xserver-xorg     xserver-xorg/config/monitor/mode-list        select 1024x768 @ 60 Hz
 xserver-xorg     xserver-xorg/config/display/modes            multiselect 1024x768, 800x600
 
 ####################################################################
 # User Creation
 ####################################################################
 
 # Root User
 d-i	passwd/root-password-crypted    passwd   Pa$$w0rd
 
 # Mortal User
 d-i	passwd/user-fullname            string 
 d-i	passwd/username                 string hacker
 d-i	passwd/user-password-crypted    passwd Pa$$w0rd
 
 ####################################################################
 # Software Selections
 ####################################################################
 
 popularity-contest popularity-contest/participate boolean false
 
 tasksel	tasksel/first	multiselect	standard
 d-i	pkgsel/include	string	 openssh-server open-vm-tools systemd-sysv
 d-i 	grub-installer/only_debian 	boolean true
 ####################################################################
 # Additional preseed entries (from data/debconf)
 ####################################################################
 
 exim4-config exim4/no_config boolean true
 
[[Category:Kickstart]]</text>
      <sha1>1xdj2ajsoy16spwh0i0o2wsy9jlfd1z</sha1>
    </revision>
  </page>
  <page>
    <title>Kickstart ESXi</title>
    <ns>0</ns>
    <id>98</id>
    <revision>
      <id>1547</id>
      <parentid>644</parentid>
      <timestamp>2016-03-17T19:22:50Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2491">ESXi 6.0
 
 accepteula
 install --firstdisk --overwritevmfs
 #For USB install use below instead
 #install --firstdisk --novmfsondisk
 rootpw bueno
 keyboard Swedish
 reboot
 
 network --bootproto=static --device=vmnic0 --hostname=esxi2.hackernet.se --ip=172.20.0.2 --netmask=255.255.255.0 --gateway=172.20.0.1 --nameserver=172.20.0.10 --addvmportgroup=false
 
 %firstboot --interpreter=busybox
 
 #SSH
 vim-cmd hostsvc/enable_ssh
 vim-cmd hostsvc/start_ssh
 esxcli system settings advanced set -o /UserVars/SuppressShellWarning -i 1
 
 vim-cmd hostsvc/datastore/rename datastore1 "LocalHDD"
 vim-cmd vimsvc/license --set 11111-BBBBB-CCCCC-BH951-CAW3U
 esxcli system module parameters set -m tcpip3 -p ipv6=0
 
 cat &gt; /etc/ntp.conf &lt;&lt; __NTP_CONFIG__
 restrict default kod nomodify notrap noquerynopeer
 restrict 127.0.0.1
 server 0.vmware.pool.ntp.org
 server 1.vmware.pool.ntp.org
 __NTP_CONFIG__
 /sbin/chkconfig ntpd on
 
 # EHC
 esxcli software vib install -v http://download3.vmware.com/software/vmw-tools/esxui/esxui_signed.vib
 
 #If planning on running nested ESXi, uncomment
 #grep -i "vhv.enable" /etc/vmware/config || echo "vhv.enable = \"TRUE\"" &gt;&gt; /etc/vmware/config
 
 # Mgmt
 esxcli network vswitch standard portgroup set --portgroup-name "Management Network" --vlan-id 2
 
 # vSwitch0
 esxcli network vswitch standard set --mtu 9000 --cdp-status both --vswitch-name vSwitch0
 esxcli network vswitch standard portgroup add --portgroup-name LAN --vswitch-name vSwitch0
 
 # vSwitch1
 esxcli network vswitch standard add --ports 256 --vswitch-name vSwitch1
 esxcli network vswitch standard uplink add --uplink-name vmnic1 --vswitch-name vSwitch1
 esxcli network vswitch standard set --cdp-status listen --vswitch-name vSwitch1
 esxcli network vswitch standard portgroup add --portgroup-name WAN --vswitch-name vSwitch1
 
 # vSwitch2 
 esxcli network vswitch standard add --ports 256 --vswitch-name vSwitch2
 esxcli network vswitch standard uplink add --uplink-name vmnic2 --vswitch-name vSwitch2
 esxcli network vswitch standard set --mtu 9000 --cdp-status both --vswitch-name vSwitch2
 esxcli network vswitch standard portgroup add --portgroup-name DMZ1 --vswitch-name vSwitch2
 esxcli network vswitch standard portgroup set --portgroup-name DMZ1 --vlan-id 1
 esxcli network vswitch standard portgroup add --portgroup-name DMZ2 --vswitch-name vSwitch2
 esxcli network vswitch standard portgroup set --portgroup-name DMZ2 --vlan-id 2

 
[[Category:Kickstart]]
[[Category:VMware]]</text>
      <sha1>22ow2ky8bphckjvnqckz117aw7koe6v</sha1>
    </revision>
  </page>
  <page>
    <title>Kickstart Fedora</title>
    <ns>0</ns>
    <id>258</id>
    <revision>
      <id>1690</id>
      <parentid>1687</parentid>
      <timestamp>2016-04-22T23:01:18Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1601">Fedora 23
 # Network information
 network  --bootproto static --ip 172.10.0.20 --netmask 255.255.255.0 --gateway 172.10.0.1 --nameserver 172.10.0.1 --device=eno16780032 --ipv6=auto --activate
 network  --hostname=fedora.hackernet.se
 
 graphical
 auth --enableshadow --passalgo=sha512
 url --url="http://download.fedoraproject.org/pub/fedora/linux/releases/23/Server/x86_64/os"
 firstboot --enable
 ignoredisk --only-use=sda
 keyboard --vckeymap=se --xlayouts='se'
 lang en_US.UTF-8
 rootpw --lock
 timezone Europe/Stockholm --isUtc
 user --groups=wheel --name=skeletor --password=$6$0mOr4b/kgDAOoxgg$vgPmtqFEZB0//fc3J9RW90eM6nDIISyE0IxT.06ufRvGnfx6ET2ollSHP46OefzAvYUs5hqbqHXzUzhptDefM1 --iscrypted --gecos="skeletor"
 bootloader --location=mbr --boot-drive=sda
 autopart --type=lvm
 zerombr
 clearpart --all --initlabel
 reboot
 
 %packages
 @^server-product-environment
 %end
 
 %anaconda
 pwpolicy root --minlen=0 --minquality=1 --notstrict --nochanges --emptyok
 pwpolicy user --minlen=0 --minquality=1 --notstrict --nochanges --emptyok
 pwpolicy luks --minlen=0 --minquality=1 --notstrict --nochanges --emptyok
 %end

=Fråga efter hostnamn=
Få fedora/centos/redhat att fråga efter hostnamn under installation. 

 %pre
 #!/bin/sh
 exec &lt; /dev/tty3 &gt; /dev/tty3 2&gt;&amp;1
 chvt 3
 hn=""
 
 while [ "$hn" == "" ]; do
  clear
   echo " *** Please enter the following details: *** "
    echo
     read -p "Hostname: " hn
     done
     clear
     chvt 1
     echo "network --device=link --bootproto=dhcp --noipv6 --hostname ${hn}.hackernet.se --activate" &gt; /tmp/network.txt
 %end

[[Category:Kickstart]]</text>
      <sha1>4pn723ct4qvmyqn1zflrx4iseqg4izo</sha1>
    </revision>
  </page>
  <page>
    <title>Kickstart Ubuntu</title>
    <ns>0</ns>
    <id>99</id>
    <revision>
      <id>1015</id>
      <parentid>642</parentid>
      <timestamp>2015-09-07T10:27:35Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>ntp</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="737">Exempel på ks-fil för Ubuntu server
 network --bootproto=static --hostname=host7.hackernet.se --ip=172.20.0.4 --netmask=255.255.255.0 --gateway=172.20.0.1 --nameserver=8.8.8.8 --device=eth0
 lang en_US
 langsupport en_US
 keyboard se
 mouse
 timezone Europe/Stockholm
 rootpw --disabled
 #Initial user
 user doge --fullname "skeletor" --password suchpw
 #Reboot after installation
 reboot
 text
 install
 #Use Web installation
 url --url http://se.archive.ubuntu.com/ubuntu
 bootloader --location=mbr
 zerombr yes
 clearpart --all --initlabel
 part / --fstype ext4 --size 1 --grow
 part swap --recommended
 auth  --useshadow
 firewall --disabled
 skipx
 
 %packages
 openssh-server
 fail2ban
 open-vm-tools
 ntp

[[Category:Kickstart]]</text>
      <sha1>50m30ltbj6qaih0jwqwvqowj9eil18i</sha1>
    </revision>
  </page>
  <page>
    <title>LAMP</title>
    <ns>0</ns>
    <id>115</id>
    <revision>
      <id>2927</id>
      <parentid>1085</parentid>
      <timestamp>2019-02-03T19:12:26Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="619">LAMP, även kallat LAMP-stack är en vanlig open-source webbplatform som vanligtvis består av:&lt;br /&gt;

* '''L'''inux
* [[Apache|'''A'''pache]] HTTP Server
* '''M'''ariaDB / [[MySQL]]
* '''P'''HP, Perl, eller [[Python]]

Man kan även använda sig av andra kombinationer för att uppnå en liknande webbplatform. Tex:&lt;br /&gt;

* Byta ut [[Apache]] mot [[nginx]] och då kallas det för LEMP-stack istället. 
* Använda sig av en annan RDBMS som Postgresql eller SQLite.&lt;br /&gt;

Flera stora hemsidor använder idag LAMP som sin platform, stora aktörer är bl.a: Wikipedia, [[MediaWiki]] och Wordpress.

[[Category:Guider]]</text>
      <sha1>g4cdrjr1bi1mpv37k7ho942e5uz2otz</sha1>
    </revision>
  </page>
  <page>
    <title>LUKS</title>
    <ns>0</ns>
    <id>95</id>
    <revision>
      <id>623</id>
      <timestamp>2015-06-24T11:06:17Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Linux Unified Key Setup är standarden för hårddiskkryptering i Linux.  =Cryptsetup= cryptsetup är ett verktyg som krypterar/avkrypterar blockenheter i realtid baserat på..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="392">Linux Unified Key Setup är standarden för hårddiskkryptering i Linux.

=Cryptsetup=
cryptsetup är ett verktyg som krypterar/avkrypterar blockenheter i realtid baserat på dm-crypt kernelmodulen.
 apt-get install cryptsetup
 yum install cryptsetup-luks

===Nuke===
Vill man radera sin data väldigt snabbt oavsett mängd kan man sätta upp en kill-switch.
 cryptsetup luksAddNuke /dev/sda5</text>
      <sha1>f49vpxeawh2r2sifrlt0jgan8otrjj5</sha1>
    </revision>
  </page>
  <page>
    <title>LXD</title>
    <ns>0</ns>
    <id>244</id>
    <revision>
      <id>1551</id>
      <timestamp>2016-03-20T19:43:31Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "LXD är en container hypervisor för Linux. Det är byggt utifrån LXC. Man skapar containrar utifrån images.  ===Installation=== ''16.04''  sudo apt-get -y install lxd Versi..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="868">LXD är en container hypervisor för Linux. Det är byggt utifrån LXC. Man skapar containrar utifrån images.

===Installation===
''16.04''
 sudo apt-get -y install lxd
Version
 lxd --version

===Images===
Kolla tillgängliga källor för images.
 lxc remote list
Lista tillgängliga images från en viss källa.
 lxc image list images:
Hämta images
 sudo lxc image copy images:/ubuntu/trusty/amd64 local: --alias=trusty-amd64
 sudo lxc image list

===Container===
Starta container utifrån image.
 lxc launch trusty-amd64 Test
 lxc list

===Remote Hosts===
Man kan med lxc-kommandot managera containrar på andra LXD-hostar. 

Allow management on remote machine
 lxc config set core.https_address [::]
 lxc config set core.trust_password PASSWORD
Control
 lxc remote add hostA &lt;ip address or DNS&gt;
 lxc exec hostA:containername -- apt-get update

[[Category:Guider]]</text>
      <sha1>o4uz2lnt985039ziznfemt7fb5bfdwa</sha1>
    </revision>
  </page>
  <page>
    <title>Lenovo BIOS update</title>
    <ns>0</ns>
    <id>36</id>
    <revision>
      <id>2192</id>
      <parentid>486</parentid>
      <timestamp>2016-12-12T18:56:26Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1085">[[Category:Hardware]]
Ladda ner senaste BIOS versionen för din x220a @ http://support.lenovo.com/us/en/products/laptops-and-netbooks/thinkpad-x-series-laptops/thinkpad-x220/downloads/ (I mitt fall så laddade jag ner "8duj25us.iso" )

=== Själva processen för att skapa imagefilen: ===
För att extrahera boot imagen så använder man sig av ett perlscript vid namn "geteltorito"
 ''wget http://www.uni-koblenz.de/~krienke/ftp/noarch/geteltorito/geteltorito.pl''
- (Ställ dig i den map där både .iso filen samt geteltorito perlscriptet ligger)
 ''perl geteltorito.pl 8duj25us.iso &gt; biosupdate.img''
Man skall kunna föra över imagefilen till usbminnet enligt följande: ''sudo dd if=biosupdate.img of=/dev/sdb1 bs=512K ''

I mitt fall blev filerna korrupta och behövde istället föra över imagen till en windowsmiljö och använde '''"win32 disk imager" '''för att fixa till det.

In med USB minnet i laptopen, kör F12 vid boot och boota från USB minnet.  

Source: http://forums.lenovo.com/t5/Linux-Discussion/SUPPORT-REQUEST-X220-BIOS-UPDATE-INSTRUCTIONS-USB/td-p/532077</text>
      <sha1>oivj8ptavxdr71u30st3sc924tdu2bx</sha1>
    </revision>
  </page>
  <page>
    <title>Let's Encrypt</title>
    <ns>0</ns>
    <id>107</id>
    <revision>
      <id>3110</id>
      <parentid>1681</parentid>
      <timestamp>2021-02-24T14:58:53Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Cipherlist */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2643">Let’s Encrypt är en certificate authority som är gratis, automatiserad och öppen. Det är ett initiativ av Internet Security Research Group som backas upp av en mängd stora företag där målet är att tillhandahålla TLS helt gratis. Underliggande säkra protokoll som används är nyutvecklat och går under namnet ACME (Automated Certificate Management Environment) och används för att underlätta verifiering av domännamn. Detta har varit krångligt tidigare då E-post och dylikt har används för SSL/TLS-certifikat.

==Förberedelse==
*Öppna port 80 mot servern.(Let's encrypt startar en python webbserver som används för att verifiera att du äger domänen)

==Installation==
'''BETA'''. Denna guiden baseras på beta dokumentation och kan komma att ändras när Let's encrypt släpps för alla.
 git clone https://github.com/letsencrypt/letsencrypt &amp;&amp; cd letsencrypt

==Konfiguration==
 ./letsencrypt-auto --agree-dev-preview --server https://acme-v01.api.letsencrypt.org/directory auth

Du kommer sedan få en fråga vilken mail som ska användas och vilka domäner du vill skapa ett cert för. För att kunna signa ett cert under '''beta''' perioden måste du fått din domän whitelistad.
Certen skapas under &lt;code&gt;/etc/letsencrypt&lt;/code&gt;. I '''live''' mappen finns symlink till senaste versionen av ett certifikat.

{| class="wikitable sortable"
|-
|privkey.pem   
|Din privata nykel, måste hållas hemlig så ingen kan komma åt den.
|-
|cert.pem
|Server certifikatet.
|-
|chain.pem
|Alla certificat som en webbläsare behöver '''utom''' server certificate. 
|-
|fullchain.pem
|Samma som '''chain.pem''' fast med server certificate också. 
|}

===Webroot===
Webroot är ett plugin som tillåter din server att validera din domän utan att stoppa webbserverm. Plugin lägger en liten dold fil i document root på webbservern, den kan sedan läsas av Let's Encrypt CA för att verifiera domänen.
 ./letsencrypt-auto certonly -a webroot --agree-tos --renew-by-default --webroot-path=/var/www/html -d hackernet.se -d www.hackernet.se

===Auto-renewal===
Finns inte inbyggt än.

==Tips n Tricks==
===Cipherlist===
[https://syslink.pl/cipherlist/ Chiperlist] är en hemsida som har olika konfigurations exemplar för olika tjänster med säkerhet i fokus.

===Signa bakom reverse proxy===
Om du använder dig av en reverse proxy och vill signa med hjälp av webroot kan man i [[apache]] göra att Let's encrypts anrop inte skickas vidare. Utan istället går till en lokal mapp där din Let's encrypt klient lagt den dolda filen.
 Alias /.well-known /var/www/.well-known
 ProxyPass /.well-known !


[[Category:Guider]]</text>
      <sha1>kg10i7m7gz29lh9jwzyr4ozg0gil6ct</sha1>
    </revision>
  </page>
  <page>
    <title>LibreNMS</title>
    <ns>0</ns>
    <id>305</id>
    <revision>
      <id>1999</id>
      <parentid>1998</parentid>
      <timestamp>2016-08-28T18:32:44Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Nagios plugins */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13209">LibreNMS är ett övervaknings verktyg för nätverks tjänster. LibreNMS går att intergrera med bla [[Rancid]] och [[Oxidized]]. LibreNMS har auto-discovery, plugins, API, och en IRC bot för att ta reda på status via IRC. Du kan autha dig mot bla MySQL(Default), LDAP eller HTTP för att få SSO stöd. LibreNMS övervakar enheter med hjälp av SNMP ,ping, check_mk_agent eller med hjälp av Nagios plugins. LibreNMS är en fork av [[Observium]].

=Förberedelser=
Du behöver en fungerande MySQL databas och en Apache med PHP.
==MySQL==
LibreNMS har inte stöd för MySQL strict mode än, därför måste det stängas av.

Öppna:
 vim /etc/mysql/mysql.conf.d/mysqld.cnf
Lägg till följande inom [mysqld] delen:
 innodb_file_per_table=1
 sql-mode=""
Och starta om MySQL servern.
==Webserver==
Installera följande paket:
'''Ubuntu 16.04'''
 apt-get install libapache2-mod-php7.0 php7.0-cli php7.0-mysql php7.0-gd php7.0-snmp php-pear php7.0-curl snmp graphviz php7.0-mcrypt php7.0-json apache2 fping imagemagick whois mtr-tiny nmap python-mysqldb snmpd php-net-ipv4 php-net-ipv6 rrdtool git

I filerna &lt;code&gt;/etc/php/7.0/apache2/php.ini&lt;/code&gt; och &lt;code&gt;/etc/php/7.0/cli/php.ini&lt;/code&gt; se till att '''date.timezone''' är satt till din tidszon. Se [http://php.net/manual/en/timezones.php PHP tidszoner] vad som stöds.

Kör följande kommandon för att enable och disable några php och apache moduler.
 a2enmod php7.0
 a2dismod mpm_event
 a2enmod mpm_prefork
 phpenmod mcrypt
==Skapa LibreNMS användaren==
 useradd librenms -d /opt/librenms -M -r
 usermod -a -G librenms www-data
=Installation=
Clona ner repot.
 cd /opt &amp;&amp; git clone https://github.com/librenms/librenms.git librenms
==Webinterface==
 cd /opt/librenms
 mkdir rrd logs
 chmod 775 rrd
 vim /etc/apache2/sites-available/librenms.conf

Lägg in följande rader:
  &lt;VirtualHost *:80&gt;
   DocumentRoot /opt/librenms/html/
   ServerName  librenms.example.com
   CustomLog /opt/librenms/logs/access_log combined
   ErrorLog /opt/librenms/logs/error_log
   AllowEncodedSlashes NoDecode
   &lt;Directory "/opt/librenms/html/"&gt;
     Require all granted
     AllowOverride All
     Options FollowSymLinks MultiViews
   &lt;/Directory&gt;
 &lt;/VirtualHost&gt;
Sätt LibreNMS användaren som ägare av mappen:
 chown -R librenms:librenms /opt/librenms

Aktivera sidan och rewrite module och starta om apache. 
 a2ensite librenms.conf
 a2enmod rewrite
 service apache2 restart

Om detta är den enda sidan du hostar glöm inte stänga av default sidan.
 a2dissite 000-default.conf

==Snmpd==
Kopiera exempel filen från LibreNMS och ersätt raden &lt;code&gt;RANDOMSTRINGGOESHERE&lt;/code&gt; med din egna commmunity sträng: 
 cp /opt/librenms/snmpd.conf.example /etc/snmp/snmpd.conf
 vim /etc/snmp/snmpd.conf
Starta om snmp servicen:
 service snmpd restart
==Cronjob==
Lägg till cronjob scriptet som sköter discovery, alerts och övervakningen.
 cp librenms.nonroot.cron /etc/cron.d/librenms
==Web installer==
Gå sedan till '''http://librenms.example.com/install.php''' och gå igenom stegen.
=Konfiguration=
Scripten finns under '''/opt/librenms'''. Och mycket av konfigurationen görs direkt i &lt;code&gt;config.php&lt;/code&gt; som också finns under '''/opt/librenms'''.
==Lägga till device==
Kan göras via web interfacet under '''Devices &gt; Add device'''

Eller från CLI med '''addhost.php''' scriptet.
 php addhost.php &lt;IP&gt;
==IRC Bot==
Lägg in följande rader i &lt;code&gt;config.php&lt;/code&gt;
 ...
 $config['irc_host'] = "irc.freenode.org";
 $config['irc_port'] = 6667;
 $config['irc_chan'] = "#librenms,#otherchan,#noc";
 ...
Om servern du vill ansluta mot kör SSL så kan du ange ett '''+''' före porten.
 ...
 $config['irc_port'] = "+6667";
 ...
Om servern har ett lösenord:
 $config['irc_pass'] = "Passphrase123";
För att ändra namn från LibreNMS till något annat:
 $config['irc_nick'] = "NotLibreNMSbot"
===Systemd service===
 cat &lt;&lt;'__EOF__'&gt;/etc/systemd/system/librenms-irc-bot.service
 [Unit]
 Description=IRC bot for LibreNMS
 After=network.target
 
 [Service]
 ExecStart=/usr/bin/php /opt/librenms/irc.php
 User=librenms
 Group=librenms
 
 [Install]
 WantedBy=multi-user.target
 __EOF__
Kör sedan följande kommando för att enable tjänsten vid omstart och för att starta tjänsten.
 systemctl enable librenms-irc-bot.service &amp;&amp; systemctl start librenms-irc-bot.service

===IRC kommandon===
Note: Det går bara att autha sig mot boten om man använder MySQL som inloggning. LDAP stöd är förhoppningsvis påväg se [https://github.com/librenms/librenms/issues/4023 issue] på LibreNMS Github.
{| class="wikitable"
|-
! Kommando
! Beskrivning
|-
| .auth &lt;User/Token&gt;
| &lt;user&gt;: Requsta auth token. &lt;token&gt;: Authar sig. Man måste autha sig för att kunna använda boten.
|-
| .device &lt;hostname&gt;
| Ger basic info om hosten.
|-
| .down
| Listar alla hostnamn som är nere.
|-
| .help
| Tillgängliga kommandon.
|-
| .join &lt;channel&gt;
| Joinar en kanal om användaren har admin-level.
|-
| .listdevices
| Listar hostnamnet på alla kända devices.
|-
| .log [&lt;N&gt;]
| Listar N linje ur eventlogen.
|-
| .port &lt;hostname&gt; &lt;ifname&gt;
| Listar info relaterat till porten.
|-
| .quit
| Boten disconnectar från IRC.
|-
| .reload
| Reloadar konfigurationen.
|-
| .status &lt;type&gt;
| Listar status info från den valda typen. En type kan vara '''devices''', '''services''', '''ports'''. Förkortning: '''dev''', '''srv''', '''prt'''.
|-
| .version
| Printar &lt;code&gt;$this-&gt;config['project_name_version']&lt;/code&gt;
|}

==LDAP==
Kräver att paketet &lt;code&gt;php-ldap&lt;/code&gt; är installerat.
Lägg in följande rader i &lt;code&gt;config.php&lt;/code&gt;
 $config['auth_mechanism'] = "ldap";

 $config['auth_ldap_version'] = 3; # v2 or v3
 $config['auth_ldap_server'] = "ldap.example.com";
 $config['auth_ldap_port']   = 389;
 $config['auth_ldap_prefix'] = "uid=";
 $config['auth_ldap_suffix'] = ",ou=People,dc=example,dc=com";
 $config['auth_ldap_group']  = "cn=groupname,ou=groups,dc=example,dc=com";
 
 $config['auth_ldap_groupbase'] = "ou=group,dc=example,dc=com";
 $config['auth_ldap_groups']['admin']['level'] = 10;
 $config['auth_ldap_groups']['noc']['level'] = 5;
 $config['auth_ldap_groupmemberattr'] = "memberUid";
===User levels===
*1: Normal användare. Kräver att en admin tilldelar devices och portar som dessa får läsa.
*5: Får läsa allt om alla devices.
*10: Admin konto som får skriva och läsa.
*11: Demo konto. Samma som 10 fast får inte ta bort devices.

==Auto discovery==
Det finns stöd för att automatiskt lägga till devices. För att det ska fungera måste man ange en default SNMP community för v1, v2c eller v3, man måste också ställa in vilka subnet som är ens egna. Discovery körs var 6h och inom 5 minuter om det är en ny enhet. Man måste också ha minst en enhet tillagd före auto discovery funkar. Om LibreNMS hittar en enhet så försöker den göra ett reverse uppslag mot DNS för att få namnet på devicen. Om det inte går så kommer den heller inte lägga till devicen, detta är inställt default men går att stänga av.

===Konfiguration===
Börja med att sätta SNMP community eller användarnamn &amp; lösenord om du kör v3:
 // v1 or v2c
 $config['snmp']['community'][] = "my_custom_public";
 $config['snmp']['community'][] = "another_public";
 
 // v3
 $config['snmp']['v3'][0]['authlevel'] = 'AuthPriv';
 $config['snmp']['v3'][0]['authname'] = 'my_username';
 $config['snmp']['v3'][0]['authpass'] = 'my_password';
 $config['snmp']['v3'][0]['authalgo'] = 'MD5';
 $config['snmp']['v3'][0]['cryptopass'] = 'my_crypto';
 $config['snmp']['v3'][0]['cryptoalgo'] = 'AES';

Ange vilka subnät som är dina:
 $config['nets'][] = '192.168.0.0/16';
 $config['nets'][] = '172.16.0.0/12';

Det går även att utesluta nätverk om man vill:
 $config['autodiscovery']['nets-exclude'][] = '192.168.1.0/24';

===Discovery methods===
Det finns fyra stycken alternativ för att lägga till devices och en manuell.

'''ARP'''

Disable by default. 

Kan slås på med följande kommando:
 $config['discovery_modules']['discovery-arp'] = 1;

'''XDP'''

Enabled by default.

För att stänga av:
 $config['autodiscovery']['xdp'] = false;

XDP inkluderar FDP, CDP och LLDP.

'''OSPF'''

Enabled by default.

För att stänga av:
 $config['autodiscovery']['ospf'] = false;

'''BGP'''

Enabled by default.

För att stänga av:
 $config['autodiscovery']['bgp'] = false;

'''SNMP Scan'''

Denna metod måste du starta själv. Om den bara körs direkt utan växlar så kommer den scanna näten i din config fil. Med växeln '''-r''' kan du säga till vilket nät den ska skanna.
 snmp-scan.php -r 172.22.0.0/24

====Korta hostnamn====
Om dina devices vid en SNMP fråga svarar med sitt hostnamn istället för FQDN kan du lägga på din domän med följande kommando:
 $config['mydomain'] = 'hackernet.se';
====Lägg till device med IP====
Utifall LibreNMS inte kan göra reverse uppslag mot DNS så kommer inte devicen att läggas till. Det går att stänga av så att den läggs till ändå fast med IP istället.
 $config['discovery_by_ip'] = true;

==Nagios plugins==
LibreNMS kan köra Nagios plugins som inte använder Nagios NRPE klient.

Börja med att sätta på services i LibreNMS och peka ut vart Nagios scripten ligger.
 $config['show_services'] = 1;
 $config['nagios_plugins']   = "/usr/lib/nagios/plugins";

Installera '''nagios-snmp-plugins''' paketet om du vill ha ett några färdiga script som fungerar.
 apt-get install nagios-snmp-plugins

I webbinterfacet så finns nu en ny knapp som heter '''Services''' där man kan lägga till vilken service som ska köras på vilken host.

Ett tips är att köra scripten med '''-h''' på i skalet så att man ser vilka parametrar man behöver ställa in för att det ska fungera.

På [https://exchange.nagios.org/ Nagios Exchange] finns ett stort antal plugins att ladda hem.

=Övervakning=
LibreNMS har stöd för att övervaka några standard tjänster direkt från start med hjälp av snmp eller med deras klient check_mk.

Dessa är några av tjänsterna det finns stöd för och hur dom övervakas:
*Apache - Agent, extend SNMP
*BIND9/named - Agent
*MySQL - Agent, extend SNMP
*NGINX - extend SNMP
*NTPD - Agent, extend SNMP, 
*PowerDNS - Agent, extend SNMP
*PowerDNS Recursor - Agent, extend SNMP
*TinyDNS/djbdns - Agent
*OS Updates - extend SNMP
*DHCP Stats - extend SNMP
*Memcached - Agent, extend SNMP
*Unbound - Agent
*Proxmox - extend SNMP
*Raspberry PI - extend SNMP


==Agent installation==
Agenten pratar default på port 6556/TCP.

Clona librenms-agent repot:
 cd /opt/
 git clone https://github.com/librenms/librenms-agent.git
 cd librenms-agent

Kopiera check_mk_agent filen och gör den körbar:
 cp check_mk_agent /usr/bin/check_mk_agent &amp;&amp; chmod +x /usr/bin/check_mk_agent

Skapa följande mappar där du sedan ska lägga scripten till tjänsterna du vill ha grafer på.
 mkdir -p /usr/lib/check_mk_agent/plugins /usr/lib/check_mk_agent/local

Kopiera scripten från '''agent-local''' mappen till '''/usr/lib/check_mk_agent/local''' och gör dom körbara med '''chmod +x'''

Kopiera sedan systemd filen och gör att den startar vid boot och starta agenten.
 cp check_mk@.service check_mk.socket /etc/systemd/system
 systemctl enable check_mk.socket &amp;&amp; systemctl start check_mk.socket

För att agenten ska fungera så måste man sätta på '''unix-agent''' under modules på varje device i web interfacet. Och enable dom tjänsterna man vill övervaka under '''application'''.
==MySQL==
MySQL scriptet kräver en extra konfigurationsfil med användarnamn och lösenord till databasen som ska övervakas.

Skapa följande fil '''/usr/lib/check_mk_agent/local/mysql.cnf''' med innehållet:
 &lt;?php
 $mysql_user = 'root';
 $mysql_pass = 'toor';
 $mysql_host = 'localhost';
 $mysql_port = 3306;

Verifera att scriptet fungerar genom att köra 
 /usr/lib/check_mk_agent/local/mysql

Lägg sedan in en extend rad i '''/etc/snmp/snmpd.conf''': 
 extend mysql /usr/lib/check_mk_agent/local/mysql
==NGINX==
Nginx kräver att status sidan är aktiverad för localhost.
 location /nginx-status {
     stub_status on;
     access_log   off;
     allow 127.0.0.1;
     deny all;
 }
Verifera att scriptet fungerar genom att köra 
 /usr/lib/check_mk_agent/local/nginx

Lägg sedan in en extend rad i '''/etc/snmp/snmpd.conf''': 
 extend nginx /usr/lib/check_mk_agent/local/nginx
==Apache==
Flytta apache scriptet till '''/usr/lib/check_mk_agent/local/'''

Verifera att scriptet fungerar genom att köra: 
 /usr/lib/check_mk_agent/local/apache

Och lägg sedan in en extend rad i '''/etc/snmp/snmpd.conf''': 
 extend apache /usr/lib/check_mk_agent/local/apache
==PowerDNS==
Flytta powerdns scriptet till '''/usr/lib/check_mk_agent/local/'''

Verifera att scriptet fungerar genom att köra: 
 /usr/lib/check_mk_agent/local/powerdns

Och lägg sedan in en extend rad i '''/etc/snmp/snmpd.conf''': 
 extend powerdns /usr/lib/check_mk_agent/local/powerdns
==PowerDNS Recursor==
Flytta powerdns-recursor scriptet till '''/usr/lib/check_mk_agent/local/'''

Verifera att scriptet fungerar genom att köra: 
 /usr/lib/check_mk_agent/local/powerdns-recursor

Och lägg sedan in en extend rad i '''/etc/snmp/snmpd.conf''': 
 extend apache /usr/lib/check_mk_agent/local/powerdns-recursor


[[Category:Guider]]</text>
      <sha1>343sxgnpvga98i9hwle949bgz4u677a</sha1>
    </revision>
  </page>
  <page>
    <title>Linux</title>
    <ns>0</ns>
    <id>54</id>
    <revision>
      <id>3165</id>
      <parentid>3155</parentid>
      <timestamp>2023-12-13T13:02:55Z</timestamp>
      <contributor>
        <username>Zunken</username>
        <id>3</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5996">
'''Linux''' är ett Unix-liknande operativsystem som till största delen, och i några varianter helt, består av fri programvara.  

=Tools=
&lt;DynamicPageList&gt;
category = Tools
ordermethod = sortkey
order = ascending
&lt;/DynamicPageList&gt;

=Distar=
&lt;DynamicPageList&gt;
category = Distar
ordermethod = sortkey
order = ascending
&lt;/DynamicPageList&gt;

=Tips'n'trix=
====Skapa ny disk====
Skapa en volume group av en disk. 
 vgcreate cs_log02_data /dev/sdb

Skapa en logical volume av volume groupen du skapa. 
 lvcreate -l 100%FREE -n logs cs_log02_data
 mkfs.xfs /dev/cs_log02_data/logs

Skapa en folder och mounta nya disken.  
 mkdir -p /data/logs
 mount /dev/cs_log02_data/logs /data/logs

Se till att mounten är permanenet när servern rebootar. 
 echo "/dev/mapper/cs_log02_data-logs /data/logs                       xfs     defaults        0 0" &gt;&gt; /etc/fstab
====Expandera disk====
 Scanna om disken du vill expandera efter du utökat i exempelvis vmware.
 echo 1&gt;/sys/class/block/sdc/device/rescan
 fdisk -l kolla så den är utökad
 Utöka PVn
 pvresize /dev/sdc
 utöka lv lvextend -l +100%FREE /dev/mapper/datavg
 expandera volymen med.
 xfs_growfs /dev/mapper/datavg
====Skapa egna selinux med grep och audit2allow.====
Kommando
 cat /var/log/audit/audit.log |grep postgres_expo |grep denied |audit2allow
Resultat som visar vad det är du skapar en regel på
 #============= init_t ==============
 allow init_t postgresql_port_t:tcp_socket name_connect;

Kommando
 cat /var/log/audit/audit.log |grep postgres_expo |grep denied |audit2allow -M postgres
Resultat som bara visar vad du skall köra för att implementera selinux regeln ovan
 ******************** IMPORTANT ***********************
 To make this policy package active, execute:
 semodule -i postgres.pp

kommando
 semodule -i postgres.pp

====Ansluta till trådlöst nätverk.====
 nmcli d wifi connect &lt;SSID&gt; password &lt;password&gt; iface wlan0
====Ta reda på om det är något lokalt prestanda eller kapacitetsproblem med maskinen.====
Finns på Github och [[Python#PIP|PyPI]]
 glances 
====Ta reda på publik IP du har====
 wget http://ipinfo.io/ip -qO -
====Testa hårdvaruaccelerering====
 openssl speed -evp AES256
====Speedtest mot internet med cli====
 wget -O speedtest-cli https://raw.github.com/sivel/speedtest-cli/master/speedtest_cli.py
 chmod +x speedtest-cli
 ./speedtest-cli --simple
====Lista filer efter storlek====
 for i in T G M K; do du -hsx * | grep "[0-9]$i\b" | sort -nr; done 2&gt;/dev/null
====Summera alla filer i en mapp och printa storleken.====
 du -hs *
====Restricted Shell====
 useradd[mod] -s /usr/sbin/scponly user1
====Process Run Time====
 ps -p PID -o etime=
====Skydda mot SYN flood====
 ss -a | grep SYN-RECV | awk '{print $4}' | awk -F":" '{print $1}' | sort | uniq -c | sort -n

 sudo netstat -antp | grep SYN_RECV|awk '{print $4}'|sort|uniq -c | sort -n
====Parallellpinga IP-adresser från fil====
 echo $(cat iplist.txt) | xargs -n 1 -P0 ping -w 1 -c 1
====Kolla vilken tjänst som vanligtvis ligger på vilken port, t.ex.====
 cat /etc/services | grep mysql
====Kör en filesystem check vid nästa uppstart====
 touch /forcefsck
====Kolla distinfo====
 lsb_release -a
 eller
 cat /etc/*release
====Titta på senaste uppstart grafiskt====
 systemd-analyze plot &gt; plot.svg
====Kolla vad ett kommando kör för systemfrågor. Väldigt användbart vid felsökning.====
 strace &lt;kommando&gt;
====Kör ett kommando tex 1 gång i sekunden. (Default 2 sekunder)====
 watch -n 1 date
====Kopiera directory-struktur utan att kopiera filer====
 rsync -a -f"+ */" -f"- *" source/ destination/
====Lista hårddiskar, partitioner och RAID.====
 lsblk
====Simpelt prestandatest av hårddiskar====
 dd if=/dev/zero of=(fil på disken/raiden) bs=1G count=1 oflag=dsync
====Packa upp initrd.====
 gunzip -dc ../initrd | cpio -idmuv
====Packa ner initrd.====
 find . -print |cpio -o -H newc | xz --format=lzma &gt; ../initrd
====Byt namn på alla filer och mappar från uppercase till lowercase i en mapp.====
'''Upper till lower'''.
 for i in *; do mv "$i" "$(echo $i|tr A-Z a-z)"; done
'''Lower till upper'''.
 for i in *; do mv "$i" "$(echo $i|tr a-z A-Z)"; done
====Sök efter en text i alla filer i en mapp====
 grep -r "string" .

====Kollar antal dagar det är kvar på ett certifikat====
&lt;syntaxhighlight lang=bash&gt; remote_cert_remaining_days() { cert_remaining_time=$(date -d "$(openssl s_client -connect $1 2&gt;/dev/null &lt;/dev/null | openssl x509  -enddate -noout | cut -d'=' -f2)" "+%s");  current_time=$(date "+%s"); echo remaining $((($cert_remaining_time - $current_time) / 60 / 60 / 24)) days; }
&lt;/syntaxhighlight&gt;
 remote_cert_remaining_days fqdn:443

====Räkna ut option 121 för DHCP====
För att kunna skicka ut fler routes via DHCP behöver man skriva på ett visst sätt. Följande sida kan hjälpa till med det:
[https://www.nboquestal.fr/outils/route-calculator/ Route calculator]

=Intervjufrågor=
Ska du på arbetsintervju för ett linuxjobb? Prepare your anus!
# Vad är det för skillnad på en vanlig fil och ett directory?
# Vad är en i-node?
# Vad är det för skillnad på hard och soft links? Vad händer om man tar bort källan för länken?
# Vad är en process och vad består den logiskt av?
# Vad är det för skillnad på mtab och fstab?
# Vad gör rm-kommandot? (utan växlar)
# Vad är det för skillnad på kill och kill -9?
# Villka process states finns det?
# Vad är det för skillnad på process och thread?
# Vad är en Socket?
# Vad är Huge Pages och vad används de till?
# Hur frigör man cacheat minne utan att reboota systemet?
# Vad är det för skillnad på chmod och setfacl?
# Vad är Memory Overcommit?
# Vad är system load average som visas av uptime-kommandot?
# Vad finns det för för- och nackdelar med kernel kontra user space?
# Vad är runlevel?
# Vad är det för skillnad på TTY och PTS?
# Du är fast på en öde ö och får bara använda ett enda kommando, vilket väljer du?

=== Svar ===
Kommer inom sinom tid, har du svar bidra gärna</text>
      <sha1>71qavc5r27fz38zgmjx1efdsinesx5p</sha1>
    </revision>
  </page>
  <page>
    <title>Logstash</title>
    <ns>0</ns>
    <id>202</id>
    <revision>
      <id>1970</id>
      <parentid>1948</parentid>
      <timestamp>2016-07-23T17:36:11Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1875">Logstash sparar alla loggar från olika system på ett centralt ställe och hjälper dig att söka bland dom.

=Installation=
 wget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
 echo "deb https://packages.elastic.co/logstash/2.3/debian stable main" | sudo tee -a /etc/apt/sources.list
 sudo apt-get update &amp;&amp; sudo apt-get -y install logstash

=Konfiguration=
'''Java''' &lt;br/&gt;
Ska logstash lyssna på portar under 1000 (t.ex. syslog 514) måste java tillåtas att binda dessa portar.
 sudo setcap cap_net_bind_service=+epi /usr/lib/jvm/java-8-oracle/jre/bin/java

==Syslog==
(RFC 3164)
&lt;syntaxhighlight lang="bash"&gt;
sudo dd of=/etc/logstash/conf.d/10-syslog.conf &lt;&lt; EOF
input {
  tcp {
    port =&gt; 514
    type =&gt; syslog
  }
  udp {
    port =&gt; 514
    type =&gt; syslog
  }
}

filter {
  if [type] == "syslog" {
    grok {
      match =&gt; { "message" =&gt; "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])$
      add_field =&gt; [ "received_at", "%{@timestamp}" ]
      add_field =&gt; [ "received_from", "%{host}" ]
    }
    syslog_pri { }
    date {
      match =&gt; [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
  }
}

output {
  elasticsearch { host =&gt; localhost }
  stdout { codec =&gt; rubydebug }
}
EOF
&lt;/syntaxhighlight&gt;

==SSL==
Logstash forwarder (klienter) använder certifikat för autentisering och SSL för kommunikation med Logstash server. Skapa cert på servern.
 sudo mkdir -p /etc/pki/tls/certs &amp;&amp; sudo mkdir /etc/pki/tls/private
 sudo nano /etc/ssl/openssl.cnf
Find the [ v3_ca ] section and add: 
 subjectAltName = IP: 10.0.0.10
 cd /etc/pki/tls
 sudo openssl req -config /etc/ssl/openssl.cnf -x509 -days 3650 -batch -nodes -newkey rsa:2048 -keyout private/logstash-forwarder.key -out certs/logstash-forwarder.crt

==Forwarder==

[[Category:Guider]]</text>
      <sha1>32zn1fjq3k3anmgku4o3wuslnso43fy</sha1>
    </revision>
  </page>
  <page>
    <title>MEAN</title>
    <ns>0</ns>
    <id>116</id>
    <revision>
      <id>778</id>
      <parentid>777</parentid>
      <timestamp>2015-07-13T09:27:06Z</timestamp>
      <contributor>
        <username>Bizze</username>
        <id>5</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="643">MEAN, även kallat MEAN-stack är en relativt ny open-source webbplatform som är anpassad för dynamiska sidor som kör JavaScript. &lt;br /&gt;
En MEAN-stack består av:
* '''M'''ongoDB - NoSQL databas.
* '''E'''xpress.js - Web framework
* '''A'''ngular.js - Frontend framework
* '''N'''ode.js - Webbserver&lt;br /&gt;

Några fördelar med att köra MEAN-stack är att man använder samma programmeringsspråk genom hela applikationen och JSON-formatering. Detta gör det simplare att skriva snabba och responsiva applikationer samtidigt som det är lättare att felsöka, eftersom te.x objekt i databasen ser likadana ut för både back- och frontend.</text>
      <sha1>4plmu1s4h14xayvpwwi5g3s89zuhkla</sha1>
    </revision>
  </page>
  <page>
    <title>Mailserver</title>
    <ns>0</ns>
    <id>185</id>
    <revision>
      <id>3111</id>
      <parentid>1349</parentid>
      <timestamp>2021-02-24T14:59:16Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Tips'N'Trix */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="17325">[[Category:Guider]] [[Category:Sparco]]
För att sätta upp en mailserver snabbt kan man använda [[IRedMail]]. Om man vill sätta upp en själv med [[Dovecot]] och [[Postfix]] och koppla allt till [[OpenLDAP]] för att lättare hantera login och skapandet av nya användare. Och sätta upp en [[Roundcube]] för att hantera webmail.

==Förberedelse==
Öppna portar i brandväggen.
*25 (SMTP)
*80 (HTTP)
*110 (POP3)
*143 (IMAP)
*443 (HTTPS)

Skapa ett A och MX record i DNSen som spekar mot mailservern.

Importera postfix schema på [[OpenLDAP#Postfix_Schema| OpenLDAP]] servern.

=Postfix=
==Installation==
 apt-get install postfix postfix-pcre postfix-ldap

Om man vill kunna skicka testmails(swaks) och enkelt styra mailboxen(mutt).
 apt-get install mutt swaks

==Konfiguration==
Konfigurations filerna finns under &lt;code&gt;/etc/postfix&lt;/code&gt;

&lt;div class="toccolours mw-collapsible mw-collapsed" style="width:800px"&gt;
&lt;code&gt;main.cf&lt;/code&gt; Detta är main konfigurations filen.
&lt;div class="mw-collapsible-content"&gt;
&lt;syntaxhighlight lang=bash&gt;#!/bin/bash
###################################################################################################
### Base Settings ###
#####################

# Listen on all interfaces
inet_interfaces = all

# Use TCP IPv4
inet_protocols = ipv4

# Greet connecting clients with this banner
smtpd_banner = $myhostname ESMTP $mail_name (Ubuntu)

# Fully-qualified hostname
myhostname = mail.example.com

# Do not append domain part to incomplete addresses (this is the MUA's job)
append_dot_mydomain = no

# Trusted networks/hosts (these are allowed to relay without authentication)
mynetworks =
    # Local
    127.0.0.0/8
    # External
    1.2.3.4/32


###################################################################################################
### Local Transport ###
#######################

# Disable local transport (so that system accounts can't receive mail)
local_transport = error:Local Transport Disabled

# Don't use local alias maps
alias_maps = 

# Local domain (could be omitted, since it is automatically derived from $myhostname)
mydomain = example.com

# Mails for these domains will be transported locally
mydestination =
    $myhostname
    localhost.$mydomain
    localhost


###################################################################################################
### Virtual Transport ###
#########################

# Deliver mail for virtual recipients to Dovecot
virtual_transport = dovecot

# Process one mail at one time
dovecot_destination_recipient_limit = 1

# Valid virtual domains
virtual_mailbox_domains = hash:/etc/postfix/virtual_domains

# Valid virtual recipients
virtual_mailbox_maps = proxy:ldap:/etc/postfix/ldap_virtual_recipients.cf

# Virtual aliases
virtual_alias_maps = proxy:ldap:/etc/postfix/ldap_virtual_aliases.cf


###################################################################################################
### ESMTP Settings ###
######################

### SASL ###

# Enable SASL (required for SMTP authentication)
smtpd_sasl_auth_enable = yes

# Enable SASL for Outlook-Clients as well
broken_sasl_auth_clients = yes

### TLS ###

# Enable TLS (required to encrypt the plaintext SASL authentication)
smtpd_tls_security_level = may

# Only offer SASL in a TLS session
smtpd_tls_auth_only = yes

# Certification Authority
smtpd_tls_CAfile = /etc/postfix/certs/example-cacert.pem

# Public Certificate
smtpd_tls_cert_file = /etc/postfix/certs/mail_public_cert.pem

# Private Key (without passphrase)
smtpd_tls_key_file = /etc/postfix/certs/mail_private_key.pem

# Randomizer for key creation
tls_random_source = dev:/dev/urandom

# TLS related logging (set to 2 for debugging)
smtpd_tls_loglevel = 0

# Avoid Denial-Of-Service-Attacks
smtpd_client_new_tls_session_rate_limit = 10

# Activate TLS Session Cache
smtpd_tls_session_cache_database = btree:/etc/postfix/smtpd_session_cache

# Deny some TLS-Ciphers
smtpd_tls_exclude_ciphers =
        EXP
        EDH-RSA-DES-CBC-SHA
        ADH-DES-CBC-SHA
        DES-CBC-SHA
        SEED-SHA

# Diffie-Hellman Parameters for Perfect Forward Secrecy
# Can be created with:
# openssl dhparam -2 -out dh_512.pem 512
# openssl dhparam -2 -out dh_1024.pem 1024
smtpd_tls_dh512_param_file = ${config_directory}/certs/dh_512.pem
smtpd_tls_dh1024_param_file = ${config_directory}/certs/dh_1024.pem


###################################################################################################
### Connection Policies ###
###########################

# Reject Early Talkers
postscreen_greet_action = enforce


###################################################################################################
### Session Policies ###
########################

# Recipient Restrictions (RCPT TO related)
smtpd_recipient_restrictions =
        # Allow relaying for SASL authenticated clients and trusted hosts/networks
        # This can be put to smtpd_relay_restrictions in Postfix 2.10 and later 
        permit_sasl_authenticated
        permit_mynetworks
        reject_non_fqdn_recipient
        reject_unknown_recipient_domain
        reject_unauth_destination
        # Reject the following hosts
        check_sender_ns_access cidr:/etc/postfix/drop.cidr
        check_sender_mx_access cidr:/etc/postfix/drop.cidr
        # Additional blacklist
        reject_rbl_client ix.dnsbl.manitu.net
        # Finally permit (relaying still requires SASL auth)
        permit

# Reject the request if the sender is the null address and there are multiple recipients
smtpd_data_restrictions = reject_multi_recipient_bounce

# Sender Restrictions
smtpd_sender_restrictions =
        reject_non_fqdn_sender
        reject_unknown_sender_domain

# HELO/EHLO Restrictions
smtpd_helo_restrictions =
		permit_mynetworks
        check_helo_access pcre:/etc/postfix/identitycheck.pcre
        #reject_non_fqdn_helo_hostname
        reject_invalid_hostname

# Deny VRFY recipient checks
disable_vrfy_command = yes

# Require HELO
smtpd_helo_required = yes

# Reject instantly if a restriction applies (do not wait until RCPT TO)
smtpd_delay_reject = no

# Client Restrictions (IP Blacklist)
smtpd_client_restrictions = check_client_access cidr:/etc/postfix/drop.cidr
&lt;/syntaxhighlight&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="toccolours mw-collapsible mw-collapsed" style="width:800px"&gt;
&lt;code&gt;virtual_domains&lt;/code&gt; Innehåller vilka domäner server tar emot mail för.
&lt;div class="mw-collapsible-content"&gt;
&lt;syntaxhighlight lang=bash&gt;#!/bin/bash
# Domain		Anything
example.com		OK
&lt;/syntaxhighlight&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="toccolours mw-collapsible mw-collapsed" style="width:800px"&gt;
&lt;code&gt;ldap_virtual_recipients.cf&lt;/code&gt; LDAP fråga för att validera mottagaren.
&lt;div class="mw-collapsible-content"&gt;
&lt;syntaxhighlight lang=bash&gt;#!/bin/bash
bind = yes
bind_dn = uid=postfix,ou=services,dc=example,dc=com
bind_pw = secret
server_host = ldap://127.0.0.1:389
search_base = ou=people,dc=example,dc=com
domain = example.com
query_filter = (&amp;(mail=%s)(mailEnabled=TRUE))
result_attribute = mail
&lt;/syntaxhighlight&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="toccolours mw-collapsible mw-collapsed" style="width:800px"&gt;
&lt;code&gt;ldap_virtual_aliases.cf&lt;/code&gt; LDAP fråga för att få fram aliases och forwarding adress.  
&lt;div class="mw-collapsible-content"&gt;
&lt;syntaxhighlight lang=bash&gt;#!/bin/bash
bind = yes
bind_dn = uid=postfix,ou=services,dc=example,dc=com
bind_pw = secret
server_host = ldap://127.0.0.1:389
search_base = ou=people,dc=example,dc=com
domain = example.com
query_filter = (&amp;(mailAlias=%s)(mailEnabled=TRUE))
result_attribute = mail, email
&lt;/syntaxhighlight&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="toccolours mw-collapsible mw-collapsed" style="width:800px"&gt;
&lt;code&gt;identitycheck.pcre&lt;/code&gt; Regexp för att blocka klienter som använder ditt hostnamn.
&lt;div class="mw-collapsible-content"&gt;
&lt;syntaxhighlight lang=bash&gt;#!/bin/bash
# Identity (RegEx)		Action

/^(mail\.example\.com)$/	REJECT Hostname Abuse: $1
/^(1\.2\.3\.4)$/		REJECT Hostname Abuse: $1
/^(\[1\.2\.3\.4\])$/		REJECT Hostname Abuse: $1
&lt;/syntaxhighlight&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="toccolours mw-collapsible mw-collapsed" style="width:800px"&gt;
&lt;code&gt;drop.cidr&lt;/code&gt; Innehåller svartlistade IP-adresser.
&lt;div class="mw-collapsible-content"&gt;
&lt;syntaxhighlight lang=bash&gt;#!/bin/bash
# IP/CIDR			Action

1.2.3.0/24			REJECT Blacklisted
&lt;/syntaxhighlight&gt;
&lt;/div&gt;
&lt;/div&gt;

Temporärt kommentera ut följande rader eftersom att [[Dovecot]] och TLS inte är konfigurerat i main.cf:
*dovecot_destination_recipient_limit = 1
*smtpd_tls_security_level = may
*smtpd_tls_auth_only = yes
*smtpd_tls_CAfile = /etc/postfix/certs/example-cacert.pem
*smtpd_tls_cert_file = /etc/postfix/certs/mail_public_cert.pem
*smtpd_tls_key_file = /etc/postfix/certs/mail_private_key.pem

Skapa en postmap db fil för din domän.
 postmap hash:/etc/postfix/virtual_domains

Starta postfix och anslut mot servern med telnet mot port 25. Prova att skicka &lt;code&gt;EHLO client&lt;/code&gt;, då ska du få följande svar:
&lt;syntaxhighlight lang=text&gt;
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
220 mail.example.com ESMTP Postfix (Ubuntu)
EHLO client
250-mail.example.com
250-PIPELINING
250-SIZE 10240000
250-ETRN
250-AUTH DIGEST-MD5 NTLM CRAM-MD5 LOGIN PLAIN
250-AUTH=DIGEST-MD5 NTLM CRAM-MD5 LOGIN PLAIN
250-ENHANCEDSTATUSCODES
250-8BITMIME
250 DSN
QUIT
221 2.0.0 Bye
&lt;/syntaxhighlight&gt;

Testa att ställa en LDAP fråga.
 postmap -q user@example.com ldap:/etc/postfix/ldap_virtual_recipients.cf
 postmap -q postmaster@example.com ldap:/etc/postfix/ldap_virtual_aliases.cf

Båda frågorna bör ge user@example.com som svar.

=Dovecot=
==Installation==
 apt-get install dovecot-core dovecot-imapd dovecot-pop3d dovecot-lmtpd dovecot-ldap
==Konfiguration==
Stäng av protocol som du inte behöver i filen &lt;code&gt;/etc/dovecot/conf.d/10-master.conf&lt;/code&gt; genom att sätta porten på '''0'''. Och sätt permissions, användare och grupp för '''authentication-userdb''' i samma fil:
&lt;syntaxhighlight lang=php&gt;
inet_listener imaps {
    port = 0
    #port = 993
    #ssl = yes
}
&lt;/syntaxhighlight&gt;
&lt;br&gt;
&lt;syntaxhighlight lang=php&gt;
inet_listener pop3s {
    port = 0
    #port = 995
    #ssl = yes
}
&lt;/syntaxhighlight&gt;
&lt;br&gt;
&lt;syntaxhighlight lang=php&gt;
unix_listener auth-userdb {
    mode = 0600
    user = vmail
    group = vmail
}
&lt;/syntaxhighlight&gt;

Stäng av system-based authentication och sätt på LDAP-based authentication istället i &lt;code&gt;/etc/dovecot/conf.d/10-auth.conf&lt;/code&gt;:
&lt;syntaxhighlight lang=php&gt;
auth_mechanisms = plain login
#!include auth-system.conf.ext
!include auth-ldap.conf.ext
&lt;/syntaxhighlight&gt;

Sätt dom LDAP relaterade inställningarna i &lt;code&gt;/etc/dovecot/dovecot-ldap.conf.ext&lt;/code&gt;:
&lt;syntaxhighlight lang=bash&gt;
hosts = 127.0.0.1
dn = uid=dovecot,ou=services,dc=example,dc=com
dnpass = secret
ldap_version = 3
base = ou=people,dc=example,dc=com
user_attrs = mailHomeDirectory=home,mailUidNumber=uid,mailGidNumber=gid,mailStorageDirectory=mail
user_filter = (&amp;(objectClass=PostfixBookMailAccount)(uniqueIdentifier=%n))
pass_attrs = uniqueIdentifier=user,userPassword=password
pass_filter = (&amp;(objectClass=PostfixBookMailAccount)(uniqueIdentifier=%n))
default_pass_scheme = CRYPT
&lt;/syntaxhighlight&gt;

Aktivera loggning i &lt;code&gt;/etc/dovecot/conf.d/10-logging.conf&lt;/code&gt;:
 log_path = syslog
 syslog_facility = mail
 auth_debug = yes

Sätt SSL cert i &lt;code&gt;/etc/dovecot/conf.d/10-ssl.conf&lt;/code&gt;:
 ssl_cert = &lt;/etc/dovecot/mail_public_cert.pem
 ssl_key = &lt;/etc/dovecot/private/mail_private_key.pem

Skapa en användare och en grupp som heter '''vmail''' med uid och gid 5000:
 addgroup --system --gid 5000 vmail
 adduser --system --home /srv/vmail --uid 5000 --gid 5000 --disabled-password --disabled-login vmail

Starta dovecot och gör ett IMAP connection &amp; authentication test med hjälp av telnet. Om du inte vill starta dovecot i bakgrunden använd &lt;code&gt;dovecot -f&lt;/code&gt;.

&lt;code&gt;telnet 127.0.0.1 143&lt;/code&gt; och skicka &lt;code&gt;1 login user@example.com secret&lt;/code&gt;
&lt;syntaxhighlight lang=bash&gt;
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
* OK [CAPABILITY IMAP4rev1 LITERAL+ SASL-IR LOGIN-REFERRALS ID ENABLE IDLE STARTTLS AUTH=PLAIN AUTH=LOGIN] Dovecot (Ubuntu) ready.
1 login user@example.com secret
1 OK [CAPABILITY IMAP4rev1 LITERAL+ SASL-IR LOGIN-REFERRALS ID ENABLE IDLE SORT SORT=DISPLAY THREAD=REFERENCES THREAD=REFS THREAD=ORDEREDSUBJECT MULTIAPPEND URL-PARTIAL CATENATE UNSELECT CHILDREN NAMESPACE UIDPLUS LIST-EXTENDED I18NLEVEL=1 CONDSTORE QRESYNC ESEARCH ESORT SEARCHRES WITHIN CONTEXT=SEARCH LIST-STATUS SPECIAL-USE BINARY MOVE] Logged in
2 logout
* BYE Logging out
&lt;/syntaxhighlight&gt;

Aktivera Dovecot deliver i Postfix genom att lägga till följande rad i &lt;code&gt;/etc/postfix/master.cf&lt;/code&gt;:
&lt;syntaxhighlight lang=bash&gt;
dovecot   unix  -       n       n       -       -       pipe
        flags=ODRhu user=vmail:vmail argv=/usr/lib/dovecot/deliver -e -f ${sender} -d ${recipient}
&lt;/syntaxhighlight&gt;

Sätt en postmaster adress i &lt;code&gt;/etc/dovecot/conf.d/15-lda.conf&lt;/code&gt;:
 postmaster_address = postmaster@example.com

Starta om '''Dovecot''' och '''Postfix''' och gör sedan ett deliver test.

 swaks --from user1@example.com --to user2@example.com --server 127.0.0.1:25

Kolla i log filerna eller i user2 mailbox
 mutt -f /srv/vmail/user2@example.com/Maildir/

=SASL=
==Installation==
 apt-get install libsasl2-2 sasl2-bin

==Konfiguration==
Skapa '''"smtpd.conf"''' i &lt;code&gt;/etc/postfix/sasl/&lt;/code&gt;:
 log_level: 3
 pwcheck_method: saslauthd
 mech_list: PLAIN LOGIN

Sätt på autostart välj LDAP som mekanism och sätt options för en chrootad Postfix i &lt;code&gt;/etc/default/saslauthd&lt;/code&gt;:
 START=yes
 MECHANISMS="ldap"
 OPTIONS="-c -m /var/spool/postfix/var/run/saslauthd"

Skapa LDAP konfigurationen i &lt;code&gt;/etc/saslauthd.conf&lt;/code&gt;:
 ldap_servers: ldap://127.0.0.1/
 ldap_bind_dn: uid=saslauthd,ou=services,dc=example,dc=com
 ldap_bind_pw: secret
 ldap_timeout: 10
 ldap_time_limit: 10
 ldap_scope: sub
 ldap_search_base: ou=people,dc=example,dc=com
 ldap_auth_method: bind
 ldap_filter: (&amp;(uniqueIdentifier=%u)(mailEnabled=TRUE))
 ldap_debug: 0
 ldap_verbose: off
 ldap_ssl: no
 ldap_starttls: no
 ldap_referrals: yes

Sätt sedan rätt permissions på filen.
 chown root:sasl /etc/saslauthd.conf
 chmod 640 /etc/saslauthd.conf

Lägg till Postfix användaren i sasl gruppen.
 adduser postfix sasl

Starta sedan SASL och gör ett auth test:
 testsaslauthd -u user -p secret -f /var/spool/postfix/var/run/saslauthd/mux
Om det funkar är svaret '''0: OK “Success.”'''


För att testa så att SASL fungerar med SMTP måste vi göra om username och password till base64.
 perl -MMIME::Base64 -e 'print encode_base64("user\@example.com");'
 perl -MMIME::Base64 -e 'print encode_base64("secret");'

Öppna sedan en telnet session och skicka &lt;code&gt;EHLO test.local&lt;/code&gt; följt av &lt;code&gt;AUTH LOGIN&lt;/code&gt;. Servern kommer då att fråga efter username och password, skicka det som base64 encoded.
&lt;syntaxhighlight lang=bash&gt;
telnet localhost 25

Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mail.example.com ESMTP Postfix (Ubuntu)
EHLO test.local
250-mail.example.com
250-PIPELINING
250-SIZE 10240000
250-ETRN
250-STARTTLS
250-AUTH PLAIN LOGIN
250-AUTH=PLAIN LOGIN
250-ENHANCEDSTATUSCODES
250-8BITMIME
250 DSN
AUTH LOGIN
334 VXNlcm5hbWU6
YWxpY2VAZXhhbXBsZS5jb20=
334 UGFzc3dvcmQ6
c2VjcmV0
235 2.7.0 Authentication successful
QUIT       
221 2.0.0 Bye
&lt;/syntaxhighlight&gt;

Om allt fungera ska du få svaret '''235 2.7.0 Authentication successful'''. Om det inte fungera titta i log filerna. Om log filerna inte hjälpte slå på extended logging genom att lägga till -v i smtpd kommandot i &lt;code&gt;/etc/postfix/master.cf&lt;/code&gt;:
 smtp      inet  n       -       -       -       -       smtpd -v

Prova att skicka ett test mail med authentication.
 swaks --from user1@example.com --to user2@example.com --server 127.0.0.1:25 --auth plain --auth-user=user1@example.com

=TLS(Postfix)=
Just nu så skickas lösenorden i plaintext. För att kryptera dom skapa certifikat och lägg dom i &lt;code&gt;/etc/postfix/certs&lt;/code&gt;. Kolla i '''main.cf''' vilket filnamn dom ska ha. 
Skapa även 2st Diffie-Hellman filer i samma map.
 openssl dhparam -2 -out dh_512.pem 512
 openssl dhparam -2 -out dh_1024.pem 1024

Sätt rätt permissions på mappen.
 chown -R root:root /etc/postfix/certs/
 chmod -R 600 /etc/postfix/certs/

Ta bort dom 6 kommentarerna du gjorde i &lt;code&gt;/etc/postfix/main.cf&lt;/code&gt; filen i början av guiden och starta om Postfix.

Om du nu telnetar till Postfix servern och skickar '''EHLO client''' så ska det stå '''STARTTLS''' istället för '''LOGIN PLAIN'''.

Med följande kommando kan du prova att ansluta med '''STARTTLS'''.
 openssl s_client -CAfile certs/example-cacert.pem -starttls smtp -connect localhost:25

=Tips'N'Trix=
Säkra upp Dovecot och Postfix med TLS conf ifrån [https://syslink.pl/cipherlist/ chiperlist].

Testa säkerheten på mailservern med [https://starttls.info starttls] eller [https://ssl-tools.net/mailservers ssl-tools].

=Klient=
Du kan nu ansluta nån mail klient tex Thunderbird eller Outlook mot servern och autentisera med ditt [[OpenLDAP]] login.

Man kan också sätta upp [[Roundcube]] för att enkelt skicka och läsa din mail från en dator med en webbläsare.

[[Category:Guider]] [[Category:Sparco]]</text>
      <sha1>dum0x2o4sys1ls9ww0nvgfwpim6v8rk</sha1>
    </revision>
  </page>
  <page>
    <title>Main Page</title>
    <ns>0</ns>
    <id>1</id>
    <revision>
      <id>3098</id>
      <parentid>2968</parentid>
      <timestamp>2020-06-28T17:10:20Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1257">__NOTOC__
__NOCACHE__
&lt;div class="container"&gt;
  &lt;div class="jumbotron"&gt;
    &lt;h1&gt;HämligaHackerWikin&lt;/h1&gt;
    &lt;p&gt;Här kommer alla hämliga hackerknep att läggas upp&lt;/p&gt;
    &lt;p&gt;Har du tips, idéer eller feedback på det som skrivs, hör gärna av dig.&lt;/p&gt; 
    &lt;p&gt;root[at]hackernet.se&lt;/p&gt; 
  &lt;/div&gt;
&lt;div class="row-fluid clearfix" style="width:90%;margin:auto;text-align:center"&gt;
&lt;div class="col-md-4"&gt;
&lt;h2&gt;&lt;span class="mw-headline" id="Chart"&gt;&lt;span class="far fa-chart-bar"&gt;&lt;/span&gt;&lt;/span&gt; Livsviktigt info&lt;/h2&gt;
&lt;h4 style="border-bottom:none;"&gt;Vi är '''{{NUMBEROFACTIVEUSERS}}''' aktiva skribenter&lt;/h4&gt;
&lt;h4 style="border-bottom:none;"&gt;som tillsammans skrivit '''{{PAGESINNS:0}}''' artiklar&lt;/h4&gt;
&lt;h4 style="border-bottom:none;"&gt;och gjort '''{{NUMBEROFEDITS}}''' redigeringar.&lt;/h4&gt;
&lt;/div&gt;

&lt;div class="col-md-4"&gt;
&lt;h2&gt;&lt;span class="mw-headline" id="Guiden"&gt;&lt;span class="fas fa-terminal"&gt;&lt;/span&gt;&lt;/span&gt; Senaste artikeln&lt;/h2&gt;
&lt;p&gt;
&lt;DynamicPageList&gt;
namespace=Special:RecentChanges
count=5
mode=none
&lt;/DynamicPageList&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="col-md-4"&gt;
&lt;h2&gt;&lt;span class="mw-headline" id="Wishlist"&gt;&lt;span class="fa fa-magic"&gt;&lt;/span&gt;&lt;/span&gt; Wishlist&lt;/h2&gt;
&lt;p&gt;
'''[[Varnish]]'''&lt;br&gt;
'''[[OpenCanary]]'''&lt;br&gt;
'''[[HAProxy]]'''&lt;br&gt;
'''[[Wazuh]]'''&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</text>
      <sha1>gv6xz792u2vb3xai06lotpdxwndo30l</sha1>
    </revision>
  </page>
  <page>
    <title>Mdadm</title>
    <ns>0</ns>
    <id>65</id>
    <revision>
      <id>622</id>
      <parentid>621</parentid>
      <timestamp>2015-06-24T07:56:22Z</timestamp>
      <contributor>
        <username>Bizze</username>
        <id>5</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5412">mdadm är ett öppet verktyg för att skapa, hantera och monitorera md-raids i Linux. De flesta Debian och Redhat-baserade system har paketet installerat per default men bör annars finnas i officiella repos om det skulle fattas.

De flesta kommersiella NASar som tex Synology använder sig av Mdadm för att hantera deras raids, detta gör det möjligt att flytta över raids och synca till och från olika enheter som har stöd för verktyget.

==Installation==
sudo apt-get install mdadm
&lt;br&gt;sudo yum install mdadm

==Raidtyper==
Mdadm har stöd för standard raidtyper såsom:
* Raid 0
* Raid 1
* Raid 4
* Raid 5
* Raid 6
* Raid 10
&lt;br&gt;
Mdadm har även stöd för "'''non-raid configurations'''" (Tänk JBOD?):
&lt;br&gt;
* Linear – sammanfogar ett antal enheter till en enda stor MD-enhet.
* Multipath – ger flera vägar med failover till en enda enhet.
* Faulty – skapar ett antal felscenarior (tex läs/skrivfel) för test.
* Container – en grupp av enheter som hanteras som en enda enhet, där man kan bygga RAID-system.

WIP!

*Tweaks
*create, assemble, monitor, build, grow, manage
*exempel

== Create ==
Att skapa en ny mdadm är är väldigt strait-forward. Du skapar en array, väljer vilka diskar du ska slå ihop och sedan till vilken raidtyp.

När du bygger ihop din raid så kan du köra &lt;code&gt;cat /cat/mdstat&lt;/code&gt; för att få fram status från bygget.

=== Skapa array: ===
&lt;code&gt;mdadm --create /dev/md'''X'''&lt;/code&gt;

&lt;code&gt;mdadm --monitor /dev/md'''X'''&lt;/code&gt;

=== Skapa Raid-0 ===
&lt;code&gt;mdadm --create --verbose /dev/md'''X''' --level=stripe --name '''XXX '''--raid-devices='''X''' /dev/sd'''X'''1 /dev/sd'''X'''1&lt;/code&gt;

=== Skapa raid-1 ===
&lt;code&gt;mdadm --create --verbose /dev/md'''X '''--level=mirror --name '''XXX '''--raid-devices='''X''' /dev/sd'''X'''1 /dev/sd'''X'''1&lt;/code&gt;

...Med spare:

&lt;code&gt;mdadm --create --verbose /dev/md'''X'''--level=mirror --name '''XXX '''--raid-devices='''X'''/dev/sd'''X'''1''' '''/dev/sd'''X'''1 --spare-device=1 /dev/sd'''X'''&lt;/code&gt;

=== Skapa Raid-4/5/6 ===
&lt;code&gt;mdadm --create --verbose /dev/md'''X''' --level='''4/5/6''' --name '''XXX '''--raid-devices='''X''' /dev/sd'''X'''1 /dev/sd'''X'''1 /dev/sd'''X'''1 --spare-devices='''X''' /dev/sd'''X'''1&lt;/code&gt;

=== Skapa Raid-10 ===
&lt;code&gt;mdadm --create --verbose /dev/md'''X''' --level raid10 --name '''XXX''' --raid-devices='''X''' /dev/sd'''X'''1 /dev/sd'''X'''1 /dev/sd'''X'''1 /dev/sd'''X'''1&lt;/code&gt;

=== Spara din raid och skapa filsystem ===
Kolla i mdastat&lt;code&gt;cat /cat/mdstat &lt;/code&gt;f ör att se om din raid är färdigbyggd och för att se status.

'''OM''' din raid är färdigbyggd så kör vi följande kommando för att spara ner vår conf. Om du kör någon annan dist, kolla vart din mdadm.conf är placerad och skriv till den. '''Detta får inte göras förens din raid är färdigbyggd!! '''

'''RHEL/CentOS/Fedora:'''

&lt;code&gt;mdadm --detail --scan &gt;&gt; /etc/mdadm.conf&lt;/code&gt;

Nu kan vi skapa ett filsystem på vår raid

'''ext4:'''

&lt;code&gt;mkfs -t ext4ext4 /dev/&lt;/code&gt;md'''X '''

'''XFS:'''

För XFS behöver du speca SU som är samma som mdadm-raidens chunk size. Föra att få fram chunk size kan du köra &lt;code&gt;mdadm --detail /dev/md'''X'''&lt;/code&gt;

Du behöver också speca sw, vilket är hur många data-diskar du har (ej spares etc). 
* RAID 0 med 2 diskar: 2 data diskar (n)
* RAID 1 med 2 diskar: 1 data disk (n/2)
* RAID 10 med 10 diskar: 5 data diskar (n/2)
* RAID 5 med 6 diskar (inga spares): 5 data diskar (n-1)
* RAID 6 med 6 diskar (inga spares): 4 data diskar (n-2)
&lt;code&gt;mkfs -t xfs -d su='''X'''k -d sw='''X''' /dev/md'''X'''&lt;/code&gt;

Tex: raid 5 med 4 diskar med en chunksize på 64k:

&lt;code&gt;mkfs -t xfs -d su=64k -d sw=3 /dev/md'''X'''&lt;/code&gt;

==Flytta en mdadm raid==
Lättast om du sparar din /etc/mdadm.conf eller ARRAY-rader från konfen och flyttar med den/dessa till din nya maskin. Skulle inte det fungera så är det inte hela världen.

Vi börjar med worst-case, du har inte sparat conf eller ARRAY-info som UUID, namn etc:

1: Installera mdadm på server B och stäng av servern

2: koppla in dina diskar och starta upp servern igen.

3: Kolla så alla diskar är hittade under /dev/. Är alla där så kan du köra antingen &lt;code&gt;cat /proc/mdstat&lt;/code&gt; eller &lt;code&gt;ls -l /dev/md/&lt;RAIDNAMN&gt; (tabba fram)&lt;/code&gt; för att få fram vilken md-device din raid ligger som just nu.

4. Säg att din raid ligger hittad som /dev/md127, kör då &lt;code&gt;# mdadm --detail /dev/md127&lt;/code&gt;. När detta körs bör du får fram all info du behöver. Dvs '''Version, Namn '''och''' UUID'''.

5. Kör kommandot:   &lt;code&gt;echo &gt;&gt; ARRAY /dev/md'''X''' metadata='''"Version"''' name='''"namn"''' UUID='''"uuid" '''/etc/mdadm.conf&lt;/code&gt; '''NOTICE: '''Du får lägga din array vart du vill, även om md127 var där den hittades så kan du lägga den på tex /dev/md0. Se bara till så att md0 inte är upptagen. Detta kommando lägger till din "nya" array i mdadm-confen som läses in varje uppstart.

6. Reboot och &lt;code&gt;cat /proc/mdstat&lt;/code&gt; för att se hur din raid bygger ihop sig.

7. När raiden har byggt ihop sig så kan du mounta, jag föredrar att mounta via fstab och UUID. Exempel på fstab conf:

&lt;code&gt;UUID='''"RaidUUID" ''' /mount/point   xfs     defaults        0 0&lt;/code&gt;



'''OBS''' Vet inte om det står något värdefullt här men det kan nog dut avgöra bättre //Alex
 http://h3x.no/2011/07/09/tuning-ubuntu-mdadm-raid56

[[Category:Tools]]</text>
      <sha1>fyb0gd7de05fy73lc0groalqivxf6my</sha1>
    </revision>
  </page>
  <page>
    <title>MediaWiki</title>
    <ns>0</ns>
    <id>111</id>
    <revision>
      <id>2606</id>
      <parentid>1357</parentid>
      <timestamp>2017-08-03T10:48:05Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Backup */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8158">[[Category:Guider]] [[Category:Sparco]]
MediaWiki är en open-source wiki application som driver två av dom största och bästa wiki hemsidorna på nätet [http://hackernet.se Hackernet] och [https://www.wikipedia.org/ Wikipedia].

== Förberedelser ==
För att kunna köra mediawiki krävs det att du har [[LAMP]].

=== Valfria program ===
Man kan installera dom i efterhand också om man kommer på att man behöver dom. 
{| class="wikitable"
|-
|php-apc||Alternative PHP Cache.
|-
|php5-intl|| Unicode normalization.
|-
|ImageMagick|| Image thumbnailing.
|-
|GD Library||Alternative to ImageMagick. Install libgd2-xpm libgd2-xpm-dev php5-gd.
|-
|phpmyadmin|| MySQL administration tool.
|-
|php5-cli||Ability to run PHP commands from the command line, which is useful for debugging and running maintenance scripts.
|}
Exempel:
  sudo apt-get install php-apc php5-intl imagemagick phpmyadmin vsftpd php5-cli

==Installation==
Tanka hem senaste eller LTS versionen från deras hemsida, packa upp filen och byt namn på foldern.
 wget https://releases.wikimedia.org/mediawiki/1.25/mediawiki-1.25.1.tar.gz | tar -xvf mediawiki-1.25.1.tar.gz -C /var/www/ | mv /var/www/mediawiki-1.25.1/ /var/www/mediawiki

Se till att användaren som kör din webbserver äger mappen &lt;code&gt;mediawiki&lt;/code&gt; så att du kan tex ladda upp filer.

Skapa sedan en databas som mediawiki kan ansluta till, surfa sedan in på &lt;nowiki&gt;http://&lt;ip&gt;/mediawiki&lt;/nowiki&gt; och följ wizarden.

När wizarden är klar ladda upp &lt;code&gt;LocalSettings.php&lt;/code&gt; till &lt;code&gt;mediawiki&lt;/code&gt; mappen.

==Konfiguration==
All konfiguration av mediawiki och plugins görs i &lt;code&gt;LocalSettings.php&lt;/code&gt; filen.

===Plugins===
[https://www.mediawiki.org/wiki/Category:Extensions Plugins] finns på mediawikis hemsida.

Några bra plugins som denna sidan använder är.
{| class="wikitable"
|-
|[https://www.mediawiki.org/wiki/Extension:VisualEditor Visual Editor]||Bra editor om man är nybörjare och inte förstår mediawikis syntax.
|-
|[https://www.mediawiki.org/wiki/Extension:Google_Analytics_Integration Google Analytics]||Enkelt att få Google analytics att fungera.
|-
|[https://www.mediawiki.org/wiki/Extension:LDAP_Authentication LDAP Authentication]||För att kunna koppla sin wiki mot en LDAP server som OpenLDAP eller Active Directory.
|-
|[https://www.mediawiki.org/wiki/Extension:WikiEditor Wiki Editor]||För att få en lite bättre source editor.
|-
|[https://www.mediawiki.org/wiki/Extension:SyntaxHighlight_GeSHi SyntaxHighlight]||För att kunna få tex php,html,python kod på en sida mer lättläst.
|-
|[https://www.mediawiki.org/wiki/Extension:MsUpload MsUpload]||Enkelt kunna ladda upp filer när man editerar.
|-
|[https://www.mediawiki.org/wiki/Extension:Intersection Dynamic Page List]||För att kunna skapa dynamiska listor från tex kategorier eller namespaces. Tools på [[Linux#Tools|Linux sidan]] använder detta plugin.
|-
|[https://www.mediawiki.org/wiki/Extension:Contribution_Scores Contribution Scores]||För att få fram en tabel om vem som bidragit med mest på wikin.
|}

==Backup==
Vi använder ett script som gör en dump på databasen och packar ihop dumpen med alla filer i mediawiki mappen. Backup filen sparas i samma mapp som scriptet körs i.

&lt;div class="panel-group" id="accordion"&gt;
 &lt;accordion parent="accordion" heading="Ändra under configuration så det passar dig."&gt;
&lt;syntaxhighlight lang=bash&gt;#!/bin/bash
#
# fullsitebackup.sh V1.2
#
# Full backup of website files and database content.
#
# A number of variables defining file location and database connection
# information must be set before this script will run.
# Files are tar'ed from the root directory of the website. All files are
# saved. The MySQL database tables are dumped without a database name and
# and with the option to drop and recreate the tables.
#
# ----------------------
# 05-Jul-2007 - Quick adaptation for MediaWiki (currently testing)
# ----------------------
# March 2007 Updates - Version for Drupal
# - Updated script to resolve minor path bug
# - Added mysql password variable (caution - this script file is now a security risk - protect it)
# - Generates temp log file
# - Updated backup and restore scripts have been tested on Ubunutu Edgy server w/Drupal 5.1
#
# - Enjoy! BristolGuy
#-----------------------
#
## Parameters:
# tar_file_name (optional)
#
#
# Configuration
#

# Database connection information
dbname="wiki" # (e.g.: dbname=wikidb)
dbhost="localhost"
dbuser="wikidb" # (e.g.: dbuser=wikiuser)
dbpw="secretpassword" # (e.g.: dbuser password)

# Website Files
webrootdir="/var/www/wiki" # (e.g.: webrootdir=/home/user/public_html)

#
# Variables
#

# Default TAR Output File Base Name
tarnamebase=wiki_sitebackup-
datestamp=`date +'%m-%d-%Y'`

# Execution directory (script start point)
startdir=`pwd`
logfile=$startdir"/fullsite.log" # file path and name of log file to use

# Temporary Directory
tempdir=$datestamp

#
# Input Parameter Check
#

if test "$1" = ""
then
tarname=$tarnamebase$datestamp.tgz
else
tarname=$1
fi

#
# Begin logging
#
echo "Beginning mediawiki site backup using fullsitebackup.sh ..." &gt; $logfile
#
# Create temporary working directory
#
echo " Creating temp working dir ..." &gt;&gt; $logfile
mkdir $tempdir

#
# TAR website files
#
echo " TARing website files into $webrootdir ..." &gt;&gt; $logfile
cd $webrootdir
tar cf $startdir/$tempdir/filecontent.tar .

#
# sqldump database information
#
echo " Dumping mediawiki database, using ..." &gt;&gt; $logfile
echo " user:$dbuser; database:$dbname host:$dbhost " &gt;&gt; $logfile
cd $startdir/$tempdir
mysqldump --user=$dbuser --password=$dbpw --add-drop-table $dbname &gt; dbcontent.sql

#
# Create final backup file
#
echo " Creating final compressed (tgz) TAR file: $tarname ..." &gt;&gt; $logfile
tar czf $startdir/$tarname filecontent.tar dbcontent.sql

#
# Cleanup
#
echo " Removing temp dir $tempdir ..." &gt;&gt; $logfile
cd $startdir
rm -r $tempdir

#
# Exit banner
#
endtime=`date`
echo "Backup completed $endtime, TAR file at $tarname. " &gt;&gt; $logfile
&lt;/syntaxhighlight&gt;
&lt;/accordion&gt;

===Cronjob===
Scriptet funkar att köra som ett cronjob. Raden gör att det körs en backup kl 05:00 varje dag.

 0 05 * * * cd /path/to/script &amp;&amp; sh Backup_script.sh

== Sitemap ==
Mediawiki har ett inbyggt script för att skapa sitemaps. Sitemaps används av sökmotorer så att deras botar vet vilka URLs det finns att indexera.

Scriptet finns under &lt;code&gt;maintenance&lt;/code&gt; och heter &lt;code&gt;generateSitemap.php&lt;/code&gt;.

Skapa en mapp att spara sitemapen i.
 mkdir /var/www/mediawiki/sitemap

Kör kommandot,
 php generateSitemap.php --fspath /var/www/mediawiki/sitemap --server "http://URLtillStartsidan" --urlpath "http://URLtill/sitemap"

Nu ska du säga till sökmotorn vart din sitemap finns så är det klart.

=== Cronjob ===
Kör generateSitemap.php som ett cronjob var 45e minut.
 */45 * * * * /usr/bin/php /var/www/wiki/maintenance/generateSitemap.php --fspath /var/www/mediawiki/sitemap --server "http://URLtillStartsidan" --urlpath "http://URLtill/sitemap"

== Upgrade ==
Mediawiki använder semantic versioning där man namnger releases X.Y.Z (Major.Minor.Patch). I skrivande stund så är Mediawiki uppe i major 1, minor 26, patch 0.

Alla versioner av Mediawiki finns att ladda hem [https://releases.wikimedia.org/mediawiki/ här!]
===Minor===
Oftast är '''LocalSettings.php''' kompatibel mellan minor versioner, läs release notes för att få reda på mer.

Ersätt dom gammla filerna med dom nya filerna. Via skalet kör sedan maintenance script för att uppdatera databas tabeller och bygg om filstrukturen för bla filer:
 php /var/www/mediawiki/maintenance/update.php
 php /var/www/mediawiki/maintenance/rebuildall.php

Gå in på din wiki sida och kolla ''Special:Version'' för att verifiera att uppgraderingen.
===Patch===
#Gå till din mediawiki mapp (den med localsettings.php i).
#Ladda ner och packa om patch filen.
#Kör '''patch -p1 --dry-run -i ''mediawiki stable release number.patch'''''
#Gick allt igenom utan problem kör samma kommando igen fast utan '''--dry-run'''.
#Surfa sedan in på din wiki sida och kolla ''Special:Version'' för att verifiera att patchen gått igenom.</text>
      <sha1>7vqnus5gz0vatnd4d97hw0121shiu9l</sha1>
    </revision>
  </page>
  <page>
    <title>Mininet</title>
    <ns>0</ns>
    <id>73</id>
    <revision>
      <id>1638</id>
      <parentid>1278</parentid>
      <timestamp>2016-04-13T17:55:19Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1760">An Instant Virtual Network on your computer. 

Intro: https://www.youtube.com/watch?v=jmlgXaocwiE

Projektets hemsida: http://mininet.org/

==Installation==
 wget https://raw.github.com/mininet/mininet/master/util/vm/install-mininet-vm.sh
 bash -v install-mininet-vm.sh master
 ~/mininet/bin/mn --version
 cd ~/mininet; git fetch --all; git checkout master; git pull --rebase origin master
 sudo -n make install
 sudo -n mn --test pingall
 sudo sed -i -e 's/^GRUB_TERMINAL=serial/#GRUB_TERMINAL=serial/' /etc/default/grub; sudo update-grub
 reboot

===OVF===
Ladda ned ovf:n och importera till ditt vmware-system. HWversion ligger på 11 så det kanske du måste sänka i vmx-filen för att kunna starta vm:n.&lt;br/&gt;
Credentials: mininet - mininet

==Basic==
http://mininet.org/walkthrough/

Kör igenom kommandona för att komma igång.
 sudo mn

==Setups==
http://sdnhub.org/resources/useful-mininet-setups/

==Controller==
Det blir lite roligare om man har en controller till sitt virtuella nätverk så man kan peka och klicka lite.
 sudo mn --controller=remote,ip=&lt;IP-to-controller&gt;,port=6633 --switch ovsk,protocols=OpenFlow13 --topo=tree,3
http://mininet.org/blog/2013/06/03/automating-controller-startup/

===OpenDaylight===
Se [[OpenDaylight]]

===Floodlight===
'''Installation'''
 sudo apt-get update &amp;&amp; sudo apt-get -y install build-essential default-jdk ant python-dev eclipse screen
 git clone git://github.com/floodlight/floodlight.git
 cd floodlight &amp;&amp; git checkout fl-last-passed-build
 ant;
 sudo mkdir /var/lib/floodlight &amp;&amp; sudo chmod 777 /var/lib/floodlight
 screen
 java -jar target/floodlight.jar
'''http://IP:8080/ui/index.html'''
 sudo mn --controller=remote,ip=127.0.0.1,port=6633 --switch ovsk,protocols=OpenFlow13

[[Category:Network]]</text>
      <sha1>nfds34vkgtdv4qvb7lx2llqrcfzmip1</sha1>
    </revision>
  </page>
  <page>
    <title>ModSecurity</title>
    <ns>0</ns>
    <id>130</id>
    <revision>
      <id>882</id>
      <timestamp>2015-08-04T09:22:14Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Open Source Web Application Firewall. Funkar med Apache, Nginx and IIS. Det följer med ett Core Rule Set (CRS) som har regler för bland annat SQL injection, cross site scrip..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1466">Open Source Web Application Firewall. Funkar med Apache, Nginx and IIS. Det följer med ett Core Rule Set (CRS) som har regler för bland annat SQL injection, cross site scripting, trojaner och session hijacking. För apache finns det modul.

==Installation==
 sudo apt-get -y install libapache2-mod-security2
 sudo apachectl -M | grep --color security2

==Konfiguration==
Det följer med ett gäng rekommenderade inställningar som man kan använda sig av.
 sudo mv /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf
 sudo service apache2 reload
Default så är ModSecurity inställt på Detection Only. För att slå på ModSecurity:
 sudo sed -i "s/SecRuleEngine DetectionOnly/SecRuleEngine On/" /etc/modsecurity/modsecurity.conf
Data leakage detection genererar ganska mycket loggar och det kan man slå av med:
 sudo sed -i "s/SecResponseBodyAccess On/SecResponseBodyAccess Off/" /etc/modsecurity/modsecurity.conf

===CRS===
För att använda sig av Core Rule Set.
 sudo nano /etc/apache2/mods-enabled/security2.conf
 ...
        IncludeOptional /etc/modsecurity/*.conf
        IncludeOptional "/usr/share/modsecurity-crs/*.conf"
        IncludeOptional "/usr/share/modsecurity-crs/activated_rules/*.conf"
 &lt;/IfModule&gt;

===Exkludering===
Vill man exkludera enskilda hemsidor kan man lägga in följande i &lt;VirtualHost&gt;-blocket i sin konfiguration.
 &lt;IfModule security2_module&gt;
    SecRuleEngine Off
 &lt;/IfModule&gt;

[[Category:Guider]]</text>
      <sha1>aeirldytb5fnk7q2gb7iu6z4swvogb9</sha1>
    </revision>
  </page>
  <page>
    <title>Multiarch</title>
    <ns>0</ns>
    <id>8</id>
    <revision>
      <id>846</id>
      <parentid>18</parentid>
      <timestamp>2015-07-24T13:23:23Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="883">Multipla architekturer kan vara bra att använda om du finner att ett program eller library du behöver inte finns i t.ex. 32 bitars men du vill köra 64 bitars på servern 

"dpkg --print-foreign-architectures" Listar arktikturer som du kan lägga till
"dpkg --add-architecture i386" lägger till i386 som en extra kategori 
Sen är det bara att göra apt-get update som vanligt så ska du kunna installera libs och program för den andra arkitekturen.

I vanliga fall kommer då det du vill installera installeras i din standard arktiektur om du istället vill tvinga det till en speciel arkitektur så kör du istället t.ex. "apt-get install apache2:i386"

Du kan ta bort multiarchs med "dpkg --remove-architecture i386"

Ett vanligt fel meddelande som kommer upp när man försöker köra en fil men inte har rätt arkitektur är "No such file or directory"

[[Category:Guider]]</text>
      <sha1>1rvctzdmj9eyi5vvbj3ociug1fxlsjj</sha1>
    </revision>
  </page>
  <page>
    <title>MySQL</title>
    <ns>0</ns>
    <id>159</id>
    <revision>
      <id>1060</id>
      <parentid>1017</parentid>
      <timestamp>2015-09-24T11:38:36Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1166">MySQL är en relational database management system(RDBMS). MySQL var den näst största RDBMS databasen och den den mest använda open-source RDBMS databasen förr. MySQL är en av programmen du får när du installerar [[LAMP]].

==Installation==
 apt-get install mysql-server

==Konfiguration==
Konfiguration av MySQL görs i &lt;code&gt;/etc/mysql/my.cnf&lt;/code&gt;.

By default så lyssnar MySQL enbart på 127.0.0.1, för att fixa det kan man ändra i my.cnf till,
 bind-address = 0.0.0.0
Då kommer MySQL lyssna på alla interface.

==Skapa en databas==
Logga in som root.
 mysql -u root -p

Skapa en databas.
 create database &lt;namn&gt;;

Skapa en användare.
 grant usage on *.* to &lt;dbuser&gt;@localhost identified by '&lt;password&gt;';

Ge en användare alla rättigheter på en databas.
 grant all privileges on &lt;databas&gt;.* to &lt;dbuser&gt;@localhost;

==Backup/Dumpa databas==
Dumpa en databas till en fil för att göra en backup på den.
 mysqldump --user=[username] --password=[password] [databas] &gt; dbcontent.sql

==Importera en databas==
För att importera en databas dump.
 mysql -u [username] -p[password] [databas] &lt; dumpfilename.sql

[[Category:Guider]] [[Category:Sparco]]</text>
      <sha1>7v31tfmvcw4oduwatemoy9fsid5luqu</sha1>
    </revision>
  </page>
  <page>
    <title>NFS</title>
    <ns>0</ns>
    <id>44</id>
    <revision>
      <id>833</id>
      <parentid>488</parentid>
      <timestamp>2015-07-23T21:26:45Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2923">[[Category:Guider]]
Network File System (NFS) är ett filsystem som tillåter datorer att komma åt filer över ett nätverk på ungefär samma sätt som de kan komma åt filer på lokal lagring. Detta är användbart för att dela filer mellan flera servrar. Här följer generella inställningar för server och klient, de fungerar i de flesta fall.

==Installation==
===Server===
 sudo apt-get update &amp;&amp; sudo apt-get -y install nfs-kernel-server

===Klient===
 sudo apt-get update &amp;&amp; sudo apt-get -y install nfs-common

==Konfiguration==
===Server===
 sudo mkdir /nfsroot
 sudo sh -c 'echo "/nfsroot 192.168.1.16/30(rw,root_squash,subtree_check)" &gt;&gt; /etc/exports'
 sudo exportfs -a
 sudo service nfs-kernel-server start

===Klient===
 sudo mkdir /nfsroot
 sudo sh -c 'echo "192.168.1.50:/nfsroot /nfsroot nfs rw,async,hard,intr 0 0" &gt;&gt; /etc/fstab'
 sudo mount /nfsroot

==Options==
Ibland kan man behöva ändra egenskaperna för NFS-share:n. T.ex. om man har problem med att program sätter lock på filer. Här tas de vanligaste alternativen upp som är bra att känna till. Det mesta görs på klientsidan.

'''Klient'''&lt;br/&gt;
'''rw''': Read/write filesystem.&lt;br/&gt;
'''ro''': Read-only filesystem. Remote NFS clients can’t modify the filesystem.&lt;br/&gt;
'''hard''': Applications using files stored on an NFS will always wait if the server goes down. User cannot terminate the process unless the option intr is set.&lt;br/&gt;
'''soft''': Applications using files stored on an NFS will wait a specified time (using the timeo option) if the server goes down, and after that, will throw an error.&lt;br/&gt;
'''intr''': Allows user interruption of processes waiting on a NFS request.&lt;br/&gt;
'''timeo=&lt;num&gt;''': For use with the soft option. Specify the timeout for an NFS request.&lt;br/&gt;
'''nolock''': Disable file locks. Useful with older NFS servers.&lt;br/&gt;
'''noexec''': Disable execution of binaries or scripts on an NFS share.&lt;br/&gt;
'''nosuid''': Prevents users from gaining ownership of files on the NFS share.&lt;br/&gt;
'''rsize=&lt;num&gt;''': Sets the read block data size. Defaults to 8192 on NFSv2 and NFSv3, and 32768 on NFSv4.&lt;br/&gt;
'''wsize=&lt;num&gt;''': Sets the write block data size. Defaults to 8192 on NFSv2 and NFSv3, and 32768 on NFSv4.&lt;br/&gt;

'''Server'''&lt;br/&gt;
'''rw''': Read/write filesystem.&lt;br/&gt;
'''ro''': Force clients to connect in the read-only filesystem mode only.&lt;br/&gt;
'''no_root_squash''': The root account on the client machine will have the same privilege level as the root on the server machine. This option has security implications; do not use unless you are sure you need it.&lt;br/&gt;
'''no_subtree_check''': Disable file location checks on partial volume exports. This option will speed up transfers on full volume exports.&lt;br/&gt;
'''sync''': Force all transfers to operate in synchronous mode, so all clients will wait until their operations are really done. This can avoid data corruption in the event of a server crash.&lt;br/&gt;</text>
      <sha1>jwo9344f8vo81ygrcp57jcm5mv5g6tv</sha1>
    </revision>
  </page>
  <page>
    <title>NIPAP</title>
    <ns>0</ns>
    <id>151</id>
    <revision>
      <id>1212</id>
      <parentid>1197</parentid>
      <timestamp>2015-11-05T17:25:14Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>Debug</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2737">NIPAP är ett IPAM-system som är skrivet i python och är open source. Det finns både webgui och cli för att managera datan som sparas i en postgres-DB.&lt;br/&gt;
Demo: http://nipap-demo.spritelink.net/

=Installation=
''Debian eller Ubuntu''
 echo "deb http://spritelink.github.io/NIPAP/repos/apt stable main extra" &gt; /etc/apt/sources.list.d/nipap.list
 wget -O - https://spritelink.github.io/NIPAP/nipap.gpg.key | apt-key add -
 apt-get update &amp;&amp; apt-get -y install nipapd
Svara Yes på frågorna för att autoskapa databas
 apt-get -y install nipap-www
Återigen yes för att skapa ett användarkonto för frontend till backend

=Konfiguration=
I denna guide görs allt på samma maskin men frontend accessas från andra maskiner. Det behövs ett konto för att logga in på webguit.
 nipap-passwd add --user user1 --password mypasswort --name "the man"

===[[Apache]]===
 apt-get -y install apache2 &amp;&amp; apt-get -y install libapache2-mod-wsgi
 nano /etc/apache2/sites-available/000-default.conf
 &lt;VirtualHost *:80&gt;
        DocumentRoot /var/www/html
        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined
 
        WSGIScriptAlias / /etc/nipap/nipap-www.wsgi
        &lt;Directory "/etc/nipap"&gt;
        Order allow,deny
        Allow from all
        &lt;Files nipap-www.wsgi&gt;
        Require all granted
        &lt;/Files&gt;
        &lt;/Directory&gt;
 &lt;/VirtualHost&gt;

 chown -R www-data:www-data /var/cache/nipap-www &amp;&amp; chmod -R u=rwX /var/cache/nipap-www
 sudo service apache2 restart

===LDAP===
Börja med att installera python-ldap modul.
 apt-get install python-ldap

Ändra sedan i &lt;code&gt;/etc/nipap/nipap.conf&lt;/code&gt; filen till följande.
 default_backend = ldap
 
 basedn = dc=hackernet,dc=se
 uri = ldap://IP
 binddn_fmt = uid={},ou=users,dc=hackernet,dc=se
 search = uid={}
 search_binddn = cn=admin,dc=hackernet,dc=se
 search_password = secretpw
 rw_group = cn=nipap,dc=hackernet,dc=se

Skapa sedan en grupp som heter nipap och som har stöd för [[OpenLDAP#memberOf|memberOf]]. Användare i denna gruppen får read/write rättigheter.

=CLI=
Med ett cli går det snabbare att fylla databasen om det handlar om stora datamängder.
 apt-get -y install nipap-cli
 nipap-passwd add --user cli-master-flash --password olasamigossenior --name "the CLI man"
 touch ~/.nipaprc &amp;&amp; chmod 0600 .nipaprc &amp;&amp; nano .nipaprc
 [global]
 hostname = localhost
 port     = 1337
 username = cli-master-flash
 password = olasamigossenior
 default_vrf_rt = none
 default_list_vrf_rt = all

 nipap address add prefix 192.0.2.0/24 type assignment description "MGM-network"
 nipap address add prefix 172.20.0.10 type host node "SW01" description "L3-switch"

=Debug=
 sudo nipapd -d -f --no-pid-file

[[Category:Guider]]</text>
      <sha1>mz93bvc26gigbx862b71o9ebumol2df</sha1>
    </revision>
  </page>
  <page>
    <title>NTP</title>
    <ns>0</ns>
    <id>61</id>
    <revision>
      <id>3158</id>
      <parentid>1369</parentid>
      <timestamp>2022-05-11T17:44:20Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="464">Ställ klockan rätt, slipp problem.

'''Ntpdate:''' engångssynkroniseringar (deprecated sedan 2012)&lt;br/&gt;
'''Ntpd:''' automatisk tidssynkronisering&lt;br/&gt;
'''SNTP:''' Simple NTP är inte lika pålitligt eller noggrannt som NTP&lt;br/&gt;
Ntpd &gt;= ntpdate + crontab

 yum/apt-get install ntp

Konfiguration
 nano /etc/ntp.conf
 server 10.0.0.10

Verifiera
 ntptrace
 ntpq -pn

===Time Zone===
 timedatectl
 sudo timedatectl set-timezone Europe/Stockholm

[[Category:Tools]]</text>
      <sha1>h1g1c1vqgqvvuwhwe5jzvls5cavo6cf</sha1>
    </revision>
  </page>
  <page>
    <title>Nameif</title>
    <ns>0</ns>
    <id>74</id>
    <revision>
      <id>556</id>
      <parentid>470</parentid>
      <timestamp>2015-06-15T19:36:09Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="617">När Linuxkärnan bootar tilldelas namn till nätverksinterfacen i den ordning som den finner dem. Detta innebär att två olika versioner av kärnan kan hitta interfacen i olika ordning. När detta händer kan du behöva byta all konf för att få igång det igen. Ett sätt att undvika detta är med udev-regler, ett annat är att namnge interfacen med nameif.
 sudo yum install net-tools

 sudo nano /etc/mactab
 # This file relates MAC addresses to interface names.
 eth0 00:60:97:52:2A:94
 eth1 00:A0:C9:43:1F:77
Ta ner interfacen och kör kommandot '''nameif''' alternativt reboota maskinen.

[[Category:Tools]]</text>
      <sha1>pjk0q9gy9m1hn9ldt66s7pi9tfuy8bk</sha1>
    </revision>
  </page>
  <page>
    <title>Netdisco</title>
    <ns>0</ns>
    <id>14</id>
    <revision>
      <id>1211</id>
      <parentid>826</parentid>
      <timestamp>2015-11-05T12:57:39Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>/* Konfiguration */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3621">[[Category:Guider]]
Netdisco hämtar MAC-tabeller, ARP-tabeller, VLAN-databaser, LLDP/CDP-grannskap, firmwareversioner, m.m från routrar och switchar med hjälp av SNMP. Man schemalägger när data ska samlas in, dvs det är inte realtidsövervakning.

Denna guide är minimalistiskt utformad, för kommandoförklaringar se referensguide alternativt google. Referens: 
 https://metacpan.org/pod/App::Netdisco

==Installation== 
''Ubuntu 14.04.1 LTS Server x64''&lt;br/&gt;
Denna guide är till stor del hämtad från: http://blog.asiantuntijakaveri.fi/2014/08/netdisco2-on-ubuntu-1404.html
 sudo su -
 apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; apt-get -y install open-vm-tools build-essential wget lftp mtr-tiny zip ntp fail2ban curl
 echo "net.ipv6.conf.all.disable_ipv6=1" &gt;&gt;/etc/sysctl.conf

===Databas===
 apt-get -y install libdbd-pg-perl libsnmp-perl postgresql pgtune 
 mv /etc/postgresql/9.3/main/postgresql.conf /etc/postgresql/9.3/main/postgresql.conf.old
 pgtune -i /etc/postgresql/9.3/main/postgresql.conf.old -o /etc/postgresql/9.3/main/postgresql.conf

Switch to postgres user and create new SQL user
 su - postgres
 createuser -DRSP netdisco
 (Enter some DB password here)
 createdb --owner netdisco netdisco

Switch back to root
 exit

===Netdisco===
 adduser netdisco --shell /bin/bash --disabled-password --gecos netdisco &amp;&amp; su - netdisco
 curl -L http://cpanmin.us/ | perl - --notest --local-lib ~/perl5 App::Netdisco

==Konfiguration==
 mkdir ~/bin &amp;&amp; mkdir ~/environments &amp;&amp; ln -s ~/perl5/bin/{localenv,netdisco-*} ~/bin/
 ~/bin/netdisco-daemon status

Här är grunden för deploymenten, lägg till de SNMP-communitys som ska användas. Schemaläggningen är i cron-format. I exemplet görs discoverall 10 över varje timme. &lt;br/&gt;
OBS Om detta görs i en virtuell maskin tas förslagsvis en snapshot här.
 cat &lt;&lt;'__EOF__'&gt;~/environments/deployment.yml
 database:
  name: 'netdisco'
  user: 'netdisco'
  pass: '(PW som sattes tidigare)'
 safe_password_store: true
 snmp_auth:
  - tag: 'default_1'
    community: 'puplic'
    read: true
    write: false
  - tag: 'default_2'
    community: 'public'
    read: true
    write: false
  - tag: 'v3example'
     user: netdisco
     auth:
       pass: netdiscokey
       proto: SHA
     priv:
       pass: netdiscokey2
       proto: AES
 schedule:
  discoverall:
     when: '10 * * * *'
  macwalk:
     when: '35 * * * *'
  arpwalk:
     when: '45 * * * *'
  nbtwalk:
     when: '55 * * * *'
  expire:
     when: '15 23 * * *'
 dns:
  max_outstanding: 50
 workers:
  tasks: 'AUTO * 5'
 __EOF__

 ~/bin/netdisco-deploy
Svara ja på allt och sätt credentials för web gui:t.

Skapa script för att starta Netdisco med listener port 5000
 cat &lt;&lt;'__EOF__'&gt;~/run-netdisco.sh
 #!/bin/bash
 ~/bin/netdisco-web start --port=5000
 sleep 5
 ~/bin/netdisco-daemon start
 __EOF__
 chmod a+x ~/run-netdisco.sh

 ~/run-netdisco.sh

Switch back to root
 exit
 echo "( sudo su - netdisco -c '/home/netdisco/run-netdisco.sh' ) &amp;" &gt;/etc/rc.local
 reboot

=== WEBGUI ===
Logga in på http://[IP]:5000 

Börja med att mata in IP-adress på en switch eller router som ska övervakas på förstasidan. Vänta och se hur mycket som upptäcks. Är allt rätt konfigurerat kommer väldigt mycket att upptäckas.

===Enheter som ska övervakas===
Logga in på diverse enhet som ska övervakas och lägg till community samt IP för Netdiscomaskinen.

===Underhåll===
upgrade Netdisco
 ~/bin/localenv cpanm --notest App::Netdisco

apply database schema updates
 ~/bin/netdisco-deploy

restart web service
 ~/bin/netdisco-web restart

restart job daemon
 ~/bin/netdisco-daemon restart</text>
      <sha1>1f5itcxtbkffevg3ymmg3q6mwsy5oa7</sha1>
    </revision>
  </page>
  <page>
    <title>Netmiko</title>
    <ns>0</ns>
    <id>235</id>
    <revision>
      <id>3038</id>
      <parentid>2958</parentid>
      <timestamp>2019-10-31T07:28:36Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2255">Netmiko är ett open-source [[Python]] library som används för att SSHa till nätverksenheter. Det är baserat på paramiko och har stöd för flera olika plattformar från olika tillverkare. Målet är att förenkla användandet av show och conf-kommandon mot nätverksutrustning från script.

Exempel på device types som stöds
* cisco_ios
* cisco_xe
* cisco_xr
* cisco_asa
* cisco_nxos
* juniper
* arista_eos
* hp_procurve

=Installation=
 sudo pip install netmiko

=Getting started=
[[Python]]
 from netmiko import ConnectHandler
Connect
 R1 = {'device_type': 'cisco_xe', 'ip': '10.0.0.10', 'username': 'cisco', 'password': 'cisco', 'secret': 'cisco'}  
 net_connect = ConnectHandler(**R1)
Byt mellan olika prompts
 net_connect.find_prompt()
 net_connect.enable()
 net_connect.find_prompt()
 net_connect.config_mode()
 net_connect.find_prompt()
 net_connect.disconnect()

'''Skicka kommandon''' &lt;br/&gt;
Send command down the SSH channel, return output back
 net_connect.send_command(arguments)
Send a set of configuration commands to remote device
 net_connect.send_config_set(arguments)
Send a set of configuration commands loaded from a file
 net_connect.send_config_from_file(arguments)

Exempel
 IPintbrief = net_connect.send_command("show ip int brief")
 print IPintbrief

'''SSHDetect'''&lt;br/&gt;
Netmiko kan även gissa vad det är för device type. 
 from netmiko.ssh_autodetect import SSHDetect
 remote_device = {'device_type': 'autodetect','host': '10.0.0.10','username': 'cisco','password': 'cisco'}
 guesser = SSHDetect(**remote_device)
 best_match = guesser.autodetect()
 print(best_match)

===Skapa VLAN===
 from netmiko import ConnectHandler
 import getpass
 
 SW1 = {'device_type': 'cisco_ios', 'ip': '10.0.0.11', 'username': 'cisco', 'password': 'cisco', 'secret': 'cisco'}
 SW2 = {'device_type': 'cisco_ios', 'ip': '10.0.0.12', 'username': 'cisco'}
 
 pw = getpass.getpass("Enter password:")
 SW02['password'] = pw
 
 all_devices = [SW1, SW2]
 
 config_commands = [ 'vlan 100', 'name NewVLAN', 'exit' ]
 
 for a_device in all_devices:
     net_connect = ConnectHandler(**a_device)
     net_connect.enable()
     output = net_connect.send_config_set(config_commands)
     print output
     net_connect.disconnect()

[[Category:Network]]</text>
      <sha1>mvzvnxwarryci65yratpt866g6suyh6</sha1>
    </revision>
  </page>
  <page>
    <title>Netsim-tools</title>
    <ns>0</ns>
    <id>563</id>
    <revision>
      <id>3145</id>
      <timestamp>2022-01-23T15:51:44Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Orkestrator för Vagrant-Libvirt, Vagrant-Virtualbox och Containerlab.  ==Installation Ubuntu==  &lt;syntaxhighlight lang="Bash"&gt; sudo apt update &amp;&amp; sudo apt install -y python3-p..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="806">Orkestrator för Vagrant-Libvirt, Vagrant-Virtualbox och Containerlab.

==Installation Ubuntu==

&lt;syntaxhighlight lang="Bash"&gt;
sudo apt update &amp;&amp; sudo apt install -y python3-pip
sudo python3 -m pip install netsim-tools
netlab install ubuntu ansible libvirt
&lt;/syntaxhighlight&gt;

== Nexus 9300v ==
Download box file, example: nexus9300v.9.3.8.box
&lt;syntaxhighlight lang="Bash"&gt;
sudo vagrant plugin install vagrant-mutate
sudo vagrant box add nexus9300v.9.3.8.box --name cisco/nexus9300v
sudo vagrant mutate cisco/nexus9300v libvirt
sudo vagrant box remove cisco/nexus9300v --provider virtualbox
&lt;/syntaxhighlight&gt;

Topology file
 ---
 defaults:
   device: nxos
 
 nodes: [ sw1, sw2 ]
 links: [ sw1-sw2 ]

Setup lab and start devices
 sudo netlab create
 sudo netlab up
 netlab connect sw1

[[Category:Network]]</text>
      <sha1>sh1a20il335x1ge060zskbl9oxr7xyr</sha1>
    </revision>
  </page>
  <page>
    <title>Network</title>
    <ns>0</ns>
    <id>194</id>
    <revision>
      <id>2797</id>
      <parentid>2758</parentid>
      <timestamp>2018-07-24T17:03:49Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="845">Här finns alla våra nätverks specifika artiklar som vi skrivit.
===Arista===
&lt;DynamicPageList&gt;
category = Arista
ordermethod = sortkey
order = ascending
&lt;/DynamicPageList&gt;
===Cisco===
&lt;DynamicPageList&gt;
category = Cisco
ordermethod = sortkey
order = ascending
&lt;/DynamicPageList&gt;
===Cumulus Networks===
&lt;DynamicPageList&gt;
category = Cumulus
ordermethod = sortkey
order = ascending
&lt;/DynamicPageList&gt;
===Extreme Networks===
&lt;DynamicPageList&gt;
category = Extreme
ordermethod = sortkey
order = ascending
&lt;/DynamicPageList&gt;
===F5===
&lt;DynamicPageList&gt;
category = F5
ordermethod = sortkey
order = ascending
&lt;/DynamicPageList&gt;
===Juniper===
&lt;DynamicPageList&gt;
category = Juniper
ordermethod = sortkey
order = ascending
&lt;/DynamicPageList&gt;
===Linux &amp; Others===
&lt;DynamicPageList&gt;
category = Network
ordermethod = sortkey
order = ascending
&lt;/DynamicPageList&gt;</text>
      <sha1>ntid9eoutv5tzv0zkepz6ylr0e3pbrp</sha1>
    </revision>
  </page>
  <page>
    <title>Nexus 1000V</title>
    <ns>0</ns>
    <id>213</id>
    <revision>
      <id>2867</id>
      <parentid>1666</parentid>
      <timestamp>2018-10-01T07:12:22Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3613">Nexus 1000V är en distribuerad virtuell switch som sträcker sig över många hypervisor-hostar. Varje server i datacentret representeras som ett linjekort i Nexusen och kan hanteras som om det vore ett linjekort i en fysisk Cisco switch. N1Kv har bl.a. stöd för [[Cisco_NetFlow|NetFlow]], [[Cisco_IGMP#IGMP_Snooping|IGMP Snooping]], [[Cisco_SPAN|SPAN]], [[Cisco_VXLAN|VXLAN]], [[Cisco_VLAN#Private_VLAN|Private VLAN]], [[Cisco_DHCP#Snooping|DHCP Snooping]], [[Cisco_L2_Security#DAI|DAI]] och [[Cisco_L3_Security#IPSG|IPSG]]. Nexus 1000V kan köras tillsammans med [[VMware_ESXi|vSphere]], Hyper-V eller [[KVM]].

'''Virtual Ethernet Module''' (VEM) är ett virtuellt linjekort och körs som en del av ESXi-kärnan (VEM agent) och ersätter vSwitcharna. 

'''Virtual Supervisor Module''' (VSM) är control plane och styr alla VEMs. I stället för fysiska SUPar körs VSM som vms på ESXi-hostarna. Konfigurationen görs i VSM och slår på alla VEMs. 

''Du behöver vSphere Enterprise Plus licensiering för att kunna använda Nexus 1000V.''

=Installation=
'''Dokumentation'''
 http://www.cisco.com/c/en/us/support/switches/nexus-1000v-switch-vmware-vsphere/products-installation-guides-list.html

==VSM==
VSM installeras som en vm.

===Registrera Nexus i vCenter===
 http://VSM-IP
Ladda ner cisco_nexus1000v_extension.xml&lt;br/&gt;
vCenter&lt;br/&gt;
Manage Plug-ins -&gt; New Plug-in -&gt; xml file -&gt; Register Plug-in

===SVS Connection===
Kan göras i L2 eller L3 mode.
 svs connection vCenterName 
  protocol vmware-vim
  remote ip address &lt;vCenter-IP&gt;
  vmware dvs datacenter-name &lt;name&gt;
  max-ports 8192
  connect
Verify
 show svs connections
 show module

==VEM==
Linjekort, ett per esxi-host. Default sätts ID dynamiskt men man kan binda det till uuid. 
 vem 3
   host vmware id 8f862310-4c63-11e2-0000-00000000000f
 vem 4
   host vmware id 8f862310-4c63-11e2-0000-00000000001f
Show
 show module

=Port Profile=
Fysiska NICs konfas med "type ethernet".
 port-profile type ethernet vMotion-Uplink
  vmware port-group
  switchport mode trunk
  switchport trunk allowed vlan 99
  no shutdown
  state enabled
 
 port-profile type ethernet VM-Guests-Uplink
  vmware port-group
  switchport mode trunk
  switchport trunk allowed vlan 100,110,111,112,120,121
  no shutdown
  system vlan 100,120,121
  state enabled
System VLAN är speciella vlan som får kommunicera innan VEM:en har lagts i vDS. Det betyder att forwarding på VEM kan göras innan VSM har programmerat forwarding tables.

Management network.
 port-profile type vethernet VMKernel
  capability l3control
  vmware port-group
  switchport mode access
  switchport access vlan 100
  no shutdown
  system vlan 100
  state enabled

Port profiles "type vethernet" är motsvarigheten till port groups i VMware och för varje port profile i Nexus 1000v skapas en portgrupp i VMware.
 port-profile type vethernet vMotion
  vmware port-group
  switchport mode access
  switchport access vlan 116
  no shutdown
  state enabled
 
 port-profile type vethernet VM-110
  vmware port-group
  switchport mode access
  switchport access vlan 110
  no shutdown
  state enabled
 
 port-profile type vethernet VM-111
  vmware port-group
  switchport mode access
  switchport access vlan 111
  no shutdown
  state enabled
 
 port-profile type vethernet N1Kv-Control
  vmware port-group
  switchport mode access
  switchport access vlan 120
  no shutdown
  system vlan 120
  state enabled
 
 port-profile type vethernet N1Kv-Management
  vmware port-group
  switchport mode access
  switchport access vlan 121
  no shutdown
  system vlan 121
  state enabled

[[Category:Cisco]]</text>
      <sha1>mnysq17yjbplg2cdjxwjuwmr8ucmcaf</sha1>
    </revision>
  </page>
  <page>
    <title>Nexus FabricPath</title>
    <ns>0</ns>
    <id>171</id>
    <revision>
      <id>2893</id>
      <parentid>2816</parentid>
      <timestamp>2018-11-15T07:31:06Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4657">FabricPath är en Ethernet fabric-teknologi framtagen av Cisco för Nexus-plattformen. Det är designat för att ge hög  skalbarhet och flexibilitet inom ett datacenter genom att kombinera funktioner från både lager 2 och lager 3. Det är MAC-in-MAC overlay som ersätter [[Cisco_STP|Spanning-tree protocol]] med fördelen att inte behöva några blockerade länkar i ett switchat core (L2MP). FabricPath-enheterna nyttjar protokollet Intermediate System to Intermediate System ([[Cisco_IS-IS|IS-IS]]) för att utbyta information om hur miljön ser ut (vilka switch ID som finns var) och bygger ett SPT (Shortest Path Tree) baserat på den informationen. Ingen STP körs inom FabricPath-nätverket men alla FabricPath Layer 2 gateway devices ska ha samma låga prio för att FP ska vara STP-root och utifrån sett är alla FP-enheter en enda stor STP-switch. 

För data plane så enkapsuleras ethernet frames med en FabricPath-header med outside source address och outside destination address vilket sedan kan routas. FP använder conversational learning och BUM skickas i ett MDT som automatiskt byggs av alla enheter, så alla får denna trafik och det är loopfritt. För att veta hur multidestinationstrafik ska forwarderas används FTAG-fältet i FP-headern. Eftersom det används multipla FTAG:s som hashas emellan ger detta lastdelning. För att synka FTAG:ar används en extension till FabricPath IS-IS som heter DRAP (Dynamic Resource Allocation Protocol). DRAP används också för att assigna unika switch ID:n inom FP-domänen men detta går även att konfa manuellt.

När man ska spegla portar ([[Cisco_SPAN|SPAN]]) kan man välja om man ska strippa fabricpath-headern eller inte. [[Cisco_BFD|BFD]] kan man använda om man kör fabricpath som DCI-lösning för att snabba upp konvergens. När man kör vPC i kombination med FabricPath skapas en logisk switch genom att samma FP switch-id annonseras ut från båda noderna i vPC-domänen, detta kallas vPC+. Se även [[Nexus_vPC|Nexus vPC]].

Wireshark kan inte avkoda FabricPath-frames.
[[File:Cisco_FabricPath.PNG]]

'''MAC Learning''' &lt;br/&gt;
* Traditional = Learn SRC MAC of all received traffic
* FabricPath = Only learn SRC MAC if you already know DST MAC
 show mac address-table learning mode

==Konfiguration==
Aktivera FabricPath
 install feature-set fabricpath
 feature-set fabricpath

Skapa nyckel för autentisering
 key chain FABRICPATH
  key 0
   key-string topsecret123

Global konfiguration med autentisering och fast convergence
 fabricpath switch-id 1
 fabricpath timers linkup-delay 60
 
 fabricpath domain default
  spf-interval 50 50 50
  lsp-gen-interval 50 50 50
  authentication-type md5   #LSP authentication
  authentication key-chain FABRICPATH
  authentication-check
  log-adjacency-changes 

Konfigurera interface för FabricPath
 interface Ethernet1/25
  switchport
  switchport mode fabricpath
  no fabricpath isis hello-padding
  fabricpath isis authentication-type md5   #hello authentication
  fabricpath isis authentication key-chain FABRICPATH
 
 show fabricpath isis interface br

VLAN
 vlan 10
  mode fabricpath
  name Server
 vlan 20
  mode fabricpath
  name DB
 exit

Show
 show fabricpath switch-id
 show fabricpath topology
 show fabricpath conflict all
 show fabricpath route
 show fabricpath isis

Effektivisera LSP-hanteringen genom att byta IS-IS network type från broadcast till p2p.
 interface e1/1
  medium p2p

'''Traffic Engineering''' &lt;br/&gt;
FabricPath gör ECMP default men man kan styra vilka länkar som används genom att manipulera IGP-metricen. Detta görs per interface.
 interface e1/1
  fabricpath isis metric 400

'''BFD''' &lt;br/&gt;
Man kan slå på [[Cisco_BFD#NX-OS|BFD]] på alla FP-interface men notera att VLAN 1 måste vara i fabricpath mode. BFD-klienten blir fabricpath-isis. Echo mode inte är supporterat. 
 fabricpath domain default
  bfd
 
 show bfd neighbors fabricpath 

===Anycast HSRP===
De aktiva HSRP-routrarna annonserar anycast switch ID som source switch ID för HSRP MAC i FabricPath IS-IS. Alla andra kan då lastdela genom att skicka till vilken HSRP-router som helst i gruppen. Max antal aktiva HSRP-routrar är 4 st. Se även [[Cisco_HSRP|Cisco HSRP]].

 hsrp anycast 1 ipv4
  switch-id 111
  vlan 10,11,12
  priority 120
  no shutdown
Man måste köra HSRP version 2 på alla SVI:er som ska dra nytta av Anycast HSRP.
 show hsrp anycast

===Troubleshooting===
 ping fabricpath switch-id 101
Send OAM Path Trace Request message to the egress switch ID
 traceroute fabricpath switch-id 101

Operation, Administration, and Maintenance
 fabricpath-oam
 show fabricpath oam loopback database

[[Category:Cisco]]</text>
      <sha1>lu43uhln7s0npfwpzfb92zxc9iguw9a</sha1>
    </revision>
  </page>
  <page>
    <title>Nexus VDC</title>
    <ns>0</ns>
    <id>168</id>
    <revision>
      <id>2914</id>
      <parentid>2799</parentid>
      <timestamp>2019-01-10T08:13:42Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3930">Virtual Device Context kan användas för att virtualisera Nexusswitchar på Nexusswitchar. En fysisk switch blir flera logiska med egna fysiska portar och processer. Detta är en partitioneringsteknik och varje VDC manageras för sig. Eftersom varje VDC har egen data plane, control plane och mgmt plane innebär detta en viss grad av fault isolation däremot kan inte olika VDC:er köra olika versioner av NX-OS. Det fysiska mgmt0 interface delas dock men varje VDC får ha egen IP-adress. Varje VDC har även egna unika MAC-adresser, detta tas ifrån backplanet (show sprom backplane). Notera att [[Cisco_FCoE|FCoE]] kräver sin egna VDC. Se även [[Cisco_Nexus|Cisco Nexus]].

'''User rights''' &lt;br/&gt;
Default-VDC
* Network-Admin = VDC-Admin
* Network-Operator = VDC-Operator
Non-Default VDC
* VDC-Admin = all read/write for that particular VDC
* VDC-Operator = read only access to that particular VDC

==Konfiguration==
''Requires Advanced Services license''

Skapa Admin VDC, denna kontrollerar övriga VDC:er. Denna har t.ex. hand om VDC creation, resource allocation, NX-OS upgrade, [[Cisco_SPAN#Ethanalyzer|Ethanalyzer]], System wide [[Cisco_QoS|QoS]], Port Channel load balancing hash, [[Cisco_IOS#EEM|EEM]] applets. Inga line cards tillåtna.
 conf
 system admin-vdc

Skapa VDC
 vdc &lt;name&gt; id 2
  cpu-share 10
  allocate interface Ethernet1/1-8
  boot-order 1
  limit-resource vlan minimum 512 maximum 4094
 
 vdc VDC3 id 3
  cpu-share 10
  allocate interface Ethernet2/1-8
  boot-order 2
  limit-resource vlan minimum 512 maximum 4094
Notera att ändringar av en VDC är disruptive. Man kan inte heller allokera enskilda interface till en VDC utan man allokerar en (eller flera) interface-range. Vilka interface som kan ingå i en range avgörs av hardware port group (asic) dvs detta skiljer sig mellan olika plattformar och linjekort. Skriver man en ogiltig range så kommer dock NX-OS korrigera det automatiskt. Man kan alltså råka sno interface ifrån en annan VDC om man inte tänker sig för.

Hoppa mellan VDC:ers CLI.
 switchto vdc &lt;namn&gt;
 switchback

Alias
 cli alias name changeto switchto vdc

Default visas VDC hostname som &lt;admin-vdc&gt;-&lt;vdc-name&gt;, detta går att stänga av.
 no vdc combined-hostname 

===High Availability===
Man kan konfa vad som ska hända om en VDC kraschar. Man kan ha olika settings för single kontra dual supervisor. Det man kan välja på är RESTART vdc, BRINGDOWN vdc, RELOAD supervisor, SWITCHOVER to standby supervisor.
 ha-policy single-sup bringdown dual-sup switchover

===Verify===
 show vdc
 show vdc resource
 show vdc membership
 copy running-config startup-config vdc-all
Notera att det finns en VDC med ID 0, den används endast som en container för interface som inte får vara med i någon annan VDC.

Nexus är en switch men varje VLAN representeras internt av en bridge domain. Detta gör att flera VDC:er kan deploya VLAN med samma ID. 
 show vlan internal bd-info vlan-to-bd all-vlan

Har man för lite ström för att klara ett PSU-bortfall startas inte alla linjekort, ''show module'' säger "pwr-denied". Man kan ändra detta beteende för att stänga av redundans.
 power redundancy-mode combined

===Routing tables===
Man kan styra hur mycket minne en VDC minimum och maximum får till IPv4 och IPv6 unicast och multicast routes. 
 vdc VDC3
  limit-resource u4route-mem minimum 2 maximum 100
 
 show vdc resource u4route-mem detail
Man ska såklart monitorera hur mycket resurser sina VDC:er använder men man kan också kolla hur mycket minne som behövs för en viss mängd routes.
 show routing ip unicast memory estimate routes 100000 next-hops 2

===Storage VDC===
Man kan använda en Storage VDC för att köra Ethernet och FCoE i samma switch.
 license fcoe module 2
 
 system qos
  service-policy type network-qos default-nq-7e-4q8q-policy
 
 vdc SAN type storage
  allocate interface e2/1-8
  allocate fcoe-vlan-range 100-101

[[Category:Cisco]]</text>
      <sha1>12lqqkrgq0xtjhf4jsbai3pxmwjss4h</sha1>
    </revision>
  </page>
  <page>
    <title>Nexus vPC</title>
    <ns>0</ns>
    <id>172</id>
    <revision>
      <id>3127</id>
      <parentid>2917</parentid>
      <timestamp>2021-11-05T09:12:46Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10290">Virtual Port-Channel är Ciscos MLAG-variant för [[Cisco_Nexus|Nexus]]-switchar. Båda switchar i paret är aktiva för data plane men den ena noden står för control plane och tar därmed hand om BPDUer och LACPDUer. Det är inte delad management plane, som t.ex. [[Cisco_VSS|Cisco VSS]]. För att avgöra om noderna i paret har kompatibel konfiguration (consistency validation) skickas en kopia med Cisco Fabric Services över peer-länken. Alla mac-adresser och IGMP snooping som switcharna lär sig synkroniseras också mha CFS över peer-länken. Peer-länken är med i [[Cisco_STP|STP]] men BPDU-hanteringen är modifierad så peer link kommer aldrig att bli blocking/discarding. Icke-vPC portar kommer att hanteras av den lokala STP-processen på varje switch. Se även [[Cisco_EtherChannel|Cisco EtherChannel]].

Det går att köra dynamisk routing över vPC men generellt sett är det inte rekommenderat samt att det endast går på vissa releaser. Det konfigureras under vPC-domänen med ''layer3 peer-router''.

==Initial setup==
Aktivera vPC
 feature vpc
 feature lacp

vPC peers skickar varje sekund keepalives mellan varandra. Man kan t.ex. använda mgmt-portarna för keepalives, det är endast små UDP-paket som ska skickas och tas emot. &lt;br/&gt;
&lt;div class="mw-collapsible mw-collapsed" style="width:300px"&gt;
Keepalive message:
&lt;div class="mw-collapsible-content"&gt;
[[File:Nexus-vPC-Keepalive.PNG]]
&lt;/div&gt;
&lt;/div&gt;

Exempel: skapa en dedikerad vrf för keepalives och assigna interface.
 vrf context VPC-KEEPALIVE
 interface po1
  no switchport
  vrf member VPC-KEEPALIVE
  ip address 10.255.255.1/30
  no shut

'''Domänkonfiguration''' &lt;br/&gt;
En VPC-domän har default en restore-delay på 30 sekunder.
 vpc domain &lt;number&gt;
  role priority 1
  system-priority 1000
  system-mac 00:00:11:11:22:22
  peer-keepalive destination 10.255.255.2 source 10.255.255.1 vrf VPC-KEEPALIVE
  peer-gateway
  auto-recovery
  ip arp synchronize
  ipv6 nd synchronize
Default-värden för keepalive: udp-port 3200, vrf management, interval 1000, timeout 5, precedence 6, hold-timeout 3

"system-priority" och "system-mac" bestämmer vilken LACP system priority och actor system som ska användas i LACPDU:er. System MAC används även för BPDU:er. Om man kör [[Nexus_FabricPath|FabricPath]] lägg även till: ''fabricpath switch-id &lt;id&gt;'' under domänkonfigurationen. Auto-recovery är på default och det bör det vara, det ser till att man kan bli forwarding trots att peer aldrig kommer upp, t.ex. om man endast har en switch eller den andra inte startar efter ett strömavbrott.

Konfigurera vPC peer-link
 interface port-channel2
  switchport
  switchport mode trunk
  spanning-tree port type network  #för Bridge Assurance
  vpc peer-link

Verify
 show vpc 
 show vpc peer-keepalive 
 show vpc role
 logging level vpc 5

För att byta role: ''vpc role preempt''

==Konfiguration==
Skapa vPC:er genom att assigna interface. Status på dessa vPC member ports signaleras med CFS mellan peers.
 interface Ethernet1/20
  switchport mode trunk
  channel-group 20 mode active
 
 interface port-channel20
  switchport mode trunk
  vpc 20

'''LACP''' &lt;br/&gt;
NX-OS har ”graceful convergence” aktiverat som standard. Denna funktion förbättrar hanteringen av handskakningen för LACP. När en PortChannel går mot en enhet som inte kör NX-OS så ska denna funktion stängas av för att minska risken att en individuell port går ner i ”suspended state”. Notera att man emot vmware esxi bör slå på graceful convergence, CSCuy84084. 
 interface port-channel10
  no lacp graceful-convergence

'''Individual port''' &lt;br/&gt;
Portar som inte får in LACPDU:er räknas som "individual". Man kan välja om portar som inte lyckas med LACP-förhandling ska fallbacka till individuella switchportar eller suspendas. Detta är t.ex. användbart om man har servrar med multipla NIC som ska [[PXE-Deploy|PXE]]-boota. Individuella switchportarna kommer att fortsätta skicka LACPDU:er för att försöka etablera LACP negotiation. Standardparametrarna för hanteringen av individuella portar inom en PortChannel skiljer sig mellan Nexus 7000 och Nexus 5000. När man uppgraderar till nyare NX-OS så läggs "no lacp suspend-individual" till i running config på interface med default-konfiguration, innan syntes inte detta. När Nexus 5000 ansluts till andra nätverksenheter, använd suspend-individual för PortChannel:n.

 interface port-channel10 
  lacp suspend-individual

'''Verify''' &lt;br/&gt;
 show vpc brief
 show port-channel database
 show vpc consistency-parameters vpc 5
 show vpc orphan ports
 show lacp neighbor
Vid en Type 1 mismatch för ett visst vlan så kommer vlanet endast att suspendas på vPC:er på secondary vPC peer, detta kallas graceful consistency check och är på default.

Advanced troubleshooting
 show cfs status
 show cfs peers
 show cfs internal notification log name vpc

'''Load balancing method'''
 show port-channel load-balance 
Notera att på Nexus 7000 går det endast ändra load balancing method i default VDC:n och detta slår chassis-wide, däremot går det att ställa in per linjekort.

'''Multicast''' &lt;br/&gt;
Peers utbyter metrics över CFS för nya sources.
 show ip pim internal vpc rpf

'''BDPU''' &lt;br/&gt;
Ändra så att VPCer använder Cisco OUI i BPDUer istället för 0026.fxxx.0000.
 Nexus7000(config-vpc-domain)# mac-address bpdu source version 2 

==vPC Enhancements==
'''Peer-switch''' &lt;br/&gt;
vPC Peer-switch möjliggör för ett vPC-par att presentera sig som en logisk enhet i STP genom att de delar på ett virtuellt bridge ID. Båda peer-enheterna kommer även att skicka ut dessa identiska BPDU:er, samt processa inkommande BPDU:er. Om peer-switch inte är påslaget, är det endast primär-enheten skickar ut BPDU:er och sekundär-enheten agerar proxy för primären och forwarderar inkommande BPDU:er till den över peer-länken. Tack vare peer-switch kortas trafikavbrottet till följd av en peer-krasch ned avsevärt, enligt Cisco själva till under sekunden, på grund av att ingen logisk topologiförändring sker i STP. Det rekommenderas att använda sig av peer-switch i en vPC-domän.

Med peer-switch påslaget är båda peer-enheterna tvungna att ha exakt samma spanning tree-konfiguration för samtliga vPC VLAN. Peer-switch måste även det vara konfigurerat på båda sidor. För att slå på peer-switch:
 vpc domain 1
  peer-switch

'''Peer-gateway''' &lt;br/&gt;
vPC Peer-gateway tillåter en vPC peer-enhet att agera gateway för paket som adresserats till den andra peer-enhetens MAC-adress. På så vis behålls routingen lokalt istället för att i onödan traversera peer-länken. Denna funktion är huvudsakligen till för att på ett bättre sätt hantera enheter som inte använder standard-ARP för sin default gateway, till exempel vissa lastbalanserare. Det finns inga nackdelar med denna teknologi och rekommenderas att aktivera i alla vPC-installationer, även denna funktion ska aktiveras på båda peer-enheterna. Båda vpc-peers blir också aktiva forwarders för HSRPs vMAC. För att slå på peer-gateway:
 vpc domain 1
  peer-gateway

'''ARP Sync''' &lt;br/&gt;
För att snabba upp återskapandet av ARP-tabellen efter exempelvis peer-flap eller att ett SVI gått up kan man använda sig av ARP-synkronisering mellan vPC-enheterna. Efter att något av tidigare nämnda händelser inträffat kommer båda enheterna då att synkronisera sina ARP-tabeller med varandra över peer-länken. Det rekommenderas starkt att alltid aktivera IP ARP synchronization på båda peer-enheterna. För att aktivera ARP sync:
 vpc domain 1
  ip arp synchronize
 
 show ip arp vpc-statistics 

'''Nexus 9000''' &lt;br/&gt;
Om man slår på vPC Fast Convergence så enablear man en feature som heter MCT Down Handler. Då skapas en lista med member ports, layer-3 interfaces (SVI:er) och alla vlan de använder. Om peer-linken failar så skickas ett suspend-meddelande till alla dem samtidigt. Det betyder att SVI:erna inte stängs ner först vilket förhindrar traffic loss. 
 vpc domain 1
  fast-convergence

Detta används för att förbättra konvergens av Layer 2 [[Cisco_EVPN|EVPN]] VXLAN.
 interface port-channel 10
  lacp vpc-convergence

'''Hybrid Setup - Spanning Tree''' &lt;br/&gt;
Om man har en mix av enheter på vPC och icke-vPC-portar kopplade till sin vPC-domän kan man ändå välja att switcharna skickar ut olika BPDU:er och därmed lastdela trafiken VLAN-baserat. Denna konfig overidar annan stp rootprio-konf.
 spanning-tree pseudo-information
  vlan 10,20 root priority 16384
  vlan 10 designated priority 4096
  vlan 20 designated priority 61440

==Failover Behavior==
Olika fel kan uppstå i ett datacenter och vPC har vissa mekanismer för att hantera det. Om peer-länken går ner så används peer-keepalive för att kolla status på peeren. Om båda noder är aktiva kommer sekundären att stänga ner alla sina vPC-portar, detta för att förhindra loopar. Går både peer-länk och peer-keepalive ner samtidigt kan det vara svårt att upptäcka samt möjlig service disruption. Kör man heartbeats på mgmt-porten så märks åtminstone att man tappat mgmt av noderna. Heartbeat-gränser går att konfigurera.

Om hela ena noden går ner så kommer den kvarvarande att ta över all forwardering. Var länkar redan innan device failure överlastade kan det såklart bli traffic drops. Finns det något konfigurationsfel mellan noderna så går inte Consistency Check igenom och då kommer endast den primära noden att vara aktiv för forwardering. Beroende på typ av mismatch så genereras syslog-meddelanden.
 show vpc consistency-parameters global

==Back to Back==
Man kan koppla ett vpc-par till ett annat vpc-par och köra en vpc på varje sida, detta kallas back-to-back vPC. Detta kan t.ex. användas mellan aggregation och access layer. Det går också att använda som DCI-lösning om man inte använder någon overlay-teknik eller om man vill ha alla länkar aktiva och avgränsa STP. Man kan stänga av att BPDU:er skickas (portfast) och ha varje DC i egen STP-domän.

Det finns inga speciella kommandon eller hårdvarukrav för detta utan det är en implementationsvariant, man konfar vpc på båda sidor. Dock måste vPC domain ID skilja sig mellan paren.

[[File:Cisco_vPC_B2B.PNG]]

[[Category:Cisco]]</text>
      <sha1>blgibxwz01wx3pvpia8owam4xxd2krc</sha1>
    </revision>
  </page>
  <page>
    <title>Nginx</title>
    <ns>0</ns>
    <id>11</id>
    <revision>
      <id>3148</id>
      <parentid>2976</parentid>
      <timestamp>2022-03-21T19:34:59Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* HTTPS */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6772">[[Category:Guider]]
Nginx används som webbserver av mer än 60% av världens top 100,000 hemsidor. Men Nginx kan vara mycket mer än bara en webbserver. 
Ett litet urval vad Nginx kan användas som:
* Reverse proxy
* Load balancer
* HTTP Cache
* RTMP Server

=Installation=
&lt;ul class="nav nav-tabs"&gt;
   &lt;li class="active"&gt;&lt;btn data-toggle="tab" class=""&gt;#tab1|CentOS 7&lt;/btn&gt;&lt;/li&gt;
   &lt;li&gt;&lt;btn data-toggle="tab" class=""&gt;#tab2|Ubuntu 16.04&lt;/btn&gt;&lt;/li&gt;
 &lt;/ul&gt;

 &lt;div class="tab-content"&gt;
   &lt;div id="tab1" class="tab-pane fade in active"&gt;
Börja med att installera epel-repot:
 yum install epel-release:
Installera Nginx:
 yum install nginx
Starta Nginx:
 systemctl start nginx
Gör så Nginx startar automatiskt vid reboot:
 systemctl enable nginx.service
Lägg till firewalld regler om det behövs.
 firewall-cmd --permanent --zone=public --add-service=http 
 firewall-cmd --permanent --zone=public --add-service=https
 firewall-cmd --reload
   &lt;/div&gt;
   &lt;div id="tab2" class="tab-pane fade"&gt;
Installera Nginx:
 apt-get update
 apt-get -y install nginx
Kolla så Nginx körs:
 systemctl status nginx
   &lt;/div&gt;
 &lt;/div&gt;
=Kommandon=
*Testa om det är en giltig konfiguration innan man startar om nginx:&lt;code&gt;nginx -t&lt;/code&gt;
*Ladda om confen utan att starta om nginx:&lt;code&gt;nginx -s reload&lt;/code&gt;

=Konfiguration=
==Reverse Proxy==
Nginx fungerar utmärkt som en reverse proxy för webbtrafik.

Exempel
  server {
  listen 80;
  server_name sub.domän.se;
  location / {
  proxy_pass http://10.0.0.10:3000;
  include /etc/nginx/proxy_params;
     }
  }
==Rewrite &amp; Redirect==

===Tabort www===
Om man inte vill ha www i sin URL så skapar man 2 servrar som man sedan kör en redirect till.
&lt;source lang=bash&gt;
server {
    listen 80;
    server_name domän.se;
}
 server {
    listen 80;
    server_name www.domän.se;
    return 301 $scheme://domän.se$request_uri;
 }
&lt;/source&gt;

===Redirect HTTP till HTTPS===
Här behöver man också skapa 2st server delar.
&lt;source lang=bash&gt;
server {
  listen      80;
  server_name domän.se;
  return 301  https://domän.se$request_uri;
}
server {
  listen      443 ssl;

  # let the browsers know that we only accept HTTPS
  add_header Strict-Transport-Security max-age=2592000;
}

&lt;/source&gt;
===Redirect HTTP till HTTPS, ej standardport===
Nginx har en egen HTTP-statuskod för detta.

  server {
  listen      1234 ssl;
  server_name sub.domän.se;
  ...
  error_page  497 https://$host:1234$request_uri;
  ...
  }

==HTTPS==
Konfigurationsexempel med säkerhet i fokus. 
 https://syslink.pl/cipherlist/

  server {
  listen 443 ssl;
  server_name secure.domän.se;
  add_header Strict-Transport-Security max-age=15768000;
  add_header X-Frame-Options DENY;
  add_header X-Content-Type-Options nosniff;
  ssl_certificate         /path/to/cert.crt;
  ssl_certificate_key     /path/to/key.pem;
  ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers 'ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!DSS:!RC4';
  ssl_prefer_server_ciphers on;
  ssl_dhparam /path/to/dhparam.pem;
  ...
  }
Generera DH-parametrar med tidtagning. Det tar lång tid!
 time openssl dhparam -out /path/to/dhparam.pem 4096

===Nyckelsäkerhet===
Av säkerhetsskäl bör endast root har rätt att läsa de privata nycklarna. Nginx processer fungerar default enligt:
* 1 nginx master process körs som root
* x nginx workers körs som www-data
Nginx master process läser SSL-nycklarna, inte worker-processerna. Därför fungerar det utmärkt att köra följande.
 sudo chown root:root certificate.key
 sudo chmod 400 certificate.key

===SPDY===
SPDY är ett protokoll utvecklat av Google för att göra HTTPS-handskakning lite snabbare. Alla moderna webbläsare har stöd för det.&lt;br/&gt;
Din nginx måste vara kompilerad med –with-http_spdy_module.
 nginx -V
 sudo sed -i -r 's/listen 443 ssl/listen 443 ssl spdy/g' /etc/nginx/sites-available/dinSSLsite
 sudo service nginx reload
http://SPDYCheck.org

== RTMP ==
Nginx rtmp modul fungerar utmärkt om man vill kunna streama något till 2 platser samtidigt tex till Twitch och Hitbox utan att behöva ha igång 2 instanser av tex OBS/Xsplit.

För att få in RTMP modulen så måste man compilera nginx från början.

 apt-get update &amp;&amp; apt-get install build-essential libpcre3 libpcre3-dev libssl-dev

Hämta hem senaste versionen av nginx och rtmp modulen.

 wget http://nginx.org/download/nginx-1.7.9.tar.gz
 wget https://github.com/arut/nginx-rtmp-module/archive/master.zip

Packa upp filerna
 tar -zxvf nginx-1.7.9.tar.gz
 unzip master.zip
 cd nginx-1.7.9

Lägg sedan till rtmp modulen i nginx.
 ./configure --add-module=../nginx-rtmp-module-master
 make
 make install

Om du inte fått några error så är nginx med rtmp modulen installerade.

Ändra och lägg till följande rader i din conf fil. &lt;code&gt;/usr/local/nginx/conf/nginx.conf&lt;/code&gt;
 rtmp {
 	server {
 		listen 1935;
 		chunk_size 8192;
 
 		application stream {
 			live on;
 			meta copy;
 			push rtmp://live-ams.twitch.tv/app/live_XYZ_ZXY;
 			push rtmp://live.hitbox.tv/push/username?key=XYZ;
 		}
 	}
 }
För att starta nginx server skriv
 /usr/local/nginx/sbin/nginx
För att stoppa nginx servern.
 /usr/local/nginx/sbin/nginx -s

Ställ in din klient att streama mot rtmp://&lt;ip&gt;/stream

==PHP==
För att kunna visa PHP sidor behövs PHP-FastCGI.
 apt-get install php5-cli php5-cgi spawn-fcgi php-pear
 wget -O /usr/bin/php-fastcgi http://www.linode.com/docs/assets/1548-php-fastcgi-deb.sh &amp;&amp; chmod +x /usr/bin/php-fastcgi
 wget -O /etc/init.d/php-fastcgi http://www.linode.com/docs/assets/1549-init-php-fastcgi-deb.sh &amp;&amp; chmod +x /etc/init.d/php-fastcgi &amp;&amp; update-rc.d php-fastcgi defaults
 /etc/init.d/php-fastcgi start

Lägg till följande i din conf fil.
&lt;syntaxhighlight lang=apache&gt;
    location ~* \.php$ {
        include fastcgi_params;
        try_files $uri =404;
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_param SCRIPT_FILENAME $request_filename;
    }
&lt;/syntaxhighlight&gt;

skapa en php info fil i din rooten på webbservern för att testa din php conf.
&lt;syntaxhighlight lang=php&gt;
echo "&lt;?php phpinfo(); ?&gt;" &gt; info.php
&lt;/syntaxhighlight&gt;

==Naxsi==
Third party Nginx-modul, motsvarighet till [[ModSecurity]]. Går att köra i learning mode.
 sudo apt-get install nginx-naxsi


= Tips n Trix =
==Fail2ban==
 sudo nano /etc/fail2ban/jail.conf
 [nginx-http-auth] 
 enabled = true

==Enable directory listing==
Om du vill att nginx ska lista filerna i en mapp som inte har någon index fil. Lägg följande under 
&lt;code&gt;location&lt;/code&gt; som du vill lista.
 autoindex on;

==Rate Limit==
Man kan begränsa bandbredden för en viss IP eller subnät.
&lt;source lang=bash&gt;
 location / {
  if ( $remote_addr ~* 192.100.20.0/24 ) {
    limit_rate 5k;
  }
 }
&lt;/source&gt;</text>
      <sha1>hv2tjykj611m4bdwqt4vp6t69pve74s</sha1>
    </revision>
  </page>
  <page>
    <title>Ntopng</title>
    <ns>0</ns>
    <id>15</id>
    <revision>
      <id>1891</id>
      <parentid>1195</parentid>
      <timestamp>2016-06-23T12:29:52Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1552">High-Speed Web-based Traffic Analysis and Flow Collection. 

== Installation ==
14.04
 wget http://www.nmon.net/apt-stable/14.04/all/apt-ntop.deb &amp;&amp; sudo dpkg -i apt-ntop.deb
 sudo apt-get clean all &amp;&amp; sudo apt-get update &amp;&amp; sudo apt-get -y install ntopng ntopng-data nbox libzmq3 libhiredis0.10
 sudo service apache2 restart
16.04
 wget http://packages.ntop.org/apt-stable/16.04/all/apt-ntop.deb &amp;&amp; sudo dpkg -i apt-ntop.deb
 sudo apt-get clean all &amp;&amp; sudo apt-get update &amp;&amp; sudo apt-get -y install ntopng ntopng-data nbox nprobe
 sudo service apache2 restart

==Konfiguration==
Konfigurationen ligger i '''/etc/ntopng.conf''' men allt kan göras med nbox gui:
 https://&lt;IP&gt;
credentials: nbox:nbox&lt;br/&gt;
ntopng konfas och startas från webgui:t

== Portspegling ==
Det finns olika sätt att få den speglade trafiken till ntop.
* '''vSwitch:''' Promiscuous mode
* '''dvSwitch:''' Distributed Port Mirroring
* '''Fysisk switch:''' [[Cisco_SPAN|SPAN]]/RSPAN/ERSPAN

Listener Port
 echo "auto eth1" | sudo tee -a /etc/network/interfaces
 echo "iface eth1 inet manual" | sudo tee -a /etc/network/interfaces

==NetFlow==
In ntopng flows are collected through nProbe that act as probe/proxy. The communication between nProbe and ntopng happens though ZeroMQ that decouples ntopng from nProbe. 

OBS nprobe kräver licens, se även [[Cisco_NetFlow|Cisco NetFlow]].

 sudo nprobe --zmq "tcp://*:5556" -i none [eth0] -n none --collector-port 2055 &amp;
 sudo ntopng -i tcp://127.0.0.1:5556

'''nProbe modes'''
[[File:Nprobe.PNG|left|607x607px]]

[[Category:Guider]]</text>
      <sha1>rp7y7btvf7h5e52vribw39v67oad47o</sha1>
    </revision>
  </page>
  <page>
    <title>OSSEC</title>
    <ns>0</ns>
    <id>256</id>
    <revision>
      <id>1872</id>
      <parentid>1673</parentid>
      <timestamp>2016-06-19T09:44:42Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Debian/Ubuntu */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8622">[[Category:Guider]]
OSSEC är ett host intrusion detection system. OSSEC monitorerar aktivt dina filer, logar, processer och letar efter rootkit's. OSSEC använder agenter för att övervaka system, det går också att köra agentless och via remote syslog.

=Supportade OS=
==Agent==
*GNU/Linux (all distributions, including RHEL, Ubuntu, Slackware, Debian, etc)
*Windows XP, 2003, Vista, 2008, 2012
*VMWare ESX 3.0,3.5 (including CIS checks)
*FreeBSD (all current versions)
*OpenBSD (all current versions)
*NetBSD (all current versions)
*Solaris 2.7, 2.8, 2.9 and 10
*AIX 5.2 and 5.3
*Mac OS X 10.x
*HP-UX 11
==Syslog==
*Cisco PIX, ASA and FWSM (all versions)
*Cisco IOS routers (all versions)
*Juniper Netscreen (all versions)
*SonicWall firewall (all versions)
*Checkpoint firewall (all versions)
*Cisco IOS IDS/IPS module (all versions)
*Sourcefire (Snort) IDS/IPS (all versions)
*Dragon NIDS (all versions)
*Checkpoint Smart Defense (all versions)
*McAfee VirusScan Enterprise (v8 and v8.5)
*Bluecoat proxy (all versions)
*Cisco VPN concentrators (all versions)
*VMWare ESXi 4.x
==Agentless==
*Cisco PIX, ASA and FWSM (all versions)
*Cisco IOS routers (all versions)
*Juniper Netscreen (all versions)
*SonicWall firewall (all versions)
*Checkpoint firewall (all versions)
*All operating systems specified in the “operating systems” section

=Installation=
OSSEC är uppdelat i server/manager som sedan pratar med agenter som installeras på varje host. Webuit får man installera separat om man vill använda det.
==Server/Manager &amp; Agent==
===Debian/Ubuntu===
Lägg till repo nyklarna.
 apt-key adv --fetch-keys http://ossec.wazuh.com/repos/apt/conf/ossec-key.gpg.key
Följande Debian distar finns det stöd för '''jessie''','''wheezy''','''strectch''' och '''sid'''.
 echo "deb http://ossec.wazuh.com/repos/apt/debian wheezy main" &gt;&gt; /etc/apt/sources.list
Om du istället kör Ubuntu så finns det stöd för '''xenial''', '''precise''', '''trusty''', '''vivid''' eller '''wily'''. 
 echo "deb http://ossec.wazuh.com/repos/apt/ubuntu precise main" &gt;&gt; /etc/apt/sources.list
Uppdatera repot.
 apt-get update
För att installera '''Server/Manager'''.
 apt-get install ossec-hids
Eller installera '''agenten'''.
 apt-get install ossec-hids-agent

===RPM based===
Lägg till yum repo.
 wget -q -O - https://updates.atomicorp.com/installers/atomic |sh
Installera sedan servern/managern.
 yum install ossec-hids ossec-hids-server
Eller agenten.
 yum install ossec-hids ossec-hids-client
==WEBui==
För att köra webui krävs:
*Apache/Nginx med PHP (&gt;= 4.1 or &gt;= 5.0) installerat.
*OSSEC (version &gt;= 0.9-3)

 git clone https://github.com/ossec/ossec-wui.git /var/www/ossec
 cd /var/www/ossec &amp;&amp; ./setup.sh

Om man har selinux på gör det att man inte kan nå visa ossec log filer. För att fixa kan man lägga till en policy.

Skapa en TE fil: &lt;code&gt;/etc/seliinux/targeted/ossec-wui/ossec-wui.te&lt;/code&gt; med följande innehåll.
 module ossec-wui 1.0;
 
    require {
        type var_log_t;
        type httpd_t;
        type var_t;
        class file { read getattr open };
    }
 
    #============= httpd_t ==============
    allow httpd_t var_log_t:file read;
    allow httpd_t var_t:file { read getattr open };

Kör sedan följande kommandon som root:
 checkmodule -M -m ossec-wui.te -o ossec-wui.mod
 semodule_package -o ossec-wui.pp -m ossec-wui.mod
 semodule -i ossec-wui.pp

Försök nå ossec via http://&lt;host&gt;/ossec

=Konfiguration=
==Agent==
Agent är att rekommendera på dom system det finns stöd för. 
===Lägga till===
Det finns 2 sätt att lägga till en agent i ossec.
*'''manage_agents'''
**Manuellt men ett säkrare och mer kontrollerat sätt att lägga till agenter. 
*'''ossec-authd'''
**Smidigt för att det går snabbt att lägga till nya agenter. Osäkert för att alla som kan nå porten kommer att få en nykel och bli inlagd i OSSEC systemet. Går att blocka med hjälp av brandväggen. 

====manage_agents====
Kör följande kommando på servern och välj '''(A)dd an agent'''.
 /var/ossec/bin/manage_agents
När man ska fylla i ett IP kan du också skriva en IP range (10.0.0.0/24) eller '''any''' ifall hosten byter IP ofta.

Välj sedan '''(E)xtract key for an agent''' och fyll sedan i ID numret du valde i sista steget.

Kopiera nykeln och kör följande kommando på agenten.
 /var/ossec/bin/manage_agents
Välj '''(I)mport key from the server''' och kopiera in nykeln. Starta sedan OSSEC agenten.

====ossec-authd====
Kör följande på '''servern'''.
 /var/ossec/bin/ossec-authd -p 1515

På '''agenten''' kör du.
 /var/ossec/bin/agent-auth -m &lt;ossec server ip&gt; -p 1515

===Konfiguration===
Det finns redan en default konfiguration som fungerar bra för agenter. Om man vill ändra något som berör ossec globalt tex ändra vilken alert nivå det måste vara för att skicka mail, lägga till nya regler så görs det i &lt;code&gt;/var/ossec/etc/ossec.conf&lt;/code&gt;.

Om man vill ändra i en regel tex höja o sänka alert nivån för en speciell output, eller skriva en egen regel för en tjänst kollar man i följande mapp: &lt;code&gt;/var/ossec/rules&lt;/code&gt;

==Agentless==
Agentless körs på system som inte har stöd för en agent men har stöd för SSH. Tex brandväggar, switchar, routrar. 
===Lägga till===
Börja med att aktivera agentless stödet på ossec servern.
 /var/ossec/bin/ossec-control enable agentless

För att lägga till en agentless host så behöver sätta SSH lösenord eller använda SSH nykel. På Cisco saker (PIX, routers) behöver du ange en extra parameter för '''enable lösenordet'''. Samma gäller om du vill lägga till '''su''' stöd för linux.
 /var/ossec/agentless/register_host.sh add root@test.hackernet.se sshpass supass
 /var/ossec/agentless/register_host.sh add pix@pix.fw.hackernet.se pixpass enablepass

Om du vill använda SSH nykel så anger du '''NOPASS''' som lösenord. Skapa sedan nycklar åt ossec.
 sudo -u ossec ssh-keygen
Nykeln sparas i &lt;code&gt;/var/ossec/.ssh&lt;/code&gt;, kopiera sedan över den publika nykeln till dina enheter.

===Konfigurera===
När man använder agentless finns det ingen default test som körs och därför behöver man lägga till vad som ska övervakas manuellt per host i &lt;code&gt;/var/ossec/etc/ossec.conf&lt;/code&gt;.

Exempel övervakning som kollar ifall nån fils checksumma ändrats i mapparna '''/bin, /etc, /sbin''' var 10h. Och en PIX övervakning som kollar ifall configen ändrats varje timme.
 &lt;ossec_config&gt;
 ...
 &lt;agentless&gt;
    &lt;type&gt;ssh_integrity_check_linux&lt;/type&gt;
    &lt;frequency&gt;36000&lt;/frequency&gt;
    &lt;host&gt;root@test.hackernet.se&lt;/host&gt;
    &lt;state&gt;periodic&lt;/state&gt;
    &lt;arguments&gt;/bin /etc/ /sbin&lt;/arguments&gt;
 &lt;/agentless&gt;
 
 &lt;agentless&gt;
    &lt;type&gt;ssh_pixconfig_diff&lt;/type&gt;
    &lt;frequency&gt;3600&lt;/frequency&gt;
    &lt;host&gt;pix@pix.fw.hackernet.se&lt;/host&gt;
    &lt;state&gt;periodic_diff&lt;/state&gt;
 &lt;/agentless&gt;
 ...
 &lt;/ossec_config&gt;

'''&lt;type&gt;'''

Default finns det 6st olika types script att välja mellan.
*'''ssh_integrity_check_bsd'''
**Kollar ifall nån fil ändrat SHA1 eller MDA5 checksum i BSD.
*'''ssh_integrity_check_linux'''
**Kollar ifall nån fil ändrat SHA1 eller MDA5 checksum i Linux. 
*'''ssh_pixconfig_diff'''
**Kollar om configen ändrats på en Cisco PIX brandvägg. Behöver inget '''arguments''' i configen.
*'''ssh_asa-fwsmconfig_diff'''
**Kollar om configen ändrats på en Cisco ASA brandvägg. Behöver inget '''arguments''' i configen.
*'''ssh_generic_diff'''
**Används för att kolla vad som helst som har SSH stöd. Man skriver kommandona man vill jämföra i '''arguments'''.

'''&lt;frequency&gt;'''

Hur ofta en check ska köras. Skriv i sekunder.

'''&lt;host&gt;'''

Vilken host scriptet ska köras mot. Om man behöver köra su lösenordet så skriver man '''use_su''', ex:
 &lt;host&gt;use_su user@test.hackernet.se&lt;/host&gt;

'''&lt;state&gt;'''

Det finns 2 olika states.
*'''periodic'''
**Skickar en kontrollerad output mot OSSEC agentless processen och jämför sedan mot tidigare körningar. Om det är någon skillnad så kommer OSSEC larma. Används för att kolla så inte checksumman ändrats.
*'''periodic_diff'''
**Skickar output mot OSSEC agentless processen och jämför sedan mot tidigare körningar. periodic_diff används när det är en type som jämför 2 en fil/config mot varandra.

'''&lt;arguments&gt;'''

Fyll i dom kommandona du vill jämföra. För flera kommandon kan man separera med ett ''';'''.
 ...
 &lt;arguments&gt;ls -la /etc; cat /etc/passwd&lt;/arguments&gt;
 ...

====Prova manuellt====
Man kan köra scripten manuellt för att prova att det fungerar. Krävs att lösenordet/nykeln blivit inlagd. 
 cd /var/ossec &amp;&amp; ./agentless/ssh_integrity_check_linux root@test.hackernet.se /bin</text>
      <sha1>tg6fp5uijufas1leerfol0ri4hllpsb</sha1>
    </revision>
  </page>
  <page>
    <title>OS X</title>
    <ns>0</ns>
    <id>219</id>
    <revision>
      <id>1378</id>
      <timestamp>2015-12-25T14:22:54Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "OS X heter operativsystemet som körs på Apple Mac datorer. OS X bygger på UNIX i botten.  ==Tips'N'Trix== ===Homebrew=== Homebrew är en paket hanterare som liknar apt och..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="552">OS X heter operativsystemet som körs på Apple Mac datorer. OS X bygger på UNIX i botten.

==Tips'N'Trix==
===Homebrew===
Homebrew är en paket hanterare som liknar apt och som OS X inte har. Mer info finns på deras [http://brew.sh/ hemsida]. 

===Byt MAC adress===
För att sätta en egen mac adress:
 sudo ifconfig en0 ether aa:bb:cc:dd:ee:ff

För att sätta en random mac adress:
 openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//' | xargs sudo ifconfig en0 ether

Ändringen är inte permanent utan försvinner vid omstart.

[[Category:Distar]]</text>
      <sha1>r1ll24owxx9ievrlv631334i5075gvs</sha1>
    </revision>
  </page>
  <page>
    <title>Ookla Speedtest Mini</title>
    <ns>0</ns>
    <id>135</id>
    <revision>
      <id>1004</id>
      <parentid>909</parentid>
      <timestamp>2015-09-05T12:29:04Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>Kategori</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="779">== Installation ==
''Debian/Ubuntu''

 wget http://c.speedtest.net/mini/mini.zip (Du kan behöva registrera dig på deras hemsida)
 unzip mini.zip

 apt-get install apache2
 apt-get install php5 php5-mysql php5-mcrypt php5-gd libapache2-mod-php5
 service apache2 restart

Kommande rad är ej obligatorisk. Den skapar endast en fil som verifierar att php'n fungerar
 echo "&lt;?php phpinfo(); ?&gt;" &gt; /var/www/phpinfo.php 

 cp -R /[location to extracted folder]/mini /var/www/

[[File:asdf.JPG|400px]]

Byt namn på index-php.html filen till index.html och lämna dem resterande orörda.

 cd /var/www/mini
 mv index-php.html index.html 

Du skall nu kunna komma åt din speedtestserver via webbläsaren på "http://dinserverip/mini"

[[File:speedtest.JPG|400px]]

[[Category:Guider]]</text>
      <sha1>5dkx5hwg1tqd15ajqpq1n12z2ph9mh9</sha1>
    </revision>
  </page>
  <page>
    <title>OpenDaylight</title>
    <ns>0</ns>
    <id>252</id>
    <revision>
      <id>1614</id>
      <parentid>1607</parentid>
      <timestamp>2016-04-09T13:56:38Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1395">OpenDaylight är en öppen kontroller-infrastruktur byggd för SDN-implementeringar.

==Installation==
Ladda ner senaste version: https://www.opendaylight.org/downloads
 wget https://nexus.opendaylight.org/content/repo...-SR1.tar.gz
''Beryllium on Ubuntu''
 sudo apt-get -y install openjdk-7-jdk
 cd &amp;&amp; echo "export JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-amd64" &gt;&gt; .profile
 tar -xzf distribution-karaf-0.4.1-Beryllium-SR1.tar.gz
Stäng av ipv6, java har ipv6 som preferred.
 
==Konfiguration==
Starta OpenDaylight
 cd ./distribution-karaf-[TAB]
 bin/karaf   #starta med karaf console
 bin/start   #starta i bakgrund
 bin/stop    #stoppa controller

Från början är ODL tomt så man får ladda in de features man vill använda. En feature installeras en gång sedan är den aktiverad även efter omstart. Lista tillgängliga features och installera några basic:
 feature:list
 feature:install odl-restconf odl-l2switch-switch odl-dlux-all
 feature:list --installed

OpenFlow
 feature:install odl-openflowplugin-flow-services-ui

DLUX web gui, admin pw: admin
 http://&lt;ip&gt;:8181/index.html
''Unable to login'' Det tar några minuter innan man kan logga in.

==Network==
ODL kan prata med nätverksutrustning med många olika protokoll, t.ex. OpenFlow, NETCONF, BGP och OVSDB. Se [[Mininet]]. &lt;br/&gt;
För [[Open_vSwitch]]:
 ovs-vsctl set-controller br0 tcp:10.0.0.20:6633

[[Category:Network]]</text>
      <sha1>3idvs6rnmakef0jdhyjikb4h10j1ten</sha1>
    </revision>
  </page>
  <page>
    <title>OpenLDAP</title>
    <ns>0</ns>
    <id>32</id>
    <revision>
      <id>1593</id>
      <parentid>1557</parentid>
      <timestamp>2016-03-31T20:11:42Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11095">[[Category:Guider]] [[Category:Sparco]]
OpenLDAP är en central inloggnings server precis som Active directory är. Det ökar användarvänligheten om man kan använda samma lösenord till flera platser. OBS det är viktigt att klockorna är synkade på maskinerna som ska använda LDAP och att namnuppslag för LDAP-servern kan göras på alla klienter.

== Installera ==
 apt-get update &amp;&amp; apt-get install slapd ldap-utils
Slå in ett lösenord.

Kör sedan,
 dpkg-reconfigure slapd

Svara följande på frågorna som kommer.
{| class="wikitable"
|-
|Omit OpenLDAP server configuration? || No || Detta kommer starta wizarden.
|-
|DNS domain name: || example.se || Namnet på din LDAP domän. (Detta namnet kommer skapa ditt BaseDN dc=example,dc=se)
|-
|Organization name: || example || Ett namn på din organisation
|-
|Administrator password: || secret || Nytt lösenord för din LDAP administratör. (cn=admin,dc=example,dc=se)
|-
|Database backend to use: || HDB || Bygger på Oracle Berkeley databas(BDB) men är mer effektiv.
|-
|Remove database when slapd is purged? || No || Spara databasen även om OpenLDAP avinstalleras.
|-
|Move old database? || Yes || Ta bort den gammla databasen så att den inte stör den nya.
|-
|Allow LDAPv2 protocol? || No || Om du inte måste ha LDAPv2 men det är rekommenderat att ha det avstängt.
|}

Gör en test query och kolla att LDAP servern fungerar.
 ldapsearch -x -W -D cn=admin,dc=example,dc=se -b dc=example,dc=se -LLL 
 
 # x = simple bind/authentication
 # W = ask for password
 # D = user DN
 # b = search base
 # LLL = omit comments

==Konfigurera==
Det finns tre olika sätt att konfigurera OpenLDAP.
*Man ändrar i själv i mappen &lt;code&gt;/etc/ldap/slapd.d&lt;/code&gt;. Detta är inte rekommenderat att göra.
*Man använder ldap-utils(ldapadd, ldapdelete, ldapmodify, etc).
*Eller så använder man ett GUI för att skapa användare, grupper eller importera LDIF. [http://phpldapadmin.sourceforge.net/wiki/index.php/Main_Page phpLDAPadmin], [https://directory.apache.org/studio/download/download-linux.html Apache Directory Studio], [http://www.ldapadmin.org LDAP Admin].

'''LDIF''' är text filer som används för att skapa användare, grupper eller för att göra ändringar på din LDAP server.
För att importera en LDIF fil kör kommandot,
 ldapadd -W -D "cn=admin,dc=example,dc=se" -f filename.ldif

===Skapa en organizational unit===

Skapa en ldif fil med följande info i och importera till OpenLDAP.
 dn: ou=users,dc=example,dc=se
 changetype: add
 objectClass: organizationalUnit
 objectClass: top
 ou: users

===Skapa en användare===
 dn: uid=user1,ou=users,dc=example,dc=se
 objectClass: inetOrgPerson
 objectClass: posixAccount
 objectClass: top
 cn: user1
 givenName: User
 sn: Usersson
 homeDirectory: /home/user1
 loginshell: /bin/bash
 uidNumber: 51397
 gidNumber: 0
 uid: user1
 userPassword: secret

Om du vill kryptera lösenordet skriv
 slappasswd -s secret

Och kopiera in SSHA nykeln i ldif filen efter &lt;code&gt;userPassword:&lt;/code&gt;

===Skapa grupper===
Den finns olika sorters grupper man kan skapa.
*posixGroup - Lik en vanlig Unix grupp och har ett gidNumber.
*groupOfNames - Används default av [[OpenLDAP#memberOf|memberOf]] overlayen och sparar varje användares FDN. 
*groupOfUniqueNames - Samma som groupOfNames fast man kan skilja på användare som har samma uid genom att lägga till en extra unique identifier.

====posixGroup====
Denna sortens grupp syns om du har LDAP kopplat dina användare på en Linux maskin.
 dn: cn=sudo,dc=hackernet,dc=se
 objectclass: posixGroup
 objectclass: top
 cn: sudo
 description: Group description
 memberUid: user1

====groupOfNames====
 dn: cn=groupname,dc=hackernet,dc=se
 objectclass: groupofnames
 cn: groupname
 description: Group desc
 member: uid=user1,ou=users,dc=example,dc=se

====groupOfUniqueNames====
Om du har LDAP kopplat din [[VMware_vCenter|vCenter]] så behöver användarna ligga i en sån här grupp.
 dn: cn=vcenter,dc=example,dc=se
 objectclass: groupOfUniqueNames
 objectclass: top
 cn: vcenter
 description: vcenter group
 uniqueMember: cn=user1,ou=users,dc=example,dc=se

===memberOf===
För enkelt göra ställa frågor och se vilken grupp en användare är med i så behöver man aktivera &lt;code&gt;memberOf&lt;/code&gt;.

Skapa tre filer med följande kod i.
'''memberof.ldif''' 
 dn: cn=module,cn=config
 cn: module
 objectClass: olcModuleList
 olcModuleLoad: memberof
 olcModulePath: /usr/lib/ldap
 
 dn: olcOverlay={0}memberof,olcDatabase={1}hdb,cn=config
 objectClass: olcConfig
 objectClass: olcMemberOf
 objectClass: olcOverlayConfig
 objectClass: top
 olcOverlay: memberof
 olcMemberOfDangling: ignore
 olcMemberOfRefInt: TRUE
 olcMemberOfGroupOC: groupOfNames
 olcMemberOfMemberAD: member
 olcMemberOfMemberOfAD: memberOf

'''refint1.ldif'''
 dn: cn=module{1},cn=config
 add: olcmoduleload
 olcmoduleload: refint

'''refint2'''
 dn: olcOverlay={1}refint,olcDatabase={1}hdb,cn=config
 objectClass: olcConfig
 objectClass: olcOverlayConfig
 objectClass: olcRefintConfig
 objectClass: top
 olcOverlay: {1}refint
 olcRefintAttribute: memberof member manager owner

Ladda sedan in filerna i OpenLDAP servern med följande kommandon.
 ldapadd -Q -Y EXTERNAL -H ldapi:/// -f memberof.ldif
 ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f refint1.ldif
 ldapadd -Q -Y EXTERNAL -H ldapi:/// -f refint2.ldif

Skapa sedan en grupp och lägg till användare.

'''add_group.ldif'''
 dn: cn=testgrupp,dc=example,dc=se
 objectClass: groupofnames
 cn: testgrupp
 description: All users
 member: uid=testuser,ou=users,dc=example,dc=se

 ldapadd -x -D cn=admin,dc=example,dc=se -W -f add_group.ldif

För att testa att det funkar kan du ställa denna frågan.
 ldapsearch -h &lt;ip&gt; -x -b "dc=example,dc=se" '(uid=testuser)' memberOf

===RootDN===
För att göra ändringar i &lt;code&gt;cn=config&lt;/code&gt; som innehåller själva LDAP konfigurationen behöver man skapa ett admin konto med lösenord.

Under cn=config kan man sätta bland annat ACLer för vilka användare som får läsa och skriva så man inte behöver använda cn=admin kontot varje gång.

 dn: olcDatabase={0}config,cn=config
 changetype: modify
 add: olcRootDN
 olcRootDN: cn=admin,cn=config
 
 dn: olcDatabase={0}config,cn=config
 changetype: modify
 add: olcRootPW
 olcRootPW: secret

 ldapadd -Y EXTERNAL -H ldapi:/// -f rootconfig.ldif

För att nå cn=config med Apache Directory Studio.
&lt;gallery&gt;
File:openldap_04.png
File:openldap_05.png
File:openldap_06.png
&lt;/gallery&gt;

===Postfix Schema===
För att styra en mailserver med LDAP behövs postfix schemat för att få fler object klasser.
 cd /etc/ldap/schema
 wget http://www.postfix-buch.com/download/postfix-book.schema.gz &amp;&amp; gunzip postfix-book.schema.gz
 mkdir ldif_output

&lt;syntaxhighlight lang=bash&gt;
cat &lt;&lt;'__EOF__'&gt;&gt;schema_convert.conf
include /etc/ldap/schema/core.schema
include /etc/ldap/schema/cosine.schema
include /etc/ldap/schema/nis.schema
include /etc/ldap/schema/inetorgperson.schema
include /etc/ldap/schema/postfix-book.schema
__EOF__
&lt;/syntaxhighlight&gt;
 slapcat -f schema_convert.conf -F ./ldif_output/ -n0
 cp /etc/ldap/schema/ldif_output/cn\=config/cn\=schema/cn\=\{4\}postfix-book.ldif /etc/ldap/schema/postfix-book.ldif

Öppna och ändra följande i &lt;code&gt;postfix-book.ldif&lt;/code&gt;
*dn: cn=postfix-book,cn=schema,cn=config
*cn: postfix-book
*Ta bort allt från structuralObjectClass och neråt.

Importera ldif filen och starta om slapd.
 ldapadd -Y EXTERNAL -H ldapi:/// -f postfix-book.ldif

&lt;div class="toccolours mw-collapsible mw-collapsed" style="width:800px"&gt;
Exempel LDIF på hur en mail användare kan se ut.
&lt;div class="mw-collapsible-content"&gt;
&lt;syntaxhighlight lang=bash&gt;#!/bin/bash
dn: uid=user,ou=users,dc=hackernet,dc=se
objectClass: inetOrgPerson
objectClass: posixAccount
objectClass: person
objectClass: top
objectClass: PostfixBookMailAccount
objectClass: extensibleObject
cn: user
givenName: User
sn: Usersson
mail: user@hackernet.se
homeDirectory: /home/user
loginShell: /bin/bash
uidNumber: 51397
gidNumber: 0
mailEnabled: TRUE
mailGidNumber: 5000
mailUidNumber: 5000
mailHomeDirectory: /srv/vmail/user@hackernet.se
mailQuota: 10240
mailStorageDirectory: maildir:/srv/vmail/user@hackernet.se/Maildir
uid: user
userPassword: secret
&lt;/syntaxhighlight&gt;
&lt;/div&gt;
&lt;/div&gt;

== Client ==
===Nslcd===
Enklaste sättet att autha mot en LDAP server är att använda nslcd.

 apt-get install nslcd

Lägg sedan till följande i &lt;code&gt;/etc/nslcd.conf&lt;/code&gt;
 ...
 uri ldapserver.hackernet.se
 base dc=hackernet,dc=se
 ...

Öppna &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; och lägg till följande:

 passwd: compat ldap
 group: compat ldap
 shadow: compat ldap
 netgroup:ldap

Starta sedan om tjänsten '''nslcd''' och '''nscd'''
 service nscd restart
 service nslcd restart

===Libnss-ldap===
Autentisera login mot LDAP servern. Veriferat på Debian 7 (Wheezy)
 apt-get update &amp;&amp; apt-get install libnss-ldap libpam-ldap ldap-utils
# Specifera URL till din ldap server.
# Skriv in din base dn. Samma som BASE i &lt;code&gt;/etc/ldap/ldap.conf&lt;/code&gt;
# Välj V3.
# Fyll i hela suffixen till adminkontot.
# Lösenordet för adminkontot.
# Välj ok. Vi ska ändra i den filen senare.
# Välj vad du vill.
# Välj vad du vill. 
# Fyll i hela suffixen till ditt LDAP adminkonto. Oftast samma som i steg 4.
# Lösenordet för adminkontot.

Öppna sedan filen,
 vim /etc/nsswitch.conf
På linje #7 lägg till,
 passwd: compat ldap
 group: compat ldap
 shadow: compat ldap

På linje #19 ändra till,
 netgroup:ldap
Öppna sedan filen,
 vim /etc/pam.d/common-password
På linje #26 ta bort &lt;code&gt;use_authtok&lt;/code&gt; och lägg till,
 password     [success=1 user_unknown=ignore default=die]     pam_ldap.so try_first_pass

I filen /etc/pam_ldap.conf. Leta upp kommandot pam_password och ändra till exop. Om du byter lösenord med passwd så väljer Debian default att skicka över lösenordet krypterat med Crypt. Crypt klarar max 8 tecken och är inte säkert. Väljer man exop så sköter OpenLDAP krypteringen av lösenordet.
 pam_password exop
Man kan skippa detta steget om man inte vill att en hemmapp ska skapas automatiskt lokalt på datorn,
 vim /etc/pam.d/common-session
Och lägga till denna raden i slutet.
 session optional        pam_mkhomedir.so skel=/etc/skel umask=077

Starta sedan om datorn och prova att logga in med ett domänkonto.

== Styr Sudo med LDAP grupp ==
Skapa en [[OpenLDAP#posixGroup|posixGroup]] som heter sudo. Lägg sedan till användarna som du vill ska få sudo rättigheter i den.
Verifiera att din användare finns med i sudo gruppen genom att logga in och skriva groups.
 sparco@jumpoff:~$ groups
 root wiki sudo

Lägg sedan till denna raden i &lt;code&gt;/etc/sudoers&lt;/code&gt; på din server.
 %sudo   ALL=(ALL:ALL) ALL

==Troubleshoot==
===Getent===
Getent står för get entries och används för att visa rader i databaser som supportas av Name Service Switch libraries(nsswitch.conf).

'''passwd''' visar alla användare som servern hittar.
 getent passwd
'''group''' visar alla grupper som hittas.
 getent group

== Förslag på möjliga rubriker ==

==== LDAP med TLS ====

==== LDAP-replikering ====</text>
      <sha1>ctykab63qb9l009luhqag0lhq0vsv5l</sha1>
    </revision>
  </page>
  <page>
    <title>OpenShift</title>
    <ns>0</ns>
    <id>241</id>
    <revision>
      <id>1506</id>
      <timestamp>2016-02-16T08:00:43Z</timestamp>
      <contributor>
        <username>Zunken</username>
        <id>3</id>
      </contributor>
      <comment>Created page with "OpenShift är ett såkallat PaaS (Platform as a service eller som på svenska platform som tjänst) från Red Hat.  Mjukvaran som kör servicen är Open-Sourced under namnet O..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1237">OpenShift är ett såkallat PaaS (Platform as a service eller som på svenska platform som tjänst) från Red Hat.

Mjukvaran som kör servicen är Open-Sourced under namnet OpenShift Origin och finns på [https://en.wikipedia.org/wiki/GitHub GitHub] versionen för cloud computing heter OpenShift Enterprise.

OpenShift supporterar också binära program som är webb baserade så länge de kan köras på Red Hat Enterprise Linux. Detta tillåter användare att använda egen gjorda språk och ramverk. OpenShift tar hand om alla tjänster som applikationen behöver samt skalar systemet efter denns behov

'''Tools'''

==Supporterade Språk==
 *Haskell
 *Java
 *JavaScript
 *.NET
 *Perl
 *PHP
 *Python
 *Ruby

==Supporterade Databaser==
 *Microsoft SQL Server
 *MongoDB
 *MySQL
 *PostgreSQL

==Supporterade Applikationer==
 *Node.js för JavaScript
 *PSGI för Perl
 *Rack för Ruby
 *WSGI för Python
Några ramverk som fungerar omodifierade på openstack 
 *CakePHP
 *Codelgniter
 *Django
 *Flask
 *Laravel
 *Perl Dancer
 *Ruby on Rails
 *Sinatra
 *Tornado
 *Vert.x
 *web2py
 
==Konkurenter==
 *Cloud Foundry
 *Google App Engine
 *Heroku
 *Jelastic
 *Bluemix
 *Tsuru (PaaS)

==Installation==

==Konfiguration==



[[Category:Linux]]</text>
      <sha1>9paaxse3j8uxklxicsmxp46poycu9j7</sha1>
    </revision>
  </page>
  <page>
    <title>OpenVPN</title>
    <ns>0</ns>
    <id>23</id>
    <revision>
      <id>2697</id>
      <parentid>2691</parentid>
      <timestamp>2017-12-06T20:49:06Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Systemd service */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3157">[[Category:Guider]]
OpenVPN är öppen källkod. Detta är exempelkonf för remote access med säkerhet i åtanke. Två-faktors-autentisering för inlogg samt TLS-autentisering av paketen. Tyvärr kan man inte hårdställa  TLS-version. CA-certifikatet och TLS-nyckeln körs inline i konfigfilen för att det ska bli färre filer att hålla reda på. Remote access VPN är utmärkt om du vill känna dig som hemma var du än befinner dig. 
== Installation ==
Med pakethanterare:
 apt-get install openvpn
 openvpn --version

Road warrior installer. 
 wget https://git.io/vpn | sudo bash
OBS kontrollera det du wgetar innan du pipear till sudo bash.

==Konfiguration==
Openvpn är uppdelat i server och klient.

=== Server ===
En OpenVPN-server måste ha Diffie-Hellman-parametrar.
 time openssl dhparam -out dhparam.pem 4096
Servern måste kunna forwarda trafik
 echo 1 &gt; /proc/sys/net/ipv4/ip_forward
TLS-autentiseringsnyckeln ska vara samma på servern som klienterna
 openvpn --genkey --secret ta.key

 dev tun
 proto tcp
 server 10.8.0.0 255.255.255.0
 ifconfig-pool-persist ipp.txt
 
 ca [inline]
 cert Server.crt
 key Server.pem
 &lt;nowiki&gt;#&lt;/nowiki&gt;auth-
 
 dh dhparam.pem
 tls-server
 tls-auth [inline] 0
 
 keepalive 10 30
 cipher AES-256-CBC
 user nobody
 group nogroup
 persist-key
 persist-tun
 comp-lzo
 tun-mtu 1500
 mssfix 1200
 verb 3
 
 client-to-client
 status openvpn-status.log
 
 push "redirect-gateway def1 bypass-dhcp"
 push "dhcp-option DNS 10.8.0.1"
 
 &lt;ca&gt;
 &lt;nowiki&gt;-----&lt;/nowiki&gt;BEGIN CERTIFICATE-----
 MIIFjjCCA3agAwIBAgICAQAwDQYJKoZIhvcNAQENBQAwaDELMAkGA1UEBhMCU0Ux
 ...
 W45x0oueEpRKlORpP00dSaeAEj9yJCd/0pltmmR92cGVYg==
 &lt;nowiki&gt;-----&lt;/nowiki&gt;END CERTIFICATE-----
 &lt;/ca&gt;
 
 &lt;tls-auth&gt;
 &lt;nowiki&gt;-----&lt;/nowiki&gt;BEGIN OpenVPN Static key V1-----
 fae4feae672f9e291a40be76ee408106
 ...
 16c46f97c66441da9bcddd2f717672d0
 &lt;nowiki&gt;-----&lt;/nowiki&gt;END OpenVPN Static key V1-----
 &lt;/tls-auth&gt;

=== Klient ===
Klientkonf som funkar till serverkonfen ovan. Spara conf filen i &lt;code&gt;/etc/openvpn/client/&lt;/code&gt;

 client
 dev tun0
 proto udp
 remote vpn.hackernet.se 1194
 resolv-retry infinite
 nobind
 
 ca [inline]
 cert Klient1.crt
 key Klient1.pem
 auth-user-pass auth.txt
 
 tls-client
 tls-auth [inline] 1
 verify-x509-name vpn.hackernet.se name
 
 keepalive 10 30
 cipher AES-256-CBC
 auth SHA256
 persist-key
 persist-tun
 comp-lzo
 tun-mtu 1500
 mssfix 1200
 verb 3
 
 &lt;ca&gt;
 &lt;nowiki&gt;-----&lt;/nowiki&gt;BEGIN CERTIFICATE-----
 MIIFjjCCA3agAwIBAgICAQAwDQYJKoZIhvcNAQENBQAwaDELMAkGA1UEBhMCU0Ux
 ...
 W45x0oueEpRKlORpP00dSaeAEj9yJCd/0pltmmR92cGVYg==
 &lt;nowiki&gt;-----&lt;/nowiki&gt;END CERTIFICATE-----
 &lt;/ca&gt;
 
 &lt;tls-auth&gt;
 &lt;nowiki&gt;-----&lt;/nowiki&gt;BEGIN OpenVPN Static key V1-----
 fae4feae672f9e291a40be76ee408106
 ...
 16c46f97c66441da9bcddd2f717672d0
 &lt;nowiki&gt;-----&lt;/nowiki&gt;END OpenVPN Static key V1-----
 &lt;/tls-auth&gt;

== HTTPS ==
OpenVPN och HTTPS kan samsas på samma port. 

[[File:Openvpn1.png]]

== Dölja trafik ==
En bra början: https://www.bestvpn.com/blog/5919/how-to-hide-openvpn-traffic-an-introduction/

==Systemd service==
{{OpenVPN-Systemd}}
Vill du veta mer om hur systemd templates fungerar kan du läsa [[Systemd#Template_unit|här]].</text>
      <sha1>iqr7wt055axhyyskujj6de6msnvgtmr</sha1>
    </revision>
  </page>
  <page>
    <title>Open vSwitch</title>
    <ns>0</ns>
    <id>109</id>
    <revision>
      <id>1911</id>
      <parentid>1832</parentid>
      <timestamp>2016-07-01T14:28:01Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>/* Konfiguration */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3178">Open vSwitch är en virtuell multi layer switch, open source licensierad under Apache 2.0. Det används oftast med hypervisors för att koppla ihop vms med varandra mellan hostar och nätverk, t.ex. med KVM eller Xen. Det kan också användas med dedikerad switchhårdvara eller SDN-lösningar. Open vSwitch har stöd för de flesta traditionella tekniker inklusive STP, VLAN, LACP, GRE, VXLAN, BFD, QoS och net/sflow. Open vSwitch består i huvudsak av VSWITCHD, OVSDB-server och en kernel-modul. Det går även köra distribuerat över flera hostar likt VMwares vDS och Cisco [[Nexus_1000V|Nexus 1000V]].

'''Tools'''
* ovs-vsctl: configuring the ovs-vswitchd configuration database
* ovs-ofctl: monitor and administer OpenFlow switches
* ovs-dpctl: administer Open vSwitch datapaths
* ovs−appctl: query and controll Open vSwitch daemons

==Installation==
''Ubuntu''
 apt-cache show openvswitch-switch | grep Version
 sudo apt-get install openvswitch-switch

''Fedora''
 sudo dnf info openvswitch | grep Version
 sudo dnf install openvswitch

 sudo systemctl start openvswitch
 lsmod | grep openv

Start at boot
 sudo systemctl enable openvswitch

==Konfiguration==
Skapa en virtuell switch och koppla interface till den.
 ovs-vsctl add-br br0
 ovs-vsctl add-port br0 eth0
 ovs-vsctl list-ifaces br0

Show
 ovs-vsctl show
 ovs-vsctl list-br
 ovs-ofctl show br0

/etc/network/interfaces
 allow-ovs ovsbr0
 iface ovsbr0 inet manual
   ovs_type OVSBridge
   ovs_ports eth1

Adress till hosten
 ifconfig eth0 0
 dhclient br0

===Interface===
''default all ports are VLAN trunks''&lt;br/&gt;
Access
 ovs-vsctl set port eth1 vlan_mode=access tag=1
Trunk
 ovs-vsctl set port eth1 vlan_mode=tagged
Hybrid
 ovs-vsctl set port eth1 vlan_mode=native-untagged trunks=[1,3] tag=2
Show
 ovs-vsctl list port eth1

===Bond===
 ovs-vsctl add-bond br0 bond0 eth0 eth1 lacp=active trunks=10,11,12
 ovs-vsctl list port bond0

===STP===
 ovs-vsctl set bridge br0 stp_enable=true

===SVI===
 ovs-vsctl add-port br0 vlan90 tag=09 -- set interface vlan09 type=internal

Interface till vms
 ip tuntap add mode tap vport1
 ip tuntap add mode tap vport2
 ovs-vsctl add-port testbridge vport1
 ovs-vsctl add-port testbridge vport2
 ovs-vsctl show
Kolla mac-tabell
 ovs-appctl fdb/show testbridge

==Controller==
 ovs-vsctl set-controller br0 tcp:10.0.0.20:6633
 ovs-vsctl list controller
Tappar man konnektivitet med controllern sätter man antingen upp flows själv eller inte alls beroende på standalone eller secure mode.
 ovs-vsctl get-fail-mode br0

Ta bort controller
 ovs-vsctl del-controller br0
==OpenFlow==
Open vSwitch har stöd för OpenFlow.
 ovs-vsctl -- set bridge br0 protocols=openflow14

==Patch Port==
Med patchportar kan man koppla ihop flera ovs:er med varandra internt inom en host. &lt;br/&gt;
Sw1
 ovs-vsctl add-port br1 patch1-2
 ovs-vsctl set interface patch1-2 type=patch
 ovs-vsctl set interface patch1-2 options:peer=patch2-1
Sw2
 ovs-vsctl add-port br2 patch2-1
 ovs-vsctl set interface patch2-1 type=patch
 ovs-vsctl set interface patch2-1 options:peer=patch1-2

 ovs-vsctl show

==sFlow==
Open vSwitch kan streama telemetry med sFlow.
 service sflowovsd start

[[Category:Network]]</text>
      <sha1>abnhhppfnr4byq83bezf45p83gjtm85</sha1>
    </revision>
  </page>
  <page>
    <title>Owncloud</title>
    <ns>0</ns>
    <id>43</id>
    <revision>
      <id>1305</id>
      <parentid>1069</parentid>
      <timestamp>2015-11-24T19:22:25Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Konfiguration */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2333">[[Category:Guider]] [[Category:Sparco]]
Owncloud är precis som namnet antyder ett eget cloud. Funkar precis som Dropbox och liknande tjänster bara att du själv måste hosta filerna på en egen server och på så sätt ha full kontroll på dom.

För att komma åt dina filer i owncloud kan du använda ett webinterface eller deras Owncloud client som finns till Windows, Linux, MacOSX, IOS, Android.

===== Features =====
Nämner bara några features owncloud har som jag tycker är bra, fler features listas [https://owncloud.org/features/ här]. 
* Revisionshantering av filer.

* Undelete om du råkar ta bort fel fil.
* Skapa en temporär URL till en fil som man kan dela med andra.
* Kryptering av filer, AES 128 eller 256 bits.
* LDAP/AD stöd.
* Lägg till external storage(Dropbox, Google Drive, Amazon S3, SMB/CIFS, FTP, SFTP)
* Synca kontakter och kalender från tex mobilen.
* Plugins.

== Installation ==
För att installera Owncloud krävs en webbserver med PHP och [[MySQL]] förkonfat. Man kan använda sig av MariaDB, SQLite och PostgreSQL också.

Gå till https://owncloud.org/install/#instructions-server för att få tag på senaste tar.bz2 filen.

Tanka hem filen till roten av din webbfolder och packa upp den.
 wget https://download.owncloud.org/community/owncloud-8.0.2.tar.bz2 &amp;&amp; tar xvf owncloud-8.0.2.tar.bz2

== Konfiguration ==
Surfa sedan in på http://&lt;IP&gt;/owncloud

Följ anvisningarna som kommer.

===NFS===
För att lagra data på en NFS share. Mounta sharen till en mapp i owncloud foldern eller till en annan mapp på servern. Se till att samma användare och grupp med samma GID som kör webbservern äger  mappen på NFS serverns sida. Peka sedan data folder mot den nya mappen under installationen eller genom att ändra på parametern datadirectory i &lt;code&gt;&lt;owncloud&gt;/config/config.php&lt;/code&gt; filen. Glöm inte flytta över index.html och .htaccess filen till NFS sharen så att inte obehöriga kan läsa dina filer. 

=== Kryptering ===
För att sätta på kryptering.

Logga in som en admin.

Uppe till vänster välj Apps.

Leta upp appen &lt;code&gt;Server-Side encryption&lt;/code&gt; och tryck enable.

Logga sedan ut och logga in igen. Har du redan sparat filer så kan inloggningen ta en stund eftersom att den börjar kryptera dina filer efter första inloggingen efter att du satt kryptering.</text>
      <sha1>9ypoh25t4pnacek5nof4cg7duw6o71n</sha1>
    </revision>
  </page>
  <page>
    <title>Oxidized</title>
    <ns>0</ns>
    <id>94</id>
    <revision>
      <id>3049</id>
      <parentid>3048</parentid>
      <timestamp>2019-11-05T07:34:27Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Hooks */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8378">[https://github.com/ytti/oxidized Oxidized] är ett backup tool för nätverk devices. Alltså en ersättare till [[Rancid]]. Oxidized bygger också på perl men är lite mer modernare än Rancid.
Oxidized har ett eget webinterface med REST API stöd för att kunna söka, diffa och visa config.
Medans [[Rancid]] enbart kan använda en csv fil som source vad den ska backupa kan Oxidized även använda samma sorts fil, en SQL databas eller en websida med JSON tex [[LibreNMS]] API.

=Supportade OS=
* A0 Networks
** ACOS
* Alcatel-Lucent
** AOS
** AOS7
** ISAM
** TiMOS
** Wireless
* Arista
** EOS
* Arris
** C4CMTS
* Aruba
** AOSW
* Brocade
** FabricOS
** Ironware
** NOS (Network Operating System)
** Vyatta
* Ciena
** SOAS
* Cisco
** AireOS
** ASA
** IOS
** IOSXR
** NXOS
** SMB (Nikola series)
* Citrix
** NetScaler (Virtual Applicance)
* Cumulus
** Linux
* DataCom
** DmSwitch 3000
* DELL
** PowerConnect
** AOSW
* Ericsson/Redback
** IPOS (former SEOS)
* Extreme Networks
** XOS
** WM
* F5
** TMOS
* Force0
** DNOS
** FTOS
* FortiGate
** FortiOS
* HP
** Comware (HP A-series, H3C, 3Com)
** Procurve
* Huawei
** VRP
* Juniper
** JunOS
** ScreenOS (Netscreen)
* Mikrotik
** RouterOS
* Motorola
** RFS
* MRV
** MasterOS
* Netonix
** WISP Switch (As Netonix)
* Opengear
** Opengear
* Palo Alto
** PANOS
* Supermicro
** Supermicro
* Ubiquiti
** AirOS
** Edgeos
** EdgeSwitch
* Zyxel
** ZyNOS

=Installation=
''requires Ruby version &gt;= 2.0''
&lt;ul class="nav nav-tabs"&gt;
   &lt;li class="active"&gt;&lt;btn data-toggle="tab" class=""&gt;#tab1|CentOS 7&lt;/btn&gt;&lt;/li&gt;
   &lt;li&gt;&lt;btn data-toggle="tab" class=""&gt;#tab2|Ubuntu 16.04&lt;/btn&gt;&lt;/li&gt;
 &lt;/ul&gt;

 &lt;div class="tab-content"&gt;
   &lt;div id="tab1" class="tab-pane fade in active"&gt;
Skapa Oxidized användaren
 useradd -d /opt/oxidized oxidized
Installera EPEL och SCL
 yum install epel-release centos-release-scl-rh centos-release-scl
Installera Ruby samt extra paket för att kompilera Oxidized.
 yum install make cmake which sqlite-devel openssl-devel libssh2-devel gcc libicu-devel gcc-c++ rh-ruby26-ruby-devel rh-ruby26-ruby git
Installera Oxidized
 scl enable rh-ruby26 bash
 gem install oxidized
 gem install oxidized-script oxidized-web
Skapa en systemd fil åt Oxidized.
&lt;div class="panel-group" id="accordion"&gt;
 &lt;accordion parent="accordion" heading="/etc/systemd/system/oxidized.service"&gt;
&lt;syntaxhighlight&gt;
#For debian 8 put it in /lib/systemd/system/
#To set OXIDIZED_HOME instead of the default:
# ~${oxidized_user}/.config/oxidized in debian 8, then uncomment
#(and modify as required) the "Environment" variable below so
#systemd sets the correct environment. Tested only on Debian 8.8.
#YMMV otherwise.
#
#For RHEL / CentOS 7 put it in /etc/systemd/system/
#and call it with systemctl start oxidized.service
 
[Unit]
Description=Oxidized - Network Device Configuration Backup Tool
After=network-online.target multi-user.target
Wants=network-online.target
 
[Service]
ExecStart=/bin/scl enable rh-ruby26 /opt/rh/rh-ruby26/root/usr/local/bin/oxidized
User=oxidized
KillSignal=SIGKILL
Restart=always
RestartSec=20
#Environment="OXIDIZED_HOME=/etc/oxidized"
 
[Install]
WantedBy=multi-user.target
&lt;/syntaxhighlight&gt;
&lt;/accordion&gt;
&lt;/div&gt;
   &lt;/div&gt;
   &lt;div id="tab2" class="tab-pane fade"&gt;
 sudo add-apt-repository universe
 sudo apt-get -y install ruby ruby-dev libsqlite3-dev libssl-dev pkg-config cmake libssh2-1-dev libicu-dev zlib1g-dev g++
 sudo gem install oxidized
 sudo gem install oxidized-script oxidized-web

   &lt;/div&gt;
 &lt;/div&gt;

=Konfiguration=
Konfigurationen är på YAML-format. Default-konf finns i: '''/etc/oxidized/config''' och sedan används'''~/.config/oxidized/config'''

För att initiera oxidized i ditt home directory kör:
 mkdir -p ~/.config/oxidized
 oxidized
 nano ~/.config/oxidized/config

Man kan ändra var man vill att oxidized ska lägga sig genom att ändra environment variable
 OXIDIZED_HOME=/etc/oxidized

Logging
 log: "/home/$USER/.config/oxidized/oxidized.log"

==Input==
Input hämtar konfiguration från enheterna.
 input:
   default: ssh, telnet
   debug: false
   ssh:
     secure: false

==Source==
Source läser vilka enheter som ska konfigbackas. Oxidized har stöd för CSV, SQLite, MySQL och HTTP som source backends. 

===CSV===
CSV backend läser vilka enheter som det ska tas backup på från en rancid-kompatibel fil.
&lt;syntaxhighlight lang=yaml&gt;
 source:
   default: csv
   csv:
     file: "/home/$USER/.config/oxidized/router.db"
     delimiter: !ruby/regexp /:/
     map:
       name: 0
       model: 1
       username: 2
       password: 3
     vars_map:
       enable: 4
&lt;/syntaxhighlight&gt;
'''router.db''' &lt;br&gt;
Format: 0:1:2:3:4
 router01.example.com:ios:user:pw:enablepw
 172.20.0.1:ios:user:pw:enablepw
===HTTP===
HTTP backend behöver läsa en JSON hemsida.
&lt;syntaxhighlight lang=yaml&gt;
source:
  default: http
  debug: false
  http:
    url: https://url
    scheme: https
    map:
      name: hostname
      model: os
&lt;/syntaxhighlight&gt;
Exempel på JSON formatet om Oxidized behöver.
&lt;syntaxhighlight lang=json&gt;

] 
  {
    "group": "default",
    "hostname": "switch1",
    "ip": "192.168.1.11",
    "os": "junos"
  },
  {
    "group": "default",
    "hostname": "switch2",
    "ip": "192.168.1.12",
    "os": "xos"
  }
]
&lt;/syntaxhighlight&gt;

==Output==
Output lagrar konfigurationen. Man måste köra git för att få versionshantering på konfig-filerna.
 output:
   default: file
   file:
     directory: "/home/$USER/.config/oxidized/configs"
GIT
 output:
   default: git
   git:
       user: Oxidized
       email: oxidized@example.com
       repo: "/home/$USER/.config/oxidized/oxidized.git"

'''Exceptions''' &lt;br/&gt;
Man kan lägga in egna undantag för rader som ej borde vara med i konfigen, t.ex. rader med tidsstämplar som ändras ofta.

Exempel IOS, edit /var/lib/gems/2.3.0/gems/oxidized-0.21.0/lib/oxidized/model/ios.rb

&lt;syntaxhighlight lang="php"&gt;
  cmd 'show running-config' do |cfg|
    cfg = cfg.each_line.to_a[3..-1]
    cfg = cfg.reject { |line| line.match /^ntp clock-period / }.join
    cfg.gsub! /^Current configuration : [^\n]*\n/, ''
    cfg.gsub! /^! Last configuration change at [^\n]*\n/, ''
    cfg.gsub! /^! NVRAM config last updated at [^\n]*\n/, ''
    cfg.gsub! /^\ tunnel\ mpls\ traffic-eng\ bandwidth[^\n]*\n*(
                  (?:\ [^\n]*\n*)*
                  tunnel\ mpls\ traffic-eng\ auto-bw)/mx, '\1'
    cfg
  end
&lt;/syntaxhighlight&gt;

==Hooks==
Hooks kan användas för att kalla på script, skicka mail eller pusha mot git när något specifikt har hänt.
Mer info om Hooks samt fler exempel finns på deras [https://github.com/ytti/oxidized/blob/master/docs/Hooks.md hemsida]
===Events===
*&lt;code&gt;node_success:&lt;/code&gt; triggas när en lyckad backup har tagits och precis före configen sparas i oxidized.
*&lt;code&gt;node_fail:&lt;/code&gt; triggas efter en node har failat.
*&lt;code&gt;post_store:&lt;/code&gt; triggas efter en node config har sparats. Körs endast om configen har ändrats.
*&lt;code&gt;nodes_done:&lt;/code&gt; triggas efter oxidized gått igenom alla nodes.
===Push to GIT===
För att pusha till git måste man skapa en hook för det. Där man anger vilket repo samt en ssh key.
&lt;syntaxhighlight lang=yaml&gt;
hooks:
  push_to_remote:
    type: githubrepo
    events: [post_store]
    remote_repo: ssh://oxidized@github.com/hackernet-oxidized.git
    publickey: /opt/oxidized/.ssh/id_rsa.pub
    privatekey: /opt/oxidized/.ssh/id_rsa
&lt;/syntaxhighlight&gt;
===Maila om en node failar===
Om en node skulle faila med backupen skicka då ett mail.
&lt;syntaxhighlight lang=yaml&gt;
  email_output:
    type: exec
    events: [node_fail]
    cmd: '/opt/oxidized/.config/oxidized/extra/oxidized-report-git-commits | mail -s "Oxidized updates for ${OX_NODE_NAME}" hackernet@hackernet.se'
    async: true
    timeout: 120
&lt;/syntaxhighlight&gt;

==Execute==
För att starta oxidized och ta en första backup
 oxidized
RESTful web API
 rest: &lt;IP&gt;:8888

==Service==
Skapa en service med hjälp av [[Systemd]]. Om du installera Oxidized enligt denna guiden för CentOS använd isåfall systemd filen som angetts där. 
 sudo cat &lt;&lt;'__EOF__'&gt;&gt; /lib/systemd/system/oxidized.service
 [Unit]
 Description=Oxidized - Network Device Configuration Backup Tool
 
 [Service]
 ExecStart=/usr/local/bin/oxidized
 User=oxidized
 
 [Install]
 WantedBy=multi-user.target
 __EOF__

 sudo systemctl enable oxidized
 sudo systemctl start oxidized
 sudo systemctl status oxidized

[[Category:Guider]]</text>
      <sha1>k2jpkcj2idsy32rm761mwd3mw7us42r</sha1>
    </revision>
  </page>
  <page>
    <title>PSC</title>
    <ns>0</ns>
    <id>530</id>
    <revision>
      <id>2865</id>
      <timestamp>2018-09-26T17:07:05Z</timestamp>
      <contributor>
        <username>Kessemess</username>
        <id>15</id>
      </contributor>
      <comment>Created page with "Platform Services Controller tillhandahåller gemensamma tjänster för vSphere-miljön, däribland licensiering, certifikatshantering och autentisering via SSO.  == Arkitektu..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6714">Platform Services Controller tillhandahåller gemensamma tjänster för vSphere-miljön, däribland licensiering, certifikatshantering och autentisering via SSO.

== Arkitektur &amp; Komponenter ==
Vid installation av vCenter finns tre olika typer av deployment:
* vCenter with External PSC – vCenter installeras standalone och ansluts mot en standalone PSC.
* vCenter with Embedded PSC – vCenter och PSC deployas i samma maskin.
* PSC Only – Standalone-installation av PSC.
PSC-gränssnittet nås via https://IP_or_FQDN/psc

=== PSC Features ===
* Hanterar och genererar SSL-certifikat till vSphere-miljön.
* Lagrar och replikerar licensnycklar.
* Lagrar och replikerar permissions via Global Permissions-lagret.
* Hanterar lagring och replikering av Tags och Categories.
* Inbyggd automatisk replikering mellan SSO-siter (om de finns).

=== vCenter Single Sign-On ===
vCenter SSO består av Secure Token Service (STS), Administration server, VMware Directory Service (vmdir) och Identity Management Service.
* STS – Delar ut Security Assertion Markup Language (SAML) tokens. Dessa tokens representerar en användares identitet efter denne autentiserat genom en identitetskälla (t ex LDAP). SAML tokens möjliggör att användaren slipper autentisera om sig för de olika vCenter-tjänster som stöds av SSO.
* Administration Server - Används för att konfigurera SSO-servern, initialt kan endast administrator@your_domain_name användas för detta. Fr o m vSphere 6.0 kan detta domännamn sättas till någon annat än vsphere.local, använd dock inte samma namn som din AD- eller OpenLDAP-domän.
* VMware Directory Service (vmdir) - vmdir är den katalogtjänst som associeras med SSO-domänen som skapas vid deployment. I miljöer med flera PSC:er propageras förändringar i en vmdir-instans till övriga instanser. Vmdir lagrar förutom vCenter SSO-information även certifikatsinformation. PSC Sites kan även skapas i vmdir, en logisk container för gruppering av PSC-instanser i en SSO-domän.
* Identity Management Service – Hanterar identitetskällor och STS authentication requests. 
Med hjälp av SSO kan de olika komponenterna i vSphere kommunicera med varandra genom samma secure token-mekanism. I vCenter SSO autentiseras mänskliga användare via AD eller OpenLDAP, medan solution users autentiseras med hjälp av certifikat.

=== Användare (SSO) ===
För att lägga till/ta bort/aktivera/inaktivera SSO-användare gå till '''Administration''' -&gt; '''SSO''' -&gt; '''Users and groups''' -&gt; Högerklicka på användaren -&gt; '''Edit'''/'''Disable'''/'''Enable'''/'''Unlock'''.

=== Grupper (SSO) ===
Administrators – Globala rättigheter till SSO och hela inventoryt. &lt;br /&gt;
CAAdmins – Kan managera VMCA. &lt;br /&gt;
LicenseService.Administrator - Kan managera licenser. 

=== SSO Policies ===
Policies för Passwords, Lockout och Tokens hanteras via '''Home''' -&gt; '''Administration''' -&gt; '''SSO''' -&gt; '''Configuration''' -&gt; '''Policies'''-fliken. För att t ex ändra till att lösenord aldrig upphör, editera Password Policy:n och sätt Maximum lifetime till 0.

=== VMware Certificate Authority (VMCA) ===
VMCA tillhandahåller och provisionerar alla nödvändiga certifikat för vCenter och ESXi, och är en del av PSC. 
VMware rekommenderar att antingen använda default-inställningarna, dvs att VMCA hanterar alla certifikat, eller VMCA default certificates med externa SSL-cert; Hybrid Mode. Hybrid mode innebär att PSC och vCenter-certifikaten byts ut och att VMCA  får hantera certifikat för solution users och ESXi-hostar.
VMware Endpoint Certificate Store (VECS) kallas det repository där alla custom-certifikat lagras. Om custom-certifikat på ESXi-hostar ska användas, lagras de lokalt på hosten, inte i VECS.

För att se vilka certifikat som används av vCenter, gå till '''Home''' -&gt; '''System Configuration''' -&gt; '''Nodes''' -&gt; '''vCenter-noden''' -&gt; '''Manage''' -&gt; '''Certificate Authority'''. Om du inte har tillgång till denna vy, lägg till din användare i CAAdmins-gruppen.

=== Licenshantering ===
Licenshantering i vSphere-miljön hanteras av VMware License Service, en del av PSC.

== Deployment ==
Det finns flera olika sätt att koppla samman vCenter och PSC.

=== Embedded Linked Mode ===
En topologi med flera vCenter Appliance:r, tillkom i 6.5U2, Windows Embedded PSC är inte supporterad för detta. Embedded Linked Mode möjliggör Enhanced Linked Mode mellan två eller flera (upp till 15) VCSA med Embedded PSC. Om vCenter HA används anses de tre noderna som en logisk vCenter-nod.
Denna deployment förenklar backup &amp; restore, då färre steg behöver genomföras. PSC HA förenklas också avsevärt, då behovet av lastbalanserare för PSC försvinner.
Embedded Linked Mode kan endast aktiveras under installation av VCSA, inte efteråt.

=== Enhanced Linked Mode ===
Enhanced Linked Mode länkar samman flera vCenter samt en eller flera PSC:er (ej embedded). Upp till 10 VCSA eller 8 Windows vCenter kan anslutas i en grupp. Anslutningen sker under installation, inte efter.

Utan lastbalanserare – I en deployment utan LB måste manuell failover till nästa PSC utföras i vCenter. Först avregistreras nuvarande PSC med &lt;code&gt;cmsso-util unregister&lt;/code&gt;, sedan pekas vCenter om med &lt;code&gt;cmsso-util repoint-psc&lt;/code&gt;. Om din topoplogi innehåller tre eller flera PSC:er kan en ringtopologi konfigureras för att garantera tillgänglighet då en instans fallerar. Detta görs genom att köra &lt;code&gt;/usr/lib/vmware-vmdir/bin/vdcrepadmin -f createagreement&lt;/code&gt; på den första och sista PSC-instansen som deployats.

Med lastbalanserare – Om LB används mellan vCenter(s) och PSC:erna sker failover automatiskt om en PSC blir oresponsiv. Detta kräver att alla PSC:er är antingen Appliance- eller Windows-baserade.

=== Multi-Site PSC-installation ===
I grova drag är det man behöver utföra: Installera PSC först, sedan vCenter som kopplas mot PSC. För flera PSC:er och vCenter; återupprepa tidigare steg. Alla efterföljande appliance:r efter den första PSC:en måste deployas med "Join an existing vCenter SSO Domain". Då blir PSC:erna replication partners och vCenter:na ansluts mot SSO-domänen.

Topologin kan ändras efter installation, från embedded till external (eller vice versa), så länge SSO-domänen inte ändras. En extern PSC bör användas då fler än en lösning med SSO-integration används, t ex vCenter + vRealize Automation. 

Nedan KB listar supporterade (även deprecated) topologier för PSC deployment:
https://kb.vmware.com/kb/2147672 

=== Uppgradera PSC ===
Om extern PSC används måste alla PSC-instanser uppgraderas i sekvens. Efter detta är gjort kan VCSA uppgraderas.

[[Category:VMware]]</text>
      <sha1>k47vaefdr7kyc4f1p8qyrwr1ekgn7p0</sha1>
    </revision>
  </page>
  <page>
    <title>PXE-Deploy</title>
    <ns>0</ns>
    <id>21</id>
    <revision>
      <id>1358</id>
      <parentid>1149</parentid>
      <timestamp>2015-12-10T17:48:30Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2919">[[Category:Guider]]
Preboot Execution Environment är en miljö som används för att boota datorer med hjälp av ett nätverkskort helt oberoende av lagringsenheter som hårddiskar eller installerade operativsystem. När du säger åt din maskin att PXE/Nätverksboota kommer den att skicka en DHCP-begäran som DHCP-servern kommer att svara på och det kommer att innehålla två speciella saker, en "next-server" och ett filnamn. "Next-server " är din TFTP-server och filen är det din server kommer att ladda ner och köra ifrån. Denna fil är vanligtvis en bootloader såsom pxelinux eller pxegrub. Se även [[IPXE]]

Valfri DHCP-server kan användas, det som ska pekas ut är tftp-servern. T.ex.
 next-server 192.168.0.100; filename "pxelinux.0";

Valfri tftp-server kan användas, den ska endast hålla filer. 

== Installation ==
Här följer ett exempel på en pxelinux-setup (ej [[TFTP]] eller [[ISC_DHCP|DHCP]]). Först gäller det att få tag på de nödvändiga filerna.
 apt-get -y install syslinux

== Konfiguration ==
 mkdir -p /tftpboot/pxelinux.cfg
 cp /usr/lib/syslinux/pxelinux.0 /tftpboot
 cp /usr/lib/syslinux/vesamenu.c32 /tftpboot/pxelinux.cfg
 cp /usr/lib/syslinux/pxechain.com /tftpboot/pxelinux.cfg
Sedan ska huvudkonf-filen skapas, här bestämmer man hur pxe:n ska se ut.
 cat&lt;&lt;'__EOF__'&gt;/tftpboot/pxelinux.cfg/default
 default vesamenu.c32
 background pxelinux.cfg/badass.png
 prompt 0
 timeout 0
 
 label First label
        kernel firstkernel
 
 label Second label
        kernel secondkernel
 __EOF__

Det som står efter kernel och initrd är sökvägar som är relativa till tftpboot

== Unattended ==
Vill man automatisera sina installationer kan man göra det med kickstart-filer. T.ex.
 label InstallServer1404
        kernel server1404/linux
        append ks=http://192.168.0.100/ks.cfg vga=normal initrd=server1404/initrd.gz ramdisk_size=16432 root=/dev/rd/0 rw  --

===Skapa ks-fil===
I många distar kan man köra följande: (in graphical environment)
 system-config-kickstart

===Kickstartfiler===
&lt;categorytree mode=pages hideroot=on&gt;Kickstart&lt;/categorytree&gt;
== Liveboot ==
Det går även att liveboota med PXE, då kan man använda en NFS-share. T.ex.
 LABEL Kali Live
 KERNEL kali/live/vmlinuz
 APPEND boot=live netboot=nfs nfsroot=192.168.0.100:/mnt/tftpboot/kali initrd=kali/live/initrd.img quiet splash --

== Flera PXE-servrar ==
Vill man hoppa till en annan PXE-server, t.ex. en windows.
 LABEL Jump to other PXE
 KERNEL pxelinux.cfg/pxechain.com
 APPEND 192.168.0.10::pxelinux.0

== Exempel på användbara verktyg att ha på en PXE ==
 LABEL Auto ^Nuke! DBAN No Questions Asked!
 KERNEL DBAN/DBAN.BZI
 APPEND nuke="dwipe --autonuke" silent
 
 
 label MemTest
 kernel memtest/mt86plus
 
 
 label GParted Live
 kernel gparted/vmlinuz
 append initrd=gparted/initrd.img boot=live config noswap noprompt nosplash netboot=nfs nfsroot=192.168.0.100:/mnt/tftpboot/gparted</text>
      <sha1>mg77uye3jije4zzrohgldzt545p8az8</sha1>
    </revision>
  </page>
  <page>
    <title>Pagespeed</title>
    <ns>0</ns>
    <id>28</id>
    <revision>
      <id>828</id>
      <parentid>496</parentid>
      <timestamp>2015-07-23T21:16:34Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3306">[[Category:Guider]]
PageSpeed är ett program utvecklat av Google för att göra internet lite snabbare. (https://developers.google.com/speed/pagespeed/)
Om man kollar på källkoden på Googles söksida ser man ett oläsligt hav av tecken, det är resultatet av PageSpeed på deras sida.
Det finns moduler för [[Nginx]] och [[Apache]]. (Pagespeed module is only available as source)

==Optimiseringsfilter==
Här följer en lista på några användbara filter:

# '''Local Storage Cache'''
This filter saves inlined resources to the browser's local storage (an HTML5 feature) on the first view of a page, and loads them from local storage on subsequent views rather than sending them (inline) again.

# '''Combine CSS'''
'Combine CSS' seeks to reduce the number of HTTP requests made by a browser during page refresh by replacing multiple distinct CSS files with a single CSS file, containing the contents of all of them. This is particularly important in old browsers, that were limited to two connections per domain. In addition to reduced overhead for HTTP headers and communications warm-up, this approach works better with TCP/IP slow-start, increasing the effective payload bit-rate through the browser's network connection.

# '''Pre-Resolve DNS'''
This can contribute significantly towards total page load time. This filter reduces DNS lookup time by providing hints to the browser at the beginning of the HTML, which allows the browser to pre-resolve DNS for resources on the page.

# '''Collapse Whitespace'''
The filter reduces the transfer size of HTML files by replacing contiguous whitespace with a single whitespace character. Because HTML is often formatted with extra whitespace for human readability or as an incidental effect of the templates used to generate it, this technique can reduce the number of bytes needed to transmit HTML resources.

# '''Lazyload Images'''
The lazyload_images filter defers loading of images until they become visible in the client's viewport or the page's onload event fires. This avoids blocking the download of other critical resources necessary for rendering the above the fold section of the page.

# '''Insert Google Analytics'''
The 'Insert Google Analytics' filter adds the basic Google Analytics javascript snippet to each HTML page. If the page already has a Google Analytics snippet inside &lt;head&gt; with the specified ID, then no additional snippet will be added. If another Google Analytics snippet is on the page with a different ID, then an additional snippet will be added with the ID specified in with AnalyticsID. In order to avoid any strange Google Analytics reporting, make sure that the ID specified in the configuration file matches the one used on your          site.

# '''Remove Comments'''
The remove_comments filter eliminates HTML comments, which are often used to document the code or to comment out experiments. Note that this directive applies only to HTML files. CSS comments are eliminated with the rewrite_css filter, and Javascript comments are eliminated with the rewrite_javascript filter.

==Nginx==

(Installation)

 server {
 ...
 pagespeed on;
 pagespeed RewriteLevel CoreFilters;
 pagespeed FileCachePath "/var/cache/ngx_pagespeed/";
 pagespeed EnableFilters combine_css,remove_comments,collapse_whitespace;
 ...
 }</text>
      <sha1>dm7lzt0opyn0da8ji7rtog0ho1q5ioj</sha1>
    </revision>
  </page>
  <page>
    <title>PhpIPAM</title>
    <ns>0</ns>
    <id>225</id>
    <revision>
      <id>1790</id>
      <parentid>1599</parentid>
      <timestamp>2016-05-20T14:45:55Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3107">[http://phpipam.net/ phpIPAM] är en IPAM-lösning som har stöd för bl.a. subnet scanning, IPv4/IPv6, AD/LDAP, VLAN, VRF, mail notifications.

=Installation=
''Ubuntu 16.04'' &lt;br/&gt;
'''Apache'''
 sudo apt-get -y install apache2
'''MySQL'''
 sudo apt-get -y install mysql-server
 mysql_secure_installation
'''PHP'''
 sudo apt-get -y install php7.0 libapache2-mod-php7.0 &amp;&amp; sudo systemctl restart apache2
 sudo apt-get -y install php7.0-cli php7.0-curl php7.0-gmp php7.0-json php7.0-ldap php7.0-mcrypt php7.0-mysql php7.0-xml php-pear &amp;&amp; sudo systemctl restart apache2

Ladda ner tarball från hemsida.
 wget https://sourceforge.net/projects/phpipam/files/phpipam-1.2.1.tar
Packa upp och lägg i directory för webbservern.
 sudo tar -xf phpipam-1.2.1.tar -C /var/www/
 sudo rm /var/www/html/index.html &amp;&amp; sudo mv /var/www/phpipam/* /var/www/html/
 sudo cp /var/www/html/config.dist.php /var/www/html/config.php
 sudo a2enmod rewrite &amp;&amp; sudo service apache2 restart

Nu kan man göra resten i webgui. ''http://&lt;IP&gt;/'' &lt;br/&gt;
Om något fattas eller är fel möts man av ett felmeddelande som berättar vad som är fel. T.ex. om man har lagt siten i en undermapp, http://&lt;IP&gt;/phpipam/, måste man konfa om config.php och .htaccess (trailing slash viktigt). 

Välj: ''Automatic database installation'' och använd root-kontot.

Följ sedan instruktionerna, logga in.

=Konfiguration=
===CLI===
Eftersom allt ligger i en SQL-databas kan man använda vanlig SQL-syntax för att manipulera datan. 
 use phpipam;
VLAN
 insert into vlans (name,number,description) values("Client", "1338", "Klient-vlan") 
VRF
 insert into vrf (name,rd,description) values("vrf2", "11:22", "bla2") 

===Pretty links===
Gör att din URL ser bättre ut. rewrite måste vara påslaget i apache för att det ska fungera.
*No: ?page=administration&amp;link2=settings
*Yes: /administration/settings/

Ändra base i '''config.php''' filen för phpIPAM. (Om phpipam ligger i rooten på webbservern så kan du skippa detta steg.)
 define('BASE', "/phpipam/");

Slå på rewrite i apache.
 a2enmod rewrite

Lägg till följande rader i apache confen. 
 ...
 Options FollowSymLinks
 '''AllowOverride all'''
 Order allow,deny
 Allow from all
 ...

Sätt på pretty links under '''Administration &gt; phpIPAM settings''' eller ändra i databasen.
 use phpipam;
 update settings set prettyLinks='Yes/No' where settings.id=1;

===AD===
Inlogg mot AD.

===[[Apache#SSL|HTTPS]]===
Aldrig fel med SSL.
 sudo a2enmod ssl &amp;&amp; sudo a2ensite default-ssl &amp;&amp; sudo systemctl restart apache2

===SMTP===

==Backup==
DB-backup kan schemaläggas med [[cron]]
 # Backup IP address table, remove backups older than 30 days
 @daily /usr/bin/mysqldump -u root -pPASSWORD phpipam &gt; /var/www/html/db/bkp/phpipam_bkp_$(date +"\%y\%m\%d").db
 @daily /usr/bin/find /var/www/html/db/bkp/ -ctime +30 -exec rm {} \;

===Restore===
Dra upp en ny databas och läs in backupen.
 CREATE DATABASE `phpipam`;
 exit
 mysql -u root -p &lt; ./backupfile.sql
 GRANT ALL on `phpipam`.* to phpipam@localhost identified by 'ipamadmin';
Logga in med Admin/ipamadmin på webgui. 

[[Category:Guider]]</text>
      <sha1>r38d1kp30e9j5fmfgsw04ylwsmesu00</sha1>
    </revision>
  </page>
  <page>
    <title>Pi-hole</title>
    <ns>0</ns>
    <id>486</id>
    <revision>
      <id>3159</id>
      <parentid>2915</parentid>
      <timestamp>2022-05-27T06:36:43Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1177">Pi-hole är en färdig DNS server med inbyggd adblock och malware block.

Eftersom Pi-hole blockar reklam redan på DNS nivå så kommer det funka på '''alla enheter''' och appar i mobilen. Får man problem att använda någon sida så kan det därför vara bra att inaktivera Pi-hole en stund, det gör man visa WebUI.

* '''DNS over TLS (DoT)''' packages DNS transactions over a persistent TLS session over TCP
* '''DNS over QUIC (DoQ)''' packages DNS transactions over an encrypted QUIC session over UDP
* '''DNS over HTTPS (DoH)''' uses DNS over HTTP/3 (over QUIC) where supported, and DNS over HTTP2 (over TLS) otherwise

=Installation=
Pi-Hole går att installera på bla '''Ubuntu, Debian, CentOS, Fedora'''. För att installera Pi-hole kör man deras script.
 curl -sSL https://install.pi-hole.net | bash

Uppdatera sedan din DHCP server så att den skickar ut Pi-Hole serverns IP adress som DNS server.

==Uppgradera==
Kör följande kommando för att uppgradera Pi-hole:
 pihole -up
Dry-run
 pihole -up --check-only

=Konfiguration=
Pi-hole har ett webui för att kunna göra enklare inställningar. Det når man via:
 http://&lt;pi-hole IP&gt;/admin


[[Category:Guider]]</text>
      <sha1>t2irglx2kcoreutbqbnabawmizcxx2o</sha1>
    </revision>
  </page>
  <page>
    <title>Piwik</title>
    <ns>0</ns>
    <id>155</id>
    <revision>
      <id>1421</id>
      <parentid>1070</parentid>
      <timestamp>2016-01-07T01:49:28Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="671">Piwik är som Google Analytics fast open-source. Man kan låta dom hosta din Piwik eller hosta den själv.
Du kan tex få reda på vart dina besökare kommer ifrån hur dom kom ditt och hur många besökare du har just nu men det är bara några av sakerna du kan få reda på.

Hackernet's egna [https://piwik.hackernet.se Piwik].

== Förberedelse ==
Du behöver [[LAMP]] och en databas som Piwik kan använda.

== Installation ==
Ladda hem och packa upp piwik i din web-root.
 wget http://builds.piwik.org/piwik.zip &amp;&amp; unzip piwik.zip

Surfa sedan till &lt;code&gt;&lt;nowiki&gt;http://&lt;ip&gt;/piwik&lt;/nowiki&gt;&lt;/code&gt; och följ instruktionerna.

[[Category:Guider]] [[Category:Sparco]]</text>
      <sha1>nkbifcv5bs3p3aa418a5bwjyozoe4bg</sha1>
    </revision>
  </page>
  <page>
    <title>Pmacct</title>
    <ns>0</ns>
    <id>184</id>
    <revision>
      <id>1534</id>
      <parentid>1516</parentid>
      <timestamp>2016-03-08T18:36:13Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2330">Pmacct är ett verktyg för att samla ihop och aggregera data om IP-trafik, som t.ex. [[Ntopng]]. Det kan (med dess underkomponenter) samla in [[Cisco_SPAN|interface-trafik]] (libpcap), [[Cisco_NetFlow|NetFlow]], IPFIX, sFlow och ULOG. Man kan spara datan i minne, flat-files eller diverse databaser, t.ex. [[MySQL]], PgSQL, SQLite, MongoDB. pmacct kan användas för att skicka data till bl.a. RRDtool, Net-SNMP, MRTG och [[Cacti]]. Det går även att peera med routrar med [[Cisco_BGP|BGP]] eller [[Cisco_IS-IS|IS-IS]] för att få ut routinginformation (passiv granne, dvs annonserar aldrig något).

'''pmacct:''' commandline pmacct client, used to retrieve data from a memory plugin

'''pmacctd:''' libpcap-based accounting daemon, it captures packets from an interface it is bound to.

'''nfacctd:''' NetFlow accounting daemon, it listens for NetFlow packets v1/v5/v7/v8/v9 and IPFIX on one or more interfaces (IPv4 and IPv6).

=Installation=
''Ubuntu 15.10''
 sudo apt-get -y install pmacct
 pmacct -V
 sudo systemctl status pmacctd

Verifiering
 whereis pmacct
 whereis pmacctd
 whereis nfacctd

=Konfiguration=
==Inputs==
Välj en input
===libpcap===
 sudo ip link set up dev eth1
 sudo nano /etc/pmacct/pmacctd.conf
 daemonize: true
 promisc: true
 interface: eth1
Start
 sudo systemctl start pmacctd

===Netflow===
 sudo nano /etc/pmacct/nfacctd.conf
 nfacctd_port: 9999
 nfacctd_ip: 172.20.0.12
 nfacctd_time_new: true
Start
 sudo systemctl start nfacctd

===BGP===
 bgp_daemon: true
 bgp_daemon_ip: 172.20.0.12
 bgp_daemon_max_peers: 1
 bgp_table_dump_file: /etc/pmacct/output/bgp-$peer_src_ip-%Y_%m_%dT%H_%M_%S.txt
 bgp_table_dump_refresh_time: 3600

==Data==
Var ska datan lagras
===Memory===
 sudo mkdir /var/spool/pmacct/
''/etc/pmacct/**acctd.conf''
 imt_mem_pools_number: 0
 plugins: memory[plugin1]
 imt_path[plugin1]: /var/spool/pmacct/plugin1.pipe
 aggregate[plugin1]: proto, src_host, src_port, dst_host, dst_port
Kolla live
 pmacct -p /var/spool/pmacct/plugin1.pipe -s

===Flat-files===
 plugins: print

===MySQL===
Databas måste skapas först.
 plugins: mysql
 sql_db: pmacct
 sql_host: localhost
 sql_user: root
 sql_passwd: pmacct
 sql_refresh_time: 3600
 sql_history: 60m
 sql_history_roundoff: h
 sql_table_version: 1

===SQLite===
Databas måste skapas först.
 plugins: sqlite3

[[Category:Guider]]</text>
      <sha1>k4gx55oke5tvogbh2tnp03jvr45paxy</sha1>
    </revision>
  </page>
  <page>
    <title>PowerCLI</title>
    <ns>0</ns>
    <id>78</id>
    <revision>
      <id>3112</id>
      <parentid>3109</parentid>
      <timestamp>2021-03-10T08:07:54Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7361">[[Category:VMware]]
PowerCLI är ett Windows Powershell-gränssnitt för hantering av VMware vSphere. PowerCLI distribueras som en Powershell snapin, och innehåller över 370 Powershell-cmdlets för att hantera och automatisera vSphere och vCloud. 

"a powerful command-line tool that lets you automate all aspects of vSphere management, including network, storage, VM, guest OS and more" - VMware

==Installation==
Ladda ner installationsfilen från VMwares hemsida alternativt importera det från online repo. 
&lt;syntaxhighlight lang="powershell"&gt;
Install-Module -Name VMware.PowerCLI
Get-PowerCLIVersion
&lt;/syntaxhighlight&gt;

Anslut till din ESXi/vCenter med:
 Connect-VIServer

Untrusted certificate
 Set-PowerCLIConfiguration -InvalidCertificateAction ignore -confirm:$false

==Exempel==
Flytta alla vms från en datastore till en annan.
 Get-Datastore
 Get-VM -Datastore Datastore1 | Move-VM -Datastore Datastore2 -DiskStorageFormat thin

Flytta alla vms från en host till en annan.
 Get-VMHost 172.20.0.2 | Get-VM | Move-VM -destination 172.20.0.8

Visa alla '''notes'''
 Get-VM | Select-Object -ExpandProperty Notes

Lista '''hardware version''' för alla vms
 Get-VM | Select Name, Version

Ladda upp fil till datastore
 Copy-DatastoreItem -Item linux.iso -Destination vmstore:\DC\DATASTORE\linux.iso

Hitta vilken vm som har en viss '''MAC-adress'''
&lt;syntaxhighlight lang="powershell"&gt;
Get-vm | Select Name, @{N=“Network“;E={$_ | Get-networkAdapter | ? {$_.macaddress -eq “00:50:56:00:50:43“}}} |Where {$_.Network-ne “”}
&lt;/syntaxhighlight&gt;

Kolla '''NTP''' för hostarna
&lt;syntaxhighlight lang="powershell"&gt;
Get-VMHost | Sort-Object Name | Select-Object Name, @{N=”Cluster”;E={$_ | Get-Cluster}}, @{N=”Datacenter”;E={$_ | Get-Datacenter}}, @{N=“NTPServiceRunning“;E={($_ | Get-VmHostService | Where-Object {$_.key-eq “ntpd“}).Running}}, @{N=“StartupPolicy“;E={($_ | Get-VmHostService | Where-Object {$_.key-eq “ntpd“}).Policy}}, @{N=“NTPServers“;E={$_ | Get-VMHostNtpServer}}, @{N="Date&amp;Time";E={(get-view $_.ExtensionData.configManager.DateTimeSystem).QueryDateTime()}} | format-table -autosize
Get-VMHost | Get-VmHostService | Where-Object {$_.key -eq "ntpd"} | Set-VMHostService -policy "on"; Get-VMHost | Add-VMHostNtpServer -NtpServer 0.se.pool.ntp.org; Get-VMHost | Get-VMHostFirewallException | Where-Object {$_.Name -eq "NTP client"} | Set-VMHostFirewallException -Enabled:$true; Get-VMHost | Get-VmHostService | Where-Object {$_.key -eq "ntpd"} | Start-VMHostService
&lt;/syntaxhighlight&gt;

Lista CPUer
&lt;syntaxhighlight lang="powershell"&gt;
Get-VMHost | Sort Name | Get-View | Select Name, @{N=“CPU“;E={$_.Hardware.CpuPkg[0].Description}}
&lt;/syntaxhighlight&gt;

Byt från e1000 till vmxnet3
&lt;syntaxhighlight lang="powershell"&gt;
Get-VM -name "&lt;VM&gt;" | Get-NetworkAdapter | Where { $_.Type -eq "E1000"} | Set-NetworkAdapter -Type "vmxnet3"
&lt;/syntaxhighlight&gt;

Byt till multipathing på lun större än 1TB
&lt;syntaxhighlight lang="powershell"&gt;
Get-VMHost | Get-ScsiLun -LunType disk | Where {$_.MultipathPolicy -notlike "RoundRobin"} | Where {$_.CapacityGB -ge 1000} | Set-Scsilun -MultiPathPolicy RoundRobin
&lt;/syntaxhighlight&gt;

'''VLAN'''-hantering om man inte kör vDS. Create and delete.
&lt;syntaxhighlight lang="powershell"&gt;
Get-Datacenter -Name DC01 | Get-VMHost | Get-VirtualSwitch -name vSwitch1 | new-VirtualPortGroup -name "DMZ01" -vlanid 101
 
Get-Datacenter -Name DC01 | Get-VMHost | Get-VirtualSwitch -Name vSwitch1 | Get-VirtualPortGroup -Name "DMZ01" | Remove-VirtualPortGroup
&lt;/syntaxhighlight&gt;

Sätta '''Syslogserver'''
&lt;syntaxhighlight lang="powershell"&gt;
Get-VMHost | Get-VMHostSysLogServer
Get-Cluster cluster | Get-VMHost | Get-AdvancedSetting -Name Syslog.global.logHost | Set-AdvancedSetting -value "syslog.hackernet.se" -Confirm:$False
&lt;/syntaxhighlight&gt;

Lagra logg på persistant storage
 Get-Cluster cluster | Get-VMhost | Get-AdvancedSetting -Name Syslog.global.logDirUnique | Set-AdvancedSetting -Value $True -Confirm:$False
 Get-Cluster cluster | Get-VMHost | Get-AdvancedSetting -Name Syslog.global.logDir | Set-AdvancedSetting -value "[datastore] esxi_logs" -Confirm:$False

'''DNS'''
&lt;syntaxhighlight lang="powershell"&gt;
Get-VMHost | Select Name, @{N='DNS Server(s)';E={$_.Extensiondata.Config.Network.DnsConfig.Address -join ', '}} | FT -autosize
Get-VMHost | Get-VMHostNetwork -ErrorAction SilentlyContinue | Set-VMHostNetwork -DnsAddress @("10.240.100.81", "10.60.0.81")
&lt;/syntaxhighlight&gt;

Find '''Thick''' VM disks
&lt;syntaxhighlight lang="powershell"&gt;
 Get-Datastore | Get-VM | Get-HardDisk | Where {$_.storageformat -eq "Thick" } | Select Parent, Name, CapacityGB, storageformat | FT -AutoSize
&lt;/syntaxhighlight&gt;

==Script==
Ett script för att skapa vm. New-VM.ps1
&lt;syntaxhighlight lang="powershell"&gt;
#List functions first

function Gather-Info {
[string]$script:VMName = Read-host "Enter the name of the VM you wish to create"
Get-VMHost | Format-Wide
[string]$script:HOSTName = Read-host "Enter host"
Get-Datastore -VMHost $HOSTName | Format-Wide
[string]$script:DSName = Read-Host "Enter datastore"
[string]$script:VERSION = Read-Host "Enter VM-Version, exempel v9"
[int]$script:NUMCPU =  Read-Host "Antal CPU-cores" 
[int]$script:MEMORYMB =  Read-Host "RAM, Antal MB" 
[int]$script:DiskGB =  Read-Host "Disk, Antal GB"
Get-VirtualPortGroup -VMHost $HOSTName
[string]$script:NETWORK = Read-Host "Select Network"
[string]$script:NOTES = Read-Host "Notes"
[System.Enum]::GetNames([VMware.Vim.VirtualMachineGuestOsIdentifier]) | Format-Wide
[string]$script:GUESTID =  Read-Host "Select that guestid" 
}


function CreateVM {
Write-Host -ForegroundColor Green "Now the magic happens"
Write-Host "Creating VM"
New-VM -Name $VMName -VMHost $HOSTName -Datastore $DSName -DiskStorageFormat Thin -version $VERSION -GuestId $GUESTID -NumCpu $NUMCPU -MemoryMB $MEMORYMB -Notes $NOTES -DiskGB $DiskGB -NetworkName $NETWORK | out-null
Write-Host -ForegroundColor Green "Convert to vmxnet3?"
Get-VM $VMName | Get-NetworkAdapter | Set-NetworkAdapter -Type vmxnet3 | out-null
Start-Sleep -Seconds 1;
Write-Host "Starting the VM"
Start-vm -VM $VMName -runAsync
Start-Sleep -Seconds 1;
Write-Host -ForegroundColor Green "Power On Complete"
}


#Connect to vSphere
$VSPHERE = Read-host "Skriv IP till vCenter eller ESXi-host, tryck enter"
Connect-VIServer $VSPHERE


#Use functions and verify input
Do {
Gather-Info
Write-Host $VMName, $HOSTName, $DSName, HW $VERSION, $NUMCPU,vCPU $MEMORYMB,MB RAM $DiskGB,GB $NETWORK, $GUESTID, $NOTES
$confirmation = Read-Host "Proceed y/n"
}
until ($confirmation -eq 'y') 

CreateVM 
break
&lt;/syntaxhighlight&gt;

Script för att kolla disktyp. Disktype.ps1
&lt;syntaxhighlight lang="powershell"&gt;
Connect-viserver "VCENTER_NAME"  #ange namn på Vcenter
 
$report = @()
 
foreach ($vm in Get-VM ){
$vmhdd = $vm | Get-HardDisk
foreach ($vmdisk in $vmhdd){
  $diskStyle = $null
  $format = $vmdisk.StorageFormat

$list = '' | select Name,Cluster,VMDK,DiskMode,DiskFormat,Filename
$list.Name = $vm.Name
$list.Cluster = $vm.VMHost.Parent
$list.VMDK = $vmdisk.name
$list.DiskMode = $vmdisk.Persistence
$list.DiskFormat = $vmdisk.StorageFormat
$list.Filename = $vmdisk.filename

$report += $list
}}
$report | Sort Name | Export-Csv -NoTypeInformation -Path C:\temp\vm_disk_type.csv   #Här sätter du vart du vill spara filen, nu sparas den under C:\temp
&lt;/syntaxhighlight&gt;</text>
      <sha1>6v7fgfgp2t9on599vt12ff988s64mbh</sha1>
    </revision>
  </page>
  <page>
    <title>PowerDNS</title>
    <ns>0</ns>
    <id>269</id>
    <revision>
      <id>2755</id>
      <parentid>2754</parentid>
      <timestamp>2018-04-01T15:59:33Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Dynamic DNS */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19451">[[Category:Guider]]
PowerDNS är en open source DNS som skapades i slutet av 1990 talet. PowerDNS är väldigt anpassningsbart för man är inte bunden att använda enbart text filer utan man kan ha sina records i databaser också. Det har gjort att PowerDNS har blivit enkelt att integrera i andra tjänster som tex [[PhpIPAM]] och det finns ännu fler olika web interface på nätet. PowerDNS har också något dom kallar för en supermaster, som gör att nya zoner som skapas automatiskt finns på alla slavar. PowerDNS har också ett väldigt bra DNSSEC stöd och driver 90% av Europas DNSSEC domäner.

PowerDNS har delats upp i två delar, '''[https://www.powerdns.com/auth.html PowerDNS Authoritative Server]''' och '''[https://www.powerdns.com/recursor.html PowerDNS Recursor]'''.

=PowerDNS Authoritative Server=
Authoritative server är den sort DNS server som har hand om en domän. Klienter frågar denna servern för att få svar på sina DNS uppslag.  
==Termer==
'''Native replication''': PowerDNS kommer inte skicka ut eller agera vid en DNS update notification. Utan tar förgivet att backend systemet tar hand om replikeringen. Att låta databaser ta hand om replication har visat sig väldigt stabilt enligt PowerDNS även vid dålig anslutning. Native väljs default på nya zoner.

'''Master operation''': PowerDNS skickar ut notifikationer till sina slavar vid en zone ändring och sköter själv replikeringen till en slav server.

'''Slave operation''': Vid uppstart skickar PowerDNS en request till alla backends en lista med domäner som nyligen inte kollat om dom ändrats. Alla domäner som inte har senaste versionen kommer laddas ner.

'''Supermaster''': En supermaster automatiskt konfigurerar slavar med nya zoner när dom skapas. För att det ska fungera krävs bla att slaven vet om vem som är supermaster, supermastern har ett SOA record i domänen och att ett NS record måste finnas som stämmer överens med supermastern IP'n som konfigurerats på slaven.

&lt;ul class="nav nav-tabs"&gt;
   &lt;li class="active"&gt;&lt;btn data-toggle="tab" class=""&gt;#tab1|CentOS 7&lt;/btn&gt;&lt;/li&gt;
   &lt;li&gt;&lt;btn data-toggle="tab" class=""&gt;#tab2|Ubuntu 16.04&lt;/btn&gt;&lt;/li&gt;
 &lt;/ul&gt;

 &lt;div class="tab-content"&gt;
   &lt;div id="tab1" class="tab-pane fade in active"&gt;
Lägg till PowerDNS repo och installera epel samt yum priority plugin. 
 yum install epel-release yum-plugin-priorities
 curl -o /etc/yum.repos.d/powerdns-auth-master.repo https://repo.powerdns.com/repo-files/centos-auth-master.repo
Installera sedan PowerDNS servern. 
 yum install pdns
 &lt;/div&gt;

 &lt;div id="tab2" class="tab-pane fade"&gt;
Börja med att lägga till PowerDNS repot:
 echo "deb [arch=amd64] http://repo.powerdns.com/ubuntu xenial-auth-master main" &gt; /etc/apt/sources.list.d/pdns.list
Skapa sedan '''/etc/apt/preferences.d/pdns''' med följande innehåll:
 Package: pdns-*
 Pin: origin repo.powerdns.com
 Pin-Priority: 600
Kör sedan dessa kommandon:
 curl https://repo.powerdns.com/CBC8B383-pub.asc | sudo apt-key add - &amp;&amp;
 sudo apt-get update
Installera sedan PowerDNS servern.
 sudo apt-get install pdns-server
   &lt;/div&gt;
&lt;/div&gt;

Välj vilken backend du vill använda, olika backends har olika stöd se följande [https://doc.powerdns.com/md/authoritative/ lista].(Bind stöd är inbyggt)
 pdns-backend-geoip - geoip backend for PowerDNS
 pdns-backend-ldap - LDAP backend for PowerDNS
 pdns-backend-lua - Lua backend for PowerDNS
 pdns-backend-mydns - MyDNS compatibility backend for PowerDNS
 pdns-backend-mysql - generic MySQL backend for PowerDNS
 pdns-backend-pgsql - generic PostgreSQL backend for PowerDNS
 pdns-backend-pipe - pipe/coprocess backend for PowerDNS
 pdns-backend-remote - remote backend for PowerDNS
 pdns-backend-sqlite3 - sqlite 3 backend for PowerDNS
 pdns-backend-tinydns - tinydns compatibility backend for PowerDNS
{{ombox
|nocat=true
| type  = notice
| text  = Om du tänkt använda en databas som backend installera den först.
}}

==Konfiguration==
'''10.0.0.1''' Supermaster.hackernet.se

'''10.0.0.2''' ns1.hackernet.se

'''10.0.0.3''' ns2.hackernet.se

I guiden har vi valt att använda [[MySQL]] som backend. Och skapa en supermaster server som låter PowerDNS sköta replikeringen.
===Master===
Lägg in följande i &lt;code&gt;/etc/powerdns/pdns.conf&lt;/code&gt;:
 allow-recursion=0.0.0.0/0
 allow-axfr-ips=10.0.0.2/32,10.0.0.3/32
 also-notify=10.0.0.2,10.0.0.3
 config-dir=/etc/powerdns
 daemon=yes
 disable-axfr=no
 guardian=yes
 local-address=0.0.0.0
 local-port=53
 log-dns-details=on
 loglevel=3
 module-dir=/usr/lib/x86_64-linux-gnu/pdns/
 master=yes
 slave=no
 setgid=pdns
 setuid=pdns
 socket-dir=/var/run
 version-string=powerdns
 include-dir=/etc/powerdns/pdns.d
 launch=gmysql

I '''/etc/powerdns/pdns.d''' skapa filen &lt;code&gt;pdns.local.gmysql.conf&lt;/code&gt;. Om filen redan fanns gå till nästa steg.
 gmysql-host=localhost
 gmysql-port=
 gmysql-dbname=pdns
 gmysql-user=pdns
 gmysql-password=&lt;PaSSw0RD&gt;
 gmysql-dnssec=yes

Om filen skulle finnas med ett lösenord redan i så är det troligt att under installationen så skapades det en databas och fylldes med default tables. Ifall du behöver skapa tables själv så kör följande MySQL kommando för att skapa dom.
&lt;div class="toccolours mw-collapsible mw-collapsed" style="width:800px"&gt;
MySQL kommandon.
&lt;div class="mw-collapsible-content"&gt;
&lt;syntaxhighlight lang=mysql&gt;
CREATE TABLE domains (
  id                    INT AUTO_INCREMENT,
  name                  VARCHAR(255) NOT NULL,
  master                VARCHAR(128) DEFAULT NULL,
  last_check            INT DEFAULT NULL,
  type                  VARCHAR(6) NOT NULL,
  notified_serial       INT DEFAULT NULL,
  account               VARCHAR(40) DEFAULT NULL,
  PRIMARY KEY (id)
) Engine=InnoDB;

CREATE UNIQUE INDEX name_index ON domains(name);


CREATE TABLE records (
  id                    INT AUTO_INCREMENT,
  domain_id             INT DEFAULT NULL,
  name                  VARCHAR(255) DEFAULT NULL,
  type                  VARCHAR(10) DEFAULT NULL,
  content               VARCHAR(64000) DEFAULT NULL,
  ttl                   INT DEFAULT NULL,
  prio                  INT DEFAULT NULL,
  change_date           INT DEFAULT NULL,
  disabled              TINYINT(1) DEFAULT 0,
  ordername             VARCHAR(255) BINARY DEFAULT NULL,
  auth                  TINYINT(1) DEFAULT 1,
  PRIMARY KEY (id)
) Engine=InnoDB;

CREATE INDEX nametype_index ON records(name,type);
CREATE INDEX domain_id ON records(domain_id);
CREATE INDEX recordorder ON records (domain_id, ordername);


CREATE TABLE supermasters (
  ip                    VARCHAR(64) NOT NULL,
  nameserver            VARCHAR(255) NOT NULL,
  account               VARCHAR(40) NOT NULL,
  PRIMARY KEY (ip, nameserver)
) Engine=InnoDB;


CREATE TABLE comments (
  id                    INT AUTO_INCREMENT,
  domain_id             INT NOT NULL,
  name                  VARCHAR(255) NOT NULL,
  type                  VARCHAR(10) NOT NULL,
  modified_at           INT NOT NULL,
  account               VARCHAR(40) NOT NULL,
  comment               VARCHAR(64000) NOT NULL,
  PRIMARY KEY (id)
) Engine=InnoDB;

CREATE INDEX comments_domain_id_idx ON comments (domain_id);
CREATE INDEX comments_name_type_idx ON comments (name, type);
CREATE INDEX comments_order_idx ON comments (domain_id, modified_at);


CREATE TABLE domainmetadata (
  id                    INT AUTO_INCREMENT,
  domain_id             INT NOT NULL,
  kind                  VARCHAR(32),
  content               TEXT,
  PRIMARY KEY (id)
) Engine=InnoDB;

CREATE INDEX domainmetadata_idx ON domainmetadata (domain_id, kind);


CREATE TABLE cryptokeys (
  id                    INT AUTO_INCREMENT,
  domain_id             INT NOT NULL,
  flags                 INT NOT NULL,
  active                BOOL,
  content               TEXT,
  PRIMARY KEY(id)
) Engine=InnoDB;

CREATE INDEX domainidindex ON cryptokeys(domain_id);


CREATE TABLE tsigkeys (
  id                    INT AUTO_INCREMENT,
  name                  VARCHAR(255),
  algorithm             VARCHAR(50),
  secret                VARCHAR(255),
  PRIMARY KEY (id)
) Engine=InnoDB;

CREATE UNIQUE INDEX namealgoindex ON tsigkeys(name, algorithm);
&lt;/syntaxhighlight&gt;
&lt;/div&gt;
&lt;/div&gt;


Ta bort &lt;code&gt;pdns.simplebind.conf&lt;/code&gt; om du inte tänkt använda bind som backend.


Starta sedan om PowerDNS tjänsten.
 service pdns restart
===Slave===
Gör exakt samma på slaven med databasen fast lägg in följande i &lt;code&gt;pdns.conf&lt;/code&gt; istället:
 allow-recursion=0.0.0.0/0
 config-dir=/etc/powerdns
 daemon=yes
 disable-axfr=yes
 guardian=yes
 local-address=0.0.0.0
 local-port=53
 log-dns-details=on
 loglevel=3
 module-dir=/usr/lib/x86_64-linux-gnu/pdns/
 master=no
 slave=yes
 slave-cycle-interval=60
 setgid=pdns
 setuid=pdns
 socket-dir=/var/run
 version-string=powerdns
 include-dir=/etc/powerdns/pdns.d
 launch=gmysql
Slaven kommer fråga supermastern efter ny zone update var 60 sekund. Vanligast är att mastern skickar ut en notifikation till slaven men om det skulle vara problem med anslutningen under den tiden så kommer slaven fråga mastern när dom kan nå varandra igen. 

Lägg till en supermaster för slaven.

Logga in på databasen med:
 mysql -u pdns -p

Byt till databasen:
 USE pdns;

Lägg in en rad i supermasters table:
 insert into supermasters values ('10.0.0.1', 'supermaster.hackernet.se', 'admin');

Lämna MySQL:
 exit;

Starta om PowerDNS:
 service pdns restart

==Skapa zone==
Skapa en zone med hjälp av '''pdnsutil''':
 pdnsutil create-zone hackernet.se supermaster.hackernet.se

Lägg till några '''A''' record:
 pdnsutil add-record hackernet.se supermaster A 10.0.0.1
 pdnsutil add-record hackernet.se ns1 A 10.0.0.2
 pdnsutil add-record hackernet.se ns2 A 10.0.0.3

Lägg till fler '''NS''' record:
 pdnsutil add-record hackernet.se @ NS ns1.hackernet.se
 pdnsutil add-record hackernet.se @ NS ns2.hackernet.se

Ändra zonen från native zone till master zone.
 pdnsutil set-kind hackernet.se master

Verifiera att zonen är master:
 pdnsutil show-zone hackernet.se

Skicka ut en notifikation med mastern eller vänta tills slaven själv hämtar zonen:
 pdns_control notify hackernet.se

==Säkra upp zonetransfer==
Man kan säkra upp zonetransfer med hjälp av en TSIG nykel.

Börja med att generera en TSIG nyckel på master servern.
 pdnsutil generate-tsig-key tsig-transfer hmac-sha512

Aktivera sedan nykel på det zoner du vill säkra upp.
 pdnsutil activate-tsig-key hackernet.se tsig-transfer master

Lista sedan TSIG nykeln så du kan kopiera den till slaven.
 pdnsutil list-tsig-keys

Importera nyckeln på slaven.
 pdnsutil import-tsig-key tsig-transfer hmac-sha512 'Långsuperhackerkod'

Aktivera sedan TSIG nykeln på samma zoner som på mastern.
 pdnsutil activate-tsig-key hackernet.se tsig-transfer slave

'''Att tänka på:''' Det är viktigt att nyckeln har samma namn på både mastern och slaven.

=PowerDNS Recursor=
Skickar vidare din fråga till olika DNS servrar tills den hittar svaret.
==Installation==
'''Debian/Ubuntu'''
 apt-get install pdns-recursor

==Konfiguration==
Recursor är väldigt simpelt att konfigurera upp. Om man vill köra recursor och authoritative på samma server så behöver man byta vilken port recursor lyssnar på. Och sedan skicka vidare svar från authoritative servern som den inte kan svara på.

'''recursor.conf'''
 forward-zones=8.8.8.8,8.8.4.4
 trace=on

===Recursor och authoritative===
Lägg till följande rad i '''pdns.conf''':
 recursor=127.0.0.1:5678

Och ändra vilken port recursor lyssnar på i '''recursor.conf''':
 local-port=5678

Var noga med att peka på rätt port så att du inte pekar tillbaka på authoritative servern för då kommer man få en loop.

=DNSSEC=
DNSSEC är en funktion som signerar DNS-uppslagningar med krypto nycklar så att man kan säkerställa att det svaret man fått kommit från rätt källa, och inte manipulerats på vägen.
Med DNSSEC skyddas du från bland annat cacheförgiftning och pharming som är dom vanligaste attackerna. 

För att sätta på DNSSEC:
 pdnsutil secure-zone ZONE

För att stänga av DNSSEC:
 pdnsutil disable-dnssec ZONE

Kör sedan följande kommando för visa dina DS record:
 pdnsutil show-zone ZONE

Outputen du är intresserad av är i slutet och ser ut som följande:
 ...
 DS = hackernet.se. IN DS 17379 13 1 75a7f4a06792509298bfb0996df3614b129a6570 ; ( SHA1 digest )
 DS = hackernet.se. IN DS 17379 13 2 c72f7424c86a46866499ae284bec1b55095ca32e0f6955a9a9ba21df5d010d57 ; ( SHA256 digest )
 ...

Formatet för ett DS record är:
 DS = &lt;zone name&gt; IN DS &lt;key tag&gt; &lt;dnskey algo&gt; &lt;digest type&gt; &lt;key digest&gt;

Det din domän återförsäljare kommer vara intresserad av för att kunna uppdatera din Top-level domain är:
*Key tag: 17379
*DNSKEY Algorithm: 13 (ECDSAP256SHA256)
*Digest Type: 1 (SHA-1)
*Key Digest: 75a7f4a06792509298bfb0996df3614b129a6570

=Dynamic DNS=
Gör att en DHCP server automatiskt uppdaterar båda din forward och reverse zone när den tilldelar en enhet en IP, då slipper man själv uppdatera zoner.

DDNS stöds bara av följande backends
*gmysql
*gpgsql
*gsqlite3
*goracle
*godbc

Börja med att generera en TSIG nykel som kommer användas för att göra uppdateringen säkrare:
 pdnsutil generate-tsig-key ddns_update hmac-sha512

Aktivera nykeln på dom domäner du vill uppdatera.
  pdnsutil set-meta hackernet.se TSIG-ALLOW-DNSUPDATE ddns_update

Tillåt enbart vissa nät att få uppdatera zonen.
 pdnsutil set-meta hackernet.se ALLOW-DNSUPDATE-FROM 192.168.1.0/24
 pdnsutil set-meta hackernet.se ALLOW-DNSUPDATE-FROM 10.100.0.0/24

Se till så att mastern skickar en notification till slavarna vid varje uppdatering. Annars får man vänta tills slaven själv frågar mastern.
 pdnsutil set-meta hackernet.se NOTIFY-DNSUPDATE 1

Lägg sedan till följande rad i '''pdns.conf'''
 dnsupdate=yes

Starta om PowerDNS, för att verifiera att det funkar kan du köra följande kommando:

 nsupdate &lt;&lt;!
 server &lt;ip&gt; &lt;port&gt;
 zone hackernet.se
 update add ddnstest.hackernet.se 3600 A 10.13.37.1
 key ddns_update &lt;lång nykel&gt;
 send
 ! 

Om det funkar kommer ett record i hackernet.se zonen att skapas som heter ddnstest. Repitera på fler domäner samt reverse zoner om sådana finns. Samma nykel kan användas på alla zoner om man vill. 

=====dhcpd=====
Konfigurera din DHCP server att använda nykeln och det namn du valt på nykeln i detta fallet '''ddns_update'''. 

Under här kommer ett exempel för [[ISC_DHCP]].

Skapa en fil som heter ddns.key med följande innehåll under '''/etc/dhcp/''':
 key "ddns_update" {
         algorithm hmac-sha512;
         secret "&lt;lång nykel&gt;";
 };

Lägg sedan in följande rader i DHCP conf filen:
 ddns-updates on;
 ddns-update-style interim;
 update-static-leases on;
 
 ddns-domainname "hackernet.se";
 ddns-rev-domainname "in-addr.arpa.";
 
 include "/etc/dhcp/ddns.key";
 zone hackernet.se {
     primary 127.0.0.1;
     key ddns_update;
 }
 
 zone 0.168.192.in-addr.arpa. {
     primary 127.0.0.1;
     key ddns_update;
 }

Byt ut 127.0.0.1 mot din primära dns server.

Starta om DHCP servern.

=Tools=
Det finns massa olika verktyg för PowerDNS tex kraftiga webinterface och cli verktyg.

==PDNS Manager==
Ett enkelt webinterface där du kan skapa nya zoner, records och som har stöd för att signa certifikat med [[Let's Encrypt]] och ett API.

https://pdnsmanager.lmitsystems.de/

==Poweradmin==
Ett webinterface som också kan skapa zoner och records men har även ett bättre stöd för användare där man kan ställa in permissions på vilka domäner som en användare får ändra i. Och har stöd för att LDAP koppla användare.

http://www.poweradmin.org/

==pdnsutil==
Är ett CLI verktyg för PowerDNS. Där man i stort sett kan göra allt på zoner tex generera och lägga till tsig nycklar, migrera backend lösning, benchmarka backend delen och mycket mer.

'''Skapa en native zone''':
 pdnsutil create-zone hackernet.se

'''Skapa en native zone med ett NS record''':
 pdnsutil create-zone hackernet.se ns1.hackernet.se

'''Skapa en slave zone där IP'n i slutet är master server''':
 pdnsutil create-slave-zone hackernet.se 10.0.0.1

'''Editera en zone''':
 pdnsutil edit-zone hackernet.se

'''Skapa ett NS record''':
 pdnsutil add-record hackernet.se @ NS ns1.hackernet.se

'''Skapa ett record''':
 pdnsutil add-record hackernet.se ns1 [A/AAAA/MX/CNAME/...] 10.0.0.2

'''Lista alla zoner''':
 pdnsutil list-all-zones

'''Ändra zone operation''':
 pdnsutil set-kind hackernet.se master/native/slave

'''Tillåt alla IP's som är inlagda som en namnserver för domänen att göra zone transfers''':
 pdnsutil set-meta hackernet.se ALLOW-AXFR-FROM AUTO-NS

'''Öka SOA serial med 1''':
 pdnsutil increase-serial hackernet.se

==pdnscat==
pdnscat är ett bash script som hämtar alla records genom PowerDNS API och gör så att man kan greppa på records. När man filtrerat ner till ett resultat så kan man välja att SSHa mot det recordet med förinställda username som root, admin och den användaren du är.

'''Curl''' och '''JQ''' behövs för att scriptet ska fungera.

 git clone https://github.com/Hackernet-se/pdnscat
 ./pdnscat arg1 arg2 arg3 ... [f] [a|r|q] ..."
====Exempel====
&lt;div class="panel-group" id="accordion"&gt;
 &lt;accordion parent="accordion" heading="Hitta alla DNS servrar."&gt;
&lt;syntaxhighlight&gt;
sparco@jumpgate:~$ y ns    
10.240.100.12   A       ns3
172.22.0.12     A       ns4
10.240.100.13   A       ns5
172.22.0.13     A       ns6
&lt;/syntaxhighlight&gt;
&lt;/accordion&gt;


&lt;div class="panel-group" id="accordion"&gt;
 &lt;accordion parent="accordion" heading="SSH till NS5"&gt;
&lt;syntaxhighlight&gt;
sparco@jumpgate:~$ y ns 5   
10.240.100.13   A       ns5
sparco@jumpgate:~$ y ns 5 r                                      
                                                                 
--- IP and hostname ---                                          
10.240.100.13                                                    
ns5                                                              
ssh root@10.240.100.13                                           
                                                                 
root@10.240.100.13's password:                                   
Welcome to Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-79-generic x86_64)
&lt;/syntaxhighlight&gt;
&lt;/accordion&gt;


&lt;div class="panel-group" id="accordion"&gt;
 &lt;accordion parent="accordion" heading="Filtrera ut alla records från en subdomän."&gt;
&lt;syntaxhighlight&gt;
sparco@jumpgate:~$ y rsg f
10.60.0.50      A       rsg-proxy.hackernet.se.
10.60.0.4       A       esxispa1-ilo.rsg.hackernet.se.
10.60.0.5       A       esxispa2-ilo.rsg.hackernet.se.
10.60.0.6       A       esxispa3-ilo.rsg.hackernet.se.
10.60.0.16      A       esxispa3.rsg.hackernet.se.
10.60.0.53      A       foreman.rsg.hackernet.se.
10.60.0.12      A       ilocz3128ldh5.rsg.hackernet.se.
10.60.0.5       A       ilocz3128ldje.rsg.hackernet.se.
10.60.0.6       A       ilocz3128ldjv.rsg.hackernet.se.
10.60.0.10      A       ilocz3128ldjy.rsg.hackernet.se.
10.60.0.11      A       ilocz3128ldkb.rsg.hackernet.se.
10.60.0.4       A       ilocz3128le5v.rsg.hackernet.se.
10.60.0.7       A       ilocz32025rlt.rsg.hackernet.se.
10.60.0.9       A       ilocz32025rma.rsg.hackernet.se.
10.60.0.8       A       iloczj2100hf4.rsg.hackernet.se.
&lt;/syntaxhighlight&gt;
&lt;/accordion&gt;

=Abbreviation=
'''AXFR'''= Är en full zone transfer som överför hela zonen.

'''IXFR'''= Är en incremental zone transfer som endast överför det som har förändrats.</text>
      <sha1>suj2erzqk4xfd8ni456q3fm6to3cine</sha1>
    </revision>
  </page>
  <page>
    <title>Prometheus</title>
    <ns>0</ns>
    <id>517</id>
    <revision>
      <id>3054</id>
      <parentid>3047</parentid>
      <timestamp>2019-11-13T18:18:55Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3601">[[Category:Guider]]

Prometheus is a an open source monitoring and alerting toolkit. Originally built by a couple of Soundcloud engineers to modernize monitoring.The core of Prometheus is a data model with time series data identified by metric name and key/value pairs and stored in a time series database.

Prometheus also includes:

* a flexible query language to leverage this dimensionality
* no reliance on distributed storage; single server nodes are autonomous
* time series collection happens via a pull model over HTTP
* pushing time series is supported via an intermediary gateway
* targets are discovered via service discovery or static configuration
* multiple modes of graphing and dashboarding 

==Hackernets Setup==

We are using a fairly simple setup with all prometheus components running in docker containers. Since Prometheus relies on pulling metrics via HTTP the data gathering and conversion to the correct metric format has to be done by components outside of Prometheus. We currently use different projects to gather data, but writing your own applications is very easy considering the extensive amount of language support that the Prometheus project has to offer.

'''Our containers:'''

&lt;syntaxhighlight lang=bash&gt;
[root@prometheus ~]# docker ps
CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS              PORTS                    NAMES
7e22a6c7bbc4        vmware_exporter      "/opt/vmware_exporte…"   8 days ago          Up 8 days           0.0.0.0:9272-&gt;9272/tcp   vmware_exporter
67c5bfbaa81b        blackbox_exporter    "/bin/blackbox_expor…"   9 days ago          Up 8 days           0.0.0.0:9115-&gt;9115/tcp   blackbox_exporter
c77043cc77fe        grafana/grafana      "/run.sh"                9 days ago          Up 8 days           0.0.0.0:80-&gt;3000/tcp     grafana
463e5b3663c7        prom/prometheus      "/bin/prometheus --c…"   2 weeks ago         Up 8 days           0.0.0.0:9090-&gt;9090/tcp   prometheus
809f4ab916c9        prom/node-exporter   "/bin/node_exporter"     2 weeks ago         Up 8 days           0.0.0.0:9100-&gt;9100/tcp   node_exporter
&lt;/syntaxhighlight&gt;
==Node Exporters==
===pfSense===
Följande är veriferat på pfsense 2.4.2 som kör FreeBSD 11.1.
Ändra till '''yes''' i följande 3 filer:
 vi /usr/local/etc/pkg/repos/FreeBSD.conf
 vi /usr/local/etc/pkg/repos/pfSense.conf               
 vi /etc/pkg/FreeBSD.conf
Installera sedan '''node_exporter'''
 pkg install node_exporter
Lägg sedan till så node_exporter startar vid omboot.
 echo "node_exporter_enable="YES"" &gt;&gt; /etc/rc.conf
Starta sedan tjänsten:
 service node_exporter start
Exportern går att nå på default porten 9100.

===Linux===
&lt;syntaxhighlight lang="Bash"&gt;
sudo useradd --no-create-home --shell /bin/false node_exporter &amp;&amp; \
wget https://github.com/prometheus/node_exporter/releases/download/v0.18.1/node_exporter-0.18.1.linux-amd64.tar.gz &amp;&amp; \
tar -xf node_exporter-0.18.1.linux-amd64.tar.gz &amp;&amp; sudo cp node_exporter-0.18.1.linux-amd64/node_exporter /usr/local/bin/ &amp;&amp; \
sudo chown node_exporter:node_exporter /usr/local/bin/node_exporter &amp;&amp; rm -rf node_exporter-0.18.1.linux-amd64* &amp;&amp; \
sudo bash -c "cat &lt;&lt;__EOF__&gt;&gt; /etc/systemd/system/node_exporter.service
[Unit]
Description=Node Exporter
Wants=network-online.target
After=network-online.target

[Service]
User=node_exporter
Group=node_exporter
Type=simple
ExecStart=/usr/local/bin/node_exporter

[Install]
WantedBy=multi-user.target
__EOF__"
sudo systemctl daemon-reload &amp;&amp; sudo systemctl start node_exporter &amp;&amp; sudo systemctl enable node_exporter
&lt;/syntaxhighlight&gt;</text>
      <sha1>11mtf3b5l31xzqyyjiri6n884raoukt</sha1>
    </revision>
  </page>
  <page>
    <title>Psql</title>
    <ns>0</ns>
    <id>556</id>
    <revision>
      <id>3056</id>
      <timestamp>2019-11-15T18:32:10Z</timestamp>
      <contributor>
        <username>Bat</username>
        <id>4</id>
      </contributor>
      <comment>Created page with "psql är terminalgränssnittet för att jobba mot PostgreSQL.  Dokumentation:  https://www.postgresql.org/docs/current/app-psql.html &lt;br/&gt;  Anslutning  psql -h värdnamn -d da..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="364">psql är terminalgränssnittet för att jobba mot PostgreSQL.

Dokumentation:  https://www.postgresql.org/docs/current/app-psql.html &lt;br/&gt;

Anslutning
 psql -h värdnamn -d databas -U användare -W
Lista Databaser
 \l 
Anslut till en specifik databas
 \c databas
Lista tabeller 
 \dt
Beskriv en tabell 
 \d tabellnamn
Visa kommandhistoriken
 \s

[[Category:Tools]]</text>
      <sha1>nvmne7uw6mcovby9e8n25dysm0mw29j</sha1>
    </revision>
  </page>
  <page>
    <title>Puppet</title>
    <ns>0</ns>
    <id>60</id>
    <revision>
      <id>1440</id>
      <parentid>1439</parentid>
      <timestamp>2016-01-14T15:37:05Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Klient */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8153">[[Category:Guider]] [[Category:Sparco]]
Puppet är ett automatiseringsverktyg för servrar. Puppet är ett väldigt kraftfullt verktyg, du kan få en fil att se likadan ut på 1000 olika servrar på bara 2 minuter eller att se till att SSH confen är den samma. Puppet kan köras i både Unix och Windows miljör. Många stora företag använder Puppet tex, Google, Twitter, Spotify, Dell. Puppet är mycket användbart om man har servrar med olika operativsystem. Skillnaderna mellan olika operativsystem spelar ingen roll, man kan sätta upp en huvudserver och lagra konfigurationer för alla servrar. Huvudservern kallas master och klienterna kör agenter. Klienterna ansluter regelbundet till mastern för att synkronisera sina konfigurationer och rapportera alla lokala ändringar tillbaka till mastern. Master måste vara av samma version eller nyare än de agenter som ansluter till den. Puppet finns i Enterprise eller som open source.

=Förberedelse=
Lägg in Puppets egna repos för att få tag på fler och senare versioner av Puppet.

Tanka hem och kör rätt deb paket från &lt;code&gt;https://apt.puppetlabs.com/&lt;/code&gt;

=Installation=
Det är viktigt att man kör samma version på puppet master och puppet agent för att inte få några kompatibilitets problem.

===Server===
==== Debian/Ubuntu ====
 sudo apt-get update &amp;&amp; sudo apt-get -y upgrade &amp;&amp; sudo apt-get -y install puppetmaster rdoc ntp
 sudo touch /etc/puppet/manifests/site.pp
==== CentOS/RedHat ====
 sudo yum update &amp;&amp; sudo yum install puppet-server ntp
 sudo touch /etc/puppet/manifests/site.pp 
===Klient===
 sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get -y install puppet ntp
 sudo yum update &amp;&amp; sudo yum install puppet ntp

=Namnuppslag=
Default för att hitta till mastern gör klienterna ett namnuppslag på ''puppet''. Sätt upp i din DNS så att puppet pekar mot mastern. T.ex. puppet.exempel.se. Sedan på klienten:
 echo "search exempel.se" | sudo tee -a /etc/resolv.conf
Om klienten använder DHCP kan det hända att resolv.conf skrivs över.&lt;br/&gt;
Testa
 ping puppet
Det måste också vara öppet för klienterna mot mastern på TCP 8140

=Konfiguration=
{| class="wikitable sortable"
|+Kommandotabell
!
Pre-2.6 
!
Post-2.6   
|-
|puppetmasterd   
|puppet master
|-
|puppetd
|puppet agent 
|-
|puppet 
|puppet apply 
|-
|puppetca
|puppet cert 
|-
|ralsh
|puppet resource 
|-
|puppetrun
|puppet kick
|-
|puppetqd 
|puppet queue 
|-
|filebucket 
|puppet filebucket  
|-
|puppetdoc
|puppet doc 
|-
|pi
|puppet describe 
|}

== Master ==
Konfigurations av puppet görs under &lt;code&gt;/etc/puppet/&lt;/code&gt;

Börja med att skapa ett CA cert för din master server.
Under &lt;code&gt;[main]&lt;/code&gt; i &lt;code&gt;puppet.conf&lt;/code&gt; lägg till,
 dns_alt_names = puppet,puppet.domän.se

Skapa sedan CA certet med kommandot,
 sudo puppet master --verbose --no-daemonize
När det står &lt;code&gt;Notice: Starting Puppet master version &lt;VERSION&gt;&lt;/code&gt; har certet skapats. Tryck ctrl-c för att stoppa.

=== Hiera ===
Är ett enklare sätt att konfigurera dina klienter på. Hiera följer med puppet och inget som ska behöva installeras. När man konfar sina noder med hiera använder man sig av yaml kod.

Skapa filen &lt;code&gt;site.pp&lt;/code&gt; i mappen &lt;code&gt;manifests&lt;/code&gt; och skriv,
 hiera_include('classes')

Skapa sedan filen &lt;code&gt;hiera.yaml&lt;/code&gt; i rooten av puppet och fyll den med,
&lt;syntaxhighlight lang="yaml"&gt;
 ---                                                                                                                                  
  :backends:                                                                                                                 
    - yaml
  :yaml:
    :datadir: /etc/puppet/hieradata
  :hierarchy:
    - "node/%{::fqdn}"
    - "os/%{::osfamily}"
    - common
  :logger:
    - puppet
&lt;/syntaxhighlight&gt;
Skapa sedan en mapp som heter &lt;code&gt;hieradata&lt;/code&gt; i rooten av puppet. I den mappen ska du skapa mapparna &lt;code&gt;node&lt;/code&gt; och &lt;code&gt;os&lt;/code&gt;.
I mappen &lt;code&gt;os&lt;/code&gt; kan du skapa en fil som heter tex &lt;code&gt;Ubuntu.yaml&lt;/code&gt;. Då kommer alla ubuntu maskiner få den confen som står där i.
I mappen &lt;code&gt;hieradata&lt;/code&gt; skapa en fil som heter &lt;code&gt;common.yaml&lt;/code&gt;. Confen som står i denna filen kommer alla noder att få.
Exempel conf på &lt;code&gt;common.yaml&lt;/code&gt; som kommer använda modulen utils och installera paketet vim och autofs.
&lt;syntaxhighlight lang="yaml"&gt;
 ---
 classes:
   -utils
 
 utils::packages:
   - vim
   - autofs
&lt;/syntaxhighlight&gt;
== Klient ==
Puppet agenten funkar direkt utan inställningar om man inte har ett annat FQDN på puppet master(se under). En sak man ska välja är om man vill köra puppet agent som ett cronjob eller som en service som hämtar ny conf automatiskt.

Har man ett annat FQDN på sin puppet master än puppet.domän.se bör man lägga till under &lt;code&gt;[main]&lt;/code&gt; i &lt;code&gt;/etc/puppet/puppet.conf&lt;/code&gt;
 server = FQDN

=== Cron job ===
För att köra puppet agent som ett cron job skriv följande.
 sudo puppet resource cron puppet-agent ensure=present user=root minute=30 command='/opt/puppet/bin/puppet agent --onetime --no-daemonize --splay --splaylimit 60'

=== Service ===
I filen &lt;code&gt;/etc/default/puppet&lt;/code&gt; ändra till &lt;code&gt;START=yes&lt;/code&gt;.
För att starta puppet agenten och att den autostartar vid omstart.
 sudo puppet resource service puppet ensure=running enable=true
Vill man ändra intervalen på hur ofta agenten frågar mastern efter ny conf. Default är 30 minuter, lägg till följande under &lt;code&gt;[agent]&lt;/code&gt; i &lt;code&gt;puppet.conf&lt;/code&gt;.
 runinterval = 2h

== Certifikat ==
All kommunikation görs med SSL och certifikat används för autentisering.&lt;br/&gt;
På klient:
 sudo puppet agent --waitforcert 120 --test
På master:
 sudo puppet cert list
 sudo puppet cert sign &lt;hostname&gt;

För att autosigna certifikat så lägg till detta under &lt;code&gt;[master]&lt;/code&gt; i &lt;code&gt;puppet.conf&lt;/code&gt; på din puppet master.
 autosign = true

Lista alla cert på puppet master:
 puppet cert list -a

Ta bort klient cert på puppet master:
 puppet cert clean &lt;hostname&gt;

=Moduler=
För att söka efter moduler till puppet använd [https://forge.puppetlabs.com/ forge].

Moduler installerar man på sin master och sedan använder tex hiera för att konfigurera sina klienter.

För att installera och ta bort moduler använd kommandot,
 puppet module install &lt;modulnamn&gt;
 puppet module uninstall &lt;modulnamn&gt;

Det är viktigt att läsa readme filen om varje modul för att förstå hur den fungerar. Den finns under &lt;code&gt;/etc/puppet/modules/"modulnamn"/&lt;/code&gt;

Varje gång du ska använda en modul måste du kalla efter den tex under &lt;code&gt;classes:&lt;/code&gt; i hiera.


== Autofs ==
Modul som styr upp autofs mounts på din server.
 puppet module install EagleDelta2-autofs
Exempel conf för hiera.
&lt;syntaxhighlight lang="yaml"&gt;
 ---
 classes:
  - autofs
 
 mapOptions:
   backup:
     mount: '/opt'
     mapfile: '/etc/auto.backup'
     mapcontents:
       - 'backup -fstype=nfs,auto,rw,async,hard,intr 192.168.1.200:/mnt/zfs/Backup'
     options: '--timeout=60'
     order: 01
   home:
     mount: '/home'
     mapfile: '/etc/auto.home'
     mapcontents:
       - '* -fstype=nfs,user,auto,rw,async,hard,intr 192.168.1.200:/mnt/zfs/Home/&amp;'
     options: '--timeout=120'
     order: 02
&lt;/syntaxhighlight&gt;
Finns mer info att läsa om modulen på [https://forge.puppetlabs.com/EagleDelta2/autofs forge].

== Utils ==
Utils är en modul som installerar paket på en node. Den har stöd för följande operativsystem. RedHat, Windows, Ubuntu, Debian, Solaris, SLES, Scientific, CentOS, OracleLinux, AIX, SLED

 puppet module install ghoneycutt-utils
Exempel conf för hiera.
&lt;syntaxhighlight lang="yaml"&gt;
 ---
 classes:
  - utils
 
 utils::packages:
  - vim
  - fail2ban
  - apache2
&lt;/syntaxhighlight&gt;
Mer om modulen finns på [https://forge.puppetlabs.com/ghoneycutt/utils forge].

== Rsyslog ==
 puppet module install saz-rsyslog
Exempel conf för hiera.
&lt;syntaxhighlight lang="yaml"&gt;
 ---
 classes:
  - rsyslog::client
 
 rsyslog::client::server: '192.168.1.205'
&lt;/syntaxhighlight&gt;
Mer om modulen finns på [https://forge.puppetlabs.com/saz/rsyslog forge].</text>
      <sha1>cxrvb0htm2ezpwv10hv6ufhr9itj8sr</sha1>
    </revision>
  </page>
  <page>
    <title>Python</title>
    <ns>0</ns>
    <id>136</id>
    <revision>
      <id>3108</id>
      <parentid>3107</parentid>
      <timestamp>2021-01-25T17:11:31Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* PIP */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3876">Python är ett objektorienterat programspråk som siktar på att vara funktionellt och lättläst. 

==Installation==
Python följer med de flesta linux-distar.
 python -V

'''Pydoc''' &lt;br/&gt;
Läsa hjälpfiler om moduler, klasser och funktioner.
 pydoc &lt;namn&gt;
 pydoc open
 pydoc file
 pydoc os

Manuellt ta reda på möjliga funktioner/methods i ett library. 
 dir()
 dir(''library'')

==Virtualenv==
Virtualenv är ett verktyg för att skapa isolerade Python environments. Det skapar ett directory som innehåller alla nödvändiga executables för att köra Python-projektet. Man kan sedan installera python-paket oberoende av övriga system. Virtualenvwrapper tillhandahåller ett gäng verktyg för att enklare jobba med virtualenv.

Setup
 sudo pip install virtualenvwrapper
 echo '. /usr/local/bin/virtualenvwrapper.sh' &gt;&gt; .bashrc &amp;&amp; source .bashrc

Jobba med virtualenv
 mkvirtualenv test
 deactivate
 lsvirtualenv
 workon test

==PIP==
PIP är ett package management system som används för att installera software packages skrivna i Python.
 sudo pip install &lt;package&gt;
Eller för att installera ett pip paket i din egen home folder kan du skriva 
 pip install &lt;package&gt; --user

'''Exempel HTTP Server''' &lt;br/&gt;
Det finns flera olika webbservrar skrivna i python.
 sudo pip install lpthw.web
 import web

==Referenslista==
Här följer en lista på hur man gör diverse vanliga saker för den ovane. Detta utgår från python 2.7.

Variabel
 nummer = 102

Output, print från variabel
 print "The name is %s and %d." % (namn, nummer)

Input
 x = raw_input("&gt;&gt; ")
 x = int(raw_input("&gt;&gt; "))

Läsa fil
 filnamn = raw_input("&gt;&gt; ")
 fil = open(filnamn)
 print fil.read()

Skriva till fil
 fil = open(filename, 'w')
 line1 = raw_input("line 1: ")
 fil.write(line1)
 fil.close()

Definiera funktion och kalla på den.
 def funk1():
    print "Detta ar en funktion"
 
 funk1()

Return value
 def funk1(x):
    return x + 4
 
 value = funk1(20)

Avsluta, ctrl + d
 exit(0) # i script
 quit() # i cli

'''If_then_else'''
 print "Valj 1 eller 2"
 valet = raw_input("&gt;&gt; ")
 
 if valet == "1":
    print "You is 1"
 elif valet == "2":
    print "You is 2"
 else:
    print "You die"

'''For-loop'''
 the_count = [1, 2, 3, 4, 5]
 for number in the_count:
    print "This is %d" % number

'''Lista'''
 lista = [1, 2, 3, 4, 5, 6, "hest" ];
 print lista[0:2]
 lista[2] = 20;
Append

'''Dictionary'''
 dict = {'Name': 'Sara', 'Age': 20, 'Class': 'No'};
 print dict['Name']
 dict['Age'] = 21;
Add new entry
 dict['School'] = "Yes";

'''Password''' &lt;br/&gt;
Get password, hidden
 import getpass
 secretx = getpass.getpass("Enter password:")

'''Grundläggande sanitetscheckar'''
 pip install pep8 pylint pyflakes
 
 pep8 the_script.py
 pylint the_script.py
 pyflakes the_script.py

==netaddr==
netaddr är ett network address manipulation library. Man kan jobba med IP-adresser och nät.
 sudo pip install netaddr
Usage
 from netaddr import *
 cidr = IPNetwork(raw_input("CIDR-notation: "))
 firstip = cidr[1]
 netmask = cidr.netmask

==OOP==
Python är ett Object Oriented Programming Language vilket innebär att man har stöd för att bygga objekt. Python är designat så att allting är ett objekt vilket t.ex. innebär att datatypen "string" i python också är ett objekt.
Exempel på hur man skapar en class och instansierar ett objekt.

 class VLAN:
     def __init__(self, id, name):
         self.id = id
         self.name = name
 
 vlan10 = VLAN(10, "Test")

==HTTP server==
Om man behöver sätta upp en http server snabbt o enkelt kan man göra det med Python.

Börja med att gå till det directory du vill dela ut.
 cd /home/sparco/secret-hackernet-stuff
Kör sedan följande kommando för att starta en python webserver som lyssnar på port 8000 på alla interface:

'''Python 2.7'''
 python -m SimpleHTTPServer
'''Python 3.X'''
 python -m http.server

[[Category:Guider]]</text>
      <sha1>crru0kdvwawkd18fdf5v1hnsm3mtsw8</sha1>
    </revision>
  </page>
  <page>
    <title>Quagga</title>
    <ns>0</ns>
    <id>217</id>
    <revision>
      <id>2581</id>
      <parentid>1613</parentid>
      <timestamp>2017-06-03T13:06:52Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2910">Quagga är en network routing software suite och har stöd för [[Cisco_OSPF|OSPF]], [[Cisco_BGP|BGP]], [[Cisco_RIP|RIP]] och [[Cisco_IS-IS|IS-IS]]. Konfigurationsyntaxen är generellt väldigt lik [[Cisco_IOS|Cisco IOS]]. Quagga har en core daemon som heter zebra och sedan klienter till det, ospfd, isisd, ripd, ospf6d, ripngd och bgpd. Zebra är en IP-routing manager som står för kommunikation med kernel, interface och redistribution mellan olika routingprotokoll.

=Installation=
Vill man ha senaste versionen kan man behöva ta ner paketet och installera manuellt annars funkar pakethanterare.
 dnf install quagga
 apt-get install quagga

Allow routing in os
 echo "net.ipv4.conf.all.forwarding=1" | sudo tee -a /etc/sysctl.conf 
 echo "net.ipv4.conf.default.forwarding=1" | sudo tee -a /etc/sysctl.conf
 sudo sysctl -p

=Konfiguration=
Slå på det som är önskvärt genom att editera daemons-filen.
 sudo nano /etc/quagga/daemons
Lägg sedan in grundkonf för zebra.
 sudo cp /usr/share/doc/quagga/examples/zebra.conf.sample /etc/quagga/zebra.conf
 sudo service quagga restart

File Permissions
 sudo chown quagga.quaggavty /etc/quagga/*.conf
 sudo chmod 640 /etc/quagga/*.conf

Zebra-only CLI
 telnet localhost zebra

'''VTYSH''', CLI som används för att sköta all quagga-konfiguration.
 sudo cp /usr/share/doc/quagga/examples/vtysh.conf.sample /etc/quagga/vtysh.conf
 sudo chown quagga:quaggavty /etc/quagga/vtysh.conf &amp;&amp; sudo chmod 660 /etc/quagga/vtysh.conf
 sudo su -
 export VTYSH_PAGER=more 
 vtysh
wr för att spara

==OSPF==
Se [[Cisco_OSPF|Cisco OSPF]] för mer info om OSPF.
 sudo cp /usr/share/doc/quagga/examples/ospfd.conf.sample /etc/quagga/ospfd.conf
 sudo nano /etc/quagga/ospfd.conf &amp;&amp; sudo service quagga restart
 hostname ospfd
 router ospf
  network 10.0.0.0/24 area 0
OSPF-only CLI
 telnet localhost ospfd
wr för att spara

==BGP==
Se [[Cisco_BGP|Cisco BGP]] för mer info om BGP.
 sudo cp /usr/share/doc/quagga/examples/bgpd.conf.sample /etc/quagga/bgpd.conf
 sudo nano /etc/quagga/bgpd.conf &amp;&amp; sudo service quagga restart
 hostname bgpd
 router bgp 100
  bgp router-id 10.0.0.1
  network 10.0.0.0/24
  neighbor 10.0.0.2 remote-as 100
BGP-only CLI
 telnet localhost bgpd
wr för att spara

===EVPN===
Ethernet VPN (RFC 7432) är en modernare variant än VPLS för att tillhandahålla Ethernet multipoint services över MPLS eller IP. Det är öppet så det finns interoperability med andra network vendors, se t.ex. [[Cisco_VXLAN|Cisco VXLAN]].

OBS detta finns än sålänge endast i en community fork av Quagga som heter FRR.

VTEP
 router bgp 100
  address-family evpn
   neighbor 10.0.0.10 activate
   advertise-all-vni
  exit-address-family

Route reflector
  address-family evpn
   neighbor 10.0.0.11 activate
   neighbor 10.0.0.11 route-reflector-client
  exit-address-family

Verify
 show bgp evpn route
 show evpn vni
 show evpn mac vni 100

[[Category:Network]]</text>
      <sha1>rxtk9zuj5lt30qdysfokl75rwvt98o8</sha1>
    </revision>
  </page>
  <page>
    <title>Quota</title>
    <ns>0</ns>
    <id>214</id>
    <revision>
      <id>1370</id>
      <parentid>1346</parentid>
      <timestamp>2015-12-17T13:15:29Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2493">Quotas kan användas så att användare eller en viss grupp bara får lagra en viss mängd på ett filsystem.

==Installation==
 apt-get install quota

==Konfiguration==
Börja med att ändra i &lt;code&gt;fstab&lt;/code&gt; och lägg till '''usrquota''' eller/och '''grpquota''' på det filsystemet du vill använda det på.

 # /home was on /dev/sda6 during installation
 UUID=9ca5cef9-f734-4396-9f29-ddaeedc21e28 /home           ext4    defaults,'''usrquota'''        0       2

Mounta om filsystemet.
 mount -o remount /home

Skapa en quota index fil. I filen sparas användarens/gruppens limit och hur mycket utrymme som används.
 quotacheck -cum /home

Slå av och på quotas med följande kommandon.
 quotaon /home
 quotaoff /home

För att sätta en quota på en användare med max limit på 1Gb skriv och ändra: [http://www.whatsabyte.com/P1/byteconverter.htm Byte converter]
 edquota user1

 Disk quotas for user user1 (uid 1001):
  Filesystem                   blocks       soft       hard     inodes     soft     hard
  /dev/disk/by-label/DOROOT         8      '''1000000'''    '''1048576'''        2        0        0

{| class="wikitable sortable"
|-
|Filesystem
|Visar vilket filsystem som har quota aktiverat
|-
|blocks
|Visar hur många block som används just nu.
|-
|soft block
|Anger hur många block som får lagras innan grace perioden börjar räkna ner. 
|-
|hard block
|Anger max antal block som en användare får lagra.
|-
|inodes
|Visar hur många inodes som finns just nu.
|-
|soft inode
|Samma som '''soft block''' fast för inode.
|-
|hard inode
|Samma som '''hard block''' fast för inode.
|-
|}

'''Blocks''' anger hur mycket utrymme man får medans '''inodes''' anger hur många filer och mappar man kan använda.

Hard block är det absoluta max en användare eller grupp kan använda når man detta får man inget mer utrymme.

Soft block sätter en max gräns för hur mycket utrymme man har. Men man kan lagra mer än vad soft anger under en tidsperiod som kallas '''grace period'''.


Kolla quotan på en användare/grupp.
 quota user1

Skapa en rapport som visar varje användare/grupp quota inställningar.
 repquota -a

===Grace Period===
Grace period sätter hur länge en användare får överstiga sin soft limit. Denna inställningen är system wide och gäller för alla grupper och användare.
 edquota -t

==Tips'N'Trix==
Prova din quota genom att skapa en 1Gb fil.
 dd if=/dev/zero of=/home/$USER/DDfile bs=1M count=1024 oflag=direct
[[Category:Guider]]</text>
      <sha1>owemgvbeqr7lpamvx1e5csfsmc1fvb2</sha1>
    </revision>
  </page>
  <page>
    <title>Rancid</title>
    <ns>0</ns>
    <id>58</id>
    <revision>
      <id>2783</id>
      <parentid>2647</parentid>
      <timestamp>2018-05-25T09:00:17Z</timestamp>
      <contributor>
        <username>Fondez</username>
        <id>13</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5309">Really Awesome New Cisco confIg Differ är ett verktyg för versionshantering av konfigurationsfiler på nätverksutrustning. Programvaran tillhandahålls av [http://www.shrubbery.net/rancid/ Shrubbery Networks].

Rancid kan användas för följande:
* Backup och lagring av konfigurationsfiler
* Jämförelse av konfiguration
* Versionsarkivering av konfiguration

Rancid kan hjälpa till i arbetet med följande frågor:
* Hur vet du när en förändring sker?
* Vad gör du när en förändring sker?
* Kan du korrelera nätverkshändelser med ändringar?
* Upprätthåller du en "basline" eller sätter en konfigurationsstandard?

==Installation==
 sudo apt-get -y install rancid subversion postfix
Rancid-användare skapas under installationen.
 apt-cache show rancid | grep Version

==Konfiguration==
Filer
* /etc/rancid/  #Config file
* /var/lib/rancid/  #Most other files
* /var/lib/rancid/[gruppnamn]/router.db  #Devices list

Byt från cvs till subversion samt skapa grupper för dina enheter. Det går även använda [[Git]].
 sudo sed -i.bak 's/RCSSYS=cvs; export RCSSYS/RCSSYS=svn; export RCSSYS/g' /etc/rancid/rancid.conf
 sudo sed -i 's#CVSROOT=$BASEDIR/CVS; export CVSROOT#CVSROOT=$BASEDIR/svn; export CVSROOT#g' /etc/rancid/rancid.conf
 echo 'LIST_OF_GROUPS="routers switches fws"' | sudo tee -a /etc/rancid/rancid.conf

Slipp att det räknas som en ändring varje gång en loggfil ändrar storlek. Modifiera ''/var/lib/rancid/bin/rancid'' (kan behövas kommenteras ut fler beroende på enhet, man får testa sig fram)
 #{‘dir /all bootflash:’         =&gt; ‘DirSlotN’},
 #{'dir /all disk0:'             =&gt; 'DirSlotN'},

Don't strip passwords from backed up configurations
 sudo sed -i 's/FILTER_PWDS=YES/FILTER_PWDS=NO/g' /etc/rancid/rancid.conf

Fixa rättigheter för rancid user
 sudo chown -R rancid:rancid /var/lib/rancid
 sudo su -s /bin/bash rancid

User rancid
 cd &amp;&amp; nano .cloginrc
 #add autoenable * 0 (tex Cisco ASA kräver manuell enable)
 add cyphertype * aes256-ctr,aes256-ctr,aes128-cbc,aes256-cbc
 add method * ssh
 add user * cisco
 add password * {cisco} {cisco}
 
 chmod 600 .cloginrc

'''Testa inlogg'''
 /var/lib/rancid/bin/clogin 172.20.0.100

===SVN===
Lagra i SVN repo. Går även att köra med cvs. Kör som user rancid.
 /var/lib/rancid/bin/rancid-cvs
Lista filer i SVN:
 svn ls file:///var/lib/rancid/svn/

'''Add devices'''&lt;br/&gt;
 nano /var/lib/rancid/switches/router.db
 192.168.0.100:cisco:up
 sw01.local:cisco:up
 10.0.0.10:hp:up

'''Removal'''&lt;br/&gt;
För devices raderas entryt ur router.db.&lt;br/&gt;
För grupper görs det genom SVN (raderar alla configs under gruppen också!):
 svn rm file:///var/lib/rancid/svn/switches --message "Not in use"

Kör igång
 /usr/lib/rancid/bin/rancid-run

===Schemaläggning===
 su - rancid
 crontab -e
 0 * * * * /usr/lib/rancid/bin/rancid-run
 0 1 * * * find /opt/rancid/var/logs -type f -mtime +30 -exec rm {} \; # Slang gamla loggar

==Web GUI==
'''CVSWeb''' &lt;br/&gt;
Endast om man valde cvs.
 sudo apt-get -y install cvsweb

===WebSVN===
 sudo apt-get -y install websvn
path: /var/lib/rancid/svn&lt;br/&gt;
repo: /var/lib/rancid/svn

 sudo ln -s /etc/websvn/apache.conf /etc/apache2/conf-available/websvn.conf
 sudo a2enconf websvn.conf
 sudo service apache2 reload
 sudo chgrp -R www-data /var/lib/rancid/svn
 sudo chmod g+w -R /var/lib/rancid/svn
http://172.20.0.10/websvn

'''Auth''' &lt;br/&gt;
HTTP authentication för /websvn
 sudo apt-get -y install apache2-utils
 sudo htpasswd -c /opt/websvnpassword admin

 sudo nano /etc/websvn/apache.conf
 AuthType Basic
 AuthName "Restricted Access"
 AuthBasicProvider file
 AuthUserFile /opt/websvnpassword
 Require user admin

 sudo service apache2 reload

'''Others''' &lt;br/&gt;
"ln: failed to create symbolic link ‘/etc/apache2/conf.d/websvn’: No such file or directory"&lt;br/&gt; 
workaround:
 sudo mkdir /etc/apache2/conf.d

==Mailnotifiering==
''Postfix''
 sudo nano /etc/aliases
 rancid-routers:     sysadm
 rancid-admin-routers:   sysadm
 sudo newaliases

==Slacknotifiering==
Eftersom Slack har incoming webhook integration kan man skicka resultatet från backupkörning till en slackkanal.  

&lt;syntaxhighlight lang="bash"&gt;
#!/bin/sh

# This script is used to send a status report for the rancid backups to Slack channel. 
# It is supposed to be executed by the cron service for the rancid user after rancid-run has completed.

# Finding errors in the latest log files. 
for dir in $(find /var/log/rancid -mmin -60 -type f -print)
do
    if [ ! -z "$(cat $dir | egrep -w 'clogin|error')" ]; then
        FAILEDDEVICES="$FAILEDDEVICES$(cat $dir | egrep -w 'clogin|error' | uniq)  -----  "
    fi
done

# Used for getting the log file error entries into a json format. 
ERRORMESSAGE='{"text": "Rancid report: There seems to be some issues :(", "attachments":[{"text": "'$FAILEDDEVICES'"}]}'

# Send error messages to slack
[ ! -z "$FAILEDDEVICES" ] &amp;&amp; curl -X POST --data-binary "${ERRORMESSAGE}" -H "Content-Type: application/json" https://hooks.slack.com/services/XXX/XXX/XXXXX

# If no errors was found a static message is posted to the channel
[ -z "$FAILEDDEVICES" ] &amp;&amp; curl -X POST --data '{"text":"Rancid report: No failed backups last rancid run :)"}' -H "Content-Type: application/json" https://hooks.slack.com/services/XXX/XXX/XXXXX

&lt;/syntaxhighlight&gt;

[[Category:Guider]]</text>
      <sha1>1e3s5bck2u06dq957mxszvr77gmali4</sha1>
    </revision>
  </page>
  <page>
    <title>Rar2fs</title>
    <ns>0</ns>
    <id>138</id>
    <revision>
      <id>2756</id>
      <parentid>1322</parentid>
      <timestamp>2018-04-02T10:12:05Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Automount */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="997">Är ett FUSE fil system som låter dig läsa rar arkiv som om det vore vanliga filer.


==Förberedelser==
 apt-get install libfuse-dev autoconf

Installera senaste unrarlib. I skrivande stund är 5.3.2 senaste.
 wget ftp://ftp.rarlab.com/rar/unrarsrc-5.3.2.tar.gz &amp;&amp; tar -xvf unrarsrc-5.3.2.tar.gz
 cd unrar &amp;&amp; make lib -f makefile &amp;&amp; cp libunrar.so /usr/lib

==Installation==
 git clone https://github.com/hasse69/rar2fs
 cd rar2fs &amp;&amp; autoreconf -f -i
 ./configure --with-unrar=../unrar
 make &amp;&amp; make install

==Kommandon==
För en lista med kommandon.
 rar2fs -h

Mounta
 rar2fs -o allow_other /path/to/rararchives /path/to/mount/point

Unmounta
 fusermount -u /path/to/mount/point

===Automount===
För att kunna automounta krävs det att fuse är installerat:

'''Debian/Ubuntu'''
 apt-get install fuse
'''RHEL/CentOS'''
 yum install fuse
Lägg till följande i &lt;code&gt;/etc/fstab&lt;/code&gt;
 rar2fs#/path/till/rar/ /vart/du/vill/mounta/ fuse allow_other,--seek-length=1    0 0

[[Category:Guider]]</text>
      <sha1>r9gpca029c7iq8nvpto9n2h9itf2muv</sha1>
    </revision>
  </page>
  <page>
    <title>RatticDB</title>
    <ns>0</ns>
    <id>166</id>
    <revision>
      <id>1577</id>
      <parentid>1062</parentid>
      <timestamp>2016-03-29T05:59:00Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Nginx konfiguration */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4990">[http://rattic.org/ RatticDB] är en open-source password management databas gjord för att flera ska kunna läsa och skriva samtidigt. Man hostar den själv och når den via en hemsida.

==Förberedelse==
Om man vill och det är rekomenderat är följande,
*Att man använder HTTPS för att logga in på Rattic.
*Filsystemet där din databas lagras bör vara krypterat.
*Access loggarna bör vara skyddade.
*Program som [[OSSEC]] är bra att använda.

En fungerande [[LAMP]] och en databas skapad åt rattic samt följande paket.
*python
*pip
*GCC
*mysql-devel
*openssl-devel
*openldap-devel
*python-devel
*libxml2-devel
*libxslt-devel
*gettext

==Installation==
Det är rekomenderat att installera under &lt;code&gt;/opt/apps&lt;/code&gt;.
 mkdir /opt/apps &amp;&amp; cd /opt/apps
 git clone https://github.com/tildaslash/RatticWeb
 cd RatticWeb
 pip install -r requirements-mysql.txt
 mkdir static
 cd conf &amp;&amp; cp defaults.cfg local.cfg

Ändra följande rader,
 [ratticweb]
 debug = False
 secretkey = [enter a string of random secret data]
 hostname = rattic 
 
 [filepaths]
 static = /opt/apps/RatticWeb/static
 
 [database]
 engine = django.db.backends.mysql
 name = rattic
 user = root
 password =
 host =
 port =

Skapa sedan tabeller i databasen och fyll static mappen.
 cd /opt/apps/RatticWeb/
 ./manage.py syncdb --noinput
 ./manage.py migrate --all
 ./manage.py collectstatic -c --noinput
 ./manage.py demosetup

Logga in med användaren &lt;code&gt;admin&lt;/code&gt; med password &lt;code&gt;rattic&lt;/code&gt;.

===Nginx konfiguration===
Börja med att installera supervisord och gunicorn.

 pip install gunicorn
 easy_install supervisor
 wget https://gist.githubusercontent.com/howthebodyworks/176149/raw/88d0d68c4af22a7474ad1d011659ea2d27e35b8d/supervisord.sh -O /etc/init.d/supervisord
 update-rc.d supervisord defaults
 mkdir /opt/apps/log

Lägg till följande rader längst ner i &lt;code&gt;/etc/superviseord.conf&lt;/code&gt;.
 [program:RatticDB]
 command = /opt/apps/gunicorn_start.sh
 user = rattic
 stdout_logfile = /opt/apps/log/gunicorn_supervisor.log
 redirect_stderr = true

Skapa en fil som heter &lt;code&gt;gunicorn_start.sh&lt;/code&gt; under /opt/apps och lägg in följande.
  #!/bin/bash
  
 NAME="RatticDB"                                   # Name of the application
 DJANGODIR=/opt/apps/RatticWeb/                     # ratticdb project directory
 USER=rattic                                       # the user to run as
 GROUP=rattic                                      # the group to run as
 NUM_WORKERS=3                             # how many worker processes should Gunicorn spawn (2xcores+1)
 DJANGO_SETTINGS_MODULE=ratticweb.settings         # which settings file should Django use
 DJANGO_WSGI_MODULE=ratticweb.wsgi                 # WSGI module name
  
 echo "Starting $NAME as `whoami`"
  
 # Activate the virtual environment
 cd $DJANGODIR
 export DJANGO_SETTINGS_MODULE=$DJANGO_SETTINGS_MODULE
 export PYTHONPATH=$DJANGODIR:$PYTHONPATH
  
 # Start your Django Unicorn
 # Programs meant to be run under supervisor should not daemonize themselves (do not use --daemon)
 exec /usr/bin/gunicorn ${DJANGO_WSGI_MODULE}:application \
   --name $NAME \
   --workers $NUM_WORKERS \
   --user=$USER --group=$GROUP \
   --log-level=debug \
   --bind=127.0.0.1:8000

Nginx conf fil.

 server {
     listen       443 ssl;
     server_name  rattic.hackernet.se;
     
 client_max_body_size 4G;
 
     location /static/ {
        alias /opt/apps/RatticWeb/static/;
     }
 
     location /media/ {
         alias   /opt/apps/RatticWeb/media/;
     }
 
     add_header Strict-Transport-Security max-age=15768000;
     add_header X-Frame-Options DENY;
     add_header X-Content-Type-Options nosniff;
     ssl_certificate         /etc/nginx/cert.crt;
     ssl_certificate_key     /etc/nginx/cert/cert.pem;
     ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
     ssl_ciphers 'ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!DSS:!RC4';
     ssl_prefer_server_ciphers on;
     ssl_dhparam /etc/nginx/cert/dhparam.pem;
     ssl_session_cache shared:SSL:1m;
     ssl_session_timeout  5m;
 
 
     location / {
         proxy_pass http://127.0.0.1:8000;
     }
 }
   server {
  listen      80;
  server_name rattic.hackernet.se;
  
  # 301 = permanent redirect, 302 = temporary redirect
  return 301  https://rattic.hackernet.se$request_uri;
  }

Starta sedan Rattic med hjälp av supervisord.
 service supervisord start

===LDAP===
Lägg in följande i conf filen. Mer dokumentation finns på [https://github.com/tildaslash/RatticWeb/wiki/LDAP Rattic Wiki].

 [ldap]
 # LDAP server details
 uri = ldap://localhost
 
 # User parameters
 userbase = ou=users,dc=example,dc=com
 userfilter = (uid=%(user)s)
 
 # Set up the basic group parameters.
 groupbase = ou=django,ou=groups,dc=example,dc=com
 groupfilter = (objectClass=groupOfNames)
 grouptype = GroupOfNamesType
 
 # How do I find staff
 staff = cn=staff,ou=groups,dc=example,dc=com
[[Category:Guider]] [[Category:Sparco]]</text>
      <sha1>o42onneyel80kx9km7ut9ezo408rngk</sha1>
    </revision>
  </page>
  <page>
    <title>Realmd</title>
    <ns>0</ns>
    <id>187</id>
    <revision>
      <id>1248</id>
      <parentid>1157</parentid>
      <timestamp>2015-11-12T12:19:48Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Konfiguration */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1011">realmd är en tjänst som gör det möjligt att konfigurera nätverksautentisering och domänmedlemskap på ett standardiserat sätt. realmd upptäcker information om domänen automatiskt. För Active Directory Backend används SSSD, det går även med winbind men SSSD är rekommenderat. Några fördelar med SSSD:

* Snabbare inloggning
* Klienter kan uppdatera sitt eget DNS record
* Klienter har stöd för sites-featuren i AD
* Enterprise Principals (UPN) är supporterade default

=Installation=
''Ubuntu''
 apt-get install realmd
 apt-get install sssd

=Konfiguration=
 nano /etc/sssd/sssd.conf
 [nss]
 filter_groups = root
 filter_users = root
 reconnection_retries = 3
 
 [pam]
 reconnection_retries = 3
Filrättigheter
 chmod 0600 /etc/sssd/sssd.conf

Joina domän
 realm --verbose join domain.local -U Administrator

Om det inte funkar, lägg till följande i sssd.conf
 use_fully_qualified_names = True

Reboota maskinen

Testa
 id LOCALDOMAIN\\username
 su username@localdomain

[[Category:Guider]]</text>
      <sha1>rqnqzunqsuem4q9f6y2sqk3vpu19z2a</sha1>
    </revision>
  </page>
  <page>
    <title>Roundcube</title>
    <ns>0</ns>
    <id>82</id>
    <revision>
      <id>822</id>
      <parentid>567</parentid>
      <timestamp>2015-07-23T20:57:26Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1202">Roundcube är en webbaserad IMAP-mailklient som är skriven i PHP och kan användas tillsammans med en LAMP-stack, eller något annat operativsystem som stödjer PHP. Webbservern behöver tillgång till IMAP-servern är hämta mail och till en SMTP-server för att kunna skicka mail. Roundcube är gratis och öppen källkod enligt GNU General Public License (GPL).

https://roundcube.net
==Installation==
Exempelinstallation
 sudo apt-get update &amp;&amp; sudo apt-get upgrade -y &amp;&amp; sudo apt-get -y install apache2 mysql-server roundcube roundcube-mysql
 sudo rm -R /var/www/html &amp;&amp; sudo ln -s /usr/share/roundcube/ /var/www/html &amp;&amp; sudo service apache2 restart
 sudo dpkg-reconfigure roundcube-core
 sudo php5enmod mcrypt &amp;&amp; sudo service apache2 restart

== Konfiguration ==
Peka mot din mailserver.
 sudo nano /etc/roundcube/main.inc.php
 $rcmail_config['default_host'] = array("ssl://10.0.0.11");
 $rcmail_config['default_port'] = 993;
 $rcmail_config['imap_auth_type'] = LOGIN;
 $rcmail_config['smtp_server'] = 'tls://10.0.0.11';
 $rcmail_config['smtp_port'] = 25;
 $rcmail_config['smtp_user'] = '%u';
 $rcmail_config['smtp_pass'] = '%p';
 $rcmail_config['smtp_auth_type'] = 'LOGIN';

[[Category:Guider]]</text>
      <sha1>lizwdghps0qtgiscca5lmbsxarl94me</sha1>
    </revision>
  </page>
  <page>
    <title>Rsync</title>
    <ns>0</ns>
    <id>69</id>
    <revision>
      <id>1504</id>
      <parentid>559</parentid>
      <timestamp>2016-02-10T20:45:48Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1725">Rsync är ett verktyg som skapats för att tillhandahålla smidig och inkrementell filöverföring. Det är en ersättning för scp och rcp och är ett bra sätt att ladda upp filer till en fjärrserver. Rsync kan köras över 2 olika protokoll.

'''SSH mode'''&lt;br/&gt;
Detta är default och är vad som används om man inte anger någon växel. All data skickas krypterat med SSH.

'''Daemon mode'''&lt;br/&gt;
Med detta skickas datan med ett eget rsync-protokoll som går mot TCP 873. Ingen kryptering av kommunikationen men funkar bra inom LAN alternativt över VPN-tunnlar. Vissa NAS-servrar stödjer endast denna variant.

==Installation==
 sudo apt-get install rsync
 sudo yum install rsync

==Kommando== 
 rsync [options] [source directory] [target directory]
Exempel
 rsync -Pavz /local/directory/ root@10.0.0.11:/remote/directory/
Jämför source och destination och kopiera över det som inte finns i remote directory.&lt;br/&gt;
OBS a trailing slash on the source directory means that the source directory's contents are copied, not the directory itself.

* '''-h''', human-readable: Number outputs are human readable
* '''-v''', verbose: Displays more output
* '''-z''', compress: Compress file data during transfer
* '''-P''', show progress
* '''-a''', archive mode: En sammanslagning av options och består av följande:
* '''-r''', operate recursively
* '''-l''', preserve links
* '''-p''', preserve permissions
* '''-t''', preserve times
* '''-g''', preserve groups
* '''-o''', preserve owner
* '''-D''', preserve device files and special files

==Cron==
Vill man ha automatisk synkning kan man schemalägga rsync-jobb enkelt med cron. Använd SSH-nycklar för smidig autentisering.

==Link Destination==

[[Category:Tools]]</text>
      <sha1>9dmdgbviirqpn82zpxc1hblhn88jgwj</sha1>
    </revision>
  </page>
  <page>
    <title>Rsyslog</title>
    <ns>0</ns>
    <id>559</id>
    <revision>
      <id>3115</id>
      <parentid>3114</parentid>
      <timestamp>2021-03-18T20:12:03Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Dynamic Topic */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5385">[[Category:Guider]]
RSYSLOG står för '''ro'''cket-fast '''sys'''tem for '''log''' processing. Rsyslog är väldigt flexibelt har en mängd olika input plugins och output plugins som gör att du kan forwarda dina loggar till andra system som Elasticsearch, Kafka eller bara spara ner dina loggar till en fil som roterar dagligen. 

Rsyslog lämpar sig därför väldigt bra som en central log aggeragator.

=Installation=
&lt;ul class="nav nav-tabs"&gt;
   &lt;li class="active"&gt;&lt;btn data-toggle="tab" class=""&gt;#tab1|CentOS 7/8&lt;/btn&gt;&lt;/li&gt;
   &lt;li&gt;&lt;btn data-toggle="tab" class=""&gt;#tab2|Ubuntu 18.04/20.04&lt;/btn&gt;&lt;/li&gt;
 &lt;/ul&gt;

 &lt;div class="tab-content"&gt;
   &lt;div id="tab1" class="tab-pane fade in active"&gt;
 yum -y install rsyslog

   &lt;/div&gt;
   &lt;div id="tab2" class="tab-pane fade"&gt;
 apt-get install rsyslog
   &lt;/div&gt;
 &lt;/div&gt;
=Konfiguration=
Default så letar rsyslog efter '''.conf''' filer under '''/etc/rsyslog.d/'''

==Syslog server==
Starta en syslog server som lysnar på port 514 TCP/UDP och som sparar ner varje enhet i sin egen fil.
&lt;source lang=bash&gt;
# Load modules for UDP &amp; TCP
module(load="imudp")
module(load="imtcp")

# Start to listen on port 514 TCP/UDP
input(type="imudp" port="514")
input(type="imtcp" port="514")

# Templates
template(name="RemoteHost" type="string" string="/var/log/remote/%HOSTNAME%_%$YEAR%_%$MONTH%_%$DAY%.log")

# Actions
action(type="omfile" DynaFile="RemoteHost")
&lt;/source&gt;
==Kafka Output==
Man kan använda rsyslog som en aggregator som sedan skickar datan vidare till en Kafka instance. Då kan man man använda sig av [https://www.rsyslog.com/doc/master/configuration/modules/omkafka.html omkafka] pluginet. 

&lt;ul class="nav nav-tabs"&gt;
   &lt;li class="active"&gt;&lt;btn data-toggle="tab" class=""&gt;#tab3|CentOS 7/8&lt;/btn&gt;&lt;/li&gt;
   &lt;li&gt;&lt;btn data-toggle="tab" class=""&gt;#tab4|Ubuntu 18.04/20.04&lt;/btn&gt;&lt;/li&gt;
 &lt;/ul&gt;

 &lt;div class="tab-content"&gt;
   &lt;div id="tab3" class="tab-pane fade in active"&gt;
 yum -y install rsyslog-kafka

   &lt;/div&gt;
   &lt;div id="tab4" class="tab-pane fade"&gt;
 apt-get install rsyslog-kafka
   &lt;/div&gt;
 &lt;/div&gt;
Simpel syslog server som tar emot på port 514 TCP/UDP och som exportar till en Kafka instans direkt.
&lt;source lang=bash&gt;
# Load modules for UDP &amp; TCP
module(load="imudp")
module(load="imtcp")
module(load="omkafka")

# Start to listen on port 514 TCP/UDP
input(type="imudp" port="514")
input(type="imtcp" port="514")

# Actions
action(type="omkafka" Broker="&lt;BROKER IP&gt;" Topic="&lt;KAFKA-TOPIC&gt;")
&lt;/source&gt;
===Dynamic Topic===
Man kan skicka syslog till olika topics baserat på innehållet i syslog meddelandet, tex facility, hostname, datum osv. Egentligen allt som rsyslog själv kan urskilja, vad det finns för färdig definierade variabler kan man hitta [https://www.rsyslog.com/doc/master/configuration/properties.html här.]

För att slå på denna funktion använder man sig av:
 DynaTopic="on"
Det gör att '''topic''' parametern pekar på en template istället. 

I detta exempel så skickar jag syslog till en topic baserat på vilken input syslogen kommer in på.
&lt;source lang=bash&gt;
# Module loaders
module(load="imudp")
module(load="imtcp")
module(load="omkafka")

# Juniper input
input(type="imudp" port="5141" name="juniper")
input(type="imtcp" port="5141" name="juniper")

# VMware input
input(type="imudp" port="5140" name="vmware")
input(type="imtcp" port="5140" name="vmware")

# Template
template(name="Kafka_Topic" type="string" string="syslog.%INPUTNAME%")

# Output to Kafka
action(type="omkafka" Broker="&lt;BROKER IP&gt;" DynaTopic="on" Topic="Kafka_Topic")
&lt;/source&gt;
===Dynamic Key===
By default så skriver man i random order till olika partitioner för att lastbalansera. Detta kommer göra att när man läser tillbaka syslogen ifrån Kafka så kommer meddelande ifrån samma enhet att inte komma i ordning. För att fixa detta måste man skicka med en key. Det gör att alla meddelande ifrån enhet1 tex alltid kommer att hamna i partition 1. På så sätt kommer man alltid läsa meddelanden från varje enhet i den ordningen dom skapades.

För att fixa detta använder man sig av:
 DynaKey="on"
Det gör att '''key''' parametern pekar på en template istället.

I exemplet nedan så sätter vi keyn till IP'n det kommer ifrån.
&lt;source lang=bash&gt;
# Module loaders
module(load="imudp")
module(load="imtcp")
module(load="omkafka")

# Input
input(type="imudp" port="514")
input(type="imtcp" port="514")

# Template
template(name="Kafka_Key" type="string" string="%FROMHOST-IP%")

# Output to Kafka
action(type="omkafka" Broker="&lt;BROKER IP&gt;" DynaKey="on" Topic="Kafka_Key")
&lt;/source&gt;

===Multiple brokers===
Om man har ett Kafka cluster så behöver man sätta flera brokers det gör man såhär:
&lt;source lang=bash&gt;
action(type="omkafka" Broker=["&lt;BROKER IP&gt;","&lt;BROKER IP&gt;","&lt;BROKER IP&gt;"] Partitions.Auto="on" Topic="Kafka_Topic")
&lt;/source&gt;
Det är också bra om man sätter på:
 Partitions.Auto="on"
Det gör att man automatiskt kommer att last balansera alla meddelande man skapar till alla partioner för den topicen.

==Structured data - RFC5424==
Ifall du har en syslog som följer RFC 5424 kan du använda dig av den fördefinierade templaten '''RSYSLOG_SyslogProtocol23Format''' för att behålla strukturen när du sparar till fil eller forwardar loggen till ett annat system.
&lt;source lang=bash&gt;
action(type="omkafka" Broker="&lt;BROKER IP&gt;" Topic="&lt;KAFKA-TOPIC&gt;" template="RSYSLOG_SyslogProtocol23Format")
&lt;/source&gt;</text>
      <sha1>dnz94a4qi278qh3dmowq5x2l8lak3ib</sha1>
    </revision>
  </page>
  <page>
    <title>SELinux</title>
    <ns>0</ns>
    <id>141</id>
    <revision>
      <id>3166</id>
      <parentid>2764</parentid>
      <timestamp>2023-12-13T13:37:44Z</timestamp>
      <contributor>
        <username>Zunken</username>
        <id>3</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2650">Security-Enhanced Linux, SELinux är en säkerhetsmodul i linuxkärnan som gör det möjligt att säkra upp både hård- och mjukvara. Kärnan i SELinux är labels. Man sätter SELinux labels på allt ifrån filer till portar, sedan applyar man policy på labels. Detta är en standardmodul sedan kernel 2.6 och går t.ex. att konfigurera med [[Ansible]] eller [[Puppet]].

Det är rekommenderat att alltid ha SELinux påslaget för att sedan whitelista de avstängda funktioner du vill åt. För att modifiera SELinux kan man använda sig av det enkla verktyget: semanage. 
 # semanage (# yum install policycoreutils-python)

Slå av och på SELinux manuellt
 setenforce 0/1
 getenforce

Byt SELinux-läge till nästa reboot (persistent)
 sudo sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config

Status
 sestatus -v

Show labels, exempelkommandon
 ls -lhZ
 ps -eZ
 ss -Z
 semanage fcontext --list

=== Exempel på funktioner som är satta och avstängda av SELinux ===
'''httpd_can_network_connect''' - Ser till så att din httpd-tjänst inte kan få tillgång till nät. Denna kan vara bra att ha igång om du tex har en webbtjänst som hämtar information via tex http externt.
&lt;br /&gt;'''ssh_port_t''' - Denna är satt till 22. Om du vill köra ssh på annan port måste du byta eller lägga till din nya port i SELinux.

=Setroubleshoot=
Det finns ett paket som heter '''setroubleshoot-server''' som är till stor hjälp om man valt att använda SElinux. Paketet gör att loggar från SELinux hamnar i '''/var/log/messages''' och att dom blir väldigt enkla att läsa. Paketet kan också hjälpa dig att lösa problemet med hjälp av kommandot '''sealert'''

För att installera:
 yum -y install setroubleshoot-server

Starta sedan om audit
 systemctl restart audit

Loggar från SELinux ska nu hamna i '''/var/log/messages'''.

Om du redan har en fil med loggar du vill analysera kan du använda dig av '''sealert'''. 
 sealert -a /var/log/audit/audit.log &gt; /var/log/audit/audit_human_readable.log
====Skapa egna selinux med grep och audit2allow.====
Kommando
 cat /var/log/audit/audit.log |grep postgres_expo |grep denied |audit2allow
Resultat som visar vad det är du skapar en regel på
 #============= init_t ==============
 allow init_t postgresql_port_t:tcp_socket name_connect;

Kommando
 cat /var/log/audit/audit.log |grep postgres_expo |grep denied |audit2allow -M postgres
Resultat som bara visar vad du skall köra för att implementera selinux regeln ovan
 ******************** IMPORTANT ***********************
 To make this policy package active, execute:
 semodule -i postgres.pp

kommando
 semodule -i postgres.pp</text>
      <sha1>ix436x0sbixzkhijqmsl79sl9bcv6b9</sha1>
    </revision>
  </page>
  <page>
    <title>SSH</title>
    <ns>0</ns>
    <id>125</id>
    <revision>
      <id>3152</id>
      <parentid>2255</parentid>
      <timestamp>2022-04-20T09:20:10Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2461">SSH kan användas för mer än bara SSHa till en server. Du kan använda det för att tunnla trafik till saker du inte har direkt åtkomst mot och köra program med hjälp av tex [[Xming]].

==Fingerprint==
Första gången man SSHar till en maskin kan man inte vara säker på äktheten för att man inte har något fingerprint cacheat. Man kan manuellt kolla fingerprint för att säkerställa att man inte blir mitmad. Kolla först på servern, detta bör alltid göras med konsolen, för att sedan jämföra det med vad din SSH-klient själv räknar ut utifrån nyckeln den får.
 cd /etc/ssh
 for file in *sa_key.pub
 do   ssh-keygen -lf $file
 done

===SSHFP===
SSHFP är ett resource record i DNS som man använder för att svara klienter som väljer att fråga DNS om nycklarna klienten får är äkta. Såhär kan det se ut i din zon.
 sshserver    IN      A       1.2.3.4
              IN      SSHFP   1 1 b4b8f2e051a16f57f69590c7c06aeaad019a3882
              IN      SSHFP   2 1 ea35c2064a5fb2ec9f51da2e7c790967f9844e59

==Reverse SSH Tunnel==
Kan användas om en server sitter bakom en brandvägg som du inte kan SSHa igenom.

Skriv detta på servern bakom brandväggen. 
 ssh -fN -R 7000:localhost:22 username@ip

Anslut sedan till servern över tunnel med kommandot.
 ssh -p 7000 username@localhost

==Tunnla trafik==
För att tunnla trafik och tex kunna RDPa eller VNC en maskin bakom din SSH host.

===RDP Trafik===
 ssh -N -L 13389:RDPhost:3389 username@ip

Starta sedan din RDP klient och anslut mot localhost:13389.
 rdesktop localhost:13389

===HTTP trafik===
 ssh -N -D 8080 username@ip

Ändra sedan din webbläsares socks proxy till localhost port 8080.
 export HTTPS_PROXY=socks5://127.0.0.1:8080

===Tunnel i en reverse tunnel===
Man kan skapa tunnlar i en reverse ssh tunnel.
 ssh -p 7000 -N -L 13389:IPtillRDPhost:3389 username@ip

Och anslut på samma sätt localhost:13389.

==Autossh==
Om man vill att SSH-tunneln ska klara reboots och disconnects kan man autostarta autossh. Detta förutsätter att man gör autentiseringen med RSA-nycklar.
 sudo apt-get -y install autossh
 sudo nano /etc/rc.local
 autossh -M 10984 -N -f -o "PubkeyAuthentication=yes" -o "PasswordAuthentication=no" -i /home/$USER/.ssh/id_rsa -R 7000:localhost:22 username@ip -p 22 &amp;

==SSH-Key==
Läs följande del hur man kan autentisera sig med RSA nykel utan att behöva skriva lösenord, [[Jumpgate#SSH_Autentisering|SSH Autentisering]].
[[Category:Guider]]</text>
      <sha1>oexhm8izjxqqpzuuouwy9zjcwgy9d16</sha1>
    </revision>
  </page>
  <page>
    <title>Scapy</title>
    <ns>0</ns>
    <id>48</id>
    <revision>
      <id>568</id>
      <parentid>344</parentid>
      <timestamp>2015-06-16T09:36:51Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="807">Scapy är ett kraftfullt och interaktivt paketmanipulationsprogram. Det kan förfalska och avkoda paket av flera protokoll samt skicka ut dem på tråd. Det kan hantera de flesta klassiska uppgifter som skanning, tracerouting, enhetstester, attacker eller nätverksidentifiering. Scapy är skrivet i Python.&lt;br/&gt;
Enligt utvecklaren kan Scapy ersätta hping, 85% av Nmap, arpspoof, arp -sk, arping, tcpdump, tethereal samt p0f.

'''Grunder:'''
 Lista protokoll och alternativ
 ls()
 Lista inbyggda kommandofunktioner
 lsc()
 Visa/sätt konfiguration
 conf
 Skicka paket på lager 3
 send()
 Skicka paket på lager 2
 sendp()

'''Användbara exempel:'''
 sendp(Ether(src='00:50:56:22:33:e7', dst='00:50:56:cc:aa:af')/IPv6(src='2001::5', dst='2001::10', hlim=64)/ICMPv6EchoRequest(data=''))

[[Category:Tools]]</text>
      <sha1>ob8e1wji99ljvb6lvp3nvag3tuezycs</sha1>
    </revision>
  </page>
  <page>
    <title>Security Onion</title>
    <ns>0</ns>
    <id>49</id>
    <revision>
      <id>820</id>
      <parentid>499</parentid>
      <timestamp>2015-07-23T20:55:57Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="680">[[Category:Distar]]
''Artikel under arbete''

"Security Onion is a Linux distro for intrusion detection, network security monitoring, and log management. It's based on Ubuntu and contains Snort, Suricata, Bro, OSSEC, Sguil, Squert, Snorby, ELSA, Xplico, NetworkMiner, and many other security tools. The easy-to-use Setup wizard allows you to build an army of distributed sensors for your enterprise in minutes"

Det finns utmärkt dokumentation på deras wiki-sida, https://github.com/Security-Onion-Solutions/security-onion/wiki&lt;br/&gt;
Denna sida innehåller endast quick 'n dirty-guider.

'''IDS'''&lt;br/&gt;
Om man speglar trafik till Security Onion kan man sätta upp det som en IDS.</text>
      <sha1>2r7t1k27odixh6sgnk351gi2v4429j3</sha1>
    </revision>
  </page>
  <page>
    <title>Shaltúre</title>
    <ns>0</ns>
    <id>161</id>
    <revision>
      <id>1063</id>
      <parentid>1022</parentid>
      <timestamp>2015-09-25T14:20:58Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3279">Shaltúre är ett gäng bra services för att komplettera din IRC server. Du kan registrera ditt nick, äga kanaler så ingen kan ta över den är några av sakerna du får.

Dessa services finns,
*NickServ
*ChanServ
*Global
*InfoServ
*OperServ
*SaslServ
*MemoServ
*GroupServ
*StatServ
*ALIS

==Förberedelse==
Du behöver ett extra A record tex &lt;code&gt;services.hackernet.se&lt;/code&gt;

 apt-get install gettext

==Installation==
Shaltúre installerar sig i användarens home folder som default. Därför behöver man klona från git till en mapp som inte heter &lt;code&gt;Shalture&lt;/code&gt;
 git clone git://github.com/shalture/shalture.git shalture-source
 cd shalture-source
 git submodule init
 git submodule update

Sedan är det bara att kompilera programmet.
 ./configure --enable-contrib
 make
 make install

==Konfiguration==
Konfigurationen är verifierad och funkar på [[InspIRCd]], men det bör vara samma för andra IRC servrar.

Börja med att kopiera exempel filen.
 cd ~/shalture/etc &amp;&amp; cp shalture.conf.example shalture.conf

Ändra rad 66 så rätt IRCd modul laddas.
 loadmodule "modules/protocol/inspircd";

På rad 793 i &lt;code&gt;serverinfo&lt;/code&gt; fältet ändra följande så dom passar dig.
 name = "services.hackernet.se";
 desc = "Hackernet IRC Services";
 numeric = "00A"; #Denna är viktigt att den inte har samma ID som i konfigurationsfilen för din IRC server.
 netname = "Hackernet";
 adminname = "Sparco";
 adminemail = "root@hackernet.se";
 registeremail = "root@hackernet.se";

Leta sedan upp &lt;code&gt;uplink&lt;/code&gt; fältet på rad 938.
 uplink "services.hackernet.se" {
 host = "irc.hackernet.se";
 port = "6666";
 send_password = "password";
 receive_password = "password";

På rad 971 i &lt;code&gt;nickserv&lt;/code&gt; ändra.
 host = "hackernet.se";

Det kommer ge nickserv FQDN namnet nickserv@hackernet.se. Ändra nu &lt;code&gt;host=&lt;/code&gt; på resterande services som kommer i filen.

Leta upp raden &lt;code&gt;operator&lt;/code&gt; på rad 2217. Ändra till samma som din IRCd oper är.

===InspIRCd===
Konfigurationen som behövs på InspIRCd för att Shaltúre ska funka. Shaltúre klarar inte av att ansluta över SSL än.

&lt;syntaxhighlight lang="bash"&gt;
&lt;bind address="192.168.1.4" port="6666" type="servers"&gt;
&lt;uline server="services.hackernet.se"&gt;
&lt;link name="services.hackernet.se" ipaddr="192.168.1.4" port="6666" allowmask="192.168.1.0/24" sendpass="password" recvpass="password"&gt;
&lt;/syntaxhighlight&gt;

Följande moduler behöver också vara laddade.
&lt;syntaxhighlight lang="bash"&gt;
&lt;module name="m_chanprotect.so"&gt;
&lt;module name="m_halfop.so"&gt;
&lt;module name="m_services_account.so"&gt;
&lt;module name="m_deaf.so"&gt;
&lt;module name="m_spanningtree.so"&gt;
&lt;module name="m_globops.so"&gt;
&lt;module name="m_cban.so"&gt;
&lt;module name="m_svshold.so"&gt;
&lt;module name="m_hidechans.so"&gt;
&lt;module name="m_servprotect.so"&gt;
&lt;module name="m_chghost.so"&gt;
&lt;module name="m_namesx.so"&gt;
&lt;module name="m_uhnames.so"&gt;
&lt;/syntaxhighlight&gt;

Starta nu Shaltúre
 cd $HOME/shalture/bin/ &amp;&amp; ./shalture-services

==Exempel==
På din IRC server skriv nu för att få hjälp.
 /msg Nickserv help
 /msg Chanserv help

==Crontab==
Lägg in följande i din crontab för att checka att Shaltúre är igång var 5e minut.
 */5 * * * * /home/shalture/shalture/etc/shalture.cron &gt;/dev/null 2&gt;&amp;1

[[Category:Guider]] [[Category:Sparco]]</text>
      <sha1>s5ji7fsnymhc2ayjoqa21vyq3yx4nxu</sha1>
    </revision>
  </page>
  <page>
    <title>Skärmsläckare</title>
    <ns>0</ns>
    <id>37</id>
    <revision>
      <id>1952</id>
      <parentid>1949</parentid>
      <timestamp>2016-07-13T19:28:25Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="645">För att stänga av skärmsläckare på din Windows-dator oavsett vad policy säger kan man lägga NoSleep.exe i mappen %AppData%\Microsoft\Windows\Start Menu\Programs\Startup. &lt;br/&gt;
Det är ett script som är kompilerat. Scriptet har en timer som gör att muspekaren flyttas 1 pixel åt höger efter 3 minuters inaktivitet och därmed förhindrar skärmsläckare. 
 http://ds.karen.hj.se/~cameljoe/resources/NoSleep.exe
OBS antivirus kan klaga pga unproven och very few users.

Skannad av [https://www.virustotal.com/en/url/1e12824c046724b77756e4f0830df50b11bd9d2df677e0bb8f84cbee26d80639/analysis/1468437913/ VirusTotal].

[[Category:Windows]]</text>
      <sha1>apptl2vymws83rw8axo7un9zew7ztmr</sha1>
    </revision>
  </page>
  <page>
    <title>SmokePing</title>
    <ns>0</ns>
    <id>236</id>
    <revision>
      <id>1480</id>
      <timestamp>2016-01-29T14:20:00Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "SmokePing är ett verktyg för att mäta latens i ett nätverk. Den kan mäta, lagra och visa latens och paketförlust. SmokePing använder rrdtool för att för att lagra dat..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1358">SmokePing är ett verktyg för att mäta latens i ett nätverk. Den kan mäta, lagra och visa latens och paketförlust. SmokePing använder rrdtool för att för att lagra data och har ett webgui för att visa graferna. 

=Installation=
 sudo apt-get update &amp;&amp; sudo apt-get upgrade
 sudo apt-get -y install smokeping
Skapa symlänk till smokeping apache config 
 cd /etc/apache2/conf-available &amp;&amp; sudo ln -s ../../smokeping/apache2.conf smokeping.conf
Enable Apache konfig och CGI
 sudo a2enconf smokeping &amp;&amp; sudo a2enmod cgid
 sudo service apache2 restart
Om detta failar se sendmail nedan.

=Konfiguration=
Generella inställningar, byt cgiurl.
 sudo nano /etc/smokeping/config.d/General
Om man inte vill använda sendmail
 sudo nano /etc/smokeping/config.d/pathnames
 sendmail = /bin/false
Ifall man vill få larm
 sudo nano /etc/smokeping/config.d/Alerts

Här görs inställningar gällande vilka hostar som ska övervakas och hur de ska struktureras (Görs med antal plustecken).
 sudo nano /etc/smokeping/config.d/Targets
 + Site1
 menu =  Site1
 title = Site1
 
 ++ LocalMachine
 menu = Local Machine
 title = This host
 host = localhost
 #alerts = someloss
 
 ++ GW
 menu = GW
 title = GW
 host = 192.168.0.1

Restart
 sudo service smokeping restart &amp;&amp; sudo service apache2 reload

Access
 http://dinserver/cgi-bin/smokeping.cgi

[[Category:Guider]]</text>
      <sha1>fp5zbdw8o4khk2yvqo9p3xohm0gifri</sha1>
    </revision>
  </page>
  <page>
    <title>Spacewalk</title>
    <ns>0</ns>
    <id>222</id>
    <revision>
      <id>1390</id>
      <timestamp>2015-12-29T16:45:21Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>Created page with "Spacewalk är ett management system för Red Hat baserade system som CentOS, Fedora. Allt sköts i ett snyggt web interface.   =====Features===== *Inventera system (Hård och..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2638">Spacewalk är ett management system för Red Hat baserade system som CentOS, Fedora. Allt sköts i ett snyggt web interface. 

=====Features=====
*Inventera system (Hård och mjukvara).
*Installera och uppdatera program.
*Kickstarta dina servrar.
*Skicka ut konfigurations filer till servrar.
*Starta/stoppa/konfigurera virtuella gäster (KVM &amp; XEN).

==Förberedelse==
Lägg till lite nya repositories som behövs.

'''EPEL repository:'''
 yum install epel-release

'''JPackage repository:'''
 cat &gt; /etc/yum.repos.d/jpackage-generic.repo &lt;&lt; EOF
 [jpackage-generic]
 name=JPackage generic
 #baseurl=http://mirrors.dotsrc.org/pub/jpackage/5.0/generic/free/
 mirrorlist=http://www.jpackage.org/mirrorlist.php?dist=generic&amp;type=free&amp;release=5.0
 enabled=1
 gpgcheck=1
 gpgkey=http://www.jpackage.org/jpackage.asc
 EOF

'''Spacewalk repository:'''

Beror på vilket dist du kommer köra. I skrivande stund är version '''2.4''' den senaste.

'''Red Hat Enterprise Linux 6, Scientific Linux 6, CentOS 6'''
 rpm -Uvh http://yum.spacewalkproject.org/2.4/RHEL/6/x86_64/spacewalk-repo-2.4-3.el6.noarch.rpm
'''Red Hat Enterprise Linux 7, Scientific Linux 7, CentOS 7'''
 rpm -Uvh http://yum.spacewalkproject.org/2.4/RHEL/7/x86_64/spacewalk-repo-2.4-3.el7.noarch.rpm
'''Fedora 21'''
 rpm -Uvh http://yum.spacewalkproject.org/2.4/Fedora/21/x86_64/spacewalk-repo-2.4-3.fc21.noarch.rpm
'''Fedora 22'''
 rpm -Uvh http://yum.spacewalkproject.org/2.4/Fedora/22/x86_64/spacewalk-repo-2.4-3.fc22.noarch.rpm

Uppdatera repona.
 yum repolist &amp;&amp; yum update

==Installera==
Spacewalk använder en databas för att spara sin data. Default så används en inbyggd PostgreSQL databas. Det går också att använda en Oracle RDBMS version 10g eller högre.

Denna guiden använder den inbyggda databasen:
 yum install spacewalk-setup-postgresql

Installera sedan Spacewalk:
 yum install spacewalk-postgresql

För att kunna nå web interfacet och kunna använda andra tjänster behöver man sätta på några portar.
 firewall-cmd --add-service=https --permanent
 firewall-cmd --add-service=http --permanent

För att kunna pusha saker till dina klienter behöver man enabla port '''5222'''. Om man tänkt använda Spacewalk proxy behöver man porten '''5269'''. Port '''69 UDP''' behövs om man tänkt använda tftp.

Ladda sedan om brandväggen.
 firewall-cmd --reload

Spacewalk måste kunna resolva sitt FQDN. Går inte det så lägg in det i host filen '''/etc/hosts'''

Kör följande kommando och svara på frågorna.
 spacewalk-setup --disconnected

Surfa sedan in på din spacewalk server '''https://hostname/''' och skapa ett inlogg.

[[Category:Guider]]</text>
      <sha1>9t2ra3mcjfr3n26k7y5z9bkt4d28ux3</sha1>
    </revision>
  </page>
  <page>
    <title>Squid</title>
    <ns>0</ns>
    <id>507</id>
    <revision>
      <id>2733</id>
      <parentid>2732</parentid>
      <timestamp>2018-01-18T17:27:44Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="795">Squid är en high-performance cache proxy som har stöd för HTTP, HTTPS, FTP mycket annat. 

=Installation=
'''Ubuntu'''
 sudo apt-get install squid
'''CentOS'''
 yum -y install squid
=Konfiguration=
All konfiguration av squid sker i /etc/squid/squid.conf. Denna guide går igenom hur man installerar väldigt grundläggande proxy server.

Öppna suid.conf och avkommentera följande rad:

 #http_access allow localnet


Därefter behöver vi definera vilka nät som ska få använda proxy servern. Leta efter denna rad:

 #acl localnet src

avkommentera den och ändra den till:

 acl localnet src &lt;intern ip range&gt;/&lt;subnät mask&gt;


Starta om squid:

 sudo service squid restart


Nu har vi konfigurerat en väldig basic proxy server som svarar på port 3128 som standard.

[[Category:Guider]]</text>
      <sha1>jh8jwh6ymnq1th3we1uw1vk5udid19v</sha1>
    </revision>
  </page>
  <page>
    <title>Sshttp</title>
    <ns>0</ns>
    <id>51</id>
    <revision>
      <id>359</id>
      <timestamp>2015-04-27T09:31:38Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "hiding SSH servers behind HTTP&lt;br/&gt; https://github.com/stealth/sshttp"</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="69">hiding SSH servers behind HTTP&lt;br/&gt;
https://github.com/stealth/sshttp</text>
      <sha1>e44yj86zpx3c3t9b0wtpdybosal31dz</sha1>
    </revision>
  </page>
  <page>
    <title>Standard vSwitch</title>
    <ns>0</ns>
    <id>535</id>
    <revision>
      <id>2885</id>
      <timestamp>2018-10-22T18:22:51Z</timestamp>
      <contributor>
        <username>Kessemess</username>
        <id>15</id>
      </contributor>
      <comment>Created page with "En vSwitch är som namnet antyder en virtuell switch, till vilken virtuella maskiner ansluter sina virtuella nätverkskort (vNIC). Till en vSwitch kopplas ett eller flera fysi..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2078">En vSwitch är som namnet antyder en virtuell switch, till vilken virtuella maskiner ansluter sina virtuella nätverkskort (vNIC). Till en vSwitch kopplas ett eller flera fysiska NIC:ar (pNIC) från ESXI-hosten som används som upplänk(ar).

==Port Groups==
Port Groups används för att gruppera och/eller separera virtuella maskiner nätverksmässigt, t ex Test och Produktion. Portgrupperna kan tilldelas olika, eller samma VLAN, dock måste de ha ett unikt namn. &lt;br /&gt;
En portgrupp kan konfigureras med tre olika VLAN Tagging Modes:&lt;br /&gt;
'''External Switch Tagging''' ('''EST'''), endast otaggad trafik forwarderas, VLAN ID 0 används. &lt;br /&gt;
'''Virtual Switch Tagging''' ('''VST'''), vSwitchen taggar trafik, VLAN ID 1-4094 används.&lt;br /&gt;
'''Virtual Guest Tagging''' ('''VGT'''), det är upp till VM:en att sköta VLAN-taggningen, VLAN ID 4096 används.

==Network Security Policies== 
I en vSwitch kan en Security Policy konfigureras, de tre inställningar som kan ändras är:&lt;br /&gt;
'''Promiscuous Mode''' - Promiscuous mode tillåter (vid Accept) att medlemmar i portgruppen tar emot samtliga frames som traverserar den virtuella switchen, eller för det VLAN som specificerats i portgruppen.&lt;br /&gt;
'''MAC Address Changes''' - Tillåter/förbjuder VM:en att byta MAC-adress inifrån gäst-OS:et. Om policyn är inställd på Reject, stängs den virtuella switchporten om ett MAC-adressbyte registreras. Porten avblockeras då MAC-adressen ändras tillbaka till "Initial address".&lt;br /&gt;
'''Forged Transmits''' - Om Forged Transmits är satt till Reject kommer ESXi-hosten att inspektera L2-headern på varje paket som skickas från VM:arna i portgruppen/vSwitch:en. MAC-adressen i headern kommer att jämföras med "Effective address" (adressen som gäst-OS:et tilldelat sin adapter, oftast samma som Initial address), matchar inte source-adressen i L2-headern kommer paketet att droppas.

Per default är endast Promiscuous Mode inställt på Reject i en Standard vSwitch. I en DvSwitch däremot är samtliga inställda på Reject från början.

[[Category:VMware]]</text>
      <sha1>ny1m8zl8cs3t9qyudixvwscj5easqzl</sha1>
    </revision>
  </page>
  <page>
    <title>Suzieq</title>
    <ns>0</ns>
    <id>560</id>
    <revision>
      <id>3151</id>
      <parentid>3134</parentid>
      <timestamp>2022-04-13T12:54:00Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1108">Suzieq är ett open-source multi-vendor network observability tool som man kan använda för att analysera ett nätverk med hjälp av olika queries. Det finns stöd för Arista, Cisco, Juniper mm. 

Skapa ett device inventory, t.ex. /home/USER/suzieq_inventory.yml.
&lt;syntaxhighlight lang="yaml"&gt;
sources:
- name: device_list
  hosts:
    - url: ssh://10.1.0.10
    - url: ssh://10.1.0.11
    - url: ssh://10.1.0.12

auths:
- name: svc
  username: svc-readonly
  password: password123

devices:
- name: nxos
  devtype: nxos
  ignore-known-hosts: true

namespaces:
- name: oob
  source: device_list
  auth: svc
  device: nxos
&lt;/syntaxhighlight&gt;

Sätt upp Suzieq med [[Docker]]
&lt;syntaxhighlight lang="Bash"&gt;
docker volume create suzieq-storage
docker run -itd --rm -p 8501:8501 -e TZ=Europe/Stockholm \
  -v suzieq-storage:/suzieq/parquet \
  -v /home/USER/suzieq_inventory.yml:/suzieq/inventory/suzieq.yml \
  --name suzieq netenglabs/suzieq:latest

docker attach suzieq

sq-poller -I /suzieq/inventory/suzieq.yml &amp;
suzieq-gui &amp; 

&lt;/syntaxhighlight&gt;

Webgui når man sedan på port 8501.

[[Category:Network]]</text>
      <sha1>1stzvr6f3xs9cb7w4h8n2rrq5h8uney</sha1>
    </revision>
  </page>
  <page>
    <title>Syntaxhighlight</title>
    <ns>0</ns>
    <id>20</id>
    <revision>
      <id>2953</id>
      <parentid>2950</parentid>
      <timestamp>2019-03-23T21:18:42Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="8754">För att highlighta kod måste man använda source editorn och syntaxhighlight.
&lt;syntaxhighlight lang="Python" line&gt;
def hello_world():
  print("Hello Hackernet")

hello_world()
&lt;/syntaxhighlight&gt;
Ser ut så här i editorn:
&lt;source lang="Python"&gt;
&lt;syntaxhighlight lang="Python" line&gt;
def hello_world():
  print("Hello Hackernet")

hello_world()
&lt;/syntaxhighlight&gt;
&lt;/source&gt; 
===Parametrar===
====line====
Gör så att du får siffror till vänster om din kod.
&lt;syntaxhighlight lang="Python" line&gt;
def hello_world():
  print("Hello Hackernet")
&lt;/syntaxhighlight&gt;
&lt;source lang="Python"&gt;
&lt;syntaxhighlight lang="Python" line&gt;
def hello_world():
  print("Hello Hackernet")
&lt;/syntaxhighlight&gt;
&lt;/source&gt;

====start====
Används tillsammans med &lt;code&gt;line&lt;/code&gt; för att starta på en annan line än 1. 
&lt;syntaxhighlight lang="Python" line start="69"&gt;
def hello_world():
  print("Hello Hackernet")
&lt;/syntaxhighlight&gt;
&lt;source lang="Python"&gt;
&lt;syntaxhighlight lang="Python" line start="69"&gt;
def hello_world():
  print("Hello Hackernet")
&lt;/syntaxhighlight&gt;
&lt;/source&gt; 
====highlight====
Används för att highlighta en eller flera rader, &lt;code&gt;hightlight="1,2"&lt;/code&gt; eller &lt;code&gt;highlight="5-7"&lt;/code&gt;
&lt;syntaxhighlight lang="Python" line highlight=2&gt;
def hello_world():
  print("Hello Hackernet")
&lt;/syntaxhighlight&gt;
&lt;source lang="Python"&gt;
&lt;syntaxhighlight lang="Python" line highlight=2&gt;
def hello_world():
  print("Hello Hackernet")
&lt;/syntaxhighlight&gt;
&lt;/source&gt; 

=== Supportade Språk ===
{| class="wikitable" style="float:left"
!Code||Language
|-
|&lt;code&gt;abap&lt;/code&gt;||[[:en:ABAP|ABAP]]
|-
|&lt;code&gt;actionscript&lt;/code&gt;||[[:en:ActionScript|ActionScript]]
|-
|&lt;code&gt;ada&lt;/code&gt;||[[:en:Ada (programming language)|Ada]]
|-
|&lt;code&gt;apache&lt;/code&gt;||[[:en:Apache HTTP Server|Apache Configuration]]
|-
|&lt;code&gt;applescript&lt;/code&gt;||[[:en:AppleScript|AppleScript]]
|-
|&lt;code&gt;asm&lt;/code&gt;||[[:en:Assembly language|Assembly]]
|-
|&lt;code&gt;asp&lt;/code&gt;||[[:en:Active Server Pages|Active Server Pages (ASP)]]
|-
|&lt;code&gt;autoit&lt;/code&gt;||[[:en:AutoIt|AutoIt]]
|-
|&lt;code&gt;bash&lt;/code&gt;||[[:en:Bash (Unix shell)|Bash]]
|-
|&lt;code&gt;basic4gl&lt;/code&gt;||[[:en:Basic4GL|Basic4GL]]
|-
|&lt;code&gt;bf&lt;/code&gt;||[[:en:Brainfuck|Brainfuck]]
|-
|&lt;code&gt;blitzbasic&lt;/code&gt;||[[:en:Blitz BASIC|Blitz BASIC]]
|-
|&lt;code&gt;bnf&lt;/code&gt;||[[:en:Backus-Naur Form|Backus-Naur Form]]
|-
|&lt;code&gt;c&lt;/code&gt;||[[:en:C (programming language)|C]]
|-
|&lt;code&gt;c_mac&lt;/code&gt;||C (Mac)
|-
|&lt;code&gt;caddcl&lt;/code&gt;||[[:en:Dialog Control Language|AutoCAD DCL]]
|-
|&lt;code&gt;cadlisp&lt;/code&gt;||[[:en:AutoLISP|AutoLISP]]
|-
|&lt;code&gt;cfdg&lt;/code&gt;||CFDG
|-
|&lt;code&gt;cfm&lt;/code&gt;||[[:en:ColdFusion_Markup_Language|ColdFusion Markup Language]]
|-
|&lt;code&gt;cil&lt;/code&gt;||[[:en:Common_Intermediate_Language|Common Intermediate Language (CIL)]]
|-
|&lt;code&gt;cobol&lt;/code&gt;||[[:en:COBOL|COBOL]]
|-
|&lt;code&gt;cpp-qt&lt;/code&gt;||[[:en:Qt (toolkit)|C++ (Qt toolkit)]]
|-
|&lt;code&gt;cpp&lt;/code&gt;||[[:en:C++|C++]]
|-
|&lt;code&gt;csharp&lt;/code&gt;||[[:en:C Sharp (programming language)|C#]]
|-
|&lt;code&gt;css&lt;/code&gt;||[[:en:Cascading Style Sheets|Cascading Style Sheets (CSS)]]
|-
|&lt;code&gt;d&lt;/code&gt;||[[:en:D (programming language)|D]]
|-
|&lt;code&gt;delphi&lt;/code&gt;||[[:en:Delphi programming language|Delphi]]
|-
|&lt;code&gt;diff&lt;/code&gt;||[[:en:diff|Diff]]
|-
|&lt;code&gt;div&lt;/code&gt;||DIV
|-
|&lt;code&gt;dos&lt;/code&gt;||[[:en:DOS batch file|DOS batch file]]
|-
|&lt;code&gt;dot&lt;/code&gt;||[[:en:DOT language|DOT]]
|-
|&lt;code&gt;eiffel&lt;/code&gt;||[[:en:Eiffel (programming language)|Eiffel]]
|-
|&lt;code&gt;fortran&lt;/code&gt;||[[:en:Fortran|Fortran]]
|-
|&lt;code&gt;freebasic&lt;/code&gt;||[[:en:FreeBASIC|FreeBASIC]]
|-
|&lt;code&gt;gambas&lt;/code&gt;||[[:en:Gambas_programming_language|Gambas]]
|-
|&lt;code&gt;genero&lt;/code&gt;||Genero
|-
|&lt;code&gt;gettext&lt;/code&gt;||[[:en:GNU_gettext|GNU internationalization (i18n) library]]
|-
|&lt;code&gt;glsl&lt;/code&gt;||[[:en:GLSL|OpenGL Shading Language (GLSL)]]
|-
|&lt;code&gt;gml&lt;/code&gt;||[[:en:Game Maker Language|Game Maker Language (GML)]]
|-
|&lt;code&gt;gnuplot&lt;/code&gt;||[[:en:Gnuplot|gnuplot]]
|-
|&lt;code&gt;groovy&lt;/code&gt;||[[:en:Groovy (programming language)|Groovy]]
|-
|&lt;code&gt;haskell&lt;/code&gt;||[[:en:Haskell (programming language)|Haskell]]
|-
|&lt;code&gt;Haxe&lt;/code&gt;||[[:en:Haxe|Haxe]]
|-
|&lt;code&gt;hq9plus&lt;/code&gt;||HQ9+
|-
|&lt;code&gt;html4strict&lt;/code&gt;||[[:en:HTML|HTML]]
|-
|&lt;code&gt;html5&lt;/code&gt;||[[:en:HTML5|HTML5]]
|-
|&lt;code&gt;idl&lt;/code&gt;||[[:en:Universal Network Objects|Uno IDL]]
|-
|&lt;code&gt;ini&lt;/code&gt;||[[:en:INI file|INI]]
|-
|&lt;code&gt;inno&lt;/code&gt;||[[:en:Inno Setup|Inno]]
|-
|&lt;code&gt;intercal&lt;/code&gt;||[[:en:INTERCAL|INTERCAL]]
|-
|&lt;code&gt;io&lt;/code&gt;||[[:en:Io (programming language)|Io]]
|-
|&lt;code&gt;java&lt;/code&gt;||[[:en:Java (programming language)|Java]]
|-
|&lt;code&gt;java5&lt;/code&gt;||[[:en:Java (programming language)|Java(TM) 2 Platform Standard Edition 5.0 ]]
|-
|&lt;code&gt;javascript&lt;/code&gt;||[[:en:JavaScript|JavaScript]]
|-
|&lt;code&gt;kixtart&lt;/code&gt;||[[:en:KiXtart|KiXtart]]
|-
|&lt;code&gt;klonec&lt;/code&gt;||Klone C
|-
|&lt;code&gt;klonecpp&lt;/code&gt;||Klone C++
|-
|&lt;code&gt;latex&lt;/code&gt;||[[:en:LaTeX|LaTeX]]
|-
|&lt;code&gt;lisp&lt;/code&gt;||[[:en:Lisp (programming language)|Lisp]]
|-
|&lt;code&gt;lolcode&lt;/code&gt;||[[:en:LOLCODE|LOLCODE]]
|-
|&lt;code&gt;lotusscript&lt;/code&gt;||[[:en:LotusScript|LotusScript]]
|-
|&lt;code&gt;lua&lt;/code&gt;||[[:en:Lua (programming language)|Lua]]
|}
{| class="wikitable" style="float:left"
!Code||Language
|-
|&lt;code&gt;m68k&lt;/code&gt;||[[:en:Motorola 68000|Motorola 68000 Assembler]]
|-
|&lt;code&gt;make&lt;/code&gt;||[[:en:Make_(software)|make]]
|-
|&lt;code&gt;matlab&lt;/code&gt;||[[:en:MATLAB|MATLAB M]]
|-
|&lt;code&gt;mirc&lt;/code&gt;||[[:en:mIRC scripting language|mIRC scripting language]]
|-
|&lt;code&gt;mxml&lt;/code&gt;||[[:en:MXML|MXML]]
|-
|&lt;code&gt;mpasm&lt;/code&gt;||[[:en:PIC microcontroller|Microchip Assembler]]
|-
|&lt;code&gt;mysql&lt;/code&gt;||[[:en:MySQL|MySQL]]
|-
|&lt;code&gt;nsis&lt;/code&gt;||[[:en:Nullsoft Scriptable Install System|Nullsoft Scriptable Install System (NSIS)]]
|-
|&lt;code&gt;objc&lt;/code&gt;||[[:en:Objective-C|Objective-C]]
|-
|&lt;code&gt;ocaml-brief&lt;/code&gt;||[[:en:Objective Caml|OCaml]]
|-
|&lt;code&gt;ocaml&lt;/code&gt;||[[:en:Objective Caml|OCaml]]
|-
|&lt;code&gt;oobas&lt;/code&gt;||[[:en:StarOffice Basic|OpenOffice.org Basic]]
|-
|&lt;code&gt;oracle8&lt;/code&gt;||[[:en:PL/SQL|Oracle 8 SQL]]
|-
|&lt;code&gt;oracle11&lt;/code&gt;||[[:en:PL/SQL|Oracle 11 SQL]]
|-
|&lt;code&gt;pascal&lt;/code&gt;||[[:en:Pascal (programming language)|Pascal]]
|-
|&lt;code&gt;per&lt;/code&gt;||per
|-
|&lt;code&gt;perl&lt;/code&gt;||[[:en:Perl|Perl]]
|-
|&lt;code&gt;php-brief&lt;/code&gt;||[[:en:PHP|PHP]]
|-
|&lt;code&gt;php&lt;/code&gt;||[[:en:PHP|PHP]]
|-
|&lt;code&gt;pixelbender&lt;/code&gt;||[[:en:Adobe_Pixel_Bender|Pixel Bender]]
|-
|&lt;code&gt;plsql&lt;/code&gt;||[[:en:PL/SQL|PL/SQL]]
|-
|&lt;code&gt;povray&lt;/code&gt;||[[:en:POV-Ray|Persistence of Vision Raytracer]]
|-
|&lt;code&gt;powershell&lt;/code&gt;||[[:en:Windows_PowerShell|Windows PowerShell]]
|-
|&lt;code&gt;progress&lt;/code&gt;||[[:en:OpenEdge_Advanced_Business_Language|OpenEdge Advanced Business Language]]
|-
|&lt;code&gt;prolog&lt;/code&gt;||[[:en:Prolog|Prolog]]
|-
|&lt;code&gt;providex&lt;/code&gt;||[[:en:ProvideX|ProvideX]]
|-
|&lt;code&gt;python&lt;/code&gt;||[[:en:Python (programming language)|Python]]
|-
|&lt;code&gt;qbasic&lt;/code&gt;||[[:en:QBasic|QBasic/QuickBASIC]]
|-
|&lt;code&gt;rails&lt;/code&gt;||[[:en:Ruby on Rails|Rails]]
|-
|&lt;code&gt;reg&lt;/code&gt;||[[:en:Windows Registry|Windows Registry]]
|-
|&lt;code&gt;robots&lt;/code&gt;||[[:en:Robots Exclusion Standard|robots.txt]]
|-
|&lt;code&gt;rsplus&lt;/code&gt;||[[:en:R (programming language)|R]]
|-
|&lt;code&gt;ruby&lt;/code&gt;||[[:en:Ruby (programming language)|Ruby]]
|-
|&lt;code&gt;sas&lt;/code&gt;||[[:en:SAS System|SAS]]
|-
|&lt;code&gt;scala&lt;/code&gt;||[[:en:Scala_(programming_language)|Scala]]
|-
|&lt;code&gt;scheme&lt;/code&gt;||[[:en:Scheme (programming language)|Scheme]]
|-
|&lt;code&gt;scilab&lt;/code&gt;||[[:en:Scilab|Scilab]]
|-
|&lt;code&gt;sdlbasic&lt;/code&gt;||[[:en:SdlBasic|SdlBasic]]
|-
|&lt;code&gt;smalltalk&lt;/code&gt;||[[:en:Smalltalk|Smalltalk]]
|-
|&lt;code&gt;smarty&lt;/code&gt;||[[:en:Smarty|Smarty]]
|-
|&lt;code&gt;sql&lt;/code&gt;||[[:en:SQL|SQL]]
|-
|&lt;code&gt;tcl&lt;/code&gt;||[[:en:Tcl|Tcl]]
|-
|&lt;code&gt;teraterm&lt;/code&gt;||[[:en:TeraTerm|Tera Term]]
|-
|&lt;code&gt;text&lt;/code&gt;||[[:en:Plain text|Plain text]]
|-
|&lt;code&gt;thinbasic&lt;/code&gt;||[[:en:thinBasic|thinBasic]]
|-
|&lt;code&gt;tsql&lt;/code&gt;||[[:en:Transact-SQL|Transact-SQL]]
|-
|&lt;code&gt;typoscript&lt;/code&gt;||[[:en:TYPO3|TypoScript]]
|-
|&lt;code&gt;vala&lt;/code&gt;||[[:en:Vala_(programming_language)|Vala]]
|-
|&lt;code&gt;vb&lt;/code&gt;||[[:en:Visual Basic|Visual Basic]]
|-
|&lt;code&gt;vbnet&lt;/code&gt;||[[:en:Visual Basic .NET|Visual Basic .NET]]
|-
|&lt;code&gt;verilog&lt;/code&gt;||[[:en:Verilog|Verilog]]
|-
|&lt;code&gt;vhdl&lt;/code&gt;||[[:en:VHSIC Hardware Description Language|VHDL]]
|-
|&lt;code&gt;vim&lt;/code&gt;||[[:en:Vimscript|Vimscript]]
|-
|&lt;code&gt;visualfoxpro&lt;/code&gt;||[[:en:Visual FoxPro|Visual FoxPro]]
|-
|&lt;code&gt;visualprolog&lt;/code&gt;||[[:en:Visual_Prolog|Visual Prolog]]
|-
|&lt;code&gt;whitespace&lt;/code&gt;||[[:en:Whitespace_(programming_language)|Whitespace]]
|-
|&lt;code&gt;winbatch&lt;/code&gt;||[[:en:Winbatch|Winbatch]]
|-
|&lt;code&gt;xml&lt;/code&gt;||[[:en:XML|XML]]
|-
|&lt;code&gt;xorg_conf&lt;/code&gt;||[[:en:Xorg.conf|Xorg.conf]]
|-
|&lt;code&gt;xpp&lt;/code&gt;||[[:en:Microsoft_Dynamics_AX|X++]]
|-
|&lt;code&gt;yaml&lt;/code&gt;||[[:en:YAML|YAML]]
|-
|&lt;code&gt;z80&lt;/code&gt;||[[:en:Zilog Z80|ZiLOG Z80 Assembler]]
|}
&lt;div style="clear:both"&gt;&lt;/div&gt;</text>
      <sha1>iuoahcv26kxu5c9u7l9lyttdnbg4753</sha1>
    </revision>
  </page>
  <page>
    <title>System storage manager</title>
    <ns>0</ns>
    <id>221</id>
    <revision>
      <id>1442</id>
      <parentid>1391</parentid>
      <timestamp>2016-01-15T18:24:40Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="514">System storage manager aka ssm, är ett CLI program som ska vara enkelt att använda. Det har stöd för bla BTRFS, RAID och krypterade volymer. SSM använder flera verktyg, bl.a. [[Mdadm]], Cryptsetup, device-mapper och LVM2.

=Installera=
 yum install system-storage-manager.noarch
 apt-get install system-storage-manager
Verify
 sudo ssm list

==Utöka en LVM volume==
Ta reda på vilken volume du vill utöka:
 ssm list volumes

För att utöka med 10Gb:
 ssm resize -s+10G /dev/centos/root

[[Category:Tools]]</text>
      <sha1>ej4b34szf0p21919xlscpl1njgq2vkb</sha1>
    </revision>
  </page>
  <page>
    <title>Systemd</title>
    <ns>0</ns>
    <id>24</id>
    <revision>
      <id>2897</id>
      <parentid>2707</parentid>
      <timestamp>2018-11-22T15:24:18Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Övervaka en service */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5316">Systemd är ett init-system och en service-hanterare som är standard för de flesta linux-distar. Det grundläggande syftet med ett init-system är att initiera de komponenter som måste startas efter att Linuxkärnan har startat. Systemd är det första som startar efter att kernel har startat och får alltid Process ID 1. Init-systemet används också för att hantera tjänster och demoner för servern medan systemet är igång. 

Default sedan:&lt;br/&gt;
Debian 8&lt;br/&gt;
Ubuntu 15.04&lt;br/&gt;
Fedora 15&lt;br/&gt;
RHEL 7&lt;br/&gt;
CentOS 7

=Systemctl=
Systemctl är det centrala verktyget för att kontrollera init-systemet. Systemctl ersätter service och chkconfig.&lt;br/&gt;
Grundfunktioner
 systemctl start sshd
 systemctl stop sshd
 systemctl reload sshd
 systemctl restart sshd
Status
 systemctl status sshd
Autostarta en service
 systemctl enable sshd
 systemctl disable sshd
Lista alla aktiva enheter
 systemctl 
Lista alla enheter
 systemctl list-units --all
OBS .service behöver inte skrivas ut, det läggs till efter tjänsten automatiskt&lt;br/&gt;
Fler kommandon
 systemctl show sshd.service
 systemctl list-dependencies sshd.service

Titta på senaste uppstart grafiskt. Testa detta, seriöst det är coolt!
 systemd-analyze plot &gt; plot.svg

== Lägga till egna services ==
Under &lt;code&gt;/etc/systemd/system&lt;/code&gt; kan man lägga till egna services som man vill hantera med systemd.

En basic service fil ser ut så här.

 [Unit]
 Description=Hello world
 After=network-online.target
 Wants=network-online.target
 
 [Service]
 ExecStart=/usr/bin/echo "Hello world!"
 
 [Install]
 WantedBy=multi-user.target

Om servicen kräver att det finns nätverk före den startar kan man skriva '''After/Wants=network-online.target''' då kommer servicen att försöka starta efter serverns nätverk har gått upp och den har fått en routebar IP. 

För att systemd ska köra servicen vid boot måste man köra enable.
 systemctl enable /etc/systemd/system/hello.service
För att starta tjänsten skriv.
 systemctl start hello.service

==Övervaka en service==
Med systemd kan man övervaka en tjänst så att den startas automatiskt om den skulle krasha.
 systemctl edit sshd
Skriv sedan in:
 [Service]
 Restart=always
Spara sedan filen. Den kommer att sparas under '''/etc/systemd/system/sshd.service.d/overrides.conf'''

Vill du ha en delay innan systemd startas tjänsten igen så går det också med:
 RestartSec=30

Kör sedan en reload:
 systemctl daemon-reload

=Journald=
Journald är en systemd-komponent som har hand om loggar från applikationer och kärna. Kommandot man använder är journalctl. Kör igenom dessa för att bilda dig en uppfattning av vad de gör och hur de fungerar.
 journalctl
 journalctl -k
 journalctl -u nginx.service
 journalctl -u nginx.service --since today
 journalctl _PID=8088
 journalctl --disk-usage

=Networkd=
 systemctl start systemd-networkd
 networkctl
 networkctl status

=Nspawn=
Systemd-nspawn är en container manager som är inbyggd i systemd.&lt;br/&gt;
''Debian''
 apt-get install -y dbus debootstrap bridge-utils
 debootstrap --arch=amd64 jessie /var/lib/machines/container1/
 systemd-nspawn -D /var/lib/machines/container1/ --machine first_container -b
OBS med denna setup delas network namespace med värdhosten. Annars måste man skapa en brygga och koppla containern till den.
 systemd-nspawn -D /var/lib/machines/container1/ --machine second_container --network-bridge=my-bridge -b
Kolla containers
 machinectl
 machinectl status first_container
 machinectl login first_container

=Template unit=
En template unit går att identifera med hjälp av '''@''' som är efter base unit namnet och före unit type suffixen.
 openvpn-client@.service

För att använda sig av en template unit så lägger man in en instance identifier mellan '''@''' och punkten när man kallar på den med &lt;code&gt;systemctl start&lt;/code&gt; eller annat kommando. 
 openvpn-client@'''hackernet-vpn'''.service
Med detta sättet så behöver man bara en unit fil istället för en fil per instans man försöker starta.

==Variabler==
* &lt;code&gt;%n&lt;/code&gt;: Ger hela unit namnet. '''Ex: openvpn-client@hackernet-vpn.service'''
* &lt;code&gt;%N&lt;/code&gt;: Samma som ovan fast all escape tecken kommer vara omvänd. '''Ex: openvpn-client@hackernet-vpn'''
* &lt;code&gt;%p&lt;/code&gt;: Ger unit namnet som är före '''@'''. '''Ex: openvpn-client'''
* &lt;code&gt;%P&lt;/code&gt;: Samma som ovan fast escape är omvänt. '''Ex: openvpn/client'''
* &lt;code&gt;%i&lt;/code&gt;: Ger det som är efter '''@''' och punkten. '''Ex: hackernet-vpn'''
* &lt;code&gt;%I&lt;/code&gt;: Samma som ovan fast escape är omvänt. '''Ex: hackernet/vpn'''
* &lt;code&gt;%f&lt;/code&gt;: Samma som ovan och den lägger på ett '''/''' före. '''Ex: /hackernet/vpn'''
* &lt;code&gt;%u&lt;/code&gt;: Vilken användare som är confad att köra uniten. '''Ex: root'''
* &lt;code&gt;%U&lt;/code&gt;: Samma som ovan fast visar &lt;code&gt;UID&lt;/code&gt; istället. '''Ex: 0'''
* &lt;code&gt;%h&lt;/code&gt;: Visar vart användarens home folder finns. '''Ex: /root'''
* &lt;code&gt;%H&lt;/code&gt;: Visar hostnamnet på servern. '''Ex vpnserver'''
* &lt;code&gt;%s&lt;/code&gt;: Visar användarens shell. '''Ex: /bin/sh'''
* &lt;code&gt;%v&lt;/code&gt;: Visar vilken kernel release som körs. Samma svar som &lt;code&gt;uname -r&lt;/code&gt;. '''Ex: 3.10.0-514.6.1.el7.x86_64'''
* &lt;code&gt;%%&lt;/code&gt;: Används för att skapa ett procent tecken.

==Exempel template unit==
{{OpenVPN-Systemd}}
[[Category:Tools]]</text>
      <sha1>14dsm0z4tz8yn6kxk5999lihq9nvbza</sha1>
    </revision>
  </page>
  <page>
    <title>TFTP</title>
    <ns>0</ns>
    <id>118</id>
    <revision>
      <id>784</id>
      <timestamp>2015-07-23T15:40:29Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "TFTP är ett väldigt simpelt protokoll som används för att överföra filer. Det används ofta för att PXE-boota maskiner eller överföra image-filer till t.ex. switchar...."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="876">TFTP är ett väldigt simpelt protokoll som används för att överföra filer. Det används ofta för att PXE-boota maskiner eller överföra image-filer till t.ex. switchar. TFTP bygger på server/klient-arkitekturen.

=Server=
Förbered ett rot-directory.
 sudo mkdir /tftproot
 sudo chmod -R 1770 /tftproot 
 sudo chown -R root:tftp /tftproot

Det finns olika TFTP-mjukvaror som fungerar som server.

==tftpd==
Trivial file transfer protocol server.
==atftpd==
Advanced TFTP server.
==tftpd-hpa==
HPA's tftp server.
 sudo apt-get -y install tftpd-hpa
 sudo mv /etc/default/tftpd-hpa /etc/default/tftpd-hpa.old

 sudo dd of=/etc/default/tftpd-hpa &lt;&lt; EOF
 TFTP_USERNAME="tftp" 
 TFTP_DIRECTORY="/tftproot" 
 TFTP_ADDRESS=":69"
 TFTP_OPTIONS="--secure --create --listen --verbose"
 EOF

 sudo service tftpd-hpa restart

=Felsökning=
 ss -tulpn | grep 69

[[Category:Guider]]</text>
      <sha1>0fgnz8n30ttbgzy3c15fdq2ph3v1z6w</sha1>
    </revision>
  </page>
  <page>
    <title>Tcpdump</title>
    <ns>0</ns>
    <id>542</id>
    <revision>
      <id>2981</id>
      <timestamp>2019-05-13T13:06:46Z</timestamp>
      <contributor>
        <username>Bat</username>
        <id>4</id>
      </contributor>
      <comment>Created page with "Tcpdump är ett verktyg för att se vilka paket som går via ett interface och göra lite grundläggande felsökning.   =Installation= Debian/Ubuntu  apt-get install tcpdump..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="770">Tcpdump är ett verktyg för att se vilka paket som går via ett interface och göra lite grundläggande felsökning. 

=Installation=
Debian/Ubuntu
 apt-get install tcpdump

=Vanliga Växlar=
*-i
**Val av interface att lyssna på
*-T 
**Paket typ t.ex. carp, snmp eller radios 
*-n 
**Gör ingen reverse lookup på IP
*-c 
**Antal paket innan klar (standard är undef) 

=Uttryck= 
tcpdump visar alla paket som matchar det angivna uttrycket och använder samma syntax som [[pcap-filter]]

=Exempel=
*tcpdump -i eth0 port 67 or port 68 
** Lyssnar efter DHCP paket på eth0
*tcpdump -i eth0 src 10.20.30.40
** Lyssnar efter paket med 10.20.30.40 som source address
* tcpdump -i eth0 host 10.20.30.40
** Lyssnar efter paket som innehåller 10.20.30.40

[[Category:Tools]]</text>
      <sha1>75jdepspi895af7ecbetcvcj5kr7uce</sha1>
    </revision>
  </page>
  <page>
    <title>Tmux</title>
    <ns>0</ns>
    <id>113</id>
    <revision>
      <id>3027</id>
      <parentid>2965</parentid>
      <timestamp>2019-09-25T15:29:08Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>/* Bra plugins */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5210">Tmux är en terminal multiplexer precis som screen. En fördel med att använda terminal multiplexers är att du inte tappar dina shell fönster om du skulle tappa anslutningen eller vill fortsätta jobbet på en annan dator. 

= Installation =
Tmux är enkelt att installera och finns redan färdig packat i dom flesta distars repos.

'''Debian baserade'''
 apt-get install tmux
'''RHEL baserade'''
 yum install epel-release
 yum install tmux

= Kommandon =

Starta tmux,
 tmux

Lista tmux sessioner,
 tmux ls

Attach till en session
 tmux attach

Attach till en session och detach andra som är anslutna till samma session.
 tmux attach -d

Attach till en session om man har flera igång.(Byt # mot siffra)
 tmux a -t #

Stäng en session(Byt # mot en siffra)
 tmux kill-session -t #

= Keybinds =
Default prefix för tmux är {{key press|Ctrl|b}}.

{{ombox
|nocat=true
| type  = notice
| text  = Tänk på att tmux är case-sensitive.
}}

{{key press|Ctrl|b|c}} - Skapa ett nytt fönster.

{{key press|Ctrl|b|n/p}} - Gå till nästa eller föregående fönster.

{{key press|Ctrl|b|0-9}} - Byt fönster.

{{key press|Ctrl|b|w}} - Meny med alla fönster.

{{key press|Ctrl|b|&amp;}} - Stäng ett fönster.

{{key press|Ctrl|b|,}} - Byt namn på ett fönster.



{{key press|Ctrl|b|shift|2}} - Splitta fönster horisontellt.

{{key press|Ctrl|b|shift|5}} - Splitta fönster vertikalt.

{{key press|Ctrl|b|Left|Down|Right|Up}} - För att hoppa imellan paneler.

{{key press|Ctrl|b|x}} - Stäng den aktiva panelen.

{{key press|Ctrl|b|shift|1}} - Skapa ett nytt fönster med den aktiva panelen.

{{key press|Ctrl|b|z}} - Zooma in ett fönster.


{{key press|Ctrl|b|alt|8}} - Copy läge.
* {{key press|Ctrl|space}} - För att börja markera text i copy läget.
* {{key press|alt|w}} För att kopiera den markerade texten.

{{key press|Ctrl|b|alt|9}} - Klistra in den kopierade texten.


{{key press|Ctrl|b|d}} - För att deattacha en session.

{{key press|Ctrl|b|page up}} - För att scrolla upp och ner.

= Tmux Plugin Manager =
Kräver version 1.9 eller högre. Plugins som gör ditt Tmux fönster lite trevligare.

== Installera ==
 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm

Skapa filen &lt;code&gt;.tmux.conf&lt;/code&gt; i din home folder.
 # List of plugins
 set -g @plugin 'tmux-plugins/tpm'
 set -g @plugin 'tmux-plugins/tmux-sensible'
 
 # Other examples:
 # set -g @plugin 'github_username/plugin_name'
 # set -g @plugin 'git@github.com/user/plugin'
 # set -g @plugin 'git@bitbucket.com/user/plugin'

 # Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
 run '~/.tmux/plugins/tpm/tpm'

Ladda sedan TPM genom att starta om din tmux session eller ladda om confen med.
 tmux source ~/.tmux.conf

== Lägga till plugins ==
Plugins finns på [https://github.com/tmux-plugins TPM's Github]

Lägg sedan till pluginet i &lt;code&gt;.tmux.conf&lt;/code&gt; med kommandot &lt;code&gt;set -g @plugin '...'&lt;/code&gt;

Öppna sedan Tmux och tryck för att installera.
 prefix + I

Ta bort plugin genom att ta bort raden kommentera ut den i &lt;code&gt;.tmux.conf&lt;/code&gt; och tryck.
 prefix + alt + u

==Bra plugins==
[https://github.com/tmux-plugins/tmux-sensible Sensible] - Ett gäng inställningar som man bör ha.

[https://github.com/tmux-plugins/tmux-resurrect Resurrect] - Spara din nuvarande Tmux session.

[https://github.com/tmux-plugins/tmux-continuum Continuum] - Autosparar din nuvarande Tmux session.(Kräver resurrect)

[https://github.com/tmux-plugins/tmux-sidebar Sidebar] - Öppnar en tree liknande sidebar.

[https://github.com/tmux-plugins/vim-tmux Vim-tmux] - Fixar visa saker i vim som inte funkar så bra annars.

[https://github.com/tmux-plugins/tmux-logging tmux-logging] - Toggla av/på för att logga en pane till textfil, "screencapture" på en pane, eller spara all historik i en pane till textfil.

=Auto attach=
Lägg detta i din &lt;code&gt;.bashrc&lt;/code&gt; för att automatiskt starta tmux och attacha till en session vid inloggning.
&lt;syntaxhighlight lang=bash&gt;
if  -z "$TMUX" ; then
   tmux has-session &amp;&gt; /dev/null
   if [ $? -eq 1 ]; then
     exec tmux new
     exit
   else
     exec tmux attach
     exit
   fi
fi
&lt;/syntaxhighlight&gt;

=Tips'n'trix=
====För att skriva till alla panes samtidigt.====
 :setw synchronize-panes
====Clear-history====
 :clear-history
Eller binda det till {{key press|Ctrl|K}}
 bind -n C-k clear-history

====Problem att piltangenterna inte fungerar?====
Upptäckte problemet när jag var ansluten till senare versioner av [[Juniper_JunOS|JunOS]]. Att jag var tvungen att skriva om alla kommandon igen för att jag inte kunde trycka fram det senast körda kommandona. Efter att ha lagt till följande i min '''.tmux.conf''' fil så fungera det igen.
 set -g default-terminal "xterm-256color"

====Byt pane snabbt utan prefix====
Lägg till följande i din tmux.conf för att kunna byta pane med {{key press|ALT|Left|Down|Right|Up}}.
 bind -n M-Left select-pane -L
 bind -n M-Right select-pane -R
 bind -n M-Up select-pane -U
 bind -n M-Down select-pane -D
====Byt window utan prefix====
Lägg till följande för att byta window med {{key press|Shift|Left|Right}}
 bind -n S-Left  previous-window
 bind -n S-Right next-window

[[Category:Tools]]</text>
      <sha1>87eod9qm62wcp9o0cpd719wwbxs5xi8</sha1>
    </revision>
  </page>
  <page>
    <title>Tor</title>
    <ns>0</ns>
    <id>31</id>
    <revision>
      <id>2934</id>
      <parentid>1420</parentid>
      <timestamp>2019-03-12T20:16:18Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3092">[[Category:Guider]]
Tor är en anonymiseringsprogram och används bla för att komma åt deep web. 
=Installation=
Källa: https://www.torproject.org/docs/debian.html.en

Ubuntu 18.04 LTS
 sudo su -
 echo "deb https://deb.torproject.org/torproject.org bionic main" &gt;&gt; /etc/apt/sources.list
 curl https://deb.torproject.org/torproject.org/A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89.asc | gpg --import
 gpg --export A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89 | apt-key add -
 apt-get update &amp;&amp; apt-get -y install deb.torproject.org-keyring ntp &amp;&amp; apt-get -y install tor

Verifiera
 tor --version

= Konfiguration =
TCP 9001 och 9030 behöver port forwardas till maskinen.
 nano /etc/tor/torrc

===Exempel===
SwedishNSA är en non-exit tor-nod. Statistik finns på https://metrics.torproject.org/rs.html.
 mv /etc/tor/torrc /etc/tor/torrc.orig
 wget https://raw.githubusercontent.com/torproject/tor/master/contrib/operator-tools/tor-exit-notice.html -O /etc/tor/tor-exit-notice.html
 
 cat&lt;&lt;'__EOF__'&gt;/etc/tor/torrc
 SocksPort 0 
 Log notice file /var/log/tor/notices.log
 RunAsDaemon 1
 DataDirectory /var/lib/tor
 ORPort 9001
 ORPort [2001:2002:beef:ffff::11]:9001
 Address swedishnsa.hackernet.se
 Nickname SwedishNSA
 ContactInfo Helikopter &lt;tor AT hackernet dot se&gt;
 DirPort 9030 # what port to advertise for directory connections
 DirPortFrontPage /etc/tor/tor-exit-notice.html
 ExitPolicy reject *:* # no exits allowed
 __EOF__
 
 systemctl restart tor

Kolla att det kommer igång som det ska
 tail -f /var/log/tor/notices.log

=Torport=
En torport kan vara en fysisk port eller ett nätverk som sätter allt som är inkopplat bakom tornätverket, helt transparant, vare sig man vill eller inte. Detta är ingen Transparent Proxy utan en Isolating proxy. Man behöver en maskin med två interface. Det ena behöver internetaccess och kan vara DHCP-klient. Det andra är DHCP-server för det som ska torifieras, [[ISC_DHCP]]. Stäng även av IP-forwardering för att undvika eventuella IP-läckor.
 sudo apt-get -y install tor
Tor kan göra det mesta själv
 sudo dd of=/etc/tor/torrc &lt;&lt; EOF
 Log notice file /var/log/tor/notices.log
 VirtualAddrNetwork 10.192.0.0/10
 AutomapHostsSuffixes .onion,.exit
 AutomapHostsOnResolve 1
 TransPort 9040
 TransListenAddress 10.0.0.1 #Interface-IPn på torporten
 DNSPort 53
 DNSListenAddress 10.0.0.1
 EOF
Men behöver lite hjälp från iptables
 sudo iptables -F
 sudo iptables -t nat -F
 sudo iptables -t nat -A PREROUTING -i p2p1 -p tcp --dport 22 -j REDIRECT --to-ports 22
 sudo iptables -t nat -A PREROUTING -i p2p1 -p udp --dport 53 -j REDIRECT --to-ports 53
 sudo iptables -t nat -A PREROUTING -i p2p1 -p tcp --syn -j REDIRECT --to-ports 9040	
 sudo sh -c "iptables-save &gt; /etc/iptables.rules"
Välj det interface som är din torport. Med p22-regeln kan man ssha till hosten från "tornätet".
 sudo nano /etc/network/if-pre-up.d/iptables
 #!/bin/bash
 /sbin/iptables-restore &lt; /etc/iptables.rules
 sudo chmod +x /etc/network/if-pre-up.d/iptables	
===Välj land===
Vill man gå i specifika länder kan man specca det i torrc
 ExitNodes {us},{uk}</text>
      <sha1>nww8tk8mh2pteid3bqgd02gwpokf9aq</sha1>
    </revision>
  </page>
  <page>
    <title>Transmission</title>
    <ns>0</ns>
    <id>25</id>
    <revision>
      <id>2771</id>
      <parentid>1467</parentid>
      <timestamp>2018-04-09T07:58:30Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Sparco's settings.json */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1418">[[Category:Guider]] [[Category:Sparco]]
Transmission är en liten men väldigt kraftfull torrent client för linux.

== Installation ==
&lt;code&gt;apt-get update &amp;&amp; apt-get install transmission transmission-daemon&lt;/code&gt;

== Konfiguration ==
Körs enklast via webinterface eller remote GUI
=== Webinterface ===
För att aktivera webinterfacet och även RPC.

Öppna &lt;code&gt;/etc/transmission-daemon/settings.json&lt;/code&gt;och ändra till &lt;code&gt;"rpc-enabled":true&lt;/code&gt;

Webinterfacet nås sedan på &lt;code&gt;http://IP:9091/transmission/web/&lt;/code&gt;

=== Transmission Remote GUI ===
Cross platform front end GUI till transmission, gör det enkelt att lägga till torrents från din vanliga dator. Finns att tanka hem på http://sourceforge.net/projects/transgui/

För att det ska fungera så måste du ha &lt;code&gt;"rpc-enabled":true&lt;/code&gt; i config filen.

RPC path är samma som ditt webinterface fast du ersätter &lt;code&gt;/transmission/web&lt;/code&gt; med &lt;code&gt;/transmission/rpc&lt;/code&gt; istället.

== Tips n Trix ==
'''3th Party tools'''

[[Flexget]], RSS feed downloader. Väldigt användbart för serier.

[[Couchpotato]], Program som laddar hem filmer åt dig med hjälp av transmission.

'''Script done.'''

Kör ett script varje gång en torrent blir klar.

Lägg till
 "script-torrent-done-enabled": true,
 "script-torrent-done-filename": "/vart/finns/scriptet.sh",
i din conf fil &lt;code&gt;/etc/transmission-daemon/settings.json&lt;/code&gt;</text>
      <sha1>41vfweb02hc9uzaqs4ffebor1ycbvg3</sha1>
    </revision>
  </page>
  <page>
    <title>Tree</title>
    <ns>0</ns>
    <id>89</id>
    <revision>
      <id>600</id>
      <timestamp>2015-06-18T11:06:51Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <comment>Created page with "Tree är ett program som listar directories rekursivt.   '''Installation'''  sudo apt-get install tree Lista directories rekursivt  tree Skapa sig en överblick över ett prog..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="277">Tree är ett program som listar directories rekursivt. 

'''Installation'''
 sudo apt-get install tree
Lista directories rekursivt
 tree
Skapa sig en överblick över ett programs filstruktur
 tree -h /etc/apache2/
Hitta stora filer
 tree -h /var/ | grep G]

[[Category:Tools]]</text>
      <sha1>rdiz979s7it3lcs6frwrowxh64wuuez</sha1>
    </revision>
  </page>
  <page>
    <title>Ubuntu</title>
    <ns>0</ns>
    <id>47</id>
    <revision>
      <id>1318</id>
      <parentid>1317</parentid>
      <timestamp>2015-11-30T10:57:36Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>/* Diverse */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1944">Ubuntu är en dist som bygger på Debian men har egna repos, även om en del paket synkas från Debians repos. 

=First 5 minutes=
Gör följande för att öka säkerheten. Switch user till root:
 sed -i -r 's/PermitRootLogin yes/PermitRootLogin no/g' /etc/ssh/sshd_config
 systemctl restart ssh

===Hostname===
 echo "hostname" &gt; /etc/hostname
 hostname -F /etc/hostname

===Tidszon===
 dpkg-reconfigure tzdata

=== Ändra namn på NIC ===
Ändra i filen &lt;code&gt;/etc/udev/rules.d/70-persistent-net.rules&lt;/code&gt;

Finns inte filen kan man skapa den. Man måste köra alla 3 kommandon för varje interface man vill lägga till i &lt;code&gt;/etc/udev/rules.d/70-persistent-net.rules&lt;/code&gt;
 export INTERFACE=eth0
 export MATCHADDR=$(ip addr show $INTERFACE | grep ether | awk '{print $2}')
 /lib/udev/write_net_rules

=Pakethanterare=
Både Debian och Ubuntu tillhandahåller flera pakethanterare.

===Apt===
Se [[Apt]]

===dpkg=== 
Debian packaging tool&lt;br/&gt;
'''Lista på installerade program'''
 dpkg --get-selections
 dpkg -l

==Tips o trix==
'''Automatiska uppdateringar'''
 sudo apt-get -y install unattended-upgrades
 sudo dpkg-reconfigure -plow unattended-upgrades

'''Minimal Ubuntu Server'''&lt;br/&gt;
Vill man reducera mängden CPU och RAM som behövs för ens vm kan man under installationen trycka f4 och välja att installera en minimal variant av Ubuntu Server.

'''Mer funktionalitet'''&lt;br/&gt;
Är man trött på att det saknas funktioner på sin maskin kan man lägga till alla paketen med följande kommando:
 sudo aptitude install '~T'

==Diverse==
Network IDS - psad
 sudo apt-get install -y psad &amp;&amp; sudo psad --sig-update
 sudo service psad restart &amp;&amp; sudo service psad status

Host IDS - Aide
 sudo apt-get install -y aide &amp;&amp; sudo aideinit
 sudo aide -u

Log Reporting
 sudo apt-get install -y logwatch
 sudo echo "/usr/sbin/logwatch --output mail --mailto ${email_address} --detail high" &gt;&gt; /etc/cron.daily/00logwatch

[[Category:Distar]]</text>
      <sha1>9kz3adstkynkjci58vpzsri6ecxcu9l</sha1>
    </revision>
  </page>
  <page>
    <title>Ulteo</title>
    <ns>0</ns>
    <id>38</id>
    <revision>
      <id>814</id>
      <parentid>502</parentid>
      <timestamp>2015-07-23T20:42:58Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1916">[[Category:Guider]]
Ulteo Open Virtual Desktop är en FOSS-plattform för virtuella skrivbord. Ulteo kan använda både java och html5, webbläsare och native client.

Rekommenderat operativsystem: Debian 7

== Installation ==
Följande instruktioner gäller för en uppsättning där Session manager och Application server körs på samma maskin. (Mer läsning om Ulteo-arkitekturen: http://archive.ulteo.com/ovd/4.0/docs/Architecture.html)

Referensguide: http://archive.ulteo.com/ovd/4.0/docs/Support_Debian_Wheezy.html
 su -
 echo "deb http://archive.ulteo.com/ovd/4.0/debian wheezy main" &gt; /etc/apt/sources.list.d/ulteo_ovd.list &amp;&amp; apt-get update &amp;&amp; apt-get -y --force-yes install ulteo-keyring &amp;&amp; apt-get update
 apt-get -y install mysql-server
Välj rootlösenord
 mysql -u root -p -e 'create database ovd'
 apt-get -y install ulteo-ovd-session-manager ulteo-ovd-administration-console

== Konfiguration ==

Gå sedan in på:följande och konfigurera databasen med root och pw som sattes tidigare.
 http://&lt;IP&gt;/ovd/admin
Fortsätt sedan i cli:t
 apt-get -y install ulteo-ovd-subsystem &amp;&amp; apt-get -y install ulteo-ovd-web-client
Man skiljer på dessa för att den med säkerhet ska ta en komponent i taget.

Resten av uppsättningen görs i det grafiska gärnssnittet. Gå in på: "unregistered servers" och välj att registrera localhost. Sätt sedan servern i "production"

Skapa sedan din första user för att sedan välja den användaren i "publication wizard". Skapa en user-grupp och en application-grupp. 

Ulteo är nu klart att användas.
 http://&lt;IP&gt;/ovd

== Terminator ==
Vad vore en linuxmaskin utan terminalemulator. Det följer inte med någon default utan man får manuellt lägga till det. Här följer instruktioner för hur man lägger till terminator.
 chroot /opt/ulteo
 apt-get update
 apt-get install terminator
Sedan kan man välja att publicera terminator som en applikation i webguit.</text>
      <sha1>tie6ejyazmglx0aqun89t1nne8si05t</sha1>
    </revision>
  </page>
  <page>
    <title>UniFi</title>
    <ns>0</ns>
    <id>197</id>
    <revision>
      <id>2839</id>
      <parentid>2089</parentid>
      <timestamp>2018-08-31T15:37:32Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1279">Ubiquiti UniFi Controller kan managera accesspunkter, switchar och gateways av märket Ubiquiti. Det stöds på Ubuntu, Debian och Windows.

=Installation=
''Ubuntu''
 echo "deb http://www.ubnt.com/downloads/unifi/debian unifi4 ubiquiti" &gt; /etc/apt/sources.list.d/20ubiquiti.list
 echo "deb http://downloads-distro.mongodb.org/repo/debian-sysvinit dist 10gen" &gt; /etc/apt/sources.list.d/21mongodb.list
 
 apt-key adv --keyserver keyserver.ubuntu.com --recv C0A52C50
 apt-key adv --keyserver keyserver.ubuntu.com --recv 7F0CEB10
 apt-get -q update &amp;&amp; apt-get install -qy --force-yes unifi 

Access web interface
 https://unifi-ip:8443

=Lägga till device manuellt=
SSH'a till din Ubiquiti device.

Default username och password är: '''ubnt'''

För att lägga till devicen kör:
 set-inform http://&lt;unifi-wlc&gt;:8080/inform

Kolla i webuit efter din device och klicka adopt.

Kör sedan samma set-inform kommando igen.

=Factory default=
==Access point==
SSHa och kör följande kommando:
 syswrapper.sh restore-default

==Switch==
SSHa eller console och kör följande:
 set-default

=CLI kommandon=
Visa arp och mac tabellen:
 ubntbox swctrl -d mac show
Visa port status:
 ubntbox swctrl -d port show
Visa startup-config:
 cat /var/run/fastpath/startup-config
[[Category:Guider]]</text>
      <sha1>o9yh0mkfrwbc6a1r0vn5rz25j8216f7</sha1>
    </revision>
  </page>
  <page>
    <title>VM Encryption</title>
    <ns>0</ns>
    <id>534</id>
    <revision>
      <id>2884</id>
      <timestamp>2018-10-15T20:17:09Z</timestamp>
      <contributor>
        <username>Kessemess</username>
        <id>15</id>
      </contributor>
      <comment>Created page with "VM Encryption sker i hypervisorn, "under" den virtuella maskinen.  VM Encryption är helt agnostiskt, Guest OS eller datastore-typ spelar ingen roll. Krypteringen aktiveras vi..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2905">VM Encryption sker i hypervisorn, "under" den virtuella maskinen. 
VM Encryption är helt agnostiskt, Guest OS eller datastore-typ spelar ingen roll. Krypteringen aktiveras via Storage-policy.
De filer som krypteras är:
* VM-filer (VSWP, VMSN mfl)
* VM-diskfiler
* Host core dumps
Filer som inte krypteras:
* Loggfiler
* VM-konfigurationsfiler (VMX, VMSD)
* Descriptor-filer för virtuella diskar (innehåller dock en krypterad bundling av nycklar)
===Requirements===
För att aktivera VM Encryption måste Host Encryption mode vara påslaget, detta ska oftast ske automatiskt, men kan explicit aktiveras. Detta görs via '''Host''' -&gt; '''Configure''' -&gt; '''System''' -&gt; '''Security Profile''' -&gt; välj '''Host Encryption Mode''' -&gt; '''Edit''' -&gt; sätt till '''Enabled'''.
Under tiden en VM krypteras måste även minst lika mycket ledig diskyta på datastore:t finnas som VM:en förbrukar.

===KMS-server för VM Encryption===
Förutsatt att en (tredjeparts) KMS-server finns tillgänglig:
#Lägg till den via '''vCenter-noden''' -&gt; '''Configure''' -&gt; '''More''' -&gt; '''Key Management Server''' -&gt; Tryck på plustecknet med texten '''Add KMS''' bredvid.
#Skapa ett nytt kluster, fyll i infon som efterfrågas.
#Sätt klustret som default KMS Cluster.
#Klicka på Trust i Trust Certificate-rutan för att acceptera Trust:en mot KMS.
Om KMS-servern är korrekt konfigurerad kan du verifiera detta genom att titta på Connection Status, en grön bock visar detta (=Normal).

KMS-servern är den som hanterar kryptering av VMs, vCenter är endast klient till KMS-servern. Om man inte vill att alla administratörer ska ha tillgång till management av VM Encryption kan man använda den nya default-rollen '''No Cryptography Administrator'''.

===Encryption Storage Policy===
Efter anslutningen mot KMS upprättats kan man skapa sin Encryption Storage Policy. Behörighetsmässigt krävs även ''Cryptographic operations.Manage encryption policies''-behörigheten.
Policyn skapas via '''Home''' -&gt; '''Policies and Profiles''' -&gt; '''VM Storage Policies''' -&gt; '''Create VM Storage Policy'''. 
#Följ wizarden, sätt namn m.m.
#Bocka för '''Use common rules in the VM storage policy'''.
#Tryck på '''Add component''', välj '''Encryption''' -&gt; '''Default Encryption Properties''' och sedan '''Next''' (Defaults räcker oftast om policyn inte skall innefatta andra funktioner, t ex caching eller replikering).
#Bocka ur '''Use rule-sets in the storage policy''', välj '''Next'''.
#På '''Storage compatibility'''-sidan, låt '''Compatible''' vara förvalt, välj ett datastore och sedan '''Next'''.
#Verifiera alla settings och tryck '''Finish'''.

Den virtuella maskinen kan krypteras för sig medan diskarna kan lämnas okrypterade, då man endast applicerar Encryption Storage Policy:n på VM Home och inte på diskarna. Krypterade diskar kan däremot inte användas av en okrypterad VM.
[[Category:VMware]]</text>
      <sha1>bhzb2le2fw1vze7gofpb26b7122ceg0</sha1>
    </revision>
  </page>
  <page>
    <title>VMware ESXi</title>
    <ns>0</ns>
    <id>3</id>
    <revision>
      <id>3120</id>
      <parentid>2966</parentid>
      <timestamp>2021-03-29T13:54:19Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7048">ESXi är en type 1 hypervisor utvecklad och såld av VMware. 

== Förberedelser ==
VMware uppdaterar ESXi med jämna mellanrum, var 1-3 månad, och din iso blir snabbt utdaterad. Det smidigaste sättet att tanka hem den senaste iso:n är med ett powershell-script. Inget VMware-konto behövs heller!

[http://vibsdepot.v-front.de/tools/ESXi-Customizer-PS-v2.5.ps1 http://vibsdepot.v-front.de/tools/ESXi-Customizer-PS-v2.5.ps1]

OBS Requirements: VMware PowerCLI version 5.1 or newer
 .\ESXi-Customizer-PS-v2.5.ps1 -v65
Planerar du att köra ESXi på ett konsumentmoderkort är det inte säkert att nätverkskortet fungerar med standard-iso:n. Vill du ha en iso med mer drivrutiner kör istället följande kommando:
 .\ESXi-Customizer-PS-v2.5.ps1 -v60 -vft -load net-e1000e,net55-r8168,net-r8169,sata-xahci

== Patchhantering ==
Detta är generell patchhantering. 

'''Online'''

Börja med att kolla vad senaste imagen heter på [https://esxi-patches.v-front.de/ patch tracker]
 esxcli network firewall ruleset set -e true -r httpClient
 esxcli software profile update -d https://hostupdate.vmware.com/software/VUM/PRODUCTION/main/vmw-depot-index.xml -p ESXi-5.X.X-2015XXXXXXX-standard [--allow-downgrades]
 reboot
'''Offline'''

Ladda ner zip från VMwares hemsida och lägg in på datastore
 esxcli software profile update -d /vmfs/volume/your_datastore/ESXi550-2015XXX.zip -p ESXi-5.5.0-2015XXX-standard 
 reboot
Detta fungerar även mellan versioner, 5.1 -&gt; 5.5 -&gt; 6.0

'''vCenter'''

Har man vCenter bör man använda VMware Update Manager.
 .\ESXi-Customizer-PS-v2.5.ps1 -v55 -ozip
Output an ESXi Offline Bundle that you can use for importing into Update Manager

==Logghantering==
Loggar berättar mycket om din miljö, samla dem. Det finns olika varianter för central ESXi-logghantering. 
* vCenter builtin syslog service
* VMware vRealize Log Insight
* http://www.sexilog.fr/
Peka loggarna i ESXi: Advanced Settings -&gt; Syslog.global.logHost -&gt; udp://[IP]:514

Verify 
 esxcli system syslog config get

==Embedded Host Client==
Webgui till enskilda ESXi-hostar, likt vCenters. Detta är standard sedan ESXi 6.0u2.
 https://[ESXI-HOST]/ui

==SSH==
Varningsmeddelande kan stängas av med:
 esxcli system settings advanced set -o /UserVars/SuppressShellWarning -i 1

Nyckelautentisering &lt;br/&gt;
OBS med -O skriver man över existerande nycklar
 wget http://website/id_dsa.pub -O /etc/ssh/keys-root/authorized_keys

DCUI &lt;br/&gt;
Skriv följande för att starta Direct Console direkt från din SSH-session:
 dcui

==SNMP==
För att slå på SNMP och sätta communitys kan man göra det via CLI.

 esxcli system snmp set --communities '''community'''

Enable SNMP Service:
 esxcli system snmp set --enable true

Öppna upp i den interna brandväggen:
 esxcli network firewall ruleset set --ruleset-id snmp --allowed-all true
 esxcli network firewall ruleset set --ruleset-id snmp --enabled true

Om du vill öppna upp i brandväggen på ett säkert sätt och endast tillåta IP's ifrån 10.0.0.0/24:
 esxcli network firewall ruleset set --ruleset-id snmp --allowed-all false
 esxcli network firewall ruleset allowedip add --ruleset-id snmp --ip-address 10.0.0.0/24
 esxcli network firewall ruleset set --ruleset-id snmp --enabled true

Starta sedan om SNMP tjänsten:
 /etc/init.d/snmpd restart

==VIB==
VIB paket kan vara drivrutiner, third party software eller uppdateringar.

'''Installera'''
 esxcli software vib install -d “/vmfs/volumes/Datastore/DirectoryName/PatchName.zip“

'''Updatera'''
 esxcli software vib update -d “/vmfs/volumes/Datastore/DirectoryName/PatchName.zip”

'''Lista installerade VIB's'''
 esxcli software vib list

== Network ==
Undrar du vilket nätverkskort t.ex. vmnic2 är fysiskt kan du köra följande kommando om du loggar in med SSH på hosten. Porten börjar blinka i 60 sekunder förutsatt att det inte sitter någon kabel i.
 ethtool -p vmnic2 60

Lista NetStack-instanser (VRF)
 esxcfg-vmknic -l
 esxcli network ip interface list 
 ping -S &lt;netstackname&gt; 10.0.0.10

'''CDP''' &lt;br/&gt;
Slå på CDP på en vSwitch
 esxcli network vswitch standard set --cdp-status both|listen --vswitch-name vSwitch1

'''Iperf''' &lt;br/&gt;
Fr.o.m. ESXi 6.0 finns iperf inbyggt. Se även [[Iperf]].

Server
 cp /usr/lib/vmware/vsan/bin/iperf /usr/lib/vmware/vsan/bin/iperf.copy
 /usr/lib/vmware/vsan/bin/iperf.copy -s
Klient
 /usr/lib/vmware/vsan/bin/iperf -c &lt;server-ip&gt;

'''PXE''' &lt;br/&gt;
Använd Ventoy.

==Tips n Tricks==
=== NTP ===
NTP via SSH
 cat &gt; /etc/ntp.conf &lt;&lt; __EOF__
 restrict default kod nomodify notrap noquery nopeer
 restrict 127.0.0.1
 driftfile /etc/ntp.drift
 server 0.se.pool.ntp.org
 __EOF__
 /sbin/chkconfig ntpd on

=== Nested Hypervisor ===
För att kunna köra en nested hypervisor (t.ex. Hyper-V, ESXi) på din ESXi-host måste det finns EPT/RVI-stöd i CPUn. Ett enkelt sätt att kolla det på din ESXi-host:
 vim-cmd hostsvc/advopt/update Config.HostAgent.plugins.solo.enableMob bool true
 https://[esxi-ip-address]/mob/?moid=ha-host&amp;doPath=capability
logga in och kolla raden: nestedHVSupported

Sedan måste hosten VHV enableas.
 grep -i "vhv.enable" /etc/vmware/config || echo "vhv.enable = \"TRUE\"" &gt;&gt; /etc/vmware/config
 reboot

=== Initializing ACPI ===
Om uppstarten fastnar på detta steg, dubbelkolla att det inte bootar med UEFI och i så fall ta bort UEFI från boot-menyn.

=== Rollback ===
För att backa en ESXi-uppgradering kan man göra en rollback. Starta om hosten, under boot när progressbaren kommer tryck: Shift+R &lt;br/&gt;
''OBS bootbanken skrivs över var 60:e minut så man har en timme på sig''
 Current hypervisor will permanently be replaced
 with build: X.X.X-XXXXXX. Are you sure? [Y/n]
 Shift+Y
 Enter to boot

=== Lista maskiner ===
Lista virtuella maskiner som är på
 /usr/sbin/localcli vm process list

=== Lämna tillbaka oanvända blocks ===
Om du har ett san, där du kör med tjocka diskar mot så kommer du behöva lämna tillbaka blocks ibland.
för att enkelt göra detta kan du köra kommandot:

 for i in $(ls /vmfs/volumes/ | grep datastorename) ; do echo "Reclaiming on: " $i ; time esxcli storage vmfs unmap -l $i ; done 

Byt ut datastorename mot namnstandarden på dina datastores. tex ssd_ds om dina datastores heter ssd_ds001-8

Detta behövs göra om du kör vmfs 5 och tjocka diskar.
Har du 512kb blocksize och vmfs 6 så sköts det automagiskt på DELL compellant

=== G5-G7 HP ProLiant ===
Ladda ner från: http://www8.hp.com/us/en/products/servers/solutions.html?compURI=1499005#tab=TAB4
 .\ESXi-Customizer-PS-v2.4.ps1 -v55 -izip .\VMware-ESXi-5.5.0-Update2-2403361-HP-550.9.2.27-Mar2015-depot.zip -update -remove hp-ams

===LSI RAID===
Vill du monitorera ditt raidkort i vsphereklienten gör följande:&lt;br/&gt;
Ladda upp följande fil till datastore
 http://ds.karen.hj.se/~cameljoe/resources/VMW-ESX-5.5.0-lsiprovider-500.04.V0.55-0006-offline_bundle-2626932.zip

 esxcli software vib install -d /vmfs/volumes/[DATASTORE]/VMW-ESX-5.5.0-lsiprovider-500.04.V0.55-0006-offline_bundle-2626932.zip
 reboot

[[Category:VMware]]
[[Category:Guider]]</text>
      <sha1>3cvp5gxd2bb8mm9qk31ncd5rsfyutgz</sha1>
    </revision>
  </page>
  <page>
    <title>VMware Vsphere Client</title>
    <ns>0</ns>
    <id>137</id>
    <revision>
      <id>1014</id>
      <parentid>921</parentid>
      <timestamp>2015-09-06T19:39:24Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>Helikopter moved page [[VMware Vsphere]] to [[VMware Vsphere Client]] without leaving a redirect</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="752">VSphere Client kan användas för att managera ESXi Hosts samt Vcenter men har inte alla funktioner till Vcenter som finns i WebGuit. 

== Installation ==
Vsphere client finns att ladda ner via din ESXi Host eller Vcenter och är bara att klicka next på genom hela.

== Kända Fel ==
Fel som kan uppstå med vsphere client.
 '''Om man får felet VPXclient.exe har slutat svara vid start av programmet.'''
 Länkplats C:\Program Files (x86)\VMware\Infrastructure\Virtual Infrastructure Client\Launcher (windows 10 Pro x64)
    - Redigera fil VpxClient.exe.config och lägg till :
          &lt;startup useLegacyV2RuntimeActivationPolicy="true"&gt;
              &lt;supportedRuntime version="v4.0"/&gt;
          &lt;/startup&gt;

[[Category:VMware]]
[[Category:Guider]]</text>
      <sha1>gil7r59u9bs1hb0q7m4fo5tp5zgd7ry</sha1>
    </revision>
  </page>
  <page>
    <title>VMware vCenter</title>
    <ns>0</ns>
    <id>88</id>
    <revision>
      <id>1707</id>
      <parentid>1628</parentid>
      <timestamp>2016-04-26T19:39:46Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <comment>/* Konfiguration */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5036">vCenter är en central manage server för alla dina ESXi hostar. Det är med vCenter du får funktioner som HA. Det krävs ett VMware konto för att kunna ladda hem vCenter och sedan en licens för att kunna använda längre än 60 dagar.  

== Installation ==
Enklaste sättet att få igång vCenter är att ladda hem vmwares appliance från vmware och deploya den på en esxi host.&lt;br/&gt;
VCSA 6.0, vCenter Server Appliance, finns inte längre som .ovf utan man laddar hem iso.

== Konfiguration ==
Den mesta konfiguration sker med hjälp av vmwares klient eller vmware webui.

=== Första gången ===
* Default användarnamn och lösenord på vmwares appliance är,
 root/vmware
* Börja med att öppna en console och logga in. Kör scriptet under för att sätta ip, hostnamn, gw, dns.
 /opt/vmware/share/vami/vami_config_net
* Surfa sedan in på https://&lt;ip&gt;:5480, här görs den initiala setupen.
* All datacenter och klustermanagering görs sedan från: https://&lt;ip&gt;:9443

=== LDAP koppla vCenter ===
* Logga in som administrator@vsphere.local (Default lösenord är vmware)
* Gå till &lt;code&gt;Administration &gt; Single Sign-On &gt; Configuration &gt; Identity Sources&lt;/code&gt;. Tryck på det gröna plustecknet.
 Om inte Single Sign-On finns under Administration så är du antagligen inloggad som användaren root.
* Fyll sedan i dina uppgifter och tryck på "Test connection".
&lt;br&gt;
För att kunna se Single sign-on under Administration och göra ändringar behöver man lägga till sin användare eller en grupp i Administrators.
* Gå till &lt;code&gt;Users and Groups &gt; Groups&lt;/code&gt;. Lägg till en användare eller en grupp i '''Administrators''' gruppen. Dettaa har inget med rättigheterna mot VM's.
&lt;br&gt;
* För att styra rättigheter för vad en användare får göra gå till &lt;code&gt;Administration &gt; Access Control &gt; Roles&lt;/code&gt; Tryck på gruppen Administrator och sedan klicka på vCenterns hostnamn.
* Under vCenterns &lt;code&gt;Manage &gt; Permissions&lt;/code&gt; Sätter man permissions för vilka användare och grupper som får göra vad på servern.

===Enable SCP===
För att kunna SCP'a filer till vCenter skriv följande:
 chsh –s /bin/bash
Då ändrar man login skalet från '''appliancesh''' till '''bash''' och kan då SCP filer.

För att ändra tillbaka till vanliga skriv:
 chsh -s /bin/appliancesh

== VMware Client Integration Plugin ==
Behövs för att kunna öppna console eller logga in med sitt windows login.
Länk till pluginet finns längst ner på https://&lt;vCenterip&gt;:9443.

===Chrome NPAPI===
Pluginet använder sig av NPAPI(Netscape Plugin Application Programming Interface). Chrome valde i version 42 att stänga av stödet för NPAPI och kommer i version 45 att ta bort NPAPI helt från webbläsaren.

Tills dom tagit bort NPAPI kan man aktivera pluginet igen med denna länken,
 chrome://flags/#enable-npapi

====Chrome 45====
Nu får man installera ett CIP-paket för att få samma funktionalitet, detta använder inte NPAPI.
 http://vsphereclient.vmware.com/vsphereclient/2/9/9/4/0/4/1/VMware-ClientIntegrationPlugin-6.0.0.exe

==VMware Remote Console==
VMware Remote Console(VMRC) togs fram efter att Chrome valde att ta bort stödet för NPAPI. VMRC är ett standalone program för Windows och Mac OS och används tillsamans med VMware vSphere Web Client det följer med vCenter Server 5.5U2b och senare.

För att ladda hem och starta VMCR i vSphere 5.5 och 6.0 så har två nya länkar lagts till på varje VM's status sida.

'''vSphere 5.5''' heter länkarna '''Open with VMRC''' och '''Download VMCR'''

'''Vsphere 6.0''' heter länkarna '''Launch Remote Console''' och '''Download Remote Console'''

==Ändra Login UI==
I vCenter 6.0 går det att göra om sitt LoginUI tex lägga till en egen bild. Det finns 2 filer som man kan ändra i, det är '''unpentry.jsp''' och '''login.css'''. I mappen '''img''' kan du lägga bilder och referera till dom i koden.

[https://github.com/Hackernet-se/vmware-custom-login Hackernet's egna Login UI]

'''VCSA 6.0'''
 /usr/lib/vmware-sso/vmware-sts/webapps/websso/WEB-INF/views/unpentry.jsp
 /usr/lib/vmware-sso/vmware-sts/webapps/websso/resources/css/login.css
 /usr/lib/vmware-sso/vmware-sts/webapps/websso/resources/img

'''Windows vCenter Server 6.0'''
 C:\ProgramData\VMware\vCenterServer\runtime\VMwareSTSService\webapps\websso\WEB-INF\views
 C:\ProgramData\VMware\vCenterServer\runtime\VMwareSTSService\webapps\websso\resources\css
 C:\ProgramData\VMware\vCenterServer\runtime\VMwareSTSService\webapps\websso\resources\img

==Regenerate certificates==
För att skapa nya cert eller lägga in ett eget cert från tex [[Let's Encrypt]] så använder man certificate manager.
 /usr/lib/vmware-vmca/bin/certificate-manager

==Reset the VMware vCenter Single Sign-On administrator password==
Om man glömt sitt lösenord till en användare tex Administrator@vSphere.local kan man skapa ett nytt.
 /usr/lib/vmware-vmdir/bin/vdcadmintool

*Välj nr 3: '''Reset account password'''
*Ange följande som UPN: '''Administrator@vSphere.

[[Category:VMware]]
[[Category:Guider]]</text>
      <sha1>qm28rryzb0ixpvhpc4vh4ea4vh0aju7</sha1>
    </revision>
  </page>
  <page>
    <title>VPP</title>
    <ns>0</ns>
    <id>251</id>
    <revision>
      <id>1929</id>
      <parentid>1722</parentid>
      <timestamp>2016-07-05T08:25:19Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1151">Vector Packet Processing är en network packet processing stack för x86-hårdvara. Det kör en Linux user space process och har stöd för bl.a. IPSEC, GRE, VXLAN, MPLS, VRF, VLAN, Segment Routing. Med denna mjukvara kan en vanlig server kan bli en router/switch med väldigt hög throughput. Det är en open source version av Cisco's Vector Packet Processing (VPP) teknologi.

==Installation==
Ubuntu 16.04
 echo "deb https://nexus.fd.io/content/repositories/fd.io.ubuntu.xenial.main/ ./" | sudo tee -a /etc/apt/sources.list.d/99fd.io.list
 sudo apt update &amp;&amp; sudo apt install vpp vpp-lib vpp-dpdk-dkms

Fedora
 sudo curl -o /etc/yum.repos.d/fdio.repo https://paste.fedoraproject.org/355177/60579220/raw/
 sudo dnf update &amp;&amp; sudo dnf install vpp

==Konfiguration==
 cat /etc/vpp/startup.conf
Service
 sudo systemctl start vpp
 sudo systemctl status vpp

VPP lyssnar default på tcp port 5000
 telnet 0 5000
VPP shell
 show interface
Bash
 sudo vppctl show ip arp

'''Honeycomb''' är en agent man kan köra på samma host som tillhandahåller yang models via netconf/restconf för remote management.
 sudo yum install honeycomb

[[Category:Network]]</text>
      <sha1>1flyhshmffcb3d515r7z8jn0dh352eo</sha1>
    </revision>
  </page>
  <page>
    <title>VSphere Permissions</title>
    <ns>0</ns>
    <id>525</id>
    <revision>
      <id>2842</id>
      <timestamp>2018-09-05T21:03:56Z</timestamp>
      <contributor>
        <username>Kessemess</username>
        <id>15</id>
      </contributor>
      <comment>Created page with "== Access Control == vSphere erbjuder detaljerad behörighetskontroll med hjälp av permissions. Behörigheterna specificeras med hjälp av roles, som kan bestå av flera priv..."</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3982">== Access Control ==
vSphere erbjuder detaljerad behörighetskontroll med hjälp av permissions. Behörigheterna specificeras med hjälp av roles, som kan bestå av flera privileges.
En permission har tre beståndsdelar; en role (innehållandes privileges), som tillsammans med en användare/grupp mappas mot ett objekt.

När en permission tilldelas får man välja om den ska propagera nedåt i hierarkin. Propageringen ställs inte in universellt, utan för varje tilldelad permission. Permissions som appliceras på child-objekt överskrider alltid en permission som propagerats från parent-objekt, dock kan enbart en permission explicit appliceras på ett objekt per användare/grupp.
Då två permissions ärvs till samma objekt, t ex vid en kombination av arv från VM Folder och Resource Pool, kombineras de.
Om en användare är medlem i flera grupper som har olika Permissions på ett objekt kan två saker hända:
*Om inga permissions definierats för användaren direkt på objektet appliceras de behörigheter som grupperna medför.
*Om en permission definierats för användaren på objektet, tar den företräde över alla gruppbehörigheter (även de som ärvts).
	
För att se vilka permissions som applicerats på ett objekt går man till vSphere-objektet -&gt; '''Permissions'''-fliken, sedan tittar man i "Defined In"-kolumnen. Ifrån denna vy kan även en lista över permissions exporteras.

För att lägga till/modifiera/ta bort permissions går man till: '''Home''' -&gt; '''Administration''' -&gt; '''Access Control''' -&gt; '''Roles'''

=== ESXi Local Host Permissions ===
Standalone-hostar har tre fördefinierade roles som kan användas för att tilldela permissions. Dessa är '''Administrator''', '''Read Only''' och '''No Access'''.

== vCenter Server Permissions ==
vCenter Permissions appliceras på objekt i objekthierarkin.

=== Global Permissions ===
Global permissions appliceras på ett globalt rotobjekt som sträcker sig över olika lösningar, t ex kan permission tilldelas en användare/grupp som ger läsrättigheter både i vCenter och vRealize Orchestrator. Om inte propagering för en Global Permission slås på kommer användaren/gruppen inte få tillgång till objekten i hierarkin, utan enbart ett fåtal globala funktioner, t ex att skapa Roles.

=== vSphere.local group membership ===
Medlemmar i vSphere.local-grupper kan utföra vissa saker, t ex licenshantering. Dessa grupper gäller också för administration av PSC.

=== Identity Sources ===
Det finns fyra supporterade identitetskällor som kan läggas till i vCenter (PSC):
* Active Directory
* Active Directory over LDAP
* OpenLDAP (flera implementationer stöds)
* LocalOS (lokala användare på PSC:n)
vCenter Single Sign-On system users finns också, denna källa skapas och läggs till automatiskt när vCenter SSO installeras.
Om Active Directory ska användas som identitetskälla måste vCenter-servern först bli medlem i domänen. Detta görs under '''Administration''' -&gt; '''Deployment''' -&gt; '''System Configuration''' -&gt; '''Nodes''', välj vCenter-servern i listan. Sedan under '''Manage'''-fliken -&gt; '''Settings''' -&gt; '''Advanced''' -&gt; '''Active Directory''', klicka på "'''Join...'''"-knappen.

=== Permission Validation ===
Som standard valideras alla användare och grupper var 1440:e minut (24h), om en användare tagits bort eller bytt namn tas alla permissions relaterade till denne bort vid nästa validering. 

=== System Roles kontra Sample Roles ===
System &amp; Sample Roles finns per default, det som skiljer dem åt är att System Roles inte går att editera eller ta bort, endast kloning är möjlig.

De System Roles som finns är följande:
Administrator, No Cryptography Administrator, No Access och Read Only.

De fördefinierade Sample Roles är:
Virtual Machine Power User, Virtual Machine User, Resource Pool Administrator, VMWare Consolidated Backup User, Datastore Consumer, Network Administrator, Content Library Administrator

[[Category:VMware]]</text>
      <sha1>hnwntyzfam240cv8bmxlt8me1d1vn47</sha1>
    </revision>
  </page>
  <page>
    <title>Vagrant</title>
    <ns>0</ns>
    <id>80</id>
    <revision>
      <id>1460</id>
      <parentid>812</parentid>
      <timestamp>2016-01-22T12:23:17Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1897">Vagrant är program som skapar och konfigurerar virtuella utvecklingsmiljöer. Det kan ses som en högre nivå av virtualisering än VirtualBox, VMware, [[KVM]] och Linux Containers (LXC). Sedan version 1.6 har Vagrant inbyggt stöd för Docker containers.

==Installation==
Fedora
 dnf install vagrant 

==Providers==
Vagrant gör ingen virtualisering utan det görs av en underliggande provider, t.ex. virtualbox, vmware, AWS eller docker. Virtualbox är default. En provider måste finnas tillgänglig på maskinen där vagrant ska användas. Installera virtualbox:
 http://www.if-not-true-then-false.com/2010/install-virtualbox-with-yum-on-fedora-centos-red-hat-rhel/

Providers installeras som plugins och listas med. För virtualbox behövs ingen plugin.
 vagrant plugin list

===== VMware Workstation =====
vagrant-vmware-workstation är en kommersiell produkt och kräver licens. 

==Boxes==
Istället för att bygga en virtuell maskin från grunden varje gång använder Vagrant en grundimage för att snabbt klona en virtuell maskin. Dessa imagear kallas på Vagrantspråk för boxes. Att ange vilken box som ska användas för din Vagrantmiljö är alltid det första steget när du ska skapa en ny Vagrantfile. Tillgängliga boxes: https://atlas.hashicorp.com/boxes/search
 vagrant box add ubuntu/trusty64 
Boxes lagras i ~/.vagrant.d/boxes/

== Konfiguration ==
Generera Vagrantfile
 mkdir vagrant &amp;&amp; cd vagrant
 vagrant init ubuntu/trusty64
Starta environment. Detta kommando startar miljö utifrån den Vagrantfile som finns det directory du kör kommandot i.
 vagrant up --provider virtualbox
Anslut till den virtuella maskinen
 vagrant ssh
Städa
 vagrant destroy
Lista skapade vagrantmiljöer
 vagrant global-status

==Plugins==
Det finns många plugins till vagrant. http://vagrant-lists.github.io/

===vSphere===
Se https://github.com/nsidc/vagrant-vsphere

[[Category:Guider]]</text>
      <sha1>2wi07f4hfuv5zmecnqhezor7kpv7utf</sha1>
    </revision>
  </page>
  <page>
    <title>Vsftpd</title>
    <ns>0</ns>
    <id>201</id>
    <revision>
      <id>1241</id>
      <parentid>1240</parentid>
      <timestamp>2015-11-11T14:23:15Z</timestamp>
      <contributor>
        <username>Bat</username>
        <id>4</id>
      </contributor>
      <comment>/* Tillåtnade/nekade Användare */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3385">[[Category:Guider]]
VSFTPD (Very secure FTP daemon) Är en snabb och smidig FTP server för Unix system.

=Installation=
De flesta distar har vsftpd i sina standardrepos så vanligtvis är det bara att köra en
apt-get install vsftpd eller motsvarande med yum 

=Konfiguration=
I en Debianbaserad dist kommer du hitta konf filen i /etc/vsftpd.conf 
Det finns 5 värden att titta på direkt

 anonymous_enable=(YES/NO) Om du vill tillåta anonyma inloggningar mot FTPN
 local_enable=(YES/NO) Om lokala användare ska kunna använda FTP tjänsten
 write_enable=(YES/NO) Om användarna ska kunna skriva data till FTPn eller inte
 force_dot_files=(YES/NO) Om . filer ska visas i FTPn t.ex. .htaccess 
 hide_ids=(YES/NO) Om rättigheterna på filer ska synas på filerna. Om man tillåter anonyma inloggningar kan det vara en bra idé att köra på YES så de inte kan få ut information om vilka konton som finns på servern.

==Chroot==

 chroot_local_user=(YES/NO) Om användarna ska vara låsta till sin hemfolder eller inte
 chroot_list_enable=(YES/NO) Om du vill ange en lista av användare som ska vara tvärtemot vad du angav i chroot_local_user

Om Chroot_list_enable=YES så får du skapa en lista i /etc/vsftpd.chroot_list där du skriver in usernamn på användarena som INTE ska följa chroot_local_user reglen.

==Tillåtnade/nekade Användare==
Om man har local_enable igång i konfen kan det vara en bra idé att inte låta t.ex. root och servicekonton logga in på FTPn.
Det kan vi lösa genom att lägga till följande rader i konfen

 userlist_deny=YES
 userlist_file=/etc/vsftpd.denied_users

I userlist_file=/etc/vsftpd.denied_users skriver du sedan in användarnamn som inte ska få logga in via ftpn t.ex. postfix och root.

==SSL==
Ganska straightforward conf här. Exemplet nedan är från en av Bats servrar
 ssl_enable=YES
 allow_anon_ssl=NO
 force_local_data_ssl=YES
 force_local_logins_ssl=YES
 ssl_tlsv1=YES
 ssl_sslv2=NO
 ssl_sslv3=NO

==Virtuela Användare==
Börja med att skapa en mapp för vsftpd om det inte finns i /etc/vftpd/
Skapa en fil med användare &amp; Lösenord (nano users.txt) i stilen

 Användare1
 Lösenord1
 Användare2
 Lösenord2 
 etc

Skapa sedan en databas med användarna
db_load -T -t hash -f users.txt vsftpd-virtual-user.db
Glöm inte att sätta rättigheter och ta bort .txt filen efteråt.

I /etc/vsftpd.conf så ska vi också göra några ändringar för att de virtuela användarna ska funka

 virtual_use_local_privs=(YES/NO) Virtuella användare får samma rättigheter som vanliga användare annars får de anon rättigheter
 pam_service_name=vsftpd.virtual Namnet på pam servicen vi vill använda
 guest_enable=YES Tillåter virtuella användare
 local_root=/home/vftp/$USER Vilken mapp de virtuela användarna ska ha access till
 user_sub_token=$USER sätter deras användarnamn till chrooten

Då ska vi bara fixa lite med PAM sen är vi good to go 
nano /etc/pam.d/vsftpd.virtual

 #%PAM-1.0
 auth       required     pam_userdb.so db=/etc/vsftpd/vsftpd-virtual-user
 account    required     pam_userdb.so db=/etc/vsftpd/vsftpd-virtual-user
 session    required     pam_loginuid.so

Sen är det bara att skapa foldrarna för användarna i /home/vftp/
Foldrarna bör ägas av samma användare som tjänsten körs ifrån då användarna använder tjänstens permissions.

==LDAP==

Kör med pam_ldap får skriva mer senare</text>
      <sha1>f7lhe605recz15g8k73foxhta8ugcnd</sha1>
    </revision>
  </page>
  <page>
    <title>VyOS</title>
    <ns>0</ns>
    <id>220</id>
    <revision>
      <id>3154</id>
      <parentid>3142</parentid>
      <timestamp>2022-04-26T11:37:31Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5364">VyOS är ett Linux-baserat network operating system med mjukvaru-routing, firewall och VPN funktionalitet. Det är en community fork av Vyatta Core med [[Juniper_JunOS|JunOS]]-liknande syntax och bygger på Debian och Quagga routing engine. Det har bl.a. stöd för [http://vyos.net/wiki/DMVPN DMVPN], [http://vyos.net/wiki/VXLAN VXLAN], [http://vyos.net/wiki/User_Guide#OSPF OSPF], [http://vyos.net/wiki/User_Guide#BGP BGP] och [http://vyos.net/wiki/IPv6 IPv6]. Men saknar tyvärr stöd för Multicast routing och MPLS. Det finns möjlighet att installera [[FastNetMon]] direkt på en VyOS-router, se länk [https://github.com/pavel-odintsov/fastnetmon/blob/master/docs/VyOS_INSTALL.md]

=Installation=
Ladda ner OVA alternativt installera från iso eller netbootxyz. PW: vyos
 vyos@vyos:~$ install image 

=Uppgradering=
 add system image https://s3.amazonaws.com/s3-us.vyos.io/rolling/current/vyos-rolling-latest.iso
 show system image

=Konfiguration=
Byt till konfigurationsläge.
 configure
Ändringar måste commitas. För att spara till startup config används save.
 commit
 save
Show run
 show conf
Show run kommandon
 show configuration commands

'''SSH'''
 set service ssh port '22'
 set service ssh listen-address '172.20.0.1'
Logga in med ssh-nyckel
 set system login user vyos authentication public-keys user@mgm key 'AAAAC3NzaC1lZAAAIGCW6VcUwAzbX0gipoiDYBxxxxxxxxx'
 set system login user vyos authentication public-keys user@mgm type 'ssh-ed25519'

'''Live logging'''
 monitor log

'''System'''
 set system domain-name hackernet.se
 set system host-name vyos01
 set system name-server 208.67.222.222
 set system name-server 208.67.220.220
 set system time-zone Europe/Stockholm

'''Backup'''
 set system config-management commit-archive location scp://user@172.20.0.20:/vyos_backups/
Testa backuptagning manuellt.
 copy file running://config/config.boot to scp://user@172.20.0.20:/vyos_backups/

'''Interface'''
 configure
 set interfaces ethernet eth0 address '10.0.0.1/24'
 set interfaces ethernet eth0 description 'INSIDE'
 show interfaces

'''Default route'''
 set protocols static route 0.0.0.0/0 next-hop 10.0.10.1 distance '1'
Verify
 show ip route

'''Comments''' &lt;br/&gt;
Man kan lägga in kommentarer var som helst i konfigurationen. 
 comment ''path-config-section'' "comment"

Default editerar man från top level ([edit]) men för att undvika att alltid skriva långa kommandon kan man ställa sig var som helst i strukturen och använda relativa paths. "up" är för att backa.
 edit interfaces ethernet eth0 
 set address '10.0.0.1/24'

'''Öka ring queue buffer size'''
 sudo ethtool -g eth0
 sudo ethtool -G eth0 tx 4096 rx 4096

==NAT==
Overload/PAT
 set nat source rule 10 outbound-interface eth0
 set nat source rule 10 source address 10.0.0.0/24
 set nat source rule 10 translation address masquerade

==IPv6==
Din ISP måste supporta IPv6 prefix delegation. Följande funkade för Bahnhof.

Slå på prefix-delegation(pd) på ditt wan interface, och assigna ett prefix till ditt interface i detta fallet eth2. 
 set interfaces ethernet eth0 address 'dhcpv6'
 set interfaces ethernet eth0 description 'WAN'
 set interfaces ethernet eth0 dhcpv6-options pd 0 interface eth2 sla-id '2'
 set interfaces ethernet eth0 dhcpv6-options pd 0 length '56'

Sätt sedan på router-advert på eth2 för att ge ut en IPv6 address och DNS server till klienterna.
 set service router-advert interface eth2 name-server '2001:4860:4860::8888'
 set service router-advert interface eth2 name-server '2001:4860:4860::8844'
 set service router-advert interface eth2 prefix ::/64

==Router-on-a-stick==
Sub-interfaces
 set firewall name LOCAL default-action 'drop'
 set firewall name LOCAL rule 10 action 'accept'
 set firewall name LOCAL rule 10 state established 'enable'
 set firewall name LOCAL rule 10 state related 'enable'
 set firewall name OUTSIDE default-action 'drop'
 set firewall name OUTSIDE rule 10 action 'accept'
 set firewall name OUTSIDE rule 10 state established 'enable'
 set firewall name OUTSIDE rule 10 state related 'enable'
 set interfaces ethernet eth0 vif 2 address '172.20.0.1/24'
 set interfaces ethernet eth0 vif 2 description 'LAN'
 set interfaces ethernet eth0 vif 3 address 'dhcp'
 set interfaces ethernet eth0 vif 3 description 'WAN'
 set interfaces ethernet eth0 vif 3 firewall in name 'OUTSIDE'
 set interfaces ethernet eth0 vif 3 firewall local name 'LOCAL'

==Zerotier==
&lt;syntaxhighlight lang="Bash"&gt;
sudo -i
curl -s https://install.zerotier.com | sudo bash
cd /var/lib &amp;&amp; mv /var/lib/zerotier-one /config/scripts/ &amp;&amp; ln -s /config/scripts/zerotier-one
/var/lib/zerotier-one/zerotier-cli join af78xxxxxxx
&lt;/syntaxhighlight&gt;

'''Upgrade'''
&lt;syntaxhighlight lang="Bash"&gt;
sudo -i
apt update &amp;&amp; apt install zerotier-one
&lt;/syntaxhighlight&gt;

==netboot.xyz==
DHCP-server + TFTP-server + netboot.xyz, all-in-one.

 set service dhcp-server shared-network-name LAN subnet 172.20.0.0/24 bootfile-server 172.20.0.1
 set service dhcp-server shared-network-name LAN subnet 172.20.0.0/24 bootfile-name netboot.xyz.efi
 set service tftp-server directory /config/tftproot
 set service tftp-server listen-address 172.20.0.1
 commit
 
 sudo -i
 mkdir /config/tftproot &amp;&amp; cd /config/tftproot/ &amp;&amp; wget https://boot.netboot.xyz/ipxe/netboot.xyz.efi

OBS funkar endast med EFI-klienter (med Secure Boot avstängt).

[[Category:Network]]</text>
      <sha1>gy4e0scirxvv1hroxny7n199s6ql63k</sha1>
    </revision>
  </page>
  <page>
    <title>Weechat</title>
    <ns>0</ns>
    <id>16</id>
    <revision>
      <id>2782</id>
      <parentid>1640</parentid>
      <timestamp>2018-05-24T14:08:47Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5547">[[Category:Guider]]
WeeChat är en terminalbaserad Internet Relay Chat (IRC) klient. WeeChat är skriven i C, och är gjord för att vara flexibel och utbyggbar. WeeChat har alla möjliga plugins skrivna i olika språk t.ex. [[Python]], Perl, och Ruby.

==Installation==
Exempel: Ubuntu 18.04
 sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 11E9DE8848F2B65222AA75B8D1820DB22A11534E
 sudo apt-get install apt-transport-https
 echo "deb https://weechat.org/ubuntu bionic main" | sudo tee /etc/apt/sources.list.d/weechat.list 
 sudo apt-get update &amp;&amp; sudo apt-get -y install weechat weechat-scripts

Använd [[Tmux]] och [[Systemd]] för att få weechat som en bakgrundstjänst med autostart.

&lt;syntaxhighlight lang="bash"&gt;
sudo dd of=/etc/systemd/system/weechat.service &lt;&lt; EOF
[Unit]
Description=Weechat IRC Client (in tmux)

[Service]
User=$USER
Type=forking
ExecStart=/usr/bin/tmux -2 new-session -d -s weechat /usr/bin/weechat
ExecStop=/usr/bin/tmux kill-session -t weechat

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl enable weechat 
&lt;/syntaxhighlight&gt;

==Konfiguration==
Starta Weechat och lägg in grundläggande konfiguration. Glöm inte att spara efter varje inställning du gör som du vill ska finnas kvar efter reboot.
 sudo systemctl start weechat &amp;&amp; tmux attach
 
 /set irc.server_default.nicks "HorseBoy_92"
 /set irc.server_default.realname "John Smith"
 /save

==== Anslut till irc-nätverk ====
Basic exempel:
 /server add freenode irc.freenode.net/6667 -autoconnect
 /set irc.server.freenode.autojoin "#FreeNAS,#cisco,#pfsense"

Exempel med password och self-signed cert server side.
 /server add hacker irc1.hacker.se/6667 -password=noes -ssl -autoconnect
 /set irc.server.hacker.ssl_verify off
 /save

Anslut till nästa IRC server. 
 /reconnect freenode -switch

==== Script ====
 /script
 /script install keepnick.py

==== Ångra inställning ====
Alla kommandon som börjar med /set kan man köra /unset på.
 /unset &lt;option&gt;

==== Relay ====
Relay behövs för tex glowing-bear, se nedan.

 /set relay.network.password secretpw
 /relay add weechat 9001

Vet ej vilken av följande två som behövs för att tillåta klienter från ett annat nät än samma som weechatservern.
 /set relay.network.allowed_ips *
 /set relay.network.websocket_allowed_origins *

Weechat relay lyssnar default efter IPv6. För att stänga av.
 /set relay.network.ipv6 off

==== Skicka ett kommando när du ansluter. ====
 /set irc.server.quakenet.command "/MSG Q@CServe.quakenet.org AUTH USERNAME PASSWORD"

==== Filter ====
Filter kan användas för att slippa se vissa ord, användare eller meddelande.

För att filtrera bort join/part/quit-meddelanden.
 /set irc.look.smart_filter on
 /filter add joinquit *.freenode.* irc_join,irc_part,irc_quit *

==Fish==
 aptitude install python-crypto
 /script install fish.py
 /set fish.look.mark_encrypted "."
 /set fish.look.mark_position off|begin|end

 DH1080:                    /blowkey exchange nick 
 Set the key for a channel: /blowkey set -server freenet #blowfish key
 Remove the key:            /blowkey remove #blowfish
 Set the key for a query:   /blowkey set nick secret+key
 List all keys:             /blowkey 

==Glowing Bear==
Glowing Bear är en webb-frontend för weechat, byggd i html5. Man behöver aldrig sköta något underhåll utav Glowing Bear, utan koden hämtas av din webbläsare från deras servrar varje gång man använder det. Kräver att man kör Weechat version 0.4.2 eller högre. En relay behövs för att glowing bear ska fungera, se ovan. Anslut sedan på glowing bear sidan mot IP eller DNS-namn. Notera att detta kan vara en intern IP.

Länk [http://www.glowing-bear.org/ http]
&lt;br&gt;
Länk [https://glowing-bear.github.io/glowing-bear/ https]

=== SSL ===
För att kryptera trafiken mellan din webbläsare och din weechat relay så använd SSL. 

====Skapa eget cert====
 mkdir -p ~/.weechat/ssl &amp;&amp; cd ~/.weechat/ssl
 openssl req -nodes -newkey rsa:4096 -keyout relay.pem -x509 -days 3650 -out relay.pem -subj "/CN=glowing.fu.se/"

 /set relay.network.password secretpw
 /relay sslcertkey
 /relay add ssl.weechat 9001

====Let's Encrypt====
Weechat kan använda cert som är signade med [[Let's_Encrypt|Let's Encrypt]].

 mkdir -p ~/.weechat/ssl
 cat cert.pem &gt; ~/.weechat/ssl/relay.pem &amp;&amp; cat chain.pem &gt;&gt; ~/.weechat/ssl/relay.pem &amp;&amp; cat privkey.pem &gt;&gt; ~/.weechat/ssl/relay.pem
 /set relay.network.password secretpw
 /relay sslcertkey
 /relay add ssl.weechat 9001

'''För att ladda om SSL certet.'''
 /relay sslcertkey

=== Bakom Reverse Proxy ===
För att köra glowing bear genom en [[Nginx]]/[[Apache]] HTTP reverse proxy måste man köra det som en websocket, inte en HTTP-anslutning ("Upgrade"). 

'''Nginx'''.
&lt;syntaxhighlight lang="apache"&gt;
limit_req_zone $binary_remote_addr zone=weechat:10m rate=5r/m;

server {
        [... other config...]

        location /weechat {
            proxy_pass http://localhost:9001/weechat;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
            proxy_read_timeout 604800;
            proxy_set_header X-Real-IP $remote_addr;
            limit_req zone=weechat burst=1 nodelay;
        }
}
&lt;/syntaxhighlight&gt;
'''Apache'''
&lt;syntaxhighlight lang="apache"&gt;
 &lt;IfModule mod_proxy.c&gt;
     ProxyVia On
     ProxyRequests Off
     ProxyPreserveHost off
 
     #Websocket
     ProxyPass / ws://10.0.0.10:9001/
     ProxyPassReverse / ws://10.0.0.10:9001/
 &lt;Proxy *&gt;
&lt;/syntaxhighlight&gt;</text>
      <sha1>ojgolxxhyfwmqrxgzz4t5dv8y6g7rhv</sha1>
    </revision>
  </page>
  <page>
    <title>Xming</title>
    <ns>0</ns>
    <id>81</id>
    <revision>
      <id>2702</id>
      <parentid>1867</parentid>
      <timestamp>2017-12-10T15:17:13Z</timestamp>
      <contributor>
        <username>Sparco</username>
        <id>1</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1329">Xming är en X server för Windows. Med Xming kan köra program som kräver X över SSH med hjälp av tex PuTTy.

Xming kan vara skönt att köra när man inte vill sätta upp SSH tunnlar. 

== Installation ==
[[sourceforge:projects/xming/files/latest/download|Ladda hem Xming.]]

Default på allt fungerar bra. Jag väljer att installera utan SSH klient. Välj sedan att starta Xming. 

== Konfiguration == 

Öppna PuTTy, under Connection --&gt; SSH --&gt; X11.

Välj Enable X11 forwarding.

I fältet X display location skriv, &lt;code&gt;localhost:0&lt;/code&gt;

Testa nu att ansluta till en server och skriv,
 echo $DISPLAY
Då bör du få ett svar i stil med &lt;code&gt;localhost:10.0&lt;/code&gt;&lt;br/&gt;
Annars dubbelkolla att X11Forwarding Yes är konfat i /etc/ssh/sshd_config

== Tips and tricks ==

==== Starta fler än ett program från samma skal. ====
Skriv ett &lt;code&gt;&amp;&lt;/code&gt; efter kommandot.
 firefox &amp;

==== För att inte tappa X11 forwarding om man SSHar till en annan maskin. ====
X11 forward inställningen följer inte med default om man SSHar till en annan maskin från sin första om man inte anger ett stort X i SSH kommandot.
 ssh -X &lt;hostname&gt;

=== Tips på bra program som funkar utmärk med X11 forward. ===
vncviewer - VNC klient.

rdesktop - RDP klient.

Wireshark - Lyssna på paket.

Firefox - Webbläsare

[[Category:Guider]]</text>
      <sha1>pzi4bwxuryxcu9slxii3ahdo70okl20</sha1>
    </revision>
  </page>
  <page>
    <title>ZFS</title>
    <ns>0</ns>
    <id>218</id>
    <revision>
      <id>2213</id>
      <parentid>1984</parentid>
      <timestamp>2017-01-05T10:41:55Z</timestamp>
      <contributor>
        <username>Helikopter</username>
        <id>10</id>
      </contributor>
      <minor/>
      <comment>/* Installation */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6446">ZFS är filsystem kombinerat med volymhanterare. Det körs främst på BSD men finns även till [http://zfsonlinux.org/ Linux].

=Installation=
''Ubuntu 16.04 onwards''
 sudo apt-get update &amp;&amp; sudo apt-get -y install zfs
''Fedora''
 sudo dnf install --nogpgcheck http://archive.zfsonlinux.org/fedora/zfs-release$(rpm -E %dist).noarch.rpm
 sudo dnf install kernel-devel zfs 
 sudo /sbin/modprobe zfs
''Debian''
 su -
 apt-get install lsb-release
 wget http://archive.zfsonlinux.org/debian/pool/main/z/zfsonlinux/zfsonlinux_6_all.deb
 dpkg -i zfsonlinux_6_all.deb
 apt-get update &amp;&amp; apt-get install debian-zfs

=Konfiguration=
===Pool===
 zpool create POOL raidz1 \
         /dev/disk/by-id/ata-WDC_WD.. \
         /dev/disk/by-id/ata-WDC_WD.. \
         /dev/disk/by-id/ata-WDC_WD.. \
         -o ashift=12 -o failmode=continue
Lägg till -f om det inte finns någon EFI label.

  zfs set atime=off POOL

Show-kommandon.
 zpool list
 zpool status
 zfs get all
 zpool iostat -v POOL

Radera en pool.
 zpool destroy POOL

Återställ raderad pool.
 zpool import -D POOL

===Mount point===
 zfs set mountpoint=/path/pool POOL
 chown -R user:user /path/pool

===Dataset===
 zfs create POOL/test
Kompression.
 zfs set compression=on POOL/test

Deduplicering.
 zfs set dedup=on POOL/test

Radera dataset.
 zfs destroy POOL/test

===L2ARC===
Level 2 Adjustable Replacement Cache (L2ARC), är en utökning av den read cache (ARC) som finns i RAM. 
 zpool add -f POOL cache sdf

===ZIL &amp; SLOG===
ZFS Intent Log (ZIL) går att likna vid journalen i ett journalförande filsystem. Synkrona skrivningar skrivs alltid till ZIL först och flushas senare till poolen vid fasta intervall. En Separate Intent Log (SLOG) i form av SSD rekommenderas för ökad prestanda vid synkrona skrivningar. ZIL är ingen write cache utan används enbart som ett skydd mot dataförlust, den enda prestandaökningen rör synkrona skrivningar som utan en SLOG hade skrivits två gånger till samma disk då ZIL befunnit sig inuti den pool dit data skrivs.
 zpool add -f POOL log sdg
Om man är extra rädd om sin data kan man tvinga alla skrivningar att gå genom ZIL med kommandot nedan. Det går att ställa på enskilda dataset eller hela pooler om så önskas.
 zfs set sync=always POOL/test
Det går även att stänga av ZIL helt om man inte bryr sig om dataintegritet (samma syntax som ovan fast disable istället för always, standard är default).

=Underhåll=

===Scrub===
Scrubbing används i ZFS för att bibehålla dataintegritet och fixa eventuella fel på diskarna i din pool. Detta sker inte per automatik utan måste triggas, cronjob rekommenderas starkt. Rekommendationen som finns för frekvens av scrubbing på Solaris för enterprise- och konsumentdiskar är en gång i månaden resp. en gång i veckan.
 zpool scrub
''IO intensive''

===Snapshots===
Snapshot kan tas både på pools och datasets, varje snapshot kräver ett unikt namn.

Dataset snapshot.
 zfs snapshot POOL/test@NAME

Pool snapshot.
 zfs snapshot POOL@NAME

Lista snapshots.
 zfs list -t snapshot

Rollback till snapshot.
 zfs rollback POOL/test@NAME

Ta bort snapshot.
 zfs destroy POOL/test@NAME

'''Automatiska snapshots'''&lt;br/&gt;
Det finns ett antal olika paket/skript för att sköta automatisering av snapshots för ZFS. Här beskrivs användning av det cron-baserade zfs-auto-snapshot som skapats av ZFS on Linux-utvecklarna. Nedan följer ett antal kommandon för justering av frekvens och historik:

&lt;code&gt;zfs set com.sun:auto-snapshot=true POOL/test&lt;/code&gt; Enable/disable av automatiska snapshots på ett dataset.

&lt;code&gt;zfs set com.sun:auto-snapshot:monthly=false POOL/test&lt;/code&gt; Enable/disable av månatliga snapshots, som mest bevaras tolv snapshots.

&lt;code&gt;zfs set com.sun:auto-snapshot:weekly=false POOL/test&lt;/code&gt; Enable/disable av veckovisa snapshots, som mest bevaras åtta snapshots.

&lt;code&gt;zfs set com.sun:auto-snapshot:daily=true POOL/test&lt;/code&gt; Enable/disable av dagliga snapshots, som mest bevaras 31 snapshots.

&lt;code&gt;zfs set com.sun:auto-snapshot:hourly=false POOL/test&lt;/code&gt; Enable/disable av snapshots varje timme, som mest bevaras 24 snapshots.

&lt;code&gt;zfs set com.sun:auto-snapshot:frequent=false POOL/test&lt;/code&gt; Enable/disable av snapshots varje kvart, som mest bevaras fyra snapshots.

För att ändra t ex antal sparade snapshots får man editera de medföljande cron-jobb som installeras tillsammans med zfs-auto-snapshot, växeln som används för att ställa just detta är &lt;code&gt;--keep=X&lt;/code&gt;.

===Byta disk===

Det går att starta en replace av disk oavsett om disken i fråga fortfarande är online eller om den tagits bort från systemet. Men innan du börjar, kör en scrub för att garantera att poolen är intakt!

Är ''disk1'' online kommer kommandot nedan att attach:a ''disk2'' till poolen och starta en resilver (rebuild, för den som inte talar ZFS) av data på den nya; ''disk2''. När ''disk1'' är redo att tas bort detach:as den automatiskt från poolen. Om ''disk1'' inte är tillgänglig är det samma förfarande för att göra en replace. Det är dock möjligt att strunta i att ange den nya diskens namn eftersom ZFS antar att den nya disken sitter på samma plats som den förra (/dev/sdX) och konfigurerar den då automatiskt. Om disk-ID används för att referera till diskarna i poolen måste dock den nya disken specificeras med sin path. Poolens namn på disken ändras då disken är frånvarande, för att ta reda på vad ''disk1'' heter istället används i vanlig ordning &lt;code&gt;zpool status&lt;/code&gt;.
 zpool replace POOL disk1 disk2
Får du ett felmeddelande som säger "''disk2'' does not contain an EFI label but it may contain partition information in the MBR" bör det räcka att skapa en GPT-tabell på disken med t ex. parted.
Vänta på att resilvering körs färdigt, kolla status med &lt;code&gt;zpool status&lt;/code&gt;.

=Tips'N'Trix=
===Byte från "/dev/sdX" till disk-ID===
Om du gjort misstaget att tilldela din pool diskar med hjälp av disknamn (/dev/sdX) och i efterhand vill byta till det mer konsekventa disk-ID finns en enkel lösning, helt utan dataförlust. Gör såhär:

Exportera din pool, poolen tas nu bort från systemet i förberedelse för "flytten".
 zpool export POOL
Importera poolen från /dev/disk/by-id.
 zpool import -d /dev/disk/by-id POOL
Verifiera att poolen är tillbaks och att diskarna i poolen refereras med sitt ID istället för "sdX" med &lt;code&gt;zpool status&lt;/code&gt;.

[[Category:Guider]]</text>
      <sha1>pcdu0txrexxv7vqh0afawoy5gaou26m</sha1>
    </revision>
  </page>
</mediawiki>
